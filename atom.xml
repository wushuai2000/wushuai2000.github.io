<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>explorerの博客</title>
  
  
  <link href="http://ccsu.top/atom.xml" rel="self"/>
  
  <link href="http://ccsu.top/"/>
  <updated>2023-04-13T16:00:00.000Z</updated>
  <id>http://ccsu.top/</id>
  
  <author>
    <name>Explorer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机组-第七章 输入输出系统</title>
    <link href="http://ccsu.top/posts/24f1e69a/"/>
    <id>http://ccsu.top/posts/24f1e69a/</id>
    <published>2023-04-13T16:00:00.000Z</published>
    <updated>2023-04-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-输入-x2F-输出系统基本概念"><a href="#1-输入-x2F-输出系统基本概念" class="headerlink" title="1.输入&#x2F;输出系统基本概念"></a>1.输入&#x2F;输出系统基本概念</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1.概述"></a>1.1.概述</h2><p><strong>现代计算机结构大体由主机和 I&#x2F;O 设备（外设）。I&#x2F;O 的意思就是 Input&#x2F;Output，意为输入和输出。I&#x2F;O 设备就是指可以将数据输入到计算机，或者可以接受计算机输出数据的外部设备</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170807128.png" alt="image-20230417080703038" loading="lazy"></p><p><strong>常见的 I&#x2F;O 设备如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170807266.png" alt="image-20230417080719167" loading="lazy"></p><p><strong>主机是通过 I&#x2F;O 接口（又称为 I&#x2F;O 控制器或设备控制器）来协调它和外部设备之间的数据传输的</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170807454.png" alt="image-20230417080738398" loading="lazy"></p><ul><li>I&#x2F;O 控制器多种多样，也会制定相应的标准，比如下面用于控制 USB 设备的 I&#x2F;O 接口。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170808431.png" alt="image-20230417080809367" loading="lazy"></p><p><strong>I&#x2F;O 控制器本质就是一块芯片，会被集成在主板上</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170808242.png" alt="image-20230417080833164" loading="lazy"></p><h2 id="1-2-I-x2F-O-系统的基本组成"><a href="#1-2-I-x2F-O-系统的基本组成" class="headerlink" title="1.2.I&#x2F;O 系统的基本组成"></a>1.2.I&#x2F;O 系统的基本组成</h2><h3 id="1-2-1-I-x2F-O-硬件和-I-x2F-O-软件"><a href="#1-2-1-I-x2F-O-硬件和-I-x2F-O-软件" class="headerlink" title="1.2.1.I&#x2F;O 硬件和 I&#x2F;O 软件"></a>1.2.1.I&#x2F;O 硬件和 I&#x2F;O 软件</h3><ul><li><p><strong>I&#x2F;O 硬件：包括外部设备，I&#x2F;O 接口，I&#x2F;O 总线。</strong></p></li><li><p><strong>I&#x2F;O 软件：包括驱动程序、用户程序、管理程序、升级补丁等等，通常采用 I&#x2F;O 指令和通道指令实现主机和 I&#x2F;O 设备的信息交换。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170809209.png" alt="image-20230417080938149" loading="lazy"></p><h3 id="1-2-2-I-x2F-O-指令和通道指令"><a href="#1-2-2-I-x2F-O-指令和通道指令" class="headerlink" title="1.2.2.I&#x2F;O 指令和通道指令"></a>1.2.2.I&#x2F;O 指令和通道指令</h3><ul><li><p><strong>I&#x2F;O 指令：是 CPU 指令的一部分。其格式与普通指令格式稍有区别，操作码指明了 CPU 要对 I&#x2F;O 接口做什么，命令码指明了 I&#x2F;O 接口要对设备做什么</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170819122.png" alt="image-20230417081928042" loading="lazy"></p></li><li><p><strong>通道指令：是指<font color='orange'>通道能识别的指令</font>。<font color='red'>通道程序</font>提前编制好<font color='red'>放在主存中</font>，在含有通道的计算机中，CPU 执行 I&#x2F;O 指令对通道发出命令，由通道执行一系列<font color='red'>通道指令</font>，代替 CPU 对 I&#x2F;O 设备进行管理</strong>。</p></li></ul><p>注：I&#x2F;O 指令与普通指令格式略有不同，操作码指明了CPU要对I&#x2F;O 接口做什么，命令码指明了I&#x2F;O 接口要对设备做什么。</p><h2 id="1-3-I-x2F-O-控制方式概述"><a href="#1-3-I-x2F-O-控制方式概述" class="headerlink" title="1.3.I&#x2F;O 控制方式概述"></a>1.3.I&#x2F;O 控制方式概述</h2><p>下面是一段简单的 C 语言代码，在其运行过程中会涉及 <strong>CPU 和 I&#x2F;O 设备之间的交互。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> i<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待输入</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%c\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当程序执行到<code>scanf(&quot;%c&quot;,&amp;i)</code>时，屏幕会不断闪烁，此时 CPU 正在等待键盘输入数据。它们会通过 I&#x2F;O 接口进行数据交互，所依靠的是如下三个重要的寄存器。</strong></p><ul><li><strong>数据寄存器</strong>：存放主机要输出到外设或外设要输入到主机的数据。</li><li><strong>控制寄存器</strong>：反映了某个外设所要执行的动作。</li><li><strong>状态寄存器</strong>：反映了当前外设的状态（比如打印机是否就绪，是否忙碌等等）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170810648.png" alt="image-20230417081042591" loading="lazy"></p><p><strong>当输入完数据之后，CPU 是如何确定此时可以被取走数据了呢？共有三种 I&#x2F;O 控制方式</strong>：</p><ul><li><strong>程序查询方式</strong>：CPU 不断轮询检查 I&#x2F;O 控制器中的 “状态寄存器”，检测到状态为“已完成” 之后，再从数据寄存器中取出输入数据。</li><li><strong>程序中断方式</strong>：等待键盘 I&#x2F;O 时 CPU 可以先去执行其他程序，键盘 I&#x2F;O 完成之后 I&#x2F;O 控制器向 CPU 发出中断请求，CPU 响应中断请求，并取走数据。</li><li><strong>DMA控制方式：</strong>主存与高速&#x2F;O设备之间有一条直接数据通路（DMA总线）。CPU向DMA接口发出“读&#x2F;写”命令，并指明主存地址、磁盘地址、读写数据量等参数。DMA控制器自动控制磁盘与主存的数据读写，每完成一整块数据读写（如1KB为一整块），才向CPU发出一次中断请求。DMA控制器与主存每次传送1个字当传送完一整块数据后才向CPU发出中断请求。</li></ul><p><strong>这三种方式具体的控制过程是本章的核心，所以这里就不多解释了，否则非但解释不清，而且大家还会感觉很乱</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170812468.png" alt="image-20230417081254404" loading="lazy"></p><p><strong>思考：</strong>对于快速&#x2F;O设备，如“磁盘”，每准备好一个字就给CPU发送一次中断请求，会导致什么问题？<br><strong>答：</strong>CPU需要花大量的时间来处理中断服务程序，CPU利用率严重下降。</p><h2 id="1-4-通道控制方式了解"><a href="#1-4-通道控制方式了解" class="headerlink" title="1.4.通道控制方式了解"></a>1.4.通道控制方式了解</h2><ul><li>我们的个人电脑的 I&#x2F;O 设备是有限的，所以 CPU 管理起来绰绰有余，但是像大型商业机或服务器的 I&#x2F;O 设备数目是相当多的，如果还用 CPU 来管理，那显然不合理。</li><li>通道是具有特殊功能的处理器能对&#x2F;o设备进行统一管理。</li></ul><p><strong>通道控制方式：除了上述三种控制方式外，在通道控制方式中，通道是一种具有特殊功能的处理器，可以对 I&#x2F;O 设备进行统一管理。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170815386.png" alt="image-20230417081546329" loading="lazy"></p><p>**通道可以理解为 <font color='red'>“弱鸡版” 的 CPU</font>，通道可以识别并执行一系列的<font color='red'>通道指令</font>**。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170817135.png" alt="image-20230417081712075" loading="lazy"></p><h1 id="2-外部设备之输入和输出设备"><a href="#2-外部设备之输入和输出设备" class="headerlink" title="2.外部设备之输入和输出设备"></a>2.外部设备之输入和输出设备</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170852912.png" loading="lazy"></p><p><strong>外部设备又称为外围设备，是除了主机以外的，能直接或间接与计算机交换信息的装置，分为</strong>：</p><ul><li><strong>输入设备</strong>：用于向计算机系统输入命令和文本、数据等信息的部件。<strong>键盘和鼠标</strong>是最基本的输入设备。</li><li><strong>输出设备</strong>：用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。<strong>显示器和打印机</strong>是最基本的输出设备。</li><li><strong>外存设备</strong>：是指除计算机内存及 CPU 缓存以外的存储器。<strong>硬磁盘、光盘</strong>等是最基本的外存设备。</li></ul><h2 id="2-1-输入设备"><a href="#2-1-输入设备" class="headerlink" title="2.1.输入设备"></a>2.1.输入设备</h2><h3 id="2-1-1-键盘"><a href="#2-1-1-键盘" class="headerlink" title="2.1.1.键盘"></a>2.1.1.键盘</h3><p><strong>键盘：键盘是最常用的输入设备，通过它可以发出命令或输入数据。每个键相当于一个开关，当按下键时，电信号连通；当松开键时，弹簧把键弹起，电信号断开。键盘输入信息可以分为如下三个步骤</strong>：</p><ul><li>查出按下的是哪个键。</li><li>将该键翻译成能被主机接受的<strong>编码</strong>，比如 ASCII 码。</li><li>将编码传送给主机。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170823939.png" alt="image-20230417082331851" loading="lazy"></p><h3 id="2-1-2-鼠标"><a href="#2-1-2-鼠标" class="headerlink" title="2.1.2.鼠标"></a>2.1.2.鼠标</h3><p><strong>鼠标：鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系，常用的有机械式和光电式两种</strong>：</p><ul><li><p>光电式：光电式鼠标使用一个小型的光学传感器来检测桌面上的纹理和移动。当鼠标移动时，传感器通过检测纹理的变化来传输信号给计算机。光电式鼠标通常使用发光二极管和光敏二极管来检测鼠标的移动。</p></li><li><p>机械式：采用机械开关来检测鼠标的移动。在每个开关下方有一个小电机，当鼠标移动时，电机会转动，触发开关，传输信号给计算机。机械式鼠标通常使用滚轮和光学传感器来跟踪鼠标的移动。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170823615.png" alt="image-20230417082350539" loading="lazy"></p></li></ul><h2 id="2-2-输出设备"><a href="#2-2-输出设备" class="headerlink" title="2.2.输出设备"></a>2.2.输出设备</h2><h3 id="2-2-1-显示器"><a href="#2-2-1-显示器" class="headerlink" title="2.2.1.显示器"></a>2.2.1.显示器</h3><h4 id="2-2-1-1-分类"><a href="#2-2-1-1-分类" class="headerlink" title="2.2.1.1.分类"></a>2.2.1.1.分类</h4><p><strong>按显示设备所用的显示器件分类</strong>：</p><ul><li><p><strong>阴极射线管（CRT）显示器：</strong>CRT显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极和荧光粉涂层及玻璃外壳5部分组成。具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短<del>等目前前LCD难以超过的优点</del>。</p></li><li><p><strong>液晶显示器（LCD）</strong></p><ul><li><p>原理：利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。</p></li><li><p>特点：体积小、重量轻、省电、无辐射、绿色环保、画面柔、不伤眼等。</p></li></ul></li><li><p><strong>LED（发光二极管） 显示器</strong></p><ul><li>原理：通过控制半导体发光二极管进行显示，用来显示文字、图形、图像等各种信息。</li></ul></li><li><p>…….</p></li></ul><p>注：LCD与LED是两种不同的显示技术，LCD是由液态晶体组成的显示屏，而LED则是由发光二极管组成的显示屏。与LCD相比，LED显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。</p><p><strong>按所显示的信息分类</strong></p><ul><li><strong>字符显示器：</strong>显示字符的方法以点阵为基础。<font color='orange'>点阵是指由m×n个点组成的阵列</font>。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔将<font color='orange'>点阵存入由ROM构成的字符发生器</font>中，在CRT进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中0和1代码不同控制扫描电子束的开或关，从而在屏幕上显示出字符。对应于每个字符窗口，所需显示<font color='orange'>字符的ASCII代码被存放在视频存储器VRAM中</font>，以备刷新。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170841117.png" alt="image-20230417084123043" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170843984.png" alt="image-20230417084314904" loading="lazy"></p><ul><li><p><strong>图形显示器</strong>：将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为了在屏幕上保留持久稳定的图像，需要按定的频率对屏幕进行反复刷新。这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。</p><ul><li><strong>按扫描方式不同可分为：</strong><ul><li>光栅扫描显示器</li><li>随机扫描显示器</li></ul></li></ul></li><li><p><strong>图像显示器</strong></p></li></ul><h4 id="2-2-1-2-参数信息"><a href="#2-2-1-2-参数信息" class="headerlink" title="2.2.1.2.参数信息"></a>2.2.1.2.参数信息</h4><p><strong>①：屏幕大小</strong></p><ul><li>以<strong>对角线长度</strong>表示，常用的有 12~29 英寸。</li></ul><p><strong>②：分辨率</strong></p><ul><li>所能表示的<strong>像素个数</strong>，屏幕上的每个光点就是一个像素，以宽、高的像素乘积表示。例如：800×600、1024×768 和 1280×1024 等等。</li></ul><p><strong>③：灰度级</strong></p><ul><li>是指黑白显示器中所显示的像素点的<strong>亮暗差别</strong>，在彩色显示器中则表现为<strong>颜色的不同</strong>。灰度级越多，<strong>图像层次就越清晰逼真</strong>。典型的有 8 位（256 级）、16 位等。<font color='cornflowerblue'>n位可以表示2^n^种不同的亮度或颜色</font>。</li></ul><p><strong>④：刷新率</strong></p><ul><li><strong>光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称之为刷新</strong>。刷新率是<strong>指单位时间内扫描整个屏幕内容的次数</strong>，按照人的视觉生理，刷新频率大于 30Hz 时才不会感到闪烁，通常显示器<font color='green'>刷新频率</font>在 60Hz~120Hz。</li></ul><p><strong>⑤：VRAM（显存）</strong></p><ul><li><p>也称为**<font color='yellow'>刷新存储器</font><strong>，为了不断提高刷新图像的信号，</strong>必须把每一帧的图像信息存储在刷新存储器中**。其存储内容由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量就越大。</p></li><li><p><strong><font color='cornflowerblue'>VRAM 容量 &#x3D; 分辨率 × 灰度级位数</font></strong></p></li><li><p><strong><font color='cyan'>VRAM 带宽 &#x3D; 分辨率 × 灰度级位数 × 帧频</font></strong>  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170825589.png" alt="image-20230417082500517" loading="lazy"></p><p>$1440*<em>900</em>3B≈3.7MB$（一帧的大小即为显存的理论最小值）</p><p>如果显示器刷新率&#x3D;60Hz，则显存带宽至少要$3.7*60&#x3D;222MB&#x2F;S$</p></li></ul><p>注：现代计算机中，显存除了作为当前显示帧的缓存，还会用于保存即将渲染的图像数据。集成显卡计算机中，通常分配一片内存作为显存。</p><h3 id="2-2-2-打印机"><a href="#2-2-2-打印机" class="headerlink" title="2.2.2.打印机"></a>2.2.2.打印机</h3><h4 id="2-2-2-1-按印字原理不同分类"><a href="#2-2-2-1-按印字原理不同分类" class="headerlink" title="2.2.2.1.按印字原理不同分类"></a>2.2.2.1.按印字原理不同分类</h4><ul><li><p><strong>击打式打印机</strong>：利用机械动作<strong>使印字机与色带或纸相撞</strong>而打印字符。如：机打发票银行回执单（防伪性好）。</p><ul><li><p>优点：设备成本低印字质量好。</p></li><li><p>缺点：噪声大速度慢。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170847073.png" alt="image-20230417084743014" loading="lazy"></p><ul><li><p><strong>非击打式打印机</strong>：采用<strong>电、磁、光、喷墨等物理或化学方法</strong>印刷字符。</p><ul><li>优点：速度快噪声小。</li><li>缺点：成本高。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170848667.png" alt="image-20230417084805581" loading="lazy"></p><h4 id="2-2-2-2-按打印机工作方式不同分类"><a href="#2-2-2-2-按打印机工作方式不同分类" class="headerlink" title="2.2.2.2.按打印机工作方式不同分类"></a>2.2.2.2.按打印机工作方式不同分类</h4><ul><li><p><strong>串行打印机：</strong> <strong>逐字</strong>打印，速度慢。</p></li><li><p><strong>行式打印机：</strong> <strong>逐行</strong>打印，速度快。</p></li></ul><h4 id="2-2-2-3-按工作方式不同分类"><a href="#2-2-2-3-按工作方式不同分类" class="headerlink" title="2.2.2.3.按工作方式不同分类"></a>2.2.2.3.按工作方式不同分类</h4><p><strong>针式打印机</strong>：</p><ul><li><strong>原理</strong>：在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需内容。</li><li><strong>特点</strong>：针式打印机擅长 “多层复写打印”，实现各种票据或蜡纸等的打印。它工作原理简单，造价低廉，耗材(色带) 便宜，但打印分辨率和打印速度不够高。</li></ul><p><strong>喷墨打印机</strong>：</p><ul><li><strong>原理</strong>：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色墨滴，按一定的比例混合出所要求的颜色。</li><li><strong>特点</strong>：打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快; 但防水性差，高质量打印需要专用打印纸。</li></ul><p><strong>激光打印机</strong>：</p><ul><li><p><strong>原理</strong>：计算机输出的二进制信息，经过调制后的<a href="https://so.csdn.net/so/search?q=%E6%BF%80%E5%85%89&spm=1001.2101.3001.7020">激光</a>束扫描，在感光鼓上形成潜像，再经过显影、车印和定影，便在纸上得到所需的字符或图像。</p></li><li><p><strong>特点</strong>：打印质量高、速度快、噪声小、处理能力强; 但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓 (也称为硒鼓) 是激光打印机的核心部件。</p></li></ul><h1 id="3-I-x2F-O接口"><a href="#3-I-x2F-O接口" class="headerlink" title="3.I&#x2F;O接口"></a>3.I&#x2F;O接口</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170919346.png" alt="image-20230417091913236" loading="lazy"></p><h2 id="3-1-I-x2F-O-接口（I-x2F-O-控制器）"><a href="#3-1-I-x2F-O-接口（I-x2F-O-控制器）" class="headerlink" title="3.1.I&#x2F;O 接口（I&#x2F;O 控制器）"></a>3.1.I&#x2F;O 接口（I&#x2F;O 控制器）</h2><p><strong>I&#x2F;O 接口（I&#x2F;O 控制器）：是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上有很大的差异，接口正是为了解决这些差异而设置的</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170855108.png" alt="image-20230417085504048" loading="lazy"></p><h2 id="3-2-I-x2F-O-接口的功能"><a href="#3-2-I-x2F-O-接口的功能" class="headerlink" title="3.2.I&#x2F;O 接口的功能"></a>3.2.I&#x2F;O 接口的功能</h2><p><strong>I&#x2F;O 接口的主要功能：</strong></p><ul><li><strong>实现主机和外设的通信联络控制</strong>：解决主机与外设<strong>时序配合问题</strong>，协调<strong>不同工作速度的外设和主机之间的信息交换</strong>，以保证整个计算机系统能<strong>统一，协调地工作</strong>。</li><li><strong>进行地址译码和设备选择</strong>：CPU 送来外设的地址码后，<strong>接口必须对地址进行译码以产生设备选择信</strong>息，使主机能和指定外设交换信息。</li><li><strong>实现数据缓冲</strong>：CPU 与外设之间的速度往往不匹配，为了<strong>消除速度差异</strong>，接口必须设置<strong>数据缓冲寄存器</strong>，用于数据的暂存，以避免速度不一致而丢失数据。</li><li><strong>信号格式的转换</strong>：外设与主机两者的电平，数据格式都可能存在差异，<strong>接口应提供计算机与外设的信号格式的转换功能</strong>，如电平转换，并 &#x2F; 串或串 &#x2F; 并转换，模 &#x2F; 数或数 &#x2F; 模转换等等。</li><li><strong>传送控制命令和状态信息</strong>：CPU 要启动某一外设时，<strong>通过接口中的命令寄存器向外设发出启动命令</strong>；外设准备就绪时，则<strong>将 “准备好” 状态信息送回接口中的状态寄存器</strong>，并反馈给 CPU。外设向 CPU 提出中断请求，CPU 也有相应的<strong>响应信号</strong>反馈给外设。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170855622.png" alt="image-20230417085539566" loading="lazy"></p><h2 id="3-3-I-x2F-O-接口基本结构"><a href="#3-3-I-x2F-O-接口基本结构" class="headerlink" title="3.3.I&#x2F;O 接口基本结构"></a>3.3.I&#x2F;O 接口基本结构</h2><p><strong>I&#x2F;O 接口基本结构：</strong></p><ul><li><strong>内部接口</strong>：与<strong>系统总线相连</strong>，实质上是与<strong>内存、CPU</strong> 相连。<del>数据的传输只能是并行传输</del> （注意这句话要辩证的看待，早期计算机的确是靠并行，但现在趋势是<strong>从并行转向串行</strong>）。</li><li><strong>外部接口</strong>：通过接口电缆<strong>与外设相连</strong>，外部接口的数据传输可能是串行方式，因此 I&#x2F;O 接口需要具有<strong>串 &#x2F; 并转换功能。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170856406.png" alt="image-20230417085618338" loading="lazy"></p><p><strong>实际图：</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170856050.png" alt="image-20230417085634957" loading="lazy"></p><h2 id="3-4-I-x2F-O-接口的工作原理"><a href="#3-4-I-x2F-O-接口的工作原理" class="headerlink" title="3.4.I&#x2F;O 接口的工作原理"></a>3.4.I&#x2F;O 接口的工作原理</h2><p><strong>I&#x2F;O 接口的工作原理：</strong></p><ul><li><strong>发命令</strong>：CPU 发送<font color='red'>命令字</font>（控制字）到 <strong>I&#x2F;O 控制寄存器</strong>中，向设备发送命令（此过程需要驱动程序的协助），然后在 I&#x2F;O 控制逻辑的控制下对设备发出相应命令。</li><li><strong>读状态</strong>：CPU 从状态寄存器中<strong>读取<font color='red'>状态字</font><strong>，获得设备或 I&#x2F;O 控制器的</strong>状态信息。</strong></li><li><strong>读写数据</strong>：从<strong>数据缓冲寄存器</strong>发送或读取数据，完成主机与外设的数据交换。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170857829.png" alt="image-20230417085756756" loading="lazy"></p><p><strong>注意</strong>：</p><ul><li>控制寄存器、状态寄存器在使用时间上是错开的，因此可以将其合二为一，使用一个寄存器完成两项功能。</li><li>上图中的各种寄存器称为 <strong>I&#x2F;O 端口</strong>（数据端口，状态端口，控制端口）。</li><li>CPU 通过<strong>地址线</strong>指明它要读写数据的端口。</li><li>CPU 通过<strong>控制线</strong>发出读写 I&#x2F;O 端口的信号、中断请求信号等。</li><li>CPU 通过<strong>数据线</strong>读写数据，读取状态和中断类型号等等。</li><li><strong>每个设备对应一组寄存器</strong>，操作不同的寄存器就是在操作不同的设备。</li></ul><h2 id="3-5-I-x2F-O-端口及其编址"><a href="#3-5-I-x2F-O-端口及其编址" class="headerlink" title="3.5.I&#x2F;O 端口及其编址"></a>3.5.I&#x2F;O 端口及其编址</h2><p>I&#x2F;O 端口是指接口电路中可被 CPU 直接访问的寄存器，主要有<strong>数据端口，状态端口和控制端口</strong>，若干端口加上相应的控制逻辑电路组成接口。通常，<strong>CPU 能对数据端口进行读写操作，但对状态端口只能进行读操作，对控制端口只能进行写操作</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170859575.png" alt="image-20230417085906494" loading="lazy"></p><p><strong>I&#x2F;O 端口及其编址：I&#x2F;O 端口要想能够被 CPU 访问，就必须要对各个端口进行编号，每个端口对应一个端口地址，编址方式有统一编址和独立编址两种</strong>。</p><h3 id="3-5-1-统一编址"><a href="#3-5-1-统一编址" class="headerlink" title="3.5.1.统一编址"></a>3.5.1.统一编址</h3><p><strong>统一编址：又称存储器映射方式，是把 I&#x2F;O 端口当作存储器的单元进行地址分配，这种方式 CPU 不需要设置专门的 I&#x2F;O 指令，用统一的<font color='cyan'>访存指令</font>就可以访问 I&#x2F;O 端口。</strong>靠不同的地址码区分内存和I&#x2F;O设备。访存类的指令都可以访问I&#x2F;O端口<br>（RISC机器常用）。</p><ul><li><strong>优点</strong>：不需要<strong>专门的输入&#x2F;输出指令</strong>，所有访存指令都可直接访问端口，程序设计灵活性高；端口有较大的编址空间读写控制逻辑电路简单。</li><li><strong>缺点</strong>：端口占用了主存地址空间，使主存地址空间变小外设寻址时间长（地址位数多，地址译码速度慢）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170859867.png" alt="image-20230417085942810" loading="lazy"></p><p>例如：系统总线中地址线共10根，则可以访问的存储单元个数为2^10^&#x3D;1024个，假设要给10个I&#x2F;O端口编址：</p><ol><li>0~9表示I&#x2F;O地址，10~1023为主存单元地址。</li><li>0~1013表示主存单元地址，1014~1023为10地址。</li><li>10~19表示I&#x2F;O地址，0~9、20~1023为主存单元地址。</li></ol><h3 id="3-5-2-独立编址"><a href="#3-5-2-独立编址" class="headerlink" title="3.5.2.独立编址"></a>3.5.2.独立编址</h3><p><strong>独立编址：又称 I&#x2F;O 映射方式，I&#x2F;O 端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的 I&#x2F;O 指令来访问 I&#x2F;O 端口。</strong></p><p>靠<font color='cyan'>不同的指令</font>区分内存和I&#x2F;O设备。只能用专门的<font color='cyan'>I&#x2F;O指令</font>访问<font color='cyan'>I&#x2F;O端口</font>（Intel处理器常用，IN、OUT就是IO指令）。</p><ul><li><strong>优点</strong>：使用专用I&#x2F;O指令，程序编制清晰；I&#x2F;O端口地址位数少，地址译码速度快；I&#x2F;O端口的地址不占用主存地址空间。</li><li><strong>缺点</strong>：I&#x2F;O<strong>指令少</strong>，一般<strong>只能对端口进行传送操作</strong>，程序设计灵活性差；尤其需要 CPU 提供存储器读写、I&#x2F;O设备读&#x2F;写两组控制信号，增加了控制逻辑电路的复杂性。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170901911.png" alt="image-20230417090130856" loading="lazy"></p><h2 id="3-6-I-x2F-O-接口的类型"><a href="#3-6-I-x2F-O-接口的类型" class="headerlink" title="3.6.I&#x2F;O 接口的类型"></a>3.6.I&#x2F;O 接口的类型</h2><p><strong>按数据传送方式分类：</strong></p><ul><li><p>并行接口：一个字节或一个字所有位同时传送。</p></li><li><p>串行接口：一位一位的传送。</p></li></ul><p>注：这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，<del>数据总是并行传送的</del>。接口要完成数据格式转换。</p><p><strong>按主机访问 I&#x2F;O 设备的控制方式分类：</strong></p><ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li></ul><p><strong>按功能选择的灵活性分类：</strong></p><ul><li>可编程接口</li><li>不可编程接口</li></ul><h2 id="3-7-I-x2F-O接口的连接电路"><a href="#3-7-I-x2F-O接口的连接电路" class="headerlink" title="3.7.I&#x2F;O接口的连接电路"></a>3.7.I&#x2F;O接口的连接电路</h2><p><strong>唐版教材示意图：</strong></p><ul><li><p>数据线&#x3D;数据总线</p></li><li><p>设备选择线&#x3D;地址总线</p></li><li><p>状态线、命令线&#x3D;控制总线</p></li></ul><p><strong>I&#x2F;O接口的功能（具体操作）</strong>：</p><ul><li>设备选址</li><li>传送命令</li><li>传送数据</li><li>反映I&#x2F;O设备的工作状态</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170928668.png" alt="image-20230417092857613" loading="lazy"></p><h2 id="3-8-I-x2F-O接口的基本结构"><a href="#3-8-I-x2F-O接口的基本结构" class="headerlink" title="3.8.I&#x2F;O接口的基本结构"></a>3.8.I&#x2F;O接口的基本结构</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170932534.png" alt="image-20230417093245453" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170933514.png" alt="image-20230417093333441" loading="lazy"></p><h1 id="4-I-x2F-O方式之程序查询方式"><a href="#4-I-x2F-O方式之程序查询方式" class="headerlink" title="4.I&#x2F;O方式之程序查询方式"></a>4.I&#x2F;O方式之程序查询方式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171031360.png" alt="image-20230417103139282" loading="lazy"></p><h2 id="4-1-I-x2F-O-控制方式"><a href="#4-1-I-x2F-O-控制方式" class="headerlink" title="4.1.I&#x2F;O 控制方式"></a>4.1.I&#x2F;O 控制方式</h2><p><strong>I&#x2F;O 控制方式：I&#x2F;O 系统实现主机与 I&#x2F;O 设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的 I&#x2F;O 方式有程序查询，程序中断，DMA 和通道等等，其中前两种方式更依赖于 CPU 中程序指令的执行</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170937416.png" alt="image-20230417093715340" loading="lazy"></p><h2 id="4-2-程序查询方式"><a href="#4-2-程序查询方式" class="headerlink" title="4.2.程序查询方式"></a>4.2.程序查询方式</h2><p><strong>程序查询方式：信息交换的控制完全由主机程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行 I&#x2F;O 操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</strong></p><ul><li><p><strong>特点</strong>： CPU 一旦启动 I&#x2F;O，必须停止现行程序的运行，并在现行程序中插入一段程序。<strong>因此有 “踏步” 等待现象，CPU 与 I&#x2F;O 串行工作。</strong></p></li><li><p><strong>优点</strong> ：接口设计<strong>简单</strong>，设备量少。</p></li><li><p><strong>缺点</strong>：CPU 在信息传送过程中要花费很多时间用于查询和等待，而且在一段时间年内只能和一台外设交换信息，<strong>效率大大降低。</strong></p></li></ul><p><strong>大致流程如下</strong>：</p><ol><li>CPU 执行初始化程序，并预置传送参数。</li><li>向 I&#x2F;O 接口发出命令字，启动 I&#x2F;O 设备。</li><li>从外设接口读取状态信息。</li><li>CPU 不断查询 I&#x2F;O 设备状态，直到外设准备就绪。</li><li>传送一次数据。</li><li>修改地址和计数器参数。</li><li>判断传送是否结束，若未结束转至第 3 步，直到计数器为 0。</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170938678.png" alt="image-20230417093850598" loading="lazy"></p><h2 id="4-3-相关例题"><a href="#4-3-相关例题" class="headerlink" title="4.3.相关例题"></a>4.3.相关例题</h2><p>在程序查询方式的输入 &#x2F; 输出系统中，假设不考虑处理时间，每一个查询操作需要 100 个时钟周期，CPU 的时钟频率为 50MHz。现有鼠标和硬盘两个设备，而且 CPU 必须每秒对鼠标进行 30 次查询，硬盘以 32 位字长为单位传输数据，即每 32 位被 CPU 查询一次，传输率为 $2 X 2 ^{20} B&#x2F;s$。求 CPU 对这两个设备查询所花费的时间比率，由此可得出什么结论?</p><p><strong>从时间的角度理解：</strong></p><p>一个时钟周期为： $ \frac{1}{50MHz} &#x3D;  20ns$。</p><p>一个查询操作耗时：$100×20 ns&#x3D;2000ns$。</p><p><strong>①对于鼠标</strong>  </p><p>每秒查询鼠标耗时：$30×2000ns&#x3D;60000 ns  $</p><p>查询鼠标所花费的时间比率：$\frac{60000ns}{1s}&#x3D;0.006 % $ </p><p><strong>②对于硬盘</strong>  </p><p>每 32 位需要查询一次，每秒传送 $2× 2^{20}B  $</p><p>每秒需要查询 $ \frac{2×2^{20}B}{4B}&#x3D;2^{19} $ 次  。</p><p>查询硬盘耗时： $2^{19} ×2000ns&#x3D;512×1024×2000 n  \approx 1.05× 10^{9} ns  $</p><p>查询硬盘所花费的时间比率： $\frac{1.05×10^{9}ns}{1s}  &#x3D; 105 % $</p><p>可见，即使 CPU 将全部时间都用于对硬盘的查询，也不能满足磁盘传输的要求，因此CPU 一般不采用程序查询方式与磁盘交换信息。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170948022.png" alt="image-20230417094802946" loading="lazy"></p><h1 id="5-I-x2F-O方式之程序中断方式"><a href="#5-I-x2F-O方式之程序中断方式" class="headerlink" title="5.I&#x2F;O方式之程序中断方式"></a>5.I&#x2F;O方式之程序中断方式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171009439.png" alt="image-20230417100951303" loading="lazy"></p><h2 id="5-1-中断的基本概念"><a href="#5-1-中断的基本概念" class="headerlink" title="5.1.中断的基本概念"></a>5.1.中断的基本概念</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170954542.png" alt="image-20230417095413455" loading="lazy"></p><p><strong>中断：中断是指在计算机执行现行程序的过程中，出现某些急需要处理的异常情况或特殊请求，CPU 暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕之后 CPU 又自动返回现行程序的断点处，继续执行原程序。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170951948.png" alt="image-20230417095131882" loading="lazy"></p><p><strong>CPU 在程序中安排好于某个时刻启动某台外设，然后 CPU 继续执行原来的程序，不需要像查询方式那样一直等待设备就绪。在可以响应中断的条件下，CPU 暂时中止现在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成之后，CPU 返回原来的程序。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170954995.png" alt="image-20230417095443930" loading="lazy"></p><p>中断时 CPU 会离开原来的程序而跑去执行其他程序，那么原来的程序是如何保证执行完成的确定性？也就是说不能出现 CPU 回来时还有 “_<strong>这些程序究竟有没有执行过？</strong>_” 这样的疑问，这一点和操作系统中锁的含义类似。<strong>因此为了实现操作的原子性，我们也需要这样一把锁，保证 CPU 在执行一段程序时不会受到中断的干扰，或者说在这个确定的周期内 CPU 必须保证确确实实执行完了原来的程序，然后才能响应中断，我们把这样的锁称之为 CPU 的关中断和开中断。</strong></p><ul><li><p><strong>关中断</strong>：不会响应中断信号</p></li><li><p><strong>开中断</strong>：响应中断信号  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170952865.png" alt="image-20230417095214801" loading="lazy"></p></li></ul><p>如何实现呢？还记得 PSW标志位吗？<strong>其中的 IF(Interrupt Flag) 如果为 1 表示开中断（允许中断），如果为 0 表示关中断（不允许中断）。</strong></p><ul><li><strong>注意</strong>：IF&#x3D;0 屏蔽的是<strong>普通中断</strong>，但是像掉电，关机这种中断是无法被屏蔽的，也是必须被响应的。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170952060.png" alt="image-20230417095257001" loading="lazy"></p><h2 id="5-2-中断执行流程"><a href="#5-2-中断执行流程" class="headerlink" title="5.2.中断执行流程"></a>5.2.中断执行流程</h2><p><strong>中断执行流程</strong></p><ul><li><strong>中断请求： 中断源向 CPU 发送中断请求信号。</strong></li><li><strong>中断响应：响应中断的条件。</strong></li><li><strong>中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。</strong></li><li><strong>中断处理：中断隐指令和中断服务程序。</strong></li></ul><h3 id="5-2-1-中断请求"><a href="#5-2-1-中断请求" class="headerlink" title="5.2.1.中断请求"></a>5.2.1.中断请求</h3><p><strong>中断请求：每个中断源向 CPU 发出中断请求的时间是随机的，因此为了记录中断时间并区分不同的中断源，中断系统需要对每个中断源设置中断请求触发器<code>INTR</code>，当其状态为 “1” 时，表示中断源有请求，这些触发器可组成中断请求标记寄存器，该寄存器可以集成在 CPU 中，也可以分散在各个中断源中。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170955438.png" alt="image-20230417095518380" loading="lazy"></p><h4 id="5-2-1-1-内中断和外中断"><a href="#5-2-1-1-内中断和外中断" class="headerlink" title="5.2.1.1.内中断和外中断"></a>5.2.1.1.内中断和外中断</h4><ul><li><p><strong>外中断</strong>：是指来自<strong>处理器和内存以外的部件</strong>引起的中断，包括 <strong>I&#x2F;O 设备发出的 I&#x2F;O 中断、外部信号中断 (如用户按 Esc 键)，以及各种定时器引起的时钟中断</strong>等。外中断在狭义上一般称为中断 (后文若未说明，一般是指外中断)。</p></li><li><p><strong>内中断</strong>：是指在<strong>处理器和内存内部产生的中断</strong>，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断及用户态到核心态的切换等。</p></li></ul><h4 id="5-2-1-2-硬件中断和软件中断"><a href="#5-2-1-2-硬件中断和软件中断" class="headerlink" title="5.2.1.2.硬件中断和软件中断"></a>5.2.1.2.硬件中断和软件中断</h4><ul><li><p><strong>硬件中断</strong>：通过<strong>外部的硬件</strong>产生的中断。属于<strong>外中断。</strong></p></li><li><p><strong>软件中断</strong>：通过<strong>某条指令</strong>产生的中断，这种中断是可以通过编程实现的。属于<strong>内中断。</strong></p></li></ul><h4 id="5-2-1-3-非屏蔽中断和可屏蔽中断"><a href="#5-2-1-3-非屏蔽中断和可屏蔽中断" class="headerlink" title="5.2.1.3.非屏蔽中断和可屏蔽中断"></a>5.2.1.3.非屏蔽中断和可屏蔽中断</h4><ul><li><p><strong>非屏蔽中断</strong>：是一种<strong>硬件中断</strong>，此种中断通过不可屏蔽中断请求<code>NMI</code>控制，<strong>不受中断标志位<code>IF</code>的影响</strong>，即使在关中断 (IF&#x3D;0) 的情况下也会被响应。</p></li><li><p><strong>可屏蔽中断</strong>：也是一种<strong>硬件中断</strong>，此种中断通过中断请求标记触发器<code>INTR</code>控制，<strong>且受中断标志位<code>IF</code>的影响</strong>，在关中断情况下不接受中断请求。</p></li></ul><h3 id="5-2-2-中断判优"><a href="#5-2-2-中断判优" class="headerlink" title="5.2.2.中断判优"></a>5.2.2.中断判优</h3><p><strong>中断判优：由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需要通过中断判优逻辑确定响应哪一个中断源的请求，中断系统在任一瞬间只能响应一个中断源的请求。</strong></p><p><strong>用硬件实现中断判优依靠硬件排队器</strong></p><ul><li>中断会按照优先级排布，当较高优先级发出中断时通过逻辑与非结果会使较低优先级的中断请求信号输出为 0，以此完成判优。</li><li>计算机大多采用硬件判优。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170955713.png" alt="image-20230417095532647" loading="lazy"></p><p><strong>用软件实现中断判优依靠查询程序</strong></p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170955658.png" alt="image-20230417095545595" style="zoom:150%;" / loading="lazy"><p><strong>不同中断有不同的优先级，这些优先级是规定好的</strong>。</p><ul><li><strong>硬件中断</strong>属于最高级，其次是软件中断。</li><li><strong>非屏蔽中断优于可屏蔽中断。</strong></li><li><strong>DMA 请求优于 I&#x2F;O 设备传送的中断请求。</strong></li><li>高速设备优于低速设备。</li><li>输入设备优于输出设备。</li><li>实时设备优于普通设备。</li></ul><h3 id="5-2-3-中断响应"><a href="#5-2-3-中断响应" class="headerlink" title="5.2.3.中断响应"></a>5.2.3.中断响应</h3><p><strong>中断响应：CPU 响应中断满足的三个条件</strong>：</p><ul><li>中断源有<strong>中断请求</strong>。</li><li>CPU 允许中断及<strong>开中断。</strong></li><li>一条指令执行完毕，且<strong>没有更紧迫的任务。</strong></li></ul><h3 id="5-2-4-中断隐指令"><a href="#5-2-4-中断隐指令" class="headerlink" title="5.2.4.中断隐指令"></a>5.2.4.中断隐指令</h3><h4 id="5-2-4-1-中断隐指令概念"><a href="#5-2-4-1-中断隐指令概念" class="headerlink" title="5.2.4.1.中断隐指令概念"></a>5.2.4.1.中断隐指令概念</h4><p><strong>中断隐指令：CPU 响应中断后，经过某些操作，就会转去执行中断服务程序，这些操作是由硬件直接实现的，称其为中断隐指令。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170956770.png" alt="image-20230417095620686" loading="lazy"></p><p><strong>中断隐指令并不是指令系统中的一条真正的指令，而是cPU在检测到中断请求时自动完成的一系列动作，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令，其完成的操作如下</strong>：</p><ul><li><strong>关中断</strong>：在中断服务程序中，为了<strong>保护中断现场</strong> (即 CPU 主要寄存器中的内容) 不被新的中断所打断，必须关中断，以此<strong>保证被中断的程序在中断服务程序执行完毕后能继续正确地执行</strong>。</li><li><strong>保存断点</strong>：为保证在中断服务程序执行完毕后能<strong>正确地返回原来的程序</strong>，必须将原来程序的断点（即 PC 的内容）<strong>保存</strong>起来。这一点在 <a href="">(计算机组成原理) 第五章中央处理器 - 指令执行过程（取指周期、间址周期、执行周期和中断周期）</a>中有过详细介绍。</li><li><strong>引出中断服务程序</strong>：其实质是<strong>取出中断服务程序的入口地址并传送给程序计数器 PC。</strong></li></ul><h4 id="5-2-4-2-确定中断服务程序的入口地址的方法"><a href="#5-2-4-2-确定中断服务程序的入口地址的方法" class="headerlink" title="5.2.4.2.确定中断服务程序的入口地址的方法"></a>5.2.4.2.确定中断服务程序的入口地址的方法</h4><p><strong>其中，确定中断服务程序的入口地址共有如下两种方法</strong>：</p><ul><li><strong>软件查询法</strong></li><li><strong>硬件向量法</strong></li></ul><p><strong>软件查询法</strong>：CPU 必须找到中断服务程序的入口地址，称之为<strong>中断向量</strong>。系统中的全部中断向量会集中存放到存储器的某个区域内，这个存放中断向量的存储器称之为<strong>中断向量表</strong>，也即服务程序入口地址表。</p><ul><li><p><strong>中断向量</strong>可以理解为函数的指针。</p></li><li><p><strong>中断向量地址</strong>就是指向函数指针的指针  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170958274.png" alt="image-20230417095815193" loading="lazy"></p></li></ul><p><strong>硬件向量法</strong>：依靠<strong>排队器</strong>，每一个中断服务被响应后会有其对应的输入，<strong>由中断向量地址形成部件映射后便会形成独特的向量</strong>，最终会由向量地址找到对应的入口地址  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171001666.png" alt="image-20230417100132593" loading="lazy"></p><h3 id="5-2-5-中断处理"><a href="#5-2-5-中断处理" class="headerlink" title="5.2.5.中断处理"></a>5.2.5.中断处理</h3><p><strong>中断服务程序的主要任务如下【此部分可结合 <a href="">(计算机组成原理) 第五章中央处理器 - 第二节：指令执行过程（取指周期、间址周期、执行周期和中断周期）</a>理解】。</strong></p><ul><li><p><strong>保护现场：</strong> 保存<strong>通用寄存器和状态寄存器</strong>的内容（即保存 ACC 寄存器的值），以便返回原程序后可以<strong>恢复 CPU 环境</strong>，可以使用堆栈，也可以使用特定存储单元。</p></li><li><p><strong>中断服务：</strong> 主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲寄存器 （中断服务的过程中有可能会修改 ACC 寄存器的值）。</p></li><li><p><strong>恢复现场：</strong> 通过<strong>出栈指令或取数指令</strong>把之前保存的信息送回寄存器中。</p></li><li><p><strong>中断返回：</strong> 通过<strong>中断返回指令回到原程序断点处。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171002103.png" loading="lazy"></p><h2 id="5-3-多重中断和中断屏蔽技术"><a href="#5-3-多重中断和中断屏蔽技术" class="headerlink" title="5.3.多重中断和中断屏蔽技术"></a>5.3.多重中断和中断屏蔽技术</h2><h3 id="5-3-1-单重中断和多重中断"><a href="#5-3-1-单重中断和多重中断" class="headerlink" title="5.3.1.单重中断和多重中断"></a>5.3.1.单重中断和多重中断</h3><ul><li><p><strong>单重中断：CPU 在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而 CPU 对新的中断请求不予响应。</strong></p></li><li><p><strong>多重中断：CPU 在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，若 CPU 暂停现行的中断服务程序，转去执行新的中断请求。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171004775.png" alt="image-20230417100419711" loading="lazy"></p><p>实现多重中断需要格外注意关中断和开中断的时机，以及屏蔽字（中断屏蔽技术）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171004764.png" alt="image-20230417100436704" loading="lazy"></p><h3 id="5-3-2-中断屏蔽技术"><a href="#5-3-2-中断屏蔽技术" class="headerlink" title="5.3.2.中断屏蔽技术"></a>5.3.2.中断屏蔽技术</h3><p><strong>中断屏蔽技术：多重中断虽然支持暂停一个中断服务程序然后再响应另一个中断，但不是所有中断都会响应，像键盘这些低速设备优先级并不高，所以就需要一个屏蔽字，指明接下来哪些中断信号应该被忽视</strong>。</p><p><strong>中断屏蔽技术主要用于多重中断，CPU 要具备多重中断的功能，需要满足下列条件</strong>：</p><ul><li>在中断服务程序中提前设置<strong>开中断</strong>指令。</li><li><strong>优先级别高的中断源有权中断优先级低的中断源。</strong></li><li>每个中断源都有一个<strong>屏蔽触发</strong>器，1 表示屏蔽该中断源的请求，0 表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个<strong>屏蔽字寄存器</strong>，屏蔽字寄存器的内容称为<strong>屏蔽字。</strong></li></ul><p><strong>具体来说</strong>：</p><ul><li>一般用 <strong><code>1</code>表示屏蔽 <strong>，</strong>0 表示正常申请。</strong></li><li><strong>每个中断源对应一个屏蔽字</strong>（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）。</li><li>屏蔽字中<code>1</code>越多，优先级越高。每个屏蔽字中至少有一个<code>1</code>（<strong>至少要能够屏蔽自身的中断</strong>）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171005835.png" alt="image-20230417100528747" loading="lazy"></p><p>设某机有 4 个中断源 A、B、C、D,其硬件排队优先次序为 A&gt;B&gt;C&gt;D, 现要求将中断处理次序改为 D&gt;A&gt;C&gt;B。  </p><ol><li>写出每个中断源对应的屏蔽字。 </li><li>按下图所示的时间轴给出的 4 个中断源的请求时刻，画出 CPU 执行程序的轨迹。设每个中断源的中断服务程序时间均为 20us。</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171007168.png" alt="image-20230417100749101" loading="lazy"></p><h2 id="5-4-程序中断方式"><a href="#5-4-程序中断方式" class="headerlink" title="5.4.程序中断方式"></a>5.4.程序中断方式</h2><ul><li>讲完了前面那么多关于中断的预备知识后，现在回归主题——<strong>引入中断系统后如何控制 I&#x2F;O 系统的数据读写工作</strong>。</li></ul><p><strong>程序中断方式：在正常情况下，CPU 正在运行某段程序，该程序有可能使用到外部设备。比如从该外部设备输入一个字符</strong>。</p><ul><li>首先会向该 I&#x2F;O 设备发出 I&#x2F;O 指令，启动该设备，接着外部设备就会去工作，<strong>准备 CPU 想要的数据和信息。</strong></li><li>在外部工作的过程中，<strong>CPU 可以继续运行。</strong></li><li>当 I&#x2F;O 设备完成工作后，会给 CPU 发送一个<strong>中断请求信号</strong>。</li><li>如下图，CPU 在 K 处检测到了信号，于是对其进行处理，处理完成之后返回 K+1 位置，继续运行。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171015519.png" alt="image-20230417101523445" loading="lazy"></p><p>假定 CPU 主频为 50MHz，CPI 为 4。设备 D 采用异步串行通信方式向主机传送 7 位 ASCII 字符，通信规程中有 1 位奇校验位和 1 位停止位，从 D 接收启动命令到字符送入 I&#x2F;0 端口需要 0.5ms。</p><p>1）每传送一个字符，在异步串行通信线上共需传输多少位？在设备D持续工作过程中，每秒钟最多可向I&#x2F;O端口送入多少个字符？</p><p>2）设备 D 采用中断方式进行输入 &#x2F; 输出，示意图如下: </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171015809.png" alt="image-20230417101536740" loading="lazy"></p><p>I&#x2F;O 端口每收到一个字符申请一次中断，中断响应需 10 个时钟周期，中断服务程序共有 20 条指令，其中第 15 条指令启动D工作。若 CPU 需从 D 读取 1000 个字符，则完成这一任务所需时间大约是多少个时钟周期? CPU 用于完成这一任务的时间大约是多少个时钟周期? 在中断响应阶段 CPU 进行了哪些操作?  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171020088.png" loading="lazy"></p><h1 id="5-5-拓展"><a href="#5-5-拓展" class="headerlink" title="5.5.拓展"></a>5.5.拓展</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171014321.png" alt="无标题" loading="lazy"></p><h1 id="6-I-x2F-O方式之DMA方式"><a href="#6-I-x2F-O方式之DMA方式" class="headerlink" title="6.I&#x2F;O方式之DMA方式"></a>6.I&#x2F;O方式之DMA方式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171030615.png" alt="image-20230417103011520" loading="lazy"></p><h2 id="6-1-什么是-DMA-方式"><a href="#6-1-什么是-DMA-方式" class="headerlink" title="6.1.什么是 DMA 方式"></a>6.1.什么是 DMA 方式</h2><p><strong>DMA 方式：DMA 方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU 与外设并行工作。DMA 方式在外设与内存之间开辟一条 “直接数据通道”，信息传送不再经过 CPU，降低了 CPU 在传送数据时的开销，因此称为直接存储器存取方式。由于数据传送不需要经过 CPU，也就不需要保护，恢复 CPU 现场等繁琐操作。此种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销较大。</strong></p><p><strong>如下图，CPU 向 DMA 控制器指明要输入还是输出、要传送多少个数据、以及数据在主存、外设中的地址</strong>：</p><ul><li><strong>传送前</strong>：接受外设发出的 DMA 请求（外设传送一个字的请求），并向 CPU 发出总线请求。</li><li><strong>传送前</strong>：CPU 响应总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。</li><li><strong>传送时</strong>：确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。</li><li><strong>传送时</strong>：规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</li><li><strong>传送后</strong>：向 CPU 报告 DMA 操作的结束。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171021304.png" alt="image-20230417102151241" loading="lazy"></p><h2 id="6-2-DMA-控制器组成"><a href="#6-2-DMA-控制器组成" class="headerlink" title="6.2.DMA 控制器组成"></a>6.2.DMA 控制器组成</h2><p><strong>DMA 控制器组成：</strong></p><ul><li><strong>主存地址寄存器</strong>：简称 AR，存放<strong>要交换数据的主存地址。</strong></li><li><strong>传送长度计数器</strong>：简称 WC，记录传送<strong>数据的长度</strong>，计数溢出时，数据即传送完毕，自动发中断请求信号。</li><li><strong>数据缓冲寄存器</strong>：暂存<strong>每次传送的数据。</strong></li><li><strong>DMA 请求触发器</strong>：每当 I&#x2F;O 设备准备好数据，给出一个控制信号，<strong>使 DMA 请求触发器置位。</strong></li><li><strong>控制 &#x2F; 状态逻辑</strong>：由控制和时序电路及状态标志组成，用于<strong>指定传送方向，修改传送参数</strong>，并对 DMA 请求信号和 CPU 相应信号进行协调和同步。</li><li><strong>中断机构</strong>：当一个数据块传送完毕之后触发中断机构，向 CPU 提出中断请求。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171023251.png" alt="image-20230417102322168" loading="lazy"></p><p><strong>注意</strong>：在 DMA 传送过程中，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用，而当 DMA 传送结束之后，将恢复 CPU 的一切权利并开始执行其操作，由此可见，DMA 控制器必须具有控制系统总线的能力。</p><h1 id="6-3-DMA-传送过程"><a href="#6-3-DMA-传送过程" class="headerlink" title="6.3.DMA 传送过程"></a>6.3.DMA 传送过程</h1><h3 id="6-3-1-预处理"><a href="#6-3-1-预处理" class="headerlink" title="6.3.1.预处理"></a>6.3.1.预处理</h3><p><strong>DMA 控制器组成：由 CPU 完成一些必要的准备工作。首先, CPU 执行几条 I&#x2F;O 指令，用以测试 I&#x2F;O 设备状态，再向 DMA 控制器的有关寄存器置初值、设置传送方向，启动该设备等等。然后 CPU 继续执行原来的程序，直到 I&#x2F;O 设备准备好发送的数据（输入情况）或接受的数据（输出情况）时，I&#x2F;O 设备向 DMA 控制器发送 DMA 请求，再由 DMA 控制器向 CPU 发送总线请求，用以传输数据。</strong></p><ul><li>主存起始地址 -&gt;AR</li><li>I&#x2F;O 设备地址 -&gt;DAR</li><li>传送数据个数 -&gt;WC</li><li>启动 I&#x2F;O 设备</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171024204.png" alt="image-20230417102412120" loading="lazy"></p><h3 id="6-3-2-数据传送"><a href="#6-3-2-数据传送" class="headerlink" title="6.3.2.数据传送"></a>6.3.2.数据传送</h3><p><strong>数据传送：DMA 的数据传输可以单字节（或字）为基本单位，也可以数据块为基本单位。对于以数据块为单位的传送（如硬盘），DMA 占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器而非通过 CPU 执行程序实现的，即数据传送阶段完全由 DMA（硬件）控制。</strong></p><ul><li>设备将输入写入 DR，发出 DMA 请求。</li><li>控制逻辑检测到一个数据后，向 CPU 发出总线请求，CPU 给予反馈信号。</li><li>DMA 控制器接管总线，进行数据传送。</li><li>主存地址计数器 + 1，长度计数器 + 1。</li><li>传输完多个字后，长度计数器溢出，溢出信号传送给中断机构，向 CPU 发出中断请求。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171024947.png" alt="image-20230417102425860" loading="lazy"></p><h3 id="6-3-3-后处理"><a href="#6-3-3-后处理" class="headerlink" title="6.3.3.后处理"></a>6.3.3.后处理</h3><p><strong>后处理：DMA 控制器向 CPU 发出中断请求：CPU 执行中断服务程序做 DMA 结束处理，包括校验送入主存的数据是否正确，测试传送过程中是否出错（如果出错则转入诊断程序）以及决定是否继续使用 DMA 传送其他数据块等等。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171025960.png" alt="image-20230417102527875" loading="lazy"></p><p><strong>接着，CPU 继续执行主程序</strong></p><h2 id="6-4-DMA-方式的特点"><a href="#6-4-DMA-方式的特点" class="headerlink" title="6.4.DMA 方式的特点"></a>6.4.DMA 方式的特点</h2><p>主存和 DMA 接口之间有一条 “直接数据通路”，由于 DMA 方式传送数据不需要经过 CPU，因此不必中断线性程序，<strong>I&#x2F;O 主机并行工作，程序和传送并行工作。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171030189.png" loading="lazy"></p><p><strong>DMA 方式特点：</strong></p><ul><li>它使主存与 CPU 的固定联系脱钩，<strong>主存既可以被 CPU 访问，又可以被外设访问。</strong></li><li>在数据块传送时，主存地址的确定、传送数据的计数都有<strong>硬件电路直接实现。</strong></li><li>主存开辟专门的<strong>数据缓冲区</strong>，及时供给和接受外设的数据。</li><li>DMA 传送速度快，CPU 和外设并行工作，<strong>提高了系统效率。</strong></li><li><strong>DMA 在传送开始前要通过程序进行预处理，结束之后要通过中断方式进行后处理。</strong></li></ul><h2 id="6-5-DMA-传送方式"><a href="#6-5-DMA-传送方式" class="headerlink" title="6.5.DMA 传送方式"></a>6.5.DMA 传送方式</h2><p><strong>DMA 传送方式：主存和 DMA 控制器之间有一条数据通路，因此主存和 I&#x2F;O 设备之间交换信息时，不通过 CPU。但是当 I&#x2F;O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器和 CPU 通常采用以下三种方法使用主存</strong>  。</p><h3 id="6-5-1-停止-CPU-访问主存"><a href="#6-5-1-停止-CPU-访问主存" class="headerlink" title="6.5.1.停止 CPU 访问主存"></a>6.5.1.停止 CPU 访问主存</h3><p><strong>停止 CPU 访问主存</strong>：这种方式是当外设需要传送成组数据时，<strong>由 DMA 接口向 CPU 发送一个信号，要求 CPU 放弃地址线、数据线和有关控制线的使用权</strong>，DMA 接口获得总线控制权后，开始进行数据传送。数据传送结束后，DMA 接口通知 CPU 可以使用主存, 并把总线控制权交还给 CPU。<strong>在这种传送过程中，CPU 基本处于不工作状态或保持原始状态。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171026941.png" loading="lazy"></p><h3 id="6-5-2-DMA-和-CPU-交替访问主存"><a href="#6-5-2-DMA-和-CPU-交替访问主存" class="headerlink" title="6.5.2.DMA 和 CPU 交替访问主存"></a>6.5.2.DMA 和 CPU 交替访问主存</h3><p><strong>DMA 和 CPU 交替访问主存</strong>：DMA 与 CPU 交替访存，这种方式适用于 <strong>CPU 的工作周期比主存存取周期长</strong>的情况。例如，若 CPU 的工作周期是 1.2μs，主存的存取周期小于 0.6μs，则可将一个 CPU 周期分为 C1 和 C2 两个周期, 其中 C1 专供 DMA 访存，C2 专供 CPU 访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过 C1 和 C2 <strong>分时控制的。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171027582.png" alt="image-20230417102741513" loading="lazy"></p><h3 id="6-5-3-周期挪用（周期窃取）"><a href="#6-5-3-周期挪用（周期窃取）" class="headerlink" title="6.5.3.周期挪用（周期窃取）"></a>6.5.3.周期挪用（周期窃取）</h3><p><strong>周期挪用（周期窃取）</strong>：这种方式是前面两种的折中操作。<strong>当 I&#x2F;O 设备没有 DMA 请求时，CPU 按程序的要求访问主存，一旦 I&#x2F;O 设备有了 DMA 请求，就会有以下三种情况</strong>：</p><ul><li>**<strong>CPU 不再访存</strong>：因此 I&#x2F;O 的访存请求与 CPU 未发生冲突。</li><li>CPU 正在访存 **：此时必须等待存取周期结束后，CPU 再将总线占有权让出。</li><li><strong>I&#x2F;O 和 CPU 同时请求访存，出现访存冲突</strong>：此时 CPU 要暂时让出总线占有权，由 I&#x2F;O 设备挪用一个或多个存取周期。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171028916.png" alt="image-20230417102829847" loading="lazy"></p><h2 id="6-6-DMA-和中断对比"><a href="#6-6-DMA-和中断对比" class="headerlink" title="6.6.DMA 和中断对比"></a>6.6.DMA 和中断对比</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171028630.png" alt="image-20230417102858560" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-输入-x2F-输出系统基本概念&quot;&gt;&lt;a href=&quot;#1-输入-x2F-输出系统基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.输入&amp;#x2F;输出系统基本概念&quot;&gt;&lt;/a&gt;1.输入&amp;#x2F;输出系统基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1</summary>
      
    
    
    
    <category term="考研408" scheme="http://ccsu.top/categories/%E8%80%83%E7%A0%94408/"/>
    
    
    <category term="计算机组成原理" scheme="http://ccsu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="考研" scheme="http://ccsu.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>机组-第六章 总线</title>
    <link href="http://ccsu.top/posts/c0af4cb/"/>
    <id>http://ccsu.top/posts/c0af4cb/</id>
    <published>2023-04-11T16:00:00.000Z</published>
    <updated>2023-04-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-总线概述"><a href="#1-总线概述" class="headerlink" title="1.总线概述"></a>1.总线概述</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162137051.png" alt="image-20230416213738949" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171119701.png" loading="lazy"></p><h2 id="1-1-总线相关概念"><a href="#1-1-总线相关概念" class="headerlink" title="1.1.总线相关概念"></a>1.1.总线相关概念</h2><h3 id="1-1-1-总线的定义"><a href="#1-1-1-总线的定义" class="headerlink" title="1.1.1.总线的定义"></a>1.1.1.总线的定义</h3><p><strong>总线：总线是一组能为多个部件分时共享的公共信息传送线路。为什么要采用总线呢？这是因为早期计算机的外部设备非常少，所以大多采用分散连接方式（也就是建立专门的数据传送线路），但是随着时代的发展，外部设备的数量越来越多，因此如果每增加一个外部设备就增加一个线路的话，显然是不合理的。所以为了更好地解决 I&#x2F;O 设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为了总线连接</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162131599.png" alt="image-20230416213125511" loading="lazy"></p><h3 id="1-1-2-总线的特点"><a href="#1-1-2-总线的特点" class="headerlink" title="1.1.2.总线的特点"></a>1.1.2.总线的特点</h3><ul><li><p><strong>共享：是指总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享。</strong></p></li><li><p><strong>。分时：是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162132774.png" alt="image-20230416213238707" loading="lazy"></p><h3 id="1-1-3-总线的特性"><a href="#1-1-3-总线的特性" class="headerlink" title="1.1.3.总线的特性"></a>1.1.3.总线的特性</h3><p><strong>设计总线时要考虑以下特性</strong>：</p><ul><li><strong>机械特性</strong>：尺寸、形状、管脚数、排列顺序。</li><li><strong>电气特性</strong>：传输方向和有效地电平范围。</li><li><strong>功能特性</strong>：每根传输线的功能（地址、数据、控制）。</li><li><strong>时间特性</strong>：信号的时序关系。</li></ul><h2 id="1-2-总线的分类"><a href="#1-2-总线的分类" class="headerlink" title="1.2.总线的分类"></a>1.2.总线的分类</h2><h3 id="1-2-1-按数据的传输格式分类"><a href="#1-2-1-按数据的传输格式分类" class="headerlink" title="1.2.1.按数据的传输格式分类"></a>1.2.1.按数据的传输格式分类</h3><p><strong>串行总线：一次只能发送一个 bit 的数据。</strong></p><ul><li><strong>优点</strong>：只需要一条传输线，<strong>成本低廉</strong>，广泛应用于<strong>长距离传输</strong>；应用于计算机内部时，可以<strong>节省布线空间。</strong></li><li><strong>缺点</strong>：在数据发送和接受的时候，需要进<strong>行拆卸和装配</strong>，要考虑<strong>串行 - 并行转换</strong>的问题。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162131212.png" alt="image-20230416213145146" loading="lazy"></p><p><strong>并行总线：一次可以并行发送多个 bit 的数据</strong>。</p><ul><li><strong>优点</strong>：总线的逻辑<strong>时序比较简单</strong>，电路实<strong>现起来比较容易。</strong></li><li><strong>缺点</strong>：信号线<strong>数量多</strong>，占用<strong>更多布线空间</strong>；远距离传输<strong>成本高昂</strong>；另外，在工作频率较高时，<strong>并行的信号线之间会产生严重干扰</strong>，对每条线等长的要求也越高，所以无法持续提升工作频率。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162131449.png" alt="image-20230416213153373" loading="lazy"></p><h3 id="1-2-2-按总线功能（连接的部件）"><a href="#1-2-2-按总线功能（连接的部件）" class="headerlink" title="1.2.2.按总线功能（连接的部件）"></a>1.2.2.按总线功能（连接的部件）</h3><h4 id="1-2-2-1-片内总线"><a href="#1-2-2-1-片内总线" class="headerlink" title="1.2.2.1.片内总线"></a>1.2.2.1.片内总线</h4><p><strong>片内总线：是芯片内部的总线，它是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线。</strong></p><h4 id="1-2-2-2-系统总线"><a href="#1-2-2-2-系统总线" class="headerlink" title="1.2.2.2.系统总线"></a>1.2.2.2.系统总线</h4><p><strong>系统总线：是计算机系统内各功能部件（CPU、主存、I&#x2F;O 接口）之间的相互连接的总线。按系统总线传输信息内容的不同，又可以分为 3 类：数据总线、地址总线和控制总线。</strong></p><ul><li><p><strong>数据总线（DATA BUS）</strong>：传输功能部件之间的<strong>数据信息</strong>，包括指令和操作数；其<strong>位数（根数）与机器字长、存储字长</strong>有关；<strong>双向</strong>传输。</p></li><li><p><strong>地址总线（ADDRESS BUS）</strong>：用于<strong>指出数据总线上的源数据或目的数据所在的主存单元或 I&#x2F;O 端口的地址</strong>；它是<strong>单向</strong>传输总线；地址总线<strong>的位数与主存地址空间</strong>的大小有关。</p></li><li><p><strong>控制总线（CONTROL BUS）</strong>：传输<strong>控制信息</strong>；一根控制线传输一个信息；<strong>对于单个控制线它是单向的，但是对于整个控制总线来说它是 “双向” 的</strong>，也就是有出（指 CPU 发出的控制信号）和有入（主存或外设返回的反馈信号)。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162132373.png" alt="image-20230416213202302" loading="lazy"></p><p><strong>注意区分数据通路和数据总线</strong></p><ul><li><strong>数据通路</strong>：各个功能部件通过数据总线连接形成的<strong>数据传输路径</strong>，它表示的是数据流经的路径。</li><li><strong>数据总线</strong>：是承载数据流动的<strong>媒介。</strong></li></ul><h4 id="1-2-2-3-通信总线"><a href="#1-2-2-3-通信总线" class="headerlink" title="1.2.2.3.通信总线"></a>1.2.2.3.通信总线</h4><p><strong>通信总线：是在计算机系统之间或计算机系统与其他系统（比如远程设备，测试设备）之间传送信息的总线，也称为外部总线。</strong></p><h3 id="1-2-3-按时序控制方式分类"><a href="#1-2-3-按时序控制方式分类" class="headerlink" title="1.2.3.按时序控制方式分类"></a>1.2.3.按时序控制方式分类</h3><ul><li><strong>同步总线</strong></li><li><strong>异步总线</strong></li></ul><h2 id="1-3-系统总线的结构"><a href="#1-3-系统总线的结构" class="headerlink" title="1.3.系统总线的结构"></a>1.3.系统总线的结构</h2><h3 id="1-3-1-单总线结构"><a href="#1-3-1-单总线结构" class="headerlink" title="1.3.1.单总线结构"></a>1.3.1.单总线结构</h3><p><strong>单总线结构：CPU、主存、I&#x2F;O 设备都连接在一组总线上，允许 I&#x2F;O 设备之间、I&#x2F;O 设备和 CPU 之间或 I&#x2F;O 设备与主存之间直接交换信息。</strong></p><ul><li><strong>优点</strong>：<strong>结构简单</strong>、<strong>成本低</strong>、<strong>易于接入新的设备。</strong></li><li><strong>缺点</strong>：<strong>带宽低、负载重、多个部件只能争用唯一的总线</strong>，且<strong>不支持并行操作</strong>；另外像 CPU、主存它们的速度是很快的，但是像硬盘这些设备速度要很慢，所以这种方式也不科学。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162135431.png" alt="image-20230416213511363" loading="lazy"></p><h3 id="1-3-2-双总线结构"><a href="#1-3-2-双总线结构" class="headerlink" title="1.3.2.双总线结构"></a>1.3.2.双总线结构</h3><p><strong>双总线结构：具有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送；另一条是 I&#x2F;O 总线，用于多个外部设备与通道之间进行数据传送。</strong></p><ul><li><strong>优点</strong>：将较<strong>低速的 I&#x2F;O 设备从单总线上分离出来</strong>，实现存储器总线和 I&#x2F;O 总线的分离。</li><li><strong>缺点</strong>：需要增加<strong>通道</strong>等硬件设备。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162134614.png" alt="image-20230416213455554" loading="lazy"></p><p><strong>其中通道是指具有特殊功能的处理器，能对 I&#x2F;O 设备进行统一管理。通道程序放在主存中；另外双总线结构还支持突发（猝发）传送（送出一个地址，收到多个地址连续的数据）。</strong></p><h3 id="1-3-3-三总线结构"><a href="#1-3-3-三总线结构" class="headerlink" title="1.3.3.三总线结构"></a>1.3.3.三总线结构</h3><p><strong>三总线结构：在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这三条总线分别为主存总线、I&#x2F;O 总线和 DMA（直接内存访问）总线</strong>。</p><ul><li><strong>优点</strong>：提高了 I&#x2F;O 设备的<strong>性能</strong>，使其能更快地响应命令，提高系统<strong>吞吐量</strong>。</li><li><strong>缺点</strong>：系统工作<strong>效率较低</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162135196.png" alt="image-20230416213524132" loading="lazy"></p><ul><li><strong>主存总线</strong>：用于 <strong>CPU 和内存之间</strong>传送地址、数据和控制信息。</li><li><strong>I&#x2F;O 总线</strong>：用于 C<strong>PU 和各类外设之间</strong>通信。</li><li><strong>DMA 总线</strong>：用于<strong>内存和高速外设之间</strong>直接传送数据。</li></ul><h3 id="1-2-4-四总线结构"><a href="#1-2-4-四总线结构" class="headerlink" title="1.2.4.四总线结构"></a>1.2.4.四总线结构</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162136468.png" alt="image-20230416213657373" loading="lazy"></p><h2 id="1-4-总线性能指标"><a href="#1-4-总线性能指标" class="headerlink" title="1.4.总线性能指标"></a>1.4.总线性能指标</h2><h3 id="1-4-1-串行总线"><a href="#1-4-1-串行总线" class="headerlink" title="1.4.1.串行总线"></a>1.4.1.串行总线</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162142566.png" alt="image-20230416214234513" loading="lazy"></p><ul><li><strong>优点：</strong>只需要一条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间。</li><li><strong>缺点：</strong>在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。</li></ul><h3 id="1-4-2-并行总线"><a href="#1-4-2-并行总线" class="headerlink" title="1.4.2.并行总线"></a>1.4.2.并行总线</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162143113.png" alt="image-20230416214329047" loading="lazy"></p><ul><li>优点：总线的逻辑时序比较简单，电路实现起来比较容易。</li><li>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高昂；由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。</li></ul><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3.总结"></a>1.3.3.总结</h3><ul><li>工作频率相同时，串行总线传输速度比并行总线慢。</li><li>并行总线的工作频率无法持续提高，而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线。</li></ul><hr><p><strong>①：总线<font color='orange'>传输周期</font>（<font color='orange'>总线周期</font>）：<font color='orange'>一次总线操作所需要的时间</font>，通常由若干个总线时钟周期构成。经过一个总线传输周期后就可以完成一组数据的传送</strong></p><ul><li>申请阶段：例如总线仲裁。</li><li>寻址阶段</li><li>传输阶段</li><li>结束阶段：释放总线使用权。</li></ul><hr><p><strong>②：总线<font color='red'>时钟周期</font>：也即<font color='red'>机器的时钟周期</font>，我们知道计算机中会有一个统一的时钟，来控制整个计算机的各个部件，总线自然也要受到时钟的控制。</strong></p><p>需要注意的是，<strong>总线周期与总线时钟周期</strong>的关系有时比较复杂。</p><ul><li>大多数情况下，一个总线周期包含多个总线时钟周期。</li><li>有的时候，一个总线周期就是一个总线时钟周期。</li><li>还有的时候，一个总线时钟周期可以包含多个总线周期。</li></ul><p>关于第三点大家可能会感觉到奇怪，其实有的时候当检测到一个时钟周期的 “上升沿” 和“下降沿”时会分别发出数据  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162135085.png" alt="image-20230416213541016" loading="lazy"></p><hr><p><strong>③：总线<font color='yellow'>工作频率</font>：总线上各种操作的频率，它是<font color='yellow'>总线周期的倒数</font>。</strong></p><p>若总线周期 &#x3D; N 个时钟周期，则总线的工作频率为 &#x3D; 时钟频率 &#x2F; N，**<font color='yellow'>表示一秒内传送了几次数据</font>**。</p><hr><p>④：总线时钟频率：即机器的时钟频率，是<font color='green'>时钟周期的倒数</font>。</p><p>若时钟周期为 T，则时钟频率为 1&#x2F;T，**表示<font color='green'>一秒内有多少个时钟周期</font>**。</p><hr><p><strong>⑤：<font color='cornflowerblue'>总线宽度</font>：又称为总线位宽，它是总线上<font color='cornflowerblue'>同时能够传输的数据位数</font>，通常是指<font color='cornflowerblue'>数据总线的根数</font>。</strong> 比如 32 根就称为 32bit 总线。</p><hr><p><strong>⑥：<font color='cyan'>总线带宽</font>：可以理解为总线的<font color='cyan'>数据传输率</font>，也即<font color='cyan'>单位时间内总线上可以传输数据的位数</font>。</strong> 通常用每秒钟传送信息的字节数来衡量，单位可以用字节 &#x2F; 秒（B&#x2F;s）表示。</p><p>因此有如下公式：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171120264.png" loading="lazy"></p><hr><p><strong>⑦：总线复用：是指一种<font color='purple'>信号线在不同的时间传输不同的信息</font>，这样做可以使用<font color='purple'>较少的成本</font>来传输更多得到信息，节省了成本，但是会使传输效率下降</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162139477.png" alt="image-20230416213930407" loading="lazy"></p><hr><p><strong>⑧：信号线数：是指地址总线、数据总线、控制总线 3 种总线线的根数之和</strong>。</p><h2 id="1-5-相关计算"><a href="#1-5-相关计算" class="headerlink" title="1.5.相关计算"></a>1.5.相关计算</h2><p><strong>这一部分特别爱出有关总线性能的计算问题</strong>。</p><p><img src="https://img-blog.csdnimg.cn/115a4d8d587947e2a9ce3f7ef9229cac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/55141e348db342f3a14348b18bb89890.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/9fd080aa2cdd46e4ae52213adaa355f8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/086831d289054af2ac5cab5a33659dc8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/a223e738f45e4220a1f24af607c1a655.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/71039f7457474585a1a07898b9fd846e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/b83e88ff83cb42e1adbf0ad1d6821dc7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/4579d7032d314d0a81f950b262ef93d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"></p><h1 id="2-总线仲裁"><a href="#2-总线仲裁" class="headerlink" title="2.总线仲裁"></a>2.总线仲裁</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171121451.png" loading="lazy"></p><h2 id="2-1-总线仲裁基本概念"><a href="#2-1-总线仲裁基本概念" class="headerlink" title="2.1.总线仲裁基本概念"></a>2.1.总线仲裁基本概念</h2><h3 id="2-1-1-主设备和从设备"><a href="#2-1-1-主设备和从设备" class="headerlink" title="2.1.1.主设备和从设备"></a>2.1.1.主设备和从设备</h3><p><strong>前面说过，同一时刻只能有一个设备控制总线进行传输，但可以有一个或多个设备从总线接受数据。因此，可以将总线上所连接的各类设备按其对总线有无控制功能分为</strong>：</p><ul><li><strong>主设备</strong>：获得<strong>总线控制权</strong>的设备。</li><li><strong>从设备</strong>：被主设备访问的设备，<strong>只能响应</strong>从设备发来的各种总线命令。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162150422.png" alt="image-20230416215052357" loading="lazy"></p><h3 id="2-1-2-总线仲裁的定义"><a href="#2-1-2-总线仲裁的定义" class="headerlink" title="2.1.2.总线仲裁的定义"></a>2.1.2.总线仲裁的定义</h3><p><strong>总线仲裁：多个主设备同时竞争总线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁。</strong></p><h3 id="2-1-3-为什么要进行总线仲裁"><a href="#2-1-3-为什么要进行总线仲裁" class="headerlink" title="2.1.3.为什么要进行总线仲裁"></a>2.1.3.为什么要进行总线仲裁</h3><p>总线属于共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。为了解决这个问题，应当采用<strong>总线仲裁部件</strong>，<strong>以某种方式选择一个主设备优先获得总线控制权，只有获得了总线控制权的设备，才能传送数据。</strong></p><h3 id="2-1-4-总线仲裁分类"><a href="#2-1-4-总线仲裁分类" class="headerlink" title="2.1.4.总线仲裁分类"></a>2.1.4.总线仲裁分类</h3><p><strong>①：集中仲裁方式</strong></p><ul><li><strong>链式查询方式</strong></li><li><strong>计数器定时查询方式</strong></li><li><strong>独立请求方式</strong></li></ul><p><strong>②：分布仲裁方式</strong></p><h2 id="2-2-集中仲裁"><a href="#2-2-集中仲裁" class="headerlink" title="2.2.集中仲裁"></a>2.2.集中仲裁</h2><p><strong>集中仲裁的工作流程</strong>：</p><ul><li>主设备发出<strong>请求信号。</strong></li><li>。若多个主设备同时要求使用总线，则<strong>总线控制器判优</strong>，仲裁逻辑按照一定的<strong>优先级顺序</strong>确定哪个主设备能够使用总线</li><li><strong>获得总线使用权</strong>的主设备开始传送数据。</li></ul><h3 id="2-2-1-链式查询方式"><a href="#2-2-1-链式查询方式" class="headerlink" title="2.2.1.链式查询方式"></a>2.2.1.链式查询方式</h3><h4 id="2-2-1-1-概述"><a href="#2-2-1-1-概述" class="headerlink" title="2.2.1.1.概述"></a>2.2.1.1.概述</h4><p><strong>链式查询方式：总线上所有的部件共用一根总线请求线（BR），当有部件请求使用总线时，需要经过此线发总线请求信号到总线控制器，由总线控制器检查总线是否忙？若总线不忙，则立即发出总线响应信号，经总线响应线（BG）串行地从一个部件传送到下一个部件，依次查询。</strong></p><ul><li><p><strong>若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件</strong>。</p></li><li><p><strong>若响应信号到达的部件有总线请求，则信号被拦截，不再传下去</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162151041.png" alt="image-20230416215127964" loading="lazy"></p></li></ul><p><strong>注意：</strong></p><ul><li>“<strong>总线忙” 信号的建立者是获得总线控制权的设备。</strong></li><li><strong>离总线控制器越近的部件优先级就越高；离总线控制器越远的部件优先级就越低。</strong></li></ul><h4 id="2-2-1-2-例子"><a href="#2-2-1-2-例子" class="headerlink" title="2.2.1.2.例子"></a>2.2.1.2.例子</h4><ul><li>假设上图中的设备 1 和设备 n 同时想要使用总线，<strong>那么它们都会向 BR 发出总线请求信号。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162152632.png" alt="image-20230416215227562" loading="lazy"></p><ul><li>当总线控制部件检测到请求信号时，它明白其中有设备想要获得总线控制权。</li><li>接着，总线控制部件会通过 <strong>BG 发出总线允许信号</strong>。该信号第一次会通过设备 0，但此时设备 0 并不想要使用总线，因此会让此信号继续往后传递；来到设备 1 后，设备 1 是想要使用总线的，<strong>所以它会接受信号，这也意味着总线控制部件允许它控制总线。</strong></li><li>同时<strong>设备 1 会向 BS 发出总线忙信号，</strong>表明此时总线已经被自己占据。当控制部件检测到 BS 信号时，就明白了此时总线控制权已经分配给了某个设备，于是会<strong>撤销 BG 信号</strong>，看起来就好像 BG 信号被设备 1 截断了一样。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162153272.png" alt="image-20230416215305200" loading="lazy"></p><p>接下来设备 1 就可以使用总线与其他设备进行数据交互了。<strong>当设备 1 使用完总线时，它会撤销总线忙信号。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162153571.png" alt="image-20230416215342495" loading="lazy"></p><p>此时设备 n 还在请求总线，总线控制部件检测到请求信号之后，重复以上步骤即可  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162155512.png" alt="image-20230416215518446" loading="lazy"></p><h4 id="2-2-1-4-优缺点"><a href="#2-2-1-4-优缺点" class="headerlink" title="2.2.1.4.优缺点"></a>2.2.1.4.优缺点</h4><p><strong>其优缺点如下</strong>：</p><ul><li><strong>优点</strong>：链式查询方式<strong>优先级固定</strong>，只需要很少几根控制线就能按一定优先次序实现总线控制，<strong>结构简单，易于扩充。</strong></li><li><strong>缺点</strong>：对硬件电路的故障<strong>十分敏感</strong>，并且<strong>优先级不能更改</strong>。当优先级较高的部件频繁使用总线时，会使优先级较低的部件长期不能使用总线，<strong>产生 “饥饿” 现象。</strong></li></ul><h3 id="2-2-2-计数器查询方式"><a href="#2-2-2-计数器查询方式" class="headerlink" title="2.2.2.计数器查询方式"></a>2.2.2.计数器查询方式</h3><h4 id="2-2-2-1-概述"><a href="#2-2-2-1-概述" class="headerlink" title="2.2.2.1.概述"></a>2.2.2.1.概述</h4><p><strong>计数器查询方式：该方式采用了一个计数器来控制总线使用权，相比链式查询方式多了一组设备地址线，少了一根总线响应线 BG，仍共用一根总线请求线，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数。计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162156297.png" alt="image-20230416215647229" loading="lazy"></p><h4 id="2-2-2-2-例子"><a href="#2-2-2-2-例子" class="headerlink" title="2.2.2.2.例子"></a>2.2.2.2.例子</h4><p>假设上图中的设备 1 和设备 n 通过 BR 发出<strong>总线请求信号。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162200938.png" alt="image-20230416220054864" loading="lazy"></p><p>当总线控制部件检测到请求信号时，它明白其中有设备想要获得总线控制权，此时<strong>计数器开始计数</strong>。比如从 0 开始，这意味着设备地址线上传过来的地址是 0，<strong>表示正在询问设备 0 是否想要控制权，</strong> 由于 0 号设备不想要使用，所以此时计数器变为 1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162201512.png" alt="image-20230416220134432" loading="lazy"></p><p>接着设备 1 发现此时的地址信息是自己的编号，而它正好也想要控制权，<strong>因此它会发出总线忙信号，表示此时已经获得了总线控制权。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162202102.png" alt="image-20230416220235021" loading="lazy"></p><p><strong>当控制部件检测到总线忙信号时，结束仲裁，同时计数器暂停</strong>。接着设备 1 就可以使用总线进行数据交互了。</p><p>使用完成之后，设备 1 会撤销 BS 信号，<strong>如果此时还有请求信号，那么计数器就可以接着计时，然后询问下一个设备是否需要控制总线。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162202102.png" alt="image-20230416220235021" loading="lazy"></p><h4 id="2-2-2-3-优缺点"><a href="#2-2-2-3-优缺点" class="headerlink" title="2.2.2.3.优缺点"></a>2.2.2.3.优缺点</h4><p><strong>优点一：就是计数初始值可以改变优先次序。</strong></p><ul><li>如果计数每次从 0 开始，那么设备的优先级就按顺序排列，固定不变。</li><li>如果计数器从上一次终点开始接着计数，此时设备优先级平等。</li><li>计数器的初始值还可以使用程序控制。</li></ul><p><strong>优点二：就是对电路的故障没有敏感</strong></p><p><strong>缺点一：就是增加了控制总线。</strong></p><ul><li>若设备有 $n$ 个，则需要 $\lceil log_{2}n \rceil $ 条控制线。</li></ul><p><strong>缺点二：就是查询较链式查询复杂。</strong></p><h3 id="2-2-3-独立请求方式"><a href="#2-2-3-独立请求方式" class="headerlink" title="2.2.3.独立请求方式"></a>2.2.3.独立请求方式</h3><h4 id="2-2-3-1-概述"><a href="#2-2-3-1-概述" class="headerlink" title="2.2.3.1.概述"></a>2.2.3.1.概述</h4><p><strong>计数器查询方式：该方式中，每个设备均有一对总线请求线 B R i BR_{i} BRi​和总线允许线 B G i BG_{i} BGi​。当总线上的部件需要使用总线时，经各自的总线请求线发出总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准每个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162203989.png" alt="image-20230416220332923" loading="lazy"></p><h4 id="2-2-3-2-例子"><a href="#2-2-3-2-例子" class="headerlink" title="2.2.3.2.例子"></a>2.2.3.2.例子</h4><p>总线控制部件中有一个排队器，如下，当设备 n 需要使用总线时会发出总线请求信号，轮到该设备使用总线时，该设备再给控制部件发送 BS 信号，告诉控制部件仲裁已经结束，当该设备使用完总线后，会撤销 BS 信号，排队继续进行 。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162205341.png" alt="image-20230416220504255" loading="lazy"></p><h4 id="2-2-3-4-优缺点"><a href="#2-2-3-4-优缺点" class="headerlink" title="2.2.3.4.优缺点"></a>2.2.3.4.优缺点</h4><p><strong>优点</strong></p><ul><li>响应<strong>速度快</strong>，总线允许信号 BG 直接从控制器发送到有关设备，不必在设备之间传递或查询。</li><li>对优先次序的控制相当<strong>灵活。</strong></li></ul><p><strong>缺点一：控制线数量多</strong></p><ul><li>若设备有 n 个，则需要 2n+1 条控制线。其中 + 1 为 BS 线，用于设备向总线控制部件反馈已经是否正在使用总线。</li></ul><p><strong>缺点二：控制逻辑更加复杂。</strong></p><h3 id="2-2-4-三种仲裁方式对比"><a href="#2-2-4-三种仲裁方式对比" class="headerlink" title="2.2.4.三种仲裁方式对比"></a>2.2.4.三种仲裁方式对比</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162205354.png" alt="image-20230416220524283" loading="lazy"></p><h2 id="2-3-分布仲裁"><a href="#2-3-分布仲裁" class="headerlink" title="2.3.分布仲裁"></a>2.3.分布仲裁</h2><p><strong>分布仲裁：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</strong></p><ul><li>当设备有总线请求时，它们就各自把唯一的仲裁号发送到共享的仲裁总线上。</li><li>每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较。</li><li>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。</li><li>最后，获胜者的仲裁号保留在仲裁总线上。</li></ul><h1 id="3-总线操作和定时"><a href="#3-总线操作和定时" class="headerlink" title="3.总线操作和定时"></a>3.总线操作和定时</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162220391.png" alt="image-20230416222036296" loading="lazy"></p><h2 id="3-1-总线定时"><a href="#3-1-总线定时" class="headerlink" title="3.1.总线定时"></a>3.1.总线定时</h2><h3 id="3-1-1-总线周期"><a href="#3-1-1-总线周期" class="headerlink" title="3.1.1.总线周期"></a>3.1.1.总线周期</h3><p><strong>总线周期：一个总线周期通常会分为以下几个阶段</strong>：</p><ul><li><p><strong>申请分配阶段：</strong> 由需要使用总线的主模块（主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者，也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两个阶段。</p></li><li><p><strong>寻址阶段：</strong> 获得使用权的主模块通过总线发出本次要访问的<strong>从模块的地址及有关命令</strong>，启动参与本次传输的从模块。</p></li><li><p><strong>传输阶段：</strong> 主模块和从模块进行<strong>数据交换</strong>，可单向或双向进行数据传送。</p></li><li><p><strong>结束阶段：</strong> 主模块的有关信息均从系统总线上<strong>撤除</strong>，让出总线使用权。</p></li></ul><h3 id="3-1-2-总线定时"><a href="#3-1-2-总线定时" class="headerlink" title="3.1.2.总线定时"></a>3.1.2.总线定时</h3><p><strong>总线定时：是指双方在总线上交换数据时对时间关系的一种控制。本质是一种协议或规则，主要有以下几种</strong>：</p><ul><li><strong>同步通信（同步定时方式）</strong>：由统一时钟控制数据传送。</li><li><strong>异步通信（异步定时方式）</strong>：采用应答方式，没有公共时钟标准。</li><li><strong>半同步通信</strong>：同步、异步的结合。</li><li><strong>分离式通信</strong>：充分挖掘系统总线每一瞬间的潜力。</li></ul><h2 id="3-2-同步定时方式"><a href="#3-2-同步定时方式" class="headerlink" title="3.2.同步定时方式"></a>3.2.同步定时方式</h2><h3 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1.概述"></a>3.2.1.概述</h3><p><strong>同步定时：总线控制器采用一个统一的时钟信号来协调发送和接受双方的传送定时关系，有如下特点</strong>：</p><ul><li>若干时钟周期产生<strong>相等的时间间隔，每个间隔构成一个总线周期。</strong></li><li>在一个总线周期中，发送方和接受方可以进行<strong>一次数据传送。</strong></li><li>采用统一的时钟，每个部件或设备发送或接受信息都在固定的传送周期中，<strong>一个总线的传送周期结束，下一个总线传送周期开始</strong>。</li></ul><p><strong>例如下图，假设 CPU 作为主设备，某个输入设备作为从设备，那么整个传送过程如下</strong>：</p><ul><li>CPU 在 $ T_{1} $时刻的<strong>上升沿</strong>给出<strong>地址信息</strong>。</li><li>在 $T_{2} $时刻的<strong>上升沿给出读命令</strong>（这里时低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且<strong>必须在$ T_{3}$​的上升沿来临之前</strong>，将 CPU 所需要的数据送到数据总线上。</li><li>CPU 在 $T_{3} $​时钟周期内，将数据线上的信息传送到内部寄存器中。</li><li>CPU 在 $ T_{4} $​时刻的上升沿<strong>撤销读命令</strong>，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162207231.png" alt="image-20230416220728165" loading="lazy"></p><h3 id="3-2-2-优缺点"><a href="#3-2-2-优缺点" class="headerlink" title="3.2.2.优缺点"></a>3.2.2.优缺点</h3><p><strong>优点</strong></p><ul><li>传送<strong>速度快</strong>、传输<strong>速率高。</strong></li><li>总线控制逻辑<strong>简单。</strong></li></ul><p><strong>缺点</strong></p><ul><li>主从设备属于<strong>强制性同步。</strong></li><li>不能及时进行数据通信的有效性检验，<strong>可靠性较差。</strong></li></ul><p><strong>同步通信适用于总线长度较短以及总线所接部件的存取时间比较接近的系统，否则就会出现诸如 “主设备跟得上总线的速度，而从设备跟不上总线的速度” 这样的尴尬情况。</strong></p><h2 id="3-3-异步定时方式"><a href="#3-3-异步定时方式" class="headerlink" title="3.3.异步定时方式"></a>3.3.异步定时方式</h2><p><strong>异步定时：没有统一的时钟，也没有固定的时钟间隔，完全依靠传送双方相互制约的 “握手” 信号来实现定时控制。</strong></p><ul><li><strong>主设备提出交换信息的 “请求” 信号，经接口传送到从设备。</strong></li><li><strong>从设备接到主设备的请求后，通过接口向主设备发出 “回答” 信号。</strong></li></ul><h3 id="3-3-1-三种异步定时方式"><a href="#3-3-1-三种异步定时方式" class="headerlink" title="3.3.1.三种异步定时方式"></a>3.3.1.三种异步定时方式</h3><p><strong>由于没有统一的时钟信号，所以他们是根据 “请求” 和“回答”信号的撤销是否互锁，分为以下三种类型。可以结合网络中的三次握手理解。</strong></p><ul><li>不互锁方式</li><li>半互锁方式</li><li>全互锁方式</li></ul><h4 id="3-3-1-1-不互锁（速度最快但可靠性最差）"><a href="#3-3-1-1-不互锁（速度最快但可靠性最差）" class="headerlink" title="3.3.1.1.不互锁（速度最快但可靠性最差）"></a>3.3.1.1.不互锁（速度最快但可靠性最差）</h4><ul><li><p><strong>主设备发出 “<font color='red'>请求</font>” 信号后，不必等从设备的 “<font color='orange'>回答</font>” 信号，而是经过一段时间，便撤销 “<font color='red'>请求</font>” 信号，双方不存在互锁关系。</strong></p></li><li><p><strong>从设备接到 “<font color='red'>请求</font>” 信号后，发出 “<font color='orange'>回答</font>” 信号，并经过一段时间后，自动撤销 “<font color='orange'>回答</font>” 信号，双方不存在互锁关系。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162208316.png" alt="image-20230416220824949" loading="lazy"></p><h4 id="3-3-1-2-半互锁"><a href="#3-3-1-2-半互锁" class="headerlink" title="3.3.1.2.半互锁"></a>3.3.1.2.半互锁</h4><ul><li><p><strong>主设备发出 “<font color='red'>请求</font>” 信号后，必须等到从设备的 “<font color='orange'>回答</font>” 信号到来，才撤销 “<font color='red'>请求</font>” 信号，有互锁的关系。</strong></p></li><li><p><strong>从设备在接受到 “<font color='red'>请求</font>” 信号后，发出 “<font color='orange'>回答</font>” 信号，但不需要等到获知主设备的 “<font color='red'>请求</font>” 信号已经撤销，而是隔一段时间后自动撤销 “<font color='orange'>回答</font>” 信号，不存在依赖关系</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162208514.png" alt="image-20230416220834430" loading="lazy"></p><h4 id="3-3-1-3-全互锁（可靠性最强但速度最慢）"><a href="#3-3-1-3-全互锁（可靠性最强但速度最慢）" class="headerlink" title="3.3.1.3.全互锁（可靠性最强但速度最慢）"></a>3.3.1.3.全互锁（可靠性最强但速度最慢）</h4><ul><li><p><strong>主设备发出 “<font color='red'>请求</font>” 信号后，必须要等到从设备的 “<font color='orange'>回答</font>” 信号到来，才撤销 “<font color='red'>请求</font>” 信号，双方存在互锁的关系</strong></p></li><li><p><strong>从设备发出“<font color='orange'>回答</font>”信号，必须待获知主设备 “<font color='red'>请求</font>” 信号已经撤销后，再撤销其 “<font color='orange'>回答</font>” 信号，双方存在互锁关系</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162208187.png" alt="image-20230416220840118" loading="lazy"></p><h3 id="3-2-2优缺点"><a href="#3-2-2优缺点" class="headerlink" title="3.2.2优缺点"></a>3.2.2优缺点</h3><ul><li><strong>优点</strong>：总线周期<strong>长度可变</strong>，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，<strong>自动适应时间的配合</strong>。</li><li><strong>缺点</strong>：同步控制方式<strong>复杂</strong>，速度<strong>慢于</strong>同步定时方式。</li></ul><h2 id="3-4-半同步通信"><a href="#3-4-半同步通信" class="headerlink" title="3.4.半同步通信"></a>3.4.半同步通信</h2><p>半同步通信：统一时钟的基础上，增加一个“等待”响应信号<code>WATT</code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162215594.png" alt="image-20230416221516520" loading="lazy"></p><h2 id="3-5-半分离通信"><a href="#3-5-半分离通信" class="headerlink" title="3.5.半分离通信"></a>3.5.半分离通信</h2><p>上述三种通信的<strong>共同点</strong>一个总线传输周期（以输入数据为例）：</p><ul><li>主模块发地址、命令            <font color='green'>使用总线</font></li><li>从模块准备数据                   <font color='green'>不使用总线</font>         <font color='cornflowerblue'>总线空闲</font></li><li>从模块向主模块发数据        <font color='green'>使用总线</font></li></ul><p><strong>分离式通信的一个总线传输周期：</strong></p><ul><li>子周期1：<font color='cornflowerblue'>主模块</font>申请<font color='cornflowerblue'>占用总线</font>，使用完后放弃总线的使用权。</li><li>子周期2：<font color='cornflowerblue'>从模块</font>申请<font color='cornflowerblue'>占用总线</font>，将各种信息送至总线上。</li></ul><p><strong>特点：</strong></p><ul><li>各模块均有权申请占用总线。</li><li>采用同步方式通信，不等对方回答。</li><li>各模块准备数据时，不占用总线。</li><li>总线利用率提高。</li></ul><h1 id="4-总线标准"><a href="#4-总线标准" class="headerlink" title="4.总线标准"></a>4.总线标准</h1><h2 id="4-1-总线标准是什么"><a href="#4-1-总线标准是什么" class="headerlink" title="4.1.总线标准是什么"></a>4.1.总线标准是什么</h2><p><strong>总线标准</strong>：<strong>是国际上公布或推荐的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范</strong>。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需要根据总线标准的要求完成自方面的功能要求，而无需了解对方接口的要求  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162221056.png" alt="image-20230416222100965" loading="lazy"></p><p><strong>根据总线在计算机系统中的位置，总线可以分为</strong>：</p><ul><li><strong>系统总线</strong>：通常<strong>与 CPU 直接相连</strong>，用于连接 CPU 与北桥芯片，或 CPU 与主存。</li><li><strong>局部总线</strong>：没有直接与 CPU 连接，通常是连<strong>接高速的北桥芯片</strong>，用于连接很多重要的硬件部件（比如显卡和声卡等）。</li><li><strong>设备总线、通信总线</strong>：通常 ** 由南桥芯片控制，** 用于连接计算机与计算机，或连接计算机与外部 I&#x2F;O 设备。</li></ul><h2 id="4-2-总线标准总结"><a href="#4-2-总线标准总结" class="headerlink" title="4.2.总线标准总结"></a>4.2.总线标准总结</h2><p><strong>总线标准总览如下，其中加粗部分为考试重点标准，各总线详细介绍请向下翻阅</strong>：</p><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td><strong>ISA</strong></td><td>Industry Standard Architecture</td><td>8MHz</td><td>8/16</td><td>16MB/s</td><td>系统总线</td></tr><tr><td><strong>EISA</strong></td><td>Extended ISA</td><td>8MHz</td><td>32</td><td>32MB/s</td><td>系统总线</td></tr><tr><td>VISA</td><td>Video Industry Standard Architecture</td><td>33MHz</td><td>32</td><td>132MB/s</td><td>局部总线</td></tr><tr><td><strong>PCI</strong></td><td>Peripheral Component Interconnect</td><td>33/66MHz</td><td>32/64</td><td>528MB/s</td><td>局部总线</td></tr><tr><td>AGP</td><td>Accelerated Graphics Port</td><td>-</td><td>-</td><td>X1:266MB/s；X8:2.1GB/s</td><td>局部总线</td></tr><tr><td><strong>PCI-E</strong></td><td>PCI-Express(3GIO)</td><td>-</td><td>-</td><td>10GB/s 以上</td><td>串行</td></tr><tr><td>SCSI</td><td>Small Computer System Interface</td><td>-</td><td>-</td><td>640MB/s</td><td>智能通用接口</td></tr><tr><td>RS-232C</td><td>Recommended Standard</td><td>-</td><td>-</td><td>20Kbps</td><td>串行通信总线</td></tr><tr><td>PCMCIA</td><td>Personal Computer Memory Card International Association</td><td>-</td><td>-</td><td>90MB/s</td><td>便携通用接口</td></tr><tr><td><strong>USB</strong></td><td>Universal Serial Bus International Association</td><td>-</td><td>-</td><td>1280MB/s</td><td>设备总线、串行</td></tr><tr><td>IDE(ATA)</td><td>Integrated Drive Electronics</td><td>-</td><td>-</td><td>100MB/s</td><td>硬盘光驱接口</td></tr><tr><td>SATA</td><td>Serial Advanced Technology Attachment</td><td>-</td><td>-</td><td>600MB/s</td><td>串行硬盘接口</td></tr></tbody></table><p><strong>思维导图如下（发展趋势）</strong>  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162221954.png" alt="image-20230416222142846" loading="lazy"></p><h2 id="4-3-总线标准详述"><a href="#4-3-总线标准详述" class="headerlink" title="4.3.总线标准详述"></a>4.3.总线标准详述</h2><h3 id="4-3-1-系统总线标准"><a href="#4-3-1-系统总线标准" class="headerlink" title="4.3.1.系统总线标准"></a>4.3.1.系统总线标准</h3><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>ISA</td><td>Industry Standard Architecture</td><td>8MHz</td><td>8/16</td><td>16MB/s</td><td>系统总线</td></tr><tr><td>EISA</td><td>Extended ISA</td><td>8MHz</td><td>32</td><td>32MB/s</td><td>系统总线</td></tr></tbody></table><blockquote><p>最早的 PC 总线是 IBM 公司 1981 年在 PC&#x2F;XT 电脑采用的系统总线，它基于 8bit 的 8088 处理器，被称为 PC 总线或者 PC&#x2F;XT 总线。</p><p>1984 年，IBM 推出基于 16-bit Intel 80286 处理器的 PC&#x2F;AT 电脑，系统总线也相应地扩展为 16bit，并被称呼为 PC&#x2F;AT 总线。而为了开发与 IBM PC 兼容的外围设备，行业内便逐渐确立了以 IBM PC 总线规范为基础的 ISA (工业标准架构: Industry Standard Architecture ) 总线。</p><p>ISA 总线最大传输速率仅为 8MB&#x2F;s，数据传送需要 CPU 或 DMA 接口来管理，传输速率过低、CPU 占用率高、占用硬件中断资源等，很快使 ISA 总线在飞速发展的计算机技术中成为瓶颈。不支持总线仲裁。</p><p>因此在 1988 年，康柏、惠普等 9 个厂商协同把 ISA 扩展到 32 -bit, 这就是著名的 EISA (Extended ISA，扩展 ISA) 总线。EISA 总线的工作频率仍旧仅有 8MHz，并且与 8&#x2F;16bit 的 ISA 总线完全兼容，带宽提高了一 - 倍，达到了 32MB&#x2F;s。从 CPU 中分离出了总线控制权，支持多个总线主控器和突发传送。可惜的是，EISA  仍旧由于速度有限，并且成本过高，在还没成为标准总线之前，在 20 世纪 90 年代初的时候，就给 PCI 总线给取代了。</p></blockquote><h3 id="4-3-2-局部总线标准"><a href="#4-3-2-局部总线标准" class="headerlink" title="4.3.2.局部总线标准"></a>4.3.2.局部总线标准</h3><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>VISA</td><td>Video Industry Standard Architecture</td><td>33MHz</td><td>32</td><td>132MB/s</td><td>局部总线</td></tr></tbody></table><blockquote><p>CPU 的主频提高，数据宽度增大及处理能力的增强使得系统的性能迅速提高。虽然系统总线在不断发展，仍然跟不上软件和 CPU 的发展速度，仍然不能充分利用 CPU 的强大处理能力。大部分时间内，CPU 都处于等待状态，特别是在日益强大的 CPU 处理能力和存储器容量的支持和激励下，操作系统和应用程度变得越来越复杂，而显示卡和硬盘控制器因位于 8 位或 16 位系统 I&#x2F;0 总线上，相对极高的 CPU 的速度而言，传输数据的速度低的多，从而影响了系统的整体工作效率。</p><p>因此，为提高系统的整体性能，解决总线传输问题的一个办法是将外设直接挂在 CPU 局部总线上并以 CPU 速度运行，将外设挂到 CPU 局部总线能够极大地提高外设的运行速度，而成本只有轻微的上浮，这个性能 &#x2F; 价格比为局部总线创造了一个巨大的市场潜力。</p><p>1991 年) 视频电子标准协会针对视频显示的高数据传输率要求而推出了 VESA 总线，又叫做视频局部总线 (VESA local bus)，  简称 VL-BUS 总线， 由 CPU 总 线演化而来，是针对多媒体 PC 要求高速传送活动图像的大量数据应运而生的。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>PCI</td><td>Peripheral Component Interconnect</td><td>33/66MHz</td><td>32/64</td><td>528MB/s</td><td>局部总线</td></tr></tbody></table><blockquote><p>由于 ISA&#x2F;EISA 总线速度缓慢，造成硬盘、显示卡还有其它的外围设备只能通过慢速并且狭窄的瓶颈来发送和接受数据，使得整机的性能受到严重的影响。为了解决这个问题，1992 年 Intel 在发布 486 处理器的时候，也同时提出了 32 -bit 的 PCI (周边组件互连) 总线。  最早提出的 PCI 总线工作在 33MHz 频率之下，传输带宽达到了 133MB&#x2F;s (33MHz X 32bit&#x2F;8)，比 ISA 总线有了极大的改善，基本上满足了当时处理器的发展需要。目前计算机上广泛采用的是这种 32-bit、33MHz 的 PCI 总线，可扩展到 64bit。</p></blockquote><p>特点如下</p><ol><li><strong>高性能</strong>，不依附于某个具体的处理器，支持突发传送</li><li>良好的<strong>兼容性</strong></li><li>支持<strong>即插即用</strong></li><li>支持<strong>多主设备。</strong></li><li>具有与处理器和存储器子系统完全<strong>并行操作</strong>的能力</li><li>提供数据和地址<strong>奇偶校验</strong>的能力</li><li>可扩充性好，可采用<strong>多层结构</strong>提高驱动能力</li><li>采用<strong>多路复用技术</strong>，减少了总线引脚个数</li></ol><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>AGP</td><td>Accelerated Graphics Port</td><td>-</td><td>-</td><td>X1:266MB/s；X8:2.1GB/s</td><td>局部总线</td></tr></tbody></table><blockquote><p>PCI 总线是独立于 CPU 的局部总线，可将显示卡、声卡、网卡、硬盘控制器等高速的外围设备直接挂在 CPU 总线上，打破了瓶颈，使得 CPU 的性能得到充分的发挥。可惜的是，由于 PCI 总线只有 133MB&#x2F;s 的带宽，对付声卡、网卡、视频卡等绝大多数输入 &#x2F; 输出设备也许显得绰绰有舍，但对于胃口越来越大的 3D 显卡却力不从心，并成为了制约显示子系统和整机性能的瓶颈。因此，PCI 总线的补充 —-AGP 总线就应运而生了。Intel 于 1996 年 7 月正式推出了 AGP (加速图形接口，Accelerated Graphics Port) 接口，这是显示卡专用的局部总线，是基于 PCI 2.1 版规范并进行扩充修改而成，工作频率为 66MHz，1X 模式下带宽为 266MB&#x2F;S，是 PCI 总 线的两倍。后来依次又推出了 AGP 2X、AGP 4X，现在则是 AGP 8X，传输速度达到了 2. 1GB&#x2F;S。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>PCI-E</td><td>PCI-Express(3GIO)</td><td>-</td><td>-</td><td>10GB/s 以上</td><td>串行</td></tr></tbody></table><blockquote><p>Intel 在 2001 年春季的 IDF 上，正式公布了旨在取代 PCI 总线的第三代 I&#x2F;0 技术，最后却被正式命名为 PCI-Express,Express 意思是高速、特别快的意思。PCI Express 总线 是一种完全不同于过去 PCI 总线的一种全新总线规范，与 PCI 总线共享并行架构相比，PCI Express 总线是一种点对点串行连接的设备连接方式，点对点意味着每 - 一个 PCI Express 设 备都拥有自己独立的数据连接，各个设备之间并发的数据传输互不影响，而对于过去 PCI 那种共享总线方式，PCI 总线上只能有一个设备进行通信，一旦 PCI 总线上挂接的设备增多，每个设备的实际传输速率就会下降，性能得不到保证。在传输速率方面，PCIExpress 总线利用串行的连接特点将能轻松将数据传输速度提到—个很高的频率，达到远超出 PCI 总线的传输速率。与此同时，PCI Express 总线支持双向传输模式，还可以运行全双工模式。支持热拔插。</p></blockquote><h3 id="4-3-3-设备总线标准"><a href="#4-3-3-设备总线标准" class="headerlink" title="4.3.3.设备总线标准"></a>4.3.3.设备总线标准</h3><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>RS-232C</td><td>Recommended Standard</td><td>-</td><td>-</td><td>20Kbps</td><td>串行通信总线</td></tr></tbody></table><blockquote><p>RS-232C 是应用于串行二进制交换的数据终端设备 (DTE) 和数据通信设备 (DCE)之间的标准接口。RS- 232C 是美国电子工业协会 EIA (Electronic Industry Association) 联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的一. 种串行物理接口标准。RS 是英文 “推荐标准” 的缩写，232 为标识号，C 表示修改次数。RS- -232C 总线标准设有 25 条信号线，包括一个主通道和一一个辅助通道。该标准规定采用 - 一个 25 个脚的 DB–25 连接器，对连接器的每个引脚的信号内容加以规定，还对各种信号的电平加以规定。后来 IBM 的 PC 机将 RS232 简化成了 DB-9 连接器，从而成为事实标准。而工业控制的 RS -232 口一般只使用 RXD、TXD、 GND 三 条线。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>SCSI</td><td>Small Computer System Interface</td><td>-</td><td>-</td><td>640MB/s</td><td>智能通用接口</td></tr></tbody></table><blockquote><p>SCSI (小型<a href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020">计算机系统</a>接口) 是一种用于计算机和智能设备之间 (硬盘、软驱、光驱、打印机、扫描仪等) 系统级接口的独立处理器标准。SCSI 是一种智能的通用接口标准。IDE 的工作方式需要 CPU 的全程参与，CPU 读写数据的时候不能再进行其他操作，这种情况在 Windows 95&#x2F;NT 的多 任务操作系统中，自然就会导致系统反应的大大减慢。而 SCSI 接口，则完全通过独立的高速的 SCSI 卡来控制数据的读写操作，CPU 就不必浪费时间进行等待，显然可以提高系统的整体性能。不过，IDE 接口为改善这个问题也做了很大改进，已经可以使用 DMA 模式而非 PI0 模式来读写，数据的交换由 DMA 通道负责，对 CPU 的占用可大大减小。尽管如此，比较 SCSI 和 IDE 在 CPU 的占用率，还是可以发现 SCSI 仍具有相当的优势。SCSI 的扩充性比 IDE 大，- - 般每个 IDE 系统可有 2 个 IDE 通道，总共连 4 个 IDE 设备，而 SCSI 接口可连接 7- -15 个设备，比 IDE 要多很多，而且连接的电缆也远长于 IDE. 虽然 SCSI 设备价格高些，与 IDE 相 比, SCSI 的性能更稳定、耐用，可靠性也更好。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>PCMCIA</td><td>Personal Computer Memory Card International Association</td><td>-</td><td>-</td><td>90MB/s</td><td>便携通用接口</td></tr></tbody></table><blockquote><p>由于可移动计算机 (笔记本) 用户对 PC 卡的需求变了，要求强度高，能耗低，尺寸小，而且对这几条性能的要求都很高。所以 PC 卡的标准也相应地变了。1991 年， PCMCIA 定 义了原本用于内存卡的 68 个脚的 I&#x2F;0 连接线路标准。同时增加了插槽使用说明。生产商意识到软件需要提高兼容性，因而这项标准也就得到了相应的应用。  PCMCIA 总线分为两类，一类为 16 位的 PCMCIA，另一类为 32 位的 CardBus。CardBus 是 - 种用于笔记本计算机的新的高性能 PC 卡总线接口标准，就像广泛地应用在台式计算机中的 PCI 总线一样。该总线标准与原来的 PC 卡标准相比，具有以下的优势:<br>第一，是 32 位数据传输和 33MHz 操作。CardBus 快速以太网 PC 卡的最大吞吐量接近 90 Mbps，而 16 位快速以太网 PC 卡仅能达到 20-30 Mbps。<br>第二，总线自主。使 PC 卡可以独立于主 CPU，与计算机内存间直接交换数据，这样 CPU 就可以处理其它的任务。<br>第三，3. 3V 供电，低功耗。提高了电池的寿命，降低了计算机内部的热扩散，增强了系统的可靠性。第四，后向兼容 16 位的 PC 卡。老式以太网和 Modem 设备的 PC 卡仍然可以插在 CardBus 插槽_上使用。PCMCIA 支持即插即用。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>USB</td><td>Universal Serial Bus International Association</td><td>-</td><td>-</td><td>1280MB/s</td><td>设备总线、串行</td></tr></tbody></table><blockquote><p>USB 是在 1994 年底由英特尔等多家公司联合在 1996 年推出后，已成功替代串口和并口，已成为当今电脑与大量智能设备的必配接口。USB 属于设备总线，是设备和设备控制器之间的接口。USB 所有新版本都向下兼容，可以连接鼠标、键盘、打印机、扫描仪、摄像头、充电器、闪存盘、MP3 机、手机、数码相机、移动硬盘、外置光软驱、USB 网卡、ADSL Modem、Cable Modem 等几乎所有的外部设备。可以热插拔、即插即用。具有很强的连接能力和很好的可扩充性。采用菊花链形式将众多外设连接起来，可使用 USB 集线器链式连接 127 个外设。标准统一。以前大家常见的是 IDE 接口的硬盘，串口的鼠标键盘，并口的打印机扫描仪，可是有了 USB 之后，这些应用外设统统可以用同样的标准与个人电脑连接，这时就有了 USB 硬盘、USB 鼠标、USB 打印机等等。高速传输。连接电缆轻巧，可为低压 (5V) 外设供电。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>IDE(ATA)</td><td>Integrated Drive Electronics</td><td>-</td><td>-</td><td>100MB/s</td><td>硬盘光驱接口</td></tr></tbody></table><blockquote><p>Integrated Drive Electronics (电子集成驱动器)本意是指把 “硬盘控制器” 与“盘体”集成在一起的硬盘驱动器。用于 IDE 硬盘的接口最初被称为 IDE 接口，后来扩展为 CD-ROM、磁带机、可移动磁盘、LS-120 磁盘等设备的接口。硬盘和光驱通过 IDE 接口与主板连接。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>SATA</td><td>Serial Advanced Technology Attachment</td><td>-</td><td>-</td><td>600MB/s</td><td>串行硬盘接口</td></tr></tbody></table><blockquote><p>SerialATA 即串行高级技术附件，它是一种完全不同于并行 ATA 的新型硬盘接口类型，由于采用串行方式传输数据而知名。是由 APT Technologies、 DELL、IBM、 Intel、 Maxtor、Quantum， Seagate 等公 司合作开发用于取代并行ATA 接口技术。与并行 ATA 相比，SATA 具有比较大的优势。<br>首先，SerialATA 以连续串行的方式传送数据，可以在较少的位宽下使用较高的工作频率来提高数据传输的带宽， Serial ATA - 次只会传送 1 位数据，这样能减少 SATA 接口的针脚数目，使连接电缆数目变少，效率也会更高。同时还能降低系统能耗，减小系统复杂性。其次，Serial ATA 的起点更高、发展潜力更大，Serial ATA 1. 0 定义的数据传输率可达 150MB&#x2F;sec，这比目前最块的并行 ATA(即 ATA&#x2F;133) 所能达到 133MB&#x2F;sec 的最高数据传输率还高，而在已经发布的 SerialATA2.0 的数据传输率将达到 300MB&#x2F;sec，最终 Serial ATA 3. 0 将实现 600MB&#x2F; sec 的最高数据传输率。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-总线概述&quot;&gt;&lt;a href=&quot;#1-总线概述&quot; class=&quot;headerlink&quot; title=&quot;1.总线概述&quot;&gt;&lt;/a&gt;1.总线概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wushuai200</summary>
      
    
    
    
    <category term="考研408" scheme="http://ccsu.top/categories/%E8%80%83%E7%A0%94408/"/>
    
    
    <category term="计算机组成原理" scheme="http://ccsu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="考研" scheme="http://ccsu.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>机组-第五章 中央处理器</title>
    <link href="http://ccsu.top/posts/ea8ec112/"/>
    <id>http://ccsu.top/posts/ea8ec112/</id>
    <published>2023-04-09T16:00:00.000Z</published>
    <updated>2023-04-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CPU的基本功能和结构"><a href="#1-CPU的基本功能和结构" class="headerlink" title="1.CPU的基本功能和结构"></a>1.CPU的基本功能和结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161552750.png" alt="image-20230416155227635" loading="lazy"></p><h2 id="1-1-CPU-的功能"><a href="#1-1-CPU-的功能" class="headerlink" title="1.1.CPU 的功能"></a>1.1.CPU 的功能</h2><h3 id="1-1-1-CPU-的具体功能"><a href="#1-1-1-CPU-的具体功能" class="headerlink" title="1.1.1.CPU 的具体功能"></a>1.1.1.CPU 的具体功能</h3><p><strong>CPU 具体功能包括</strong>：</p><ul><li><strong>指令控制</strong>：完成<strong>取指令、分析指令和执行指令</strong>的操作，也即程序的<strong>顺序控制</strong>。</li><li><strong>操作控制</strong>：<strong>一条指令的功能是通过若干操作信号组合来实现的</strong>。CPU 管理并产生由内存取出的每条指令的操作信号，<strong>把各种操作信号送往相应部件，从而控制这些部件按指令的要求进行动作。</strong></li><li><strong>时间控制</strong>：对各种操作加以时间上的控制。时间控制要为每条指令按<strong>时间顺序</strong>提供应有的控制信号。</li><li><strong>数据加工</strong>：对数据进行<strong>算数和逻辑运算。</strong></li><li><strong>中断处理</strong>：对计算机运行过程中出现的<strong>异常情况和特殊请求</strong>进行处理。</li></ul><h3 id="1-1-2-每个部件的功能"><a href="#1-1-2-每个部件的功能" class="headerlink" title="1.1.2.每个部件的功能"></a>1.1.2.每个部件的功能</h3><p><strong>CPU 由运算器和控制器构成，其中运算器主要作用就是对数据进行加工</strong>；<strong>控制器主要作用就是协调和控制计算机各部件执行程序的指令序列，具体来说</strong>：</p><ul><li><strong>取指令</strong>：自动形成<strong>指令地址</strong>，自动发出取指令的命令。</li><li><strong>分析指令</strong>：操作码<strong>译码</strong>（分析本条指令要完成什么操作）；产生操作数的<strong>有效地址。</strong></li><li><strong>执行指令</strong>：由 “操作命令” 和“操作数地址”，形成<strong>操作信号控制序列</strong>，控制运算器、存储器以及 I&#x2F;O 设备完成相应的操作。</li><li><strong>中断处理</strong>：管理<strong>总线</strong>及输入输出；处理<strong>异常情况</strong>（比如掉电、浮点异常等）和<strong>特殊情况</strong>的请求（打印机请求打印一行字符等）。</li></ul><h2 id="1-2-运算器基本结构"><a href="#1-2-运算器基本结构" class="headerlink" title="1.2.运算器基本结构"></a>1.2.运算器基本结构</h2><h3 id="1-2-1-运算器概述"><a href="#1-2-1-运算器概述" class="headerlink" title="1.2.1.运算器概述"></a>1.2.1.运算器概述</h3><p>运算器核心是 <strong>ALU 算数逻辑单元</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161531640.png" loading="lazy">  </p><p>ALU需要<strong>两个操作数</strong>，经过处理后，就会输出运算结果。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532177.png" loading="lazy"></p><p><strong>运算器是计算机中加工数据的中心</strong>，除了 ALU 外，它还有很多寄存器，这里先给出它们的大致功能：</p><ul><li><strong>暂存寄存器</strong>：用于<strong>暂存从主存读过来的数据</strong>，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对<strong>应用程序员</strong>是透明的。</li><li><strong>累加寄存器</strong>：它是一个通用寄存器，用于<strong>暂时存放 ALU 的运算结果</strong>，可以作为加法运算的一个输入端。</li><li><strong>通用寄存器组</strong>：如<code>AX</code>、<code>BX</code>、<code>CX</code>、<code>DX</code>、<code>SP</code>等，用于<strong>存放操作数（包括源操作数，目的操作数及中间结果）和各种地址信息</strong>。注意<code>SP</code>是堆栈指针，用于指示栈顶地址。</li><li><strong>程序状态字寄存器</strong>：保留<strong>由算数逻辑运算指令或测试指令的结果而建立的各种状态信息</strong>，如溢出标志（<code>OF</code>）、符号标志（<code>SF</code>）、零标志（<code>ZF</code>），进行标志（<code>CF</code>）等。PSW 中的这些位参与并决定<strong>微操作</strong>的形成。</li><li><strong>移位器</strong>：对操作数或运算结果进行<strong>移位运算。</strong></li><li><strong>计数器</strong>：控制<strong>乘除运算</strong>的操作步数。</li></ul><h3 id="1-2-2-两种数据通路设计方式"><a href="#1-2-2-两种数据通路设计方式" class="headerlink" title="1.2.2.两种数据通路设计方式"></a>1.2.2.两种数据通路设计方式</h3><ul><li><p>接下来介绍两种数据通路设计方式，来详细探讨这些寄存器的作用。</p></li><li><p>注意下面的叙述仅仅是了解，不知道没有关系，后面会具体学习的。</p></li></ul><p><strong>数据通路：是指执行部件之间传送信息的路径，由控制信号控制。</strong></p><h4 id="1-2-2-1-专用数据通路"><a href="#1-2-2-1-专用数据通路" class="headerlink" title="1.2.2.1.专用数据通路"></a>1.2.2.1.专用数据通路</h4><p><strong>专用数据通路：根据指令执行过程中的数据和地址的流动方向安排连接线路。例如下图中每个寄存器与 ALU 都有专门的数据连线</strong>。</p><ul><li><p>任何一个通用寄存器中保存的数据都有可能作为 ALU 的输入，因此需要<strong>提供两组连线分别将通用寄存器两端连接至 ALU 两端</strong>（注意连线并不是只有一根，而是要视具体的数据传输情况而定）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532930.png" alt="image-20230416153257853" loading="lazy"></p></li></ul><p><strong>专用数据通路方式下，有可能多个寄存器会同时向 ALU 传输数据，这显然是不合理的，主要有以下两种解决方案</strong>：</p><ul><li><p><strong>多路选择器（MUX)<strong>：根据控制信号选择一路输出，</strong>每个多路选择器都可以决定要把哪一个信号输出</strong>。比如下图左侧的多路选择器信号为 00，就表示让 $R_{0} $通过，右侧的多路选择器信号为 01，就表示让$R_{1} $通过  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161533771.png" alt="image-20230416153317677" loading="lazy"></p></li><li><p><strong>三态门</strong>：控制<strong>每一路是否可以输出</strong>。比如下图， $R_0out  $为 1 时表示 $R_{0} $的数据可以输出到 A 端， $R_0out  $为 0 时表示 $R_{0} $的数据无法输出到 B 端。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161534435.png" alt="image-20230416153447350" loading="lazy"></p></li></ul><p><strong>专用数据通路方式优缺点如下</strong>：</p><ul><li><strong>优点</strong>：基本不存在数据冲突的现象。</li><li><strong>缺点</strong>：结构复杂，流量大，不易实现，只在特殊场合、需求中使用。</li></ul><h4 id="1-2-2-2-CPU-内部单总线（主要使用）"><a href="#1-2-2-2-CPU-内部单总线（主要使用）" class="headerlink" title="1.2.2.2.CPU 内部单总线（主要使用）"></a>1.2.2.2.CPU 内部单总线（主要使用）</h4><p><strong>CPU 内部单总线：此种方式会将所有寄存器的输入和输出端都连接到一条公共的通路上。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124924.png" alt="image-20230416153521914" loading="lazy"></p><ul><li>$R_{x}out $ 表示寄存器的输出控制信号， $ R_{x}in$ 表示寄存器的输入控制信号。</li></ul><p>ALU 接受数据时也是通过总线接受，但这种方式会导致 <strong>ALU 无法分清这是哪一个操作数</strong>，所以我们可以在其中设置一个<strong>暂存寄存器</strong>。例如，<strong>下图中 $R_{0} $的数据会被先送到暂存寄存器上，然后使 $R_{0}out $ 失效，再导通 $R_{1}out $，最后将$R_{1} $数据输出到 B 端，这样的话就可以保证操作数的次序正确</strong>。</p><p>同时，<strong>暂存寄存器也可以避免破坏寄存器原有的内容</strong>。例如，某次运算两个操作数分别来自主存和 $R_{0} $，那么来自主存的操作数就可以直接放入暂存寄存器，而不用先放入 A，<strong>这样就避免了因 A 原本有内容而由于主存操作数的读入破坏了其内容的情况发生</strong>。  </p><p>ALU 在计算完成之后仍然会将计算结果放回内部总线，不过这样做容易产生一个问题，<strong>一旦输入端发送的信号还没有稳定前，ALU 就产生了计算结果，并通过内部总线送回了寄存器，这样会导致运算错误</strong>。所以我们可以在 ALU 的输出端再加一个暂存寄存器，同时在暂存寄存器上方加一个三态门，等 ALU 输出结果稳定之后，让三态门导通，然后给寄存器加上电信号让输出结果送回寄存器即可。</p><h2 id="1-3-控制器基本结构"><a href="#1-3-控制器基本结构" class="headerlink" title="1.3.控制器基本结构"></a>1.3.控制器基本结构</h2><h3 id="1-3-1-控制器概述"><a href="#1-3-1-控制器概述" class="headerlink" title="1.3.1.控制器概述"></a>1.3.1.控制器概述</h3><p><strong>控制器主要作用是取指令，分析指令和执行指令，主要涉及以下寄存器</strong>：</p><ul><li><strong>程序计数器 PC</strong>：用于指出<strong>下一条指令在主存中的存放地址</strong>。</li><li><strong>指令寄存器 IR</strong>：用于保存<strong>当前正在执行的那条指令。</strong></li><li><strong>指令译码器</strong>：仅对操作码字段进行<strong>译码</strong>，向控制器提供特定的操作信号。</li><li><strong>存储器地址寄存器</strong>：用于存放要<strong>访问的主存单元的地址</strong>。</li><li><strong>存储器数据寄存器</strong>：用于存放向<strong>主存写入的信息或从主存读出的信息。</strong></li><li><strong>时序系统</strong>：用于产生各种<strong>时序信号</strong>，它们都是由统一时钟（CLOCK）分频得到。</li><li><strong>微操作信号发生器</strong>：根据 IR 的内（指令）、PSW 的内容及时序信号，<strong>产生控制计算机系统的所需要的各种控制信号</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161540190.png" loading="lazy"></p><h3 id="1-3-2-控制器控制过程概述"><a href="#1-3-2-控制器控制过程概述" class="headerlink" title="1.3.2.控制器控制过程概述"></a>1.3.2.控制器控制过程概述</h3><p><strong>控制器控制过程概述：大致逻辑过程描述如下</strong>：</p><ul><li><p><strong>程序计数器 PC</strong> 会指明下一条指令的地址，当取出该指令后会将其放到<strong>指令寄存器</strong> IR 当中。指令的地址码指明了操作数的地址信息，所以<strong>地址码的信息需要输出到内部总线上，而操作码部分会送给控制单元 CU</strong>。</p></li><li><p><strong>具体来说，操作码会送给指令译码器</strong> ，译码器的对应端会被选通，了解当前的指令类型后，就明白了下次执行的微操作是什么，所以<strong>译码器的输出信号会作为微操作信号发生器</strong>的输入信号，用于产生该指令的<strong>微操作序列</strong>。</p></li><li><p>微操作序列需要受到时序系统的控制。<strong>时序系统</strong>产生时序信号，微操作发生器每接受到一次信号，就会产生一个微操作（注意此时会受到 PSW 标志位的影响，有可能改变微操作的类型）。</p></li><li><p>最后还需要 <strong>MAR 和 MDR</strong>，MAR 连接地址总线，MDR 连接数据总线，用于和存储器进行交互。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161541097.png" alt="image-20230416154119009" loading="lazy"></p><h2 id="1-4-CPU-的本质——寄存器的集合体"><a href="#1-4-CPU-的本质——寄存器的集合体" class="headerlink" title="1.4.CPU 的本质——寄存器的集合体"></a>1.4.CPU 的本质——寄存器的集合体</h2><p><strong>CPU 的本质就是寄存器的集合体，所以这也是 CPU 很贵的原因。</strong></p><ul><li><strong>用户可见的寄存器</strong>：通用寄存器组、程序状态字寄存器 PSW，程序计数器 PC。</li><li><strong>用户不可见的寄存器</strong>：MAR、MDR、IR 和暂存寄存器。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161544495.png" alt="image-20230416154413382" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161550448.png" alt="image-20230416155037353" loading="lazy"></p><h1 id="2-指令执行过程"><a href="#2-指令执行过程" class="headerlink" title="2.指令执行过程"></a><a name="2.指令执行过程">2.指令执行过程</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161611723.png" alt="image-20230416161109612" loading="lazy"></p><h2 id="2-1-指令周期是什么"><a href="#2-1-指令周期是什么" class="headerlink" title="2.1.指令周期是什么"></a>2.1.指令周期是什么</h2><p><strong>指令周期：是指 CPU 从主存中取出并执行一条指令所需要的全部时间，不同指令的指令周期可能不同。指令周期常用若干机器周期（又叫 CPU 周期）来表示，一个机器周期又包含若干时钟周期（也称为节拍或 T 周期，T 是 CPU 操作的最基本单位）</strong>。</p><ul><li><strong>每个指令周期内的机器周期数可以不等。</strong></li><li><strong>每个机器周期内的时钟周期数可以不等。</strong></li></ul><p><strong>机器周期指的是完成一个子过程所花费的时间，下图中的方波表示若干时钟周期。例如 CPU 取指令，它是一个程序化、步骤化的过程，所以需要花费多个时钟周期（对应多个操作）来完成</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161554507.png" alt="image-20230416155450425" loading="lazy"></p><p><strong>不同指令的指令周期可能不同，例如</strong>：</p><ul><li><strong>空指令 NOP</strong>：空指令的意思就是什么也不做，因此其指令周期就是取指周期。</li><li><strong>加法指令 ADD</strong>：指令周期包括取指和执行两个部分，且这个两个部分长度差不多。</li><li><strong>乘法指令 MUL</strong>：相较于加法指令，由于乘法较为复杂，所以它的执行周期可能会更长。</li><li><strong>具有间接寻址的指令</strong>：间接寻址需要多次访问主存才能取到真实的地址，因此它会多一个<strong>间址周期</strong>。</li><li><strong>带有中断周期的指令</strong>：这种类型的指令会专门留出时间用于检测是否有中断信号，所以又会多一个中断周期。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161555299.png" alt="image-20230416155525209" loading="lazy"></p><h2 id="2-2-指令周期流程"><a href="#2-2-指令周期流程" class="headerlink" title="2.2.指令周期流程"></a>2.2.指令周期流程</h2><p><strong>不同指令的指令周期可能不同，自然也会有不一样的执行流程。某个指令在执行过程中是否要经过某个周期需要进行判断。且这四个工作周期都会涉及到 CPU 的访存操作，只是访存的目的不同。</strong></p><ul><li><p><strong>取指周期 (FE)：为了取出指令</strong>。</p></li><li><p><strong>间址周期 (IND)（可能有）：为了得到有效地址。</strong></p></li><li><p><strong>执行周期 (EX)：为了取得操作数。</strong></p></li><li><p><strong>中断周期 (INT)（可能有）：为了保存程序断点</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556575.png" alt="image-20230416155606476" loading="lazy"></p></li><li><p>具体实现时可借助<strong>触发器</strong>完成，通过二进制位是否有效进行控制  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556914.png" alt="image-20230416155634819" loading="lazy"></p></li></ul><h3 id="2-2-1-取指周期"><a href="#2-2-1-取指周期" class="headerlink" title="2.2.1.取指周期"></a>2.2.1.取指周期</h3><ul><li><p>首先 PC 指明了<strong>当前要执行的指令在主存的存放地址</strong>，所以需要先把 PC 中的内容（指令地址）送入 MAR中，<strong>也即<code>(PC)-&gt;MAR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557655.png" alt="image-20230416155752570" loading="lazy"></p></li><li><p>因为取指令需要访问主存，所以 CU 通过<strong>控制总线</strong>向主存发出<strong>读信号</strong>， <strong>也即<code>1-&gt;R</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557897.png" alt="image-20230416155721809" loading="lazy"></p></li><li><p>MAR 中的地址信息会通过<strong>地址总线送给主存</strong>，读出相应数据后，该指令会通过<strong>数据总线送到 MDR 当中</strong>，<strong>也即<code>M(MAR)-&gt;MDR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558392.png" alt="image-20230416155819305" loading="lazy"></p></li><li><p>然后把 MDR 中的内容送入 <strong>IR</strong> 当中，<strong>也即<code>(MDR)-&gt;IR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161559158.png" alt="image-20230416155939043" loading="lazy"></p></li><li><p>最后 <strong>CU 发出控制信号</strong>，让 PC+“1”，形成下一条地址，<strong>也即<code>PC=PC+1</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558096.png" loading="lazy"></p></li></ul><p><strong>总结</strong>：</p><ul><li><code>(PC)-&gt;MAR</code>。</li><li><code>1-&gt;R</code>。</li><li><code>M(MAR)-&gt;MDR</code>。</li><li><code>(MDR)-&gt;IR</code>。</li><li><code>PC+1</code>。</li></ul><h3 id="2-2-2-间址周期"><a href="#2-2-2-间址周期" class="headerlink" title="2.2.2.间址周期"></a>2.2.2.间址周期</h3><p><strong>一旦指令采用间接寻址，就需要进入间址周期。</strong></p><ul><li><p>首先将指令的<strong>地址码送入 MAR</strong>，<strong>也即 Ad(IR)-&gt;MAR</strong>（注意也可以<code>Ad(MDR)-&gt;MAR</code>）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161601516.png" alt="image-20230416160146430" loading="lazy"></p></li><li><p>CU 发出<strong>读控制信号</strong>，**也即<code>1-&gt;R</code>**。</p></li><li><p>将 MAR 所指主存中的内容通过数据总线送入 MDR，<strong>也即<code>M(MAR)-&gt;MDR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161602831.png" alt="image-20230416160207749" loading="lazy"></p></li><li><p>此时 MDR 保存的是操作数的<strong>有效地址</strong>。接下来 <strong>MDR 中的内容可以直接放入 MAR，也可以放入 IR 与原来的指令进行拼接</strong>（因为原来的地址只是形式地址）形成一个新的指令。</p></li></ul><p><strong>总结</strong>：</p><ul><li><code>Ad(IR)-&gt;MAR</code>（也可以是 <code>Ad(MDR)-&gt;MAR</code>）。</li><li><code>1-&gt;R</code>。</li><li><code>M(MAR)-&gt;MDR</code>。</li></ul><h3 id="2-2-3-执行周期"><a href="#2-2-3-执行周期" class="headerlink" title="2.2.3.执行周期"></a>2.2.3.执行周期</h3><p>执行周期的任务就是<strong>根据 IR 中指令字的操作码和操作数通过 ALU</strong> 产生执行结果，由于不同指令的执行周期操作不同，<strong>所以没有统一的数据流向</strong>。</p><h3 id="2-2-4-中断周期"><a href="#2-2-4-中断周期" class="headerlink" title="2.2.4.中断周期"></a>2.2.4.中断周期</h3><h4 id="2-2-4-1-中断"><a href="#2-2-4-1-中断" class="headerlink" title="2.2.4.1.中断"></a>2.2.4.1.中断</h4><p><strong>中断：通俗理解就是暂停当前任务去完成其他任务，完成后返回。</strong></p><p>例如，当前执行的程序由一些指令组成，现在执行到了指令 2，那么此时 PC 应该指向指令 3  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171116631.png" alt="image-20230417111622548" loading="lazy"></p><p>指令 2 结束之后会进行<strong>中断检查</strong>，如果此时有中断信号过来，那么在指令 2 执行完毕之后，就要<strong>暂停当前程序，转而执行中断信号所对应的程序指令</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161604726.png" loading="lazy">  </p><p>执行完毕之后，再返回原来程序继续执行  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161605611.png" loading="lazy"></p><h4 id="2-2-4-2-中断周期"><a href="#2-2-4-2-中断周期" class="headerlink" title="2.2.4.2.中断周期"></a>2.2.4.2.中断周期</h4><p><strong>为了能够找到 “回家的路”，所以需要保存程序断点，其实也就是 PC 的值。一般使用堆栈来保存断点。下图 SP 表示栈顶指针，假设 SP 此时指向栈顶元素，进栈操作是先修改指针，后保存数据</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161606339.png" loading="lazy"></p><ul><li><p>首先 CU 控制 SP，让其减 1，新指向的位置需要放入 PC。需要注意 <strong>SP 是堆栈指针，但其本质指向的是某个主存地址，所以它的意思就是现在需要把 PC 内的值放入 SP 所指向的某个主存单元保存起来</strong>，也即 <strong><code>(SP-1)-&gt;SP</code>，<code>(SP)-&gt;MAR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608679.png" alt="image-20230416160834593" loading="lazy"></p></li><li><p>CU 通过控制总线向主存发出<strong>写信号</strong>，**也即<code>1-&gt;W</code>**。</p></li><li><p><strong>向 MAR 所指地址处写入 PC（断点）</strong>。一个数据想要写入主存，首先得放入 MDR。因此 <strong>(PC)-&gt;MDR</strong>，至此<strong>断点信息被保存</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608595.png" alt="image-20230416160857514" loading="lazy"></p></li><li><p>接下来就需要<strong>执行新的程序指令了</strong>，因此 CU 控制<strong>将中断服务程序的入口地址送入 PC</strong>，也就是把最上面示例图的 PC 指向改为指向 “X”，**也即<code>向量地址-&gt;PC</code>**。</p></li><li><p>最后新的程序指令执行完成之后，<strong>依靠堆栈返回到之前的位置继续执行</strong>。</p></li></ul><p><strong>总之</strong>：</p><ul><li><code>(SP-1)-&gt;SP</code></li><li><code>SP-&gt;MAR</code></li><li><code>1-&gt;W</code></li><li><code>(PC)-&gt;MDR</code></li><li><code>MDR-&gt;M(MAR)</code></li><li><code>向量地址 -&gt;PC</code></li></ul><h2 id="2-3-指令执行方案"><a href="#2-3-指令执行方案" class="headerlink" title="2.3.指令执行方案"></a>2.3.指令执行方案</h2><p><strong>指令执行方案：一个指令周期通常要包括几个执行步骤，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。出于性能和硬件成本的考虑，可以选用如下三种不同的方案来安排指令的执行步骤</strong>：</p><ul><li>单指令周期。</li><li>多指令周期。</li><li>流水线方案。</li></ul><h3 id="2-3-1-单指令周期"><a href="#2-3-1-单指令周期" class="headerlink" title="2.3.1.单指令周期"></a>2.3.1.单指令周期</h3><p><strong>单指令周期：对所有指令都选用相同的执行时间来完成，称为单指令周期方案。</strong></p><p>此时每条指令都在固定的时钟周期内完成，指令之间 <strong>串行执行</strong>，即下一条指令只能在前一条指令执行结束之后启动。<strong>因此指令周期取决于最长的指令的执行时间，对于那些本来可以在更短时间内完成的指令，也要使用这个较长的执行周期，会降低整个系统的运行速度。</strong></p><h3 id="2-3-2-多指令周期"><a href="#2-3-2-多指令周期" class="headerlink" title="2.3.2.多指令周期"></a>2.3.2.多指令周期</h3><p><strong>多指令周期：对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案</strong>。</p><p>指令之间 <strong>串行执行</strong>，即下一条指令只能在前一条指令执行结束后启动。但是可以选用<strong>不同个数的时钟周期来完成不同指令的执行过程</strong>，<strong>指令需要几个周期就分配几个周期，而不再强求所有指令占用相同的执行时间。</strong></p><h3 id="2-3-3-流水线方案"><a href="#2-3-3-流水线方案" class="headerlink" title="2.3.3.流水线方案"></a>2.3.3.流水线方案</h3><p><strong>流水线方案：指令之间可以并行执行的方案，称为流水线方案。</strong></p><p>流水线方案力争 <strong>在每个时钟周期完成一条指令的执行过程</strong>（当然这只有在理想情况下才能达到）。<strong>这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自在不同的执行步骤</strong>。</p><h1 id="3-数据通路单总线结构"><a href="#3-数据通路单总线结构" class="headerlink" title="3.数据通路单总线结构"></a>3.数据通路单总线结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640918.png" alt="image-20230416164054829" loading="lazy"></p><h2 id="3-1-有关概念"><a href="#3-1-有关概念" class="headerlink" title="3.1.有关概念"></a>3.1.有关概念</h2><h3 id="3-1-1-CPU-中数据的流动方式"><a href="#3-1-1-CPU-中数据的流动方式" class="headerlink" title="3.1.1.CPU 中数据的流动方式"></a>3.1.1.CPU 中数据的流动方式</h3><p><strong>一条指令的指令周期是会被划分为不同阶段，而不同阶段的数据流向也会不同，主要有以下三种</strong>：</p><ul><li>寄存器和寄存器之间。</li><li>寄存器与主存之间。</li><li>寄存器与 ALU 之间。</li></ul><h3 id="3-1-2-数据通路和控制信号"><a href="#3-1-2-数据通路和控制信号" class="headerlink" title="3.1.2.数据通路和控制信号"></a>3.1.2.数据通路和控制信号</h3><p><strong>数据通路：描述了数据在各个功能部件之间传送的路径。我们需要确定信息从哪里开始，中间经过哪些部件，最后又传至哪里。因此只要确定了数据的流向，我们就可以发出不一样的控制信号，来控制这些数据的流动。</strong></p><p><strong>控制信号是由控制部件产生的，虽然寄存器种类繁杂，但它们只会发出如下两类控制信号：</strong></p><ul><li><strong><code>in</code>：也即输入路径。</strong></li><li><strong><code>out</code>：也即输出路径</strong>。</li></ul><p><strong>这些信号都是由控制器发出的，所以下图中的 $ACC_{in} $、$ACC_{out} $、 $R0_{in} $和 $R0_{out} $​等控制信号事实上和微操作发生器（CU）有着线路连接，微操作发生器发出不一样的信号就会使这些寄存器之间产生多种多样的联系</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161614739.png" alt="image-20230416161446625" loading="lazy"></p><h3 id="3-1-3-数据通路种类"><a href="#3-1-3-数据通路种类" class="headerlink" title="3.1.3.数据通路种类"></a>3.1.3.数据通路种类</h3><ul><li><p><strong>CPU 内部单总线（上图）</strong>：该方式<strong>将所有寄存器的输入端和输出端都连接到同一条公共的通路上</strong>，这意味着<strong>同一时刻只允许两个部进行数据交换</strong>，它们对总线的使用是独占的。<strong>本小节探讨的内容所用的数据通路方式便是这种</strong>。</p></li><li><p><strong>CPU 内部多总线方式</strong>：将所有寄存器的输入和输出端都连接到<strong>多条公共通路上</strong>。采用多总线方式，可以同时在多个总线上<strong>传送不同的数据。</strong></p></li><li><p><strong>专用数据通路方式</strong>：根据指令执行过程中的数据和地址的流动方向安排连接线路，<strong>避免使用共享的总线</strong>，性能高，但是硬件消耗量大。</p></li></ul><h3 id="3-1-4-内部总线与系统总线"><a href="#3-1-4-内部总线与系统总线" class="headerlink" title="3.1.4.内部总线与系统总线"></a>3.1.4.内部总线与系统总线</h3><ul><li><strong>内部总线</strong>：<strong>同一部件</strong>，如 CPU 内部连接各寄存器及运算部件之间的总线。</li><li><strong>系统总线</strong>：<strong>同一台计算机系统的各部件</strong>，如 CPU、内存、通道和各类 I&#x2F;O 接口间相互连接的总线。</li></ul><p>以下的讲解中会使用这张图  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161616080.png" alt="image-20230416161620990" loading="lazy"></p><h2 id="3-2-寄存器之间的数据流动"><a href="#3-2-寄存器之间的数据流动" class="headerlink" title="3.2.寄存器之间的数据流动"></a>3.2.寄存器之间的数据流动</h2><p><strong>例子：现在要把 PC 的内容送至 MAR，那么传送操作流程如下</strong>：</p><ul><li><p>首先 $ PCout $有效（CU 发出信号），让其和总线导通  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161617187.png" alt="image-20230416161715097" loading="lazy"></p></li><li><p>然后把 $PC$ 的内容（其实就是电信号）送至 $BUS$（总线），也即 ( $PC$)-&gt; $BUS$ 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618824.png" loading="lazy"></p><ul><li><p>最后使 $MAR_{in}$​有效， $BUS$ 内容再送至 $MAR$ 即可，也即 $BUS$-&gt; $MAR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618616.png" loading="lazy"></p></li></ul></li></ul><p>在答题时一定要写清楚数据流向，最规范的模板为  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618459.png" loading="lazy"></p><h2 id="3-3-主存与-CPU-之间的数据流动"><a href="#3-3-主存与-CPU-之间的数据流动" class="headerlink" title="3.3.主存与 CPU 之间的数据流动"></a>3.3.主存与 CPU 之间的数据流动</h2><p><strong>例子：现在 CPU 要从主存中读取指令，那么传送操作流程如下</strong>：</p><ul><li><p>首先，程序计数器 $PC$ 指明了我们要读取的指令存放在什么地址，所以要把 $PC$ 的内容放入 $MAR$ 当中，即$ (PC)-&gt;Bus-&gt;MAR $（这一步其实也就是上面寄存器与寄存器之间的数据流动）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161619583.png" loading="lazy"></p></li><li><p>刚才，为了实现 PC 到 MAR 而使得 $PC_{out} $​和 $PC_{in} $​有效了，现在<strong>应该撤销这两个控制信号</strong>，让总线空闲。接下来要进行读操作，所以 CU 要向主存发出读信号，即 $1-&gt; R$（注意该信号是通过控制总线发出的）。</p></li><li><p>然后使 $MDR_{in}$ 有效（**注意区分图中的 $MDR_{in} $​， $MDR_{in} $​是控制数据是否可以从内部总线流入 $MDR$**），主存中对应地址信息的内容通过外部数据总线送入 $MDR$ 当中，即 $MEM(MAR)$-&gt; $MDR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161628556.png" alt="1" loading="lazy"></p></li><li><p>最后需要把该指令放入$IR$ 当中， $MDR-&gt;Bus-&gt;IR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161629503.png" alt="image-20230416162948426" loading="lazy"></p></li></ul><p>较为规范的模板为：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161630911.png" loading="lazy"></p><h2 id="3-4-寄存器与-ALU-之间的数据流动"><a href="#3-4-寄存器与-ALU-之间的数据流动" class="headerlink" title="3.4.寄存器与 ALU 之间的数据流动"></a>3.4.寄存器与 ALU 之间的数据流动</h2><p><strong>执行算数或逻辑运算时数据可能会流向 ALU，比如现在要执行一条加法指令，加法运算的其中一个操作数已经被存放在 $ACC$ 中了，另一个操作数地址会由加法指令直接指明</strong>。</p><ul><li><p>首先需要根据该指令的地址码部分读取出参与加法的另一个操作数，即 $ Ad(IR) -&gt;Bus-&gt; MAR$，此时 $MDR_{out} $和 $MAR_{in}$​有效。</p></li><li><p>当然还可以采用另外一种方式。之前就说过，取指令的时候是把指令先取到了 $MDR$ 中然后再拷贝至$IR$ 中，所以取指结束后， $MDR$ 中也存放了这条指令的完整信息，因此可以直接把 $MDR$ 中指令的地址码传送到 $MAR$ 中，此时 $MDR_{out} $​和 $MAR_{in}$​有效。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161634185.png" alt="image-20230416163418087" loading="lazy"></p></li><li><p>CU 向主存发出读控制信号，即 $1-&gt; R $</p></li><li><p>主存中相应信息通过外部数据总线送至 $MDR$ 当中， $MDR_{in}$ 有效，即 $MEM(MAR)$-&gt; 数据总线 -&gt; $MDR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161635806.png" alt="image-20230416163548712" loading="lazy"></p></li><li><p>接下来把操作数放到暂存寄存器 $Y$ 中，此时 $MDR_{out} $​和 $ Y_{in} $有效，即 MDR-&gt;bus-&gt; $Y$。<strong>之所以这样做是因为 ALU 必须同时接受到两个信号才可以运作，但是内部总线同一时刻只能传送一个输入信号，因此不得不把其中的一个操作放到暂存寄存器中，该寄存器与 ALU 是有一个专门的数据通路的，他们的传送不会占用内部总线</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161636910.png" alt="image-20230416163629820" loading="lazy"></p></li><li><p>CU 向 ALU 发送加命令，然后 $ACC_{out}$和 $ALU_{in} $有效，执行加法操作，即 ( $ACC$)+( $Y$)-&gt;$ Z  $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637327.png" alt="image-20230416163713240" loading="lazy"></p></li><li><p>当输出数据稳定之后，撤销 $ACC_{out}$和 $ALU_{in} $​。最后将结果存回 $ACC$ 中，即 $ Z-&gt; ACC$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637988.png" alt="image-20230416163739894" loading="lazy"></p></li></ul><p>较为规范的模板为  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161638315.png" loading="lazy"></p><p><strong>可以看出，通过发出不一样的控制信号，就能使微操作一步接着一步进行下去，每个微操作至少需要消耗一个时钟周期，每一个时钟周期内，CU 都会发出一组相应的控制信号来完成其中的某一个微操作</strong>。</p><h2 id="3-5-有关-CPU-内部单总线经典例题"><a href="#3-5-有关-CPU-内部单总线经典例题" class="headerlink" title="3.5.有关 CPU 内部单总线经典例题"></a>3.5.有关 CPU 内部单总线经典例题</h2><p>设有如下所示的单总线结构，请分支指令<code>ADD (R0),R1</code>的指令流程和控制信号。</p><ul><li>$R  _{1} $表示源操作数（没有括号表示直接存放在寄存器中），$(R  _{0} )$ 表示目的操作数（带有括号表示存储的操作数的地址，同时这两个操作数的运算的结果又会放回 $R _{0} $所指向主存单元）。也即$ ((R _{0} ))+(R <em>{1} )-&gt;(R 0</em>{0} )$。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639870.png" alt="image-20230416163921777" loading="lazy"></p><p>各个阶段的指令流程如下  ：</p><p><strong>1：取指周期</strong>：公共操作，都一样。</p><table><thead><tr><th>时序</th><th>微操作</th><th>有效控制信号</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>(PC)-&gt;MAR</td><td>PCout,MARin</td><td>PC 所指指令地址送至 MAR</td></tr><tr><td>2</td><td>M(MAR)-&gt;MDR</td><td>MemR，MARout，MDRinE</td><td>把指令送到 MDR 中</td></tr><tr><td>3</td><td>(MDR)-&gt;IR</td><td>MDRout,IRin</td><td>把指令由 MDR 送到 IR</td></tr><tr><td>4</td><td>指令译码</td><td>-</td><td>进行译码操作</td></tr><tr><td>5</td><td>(PC)+1-&gt;PC</td><td>-</td><td>PC+1 操作</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639924.png" alt="image-20230416163938826" loading="lazy"></p><p><strong>2：间指周期</strong>：完成取数操作，被加数在主存中，加数已经存放在寄存器 $R _{1}$中了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424883.png" alt="image-20230416142413792" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640100.png" alt="image-20230416164011484" loading="lazy"></p><p><strong>3：执行周期</strong>：此时加数在 R1 中，被加数在 Y 中。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424547.png" alt="image-20230416142439466" loading="lazy"></p><p><strong>注意：本节内容是计组考试中的高频考点，注意考察指令的执行过程。</strong></p><h1 id="4-数据通路专用通路结构"><a href="#4-数据通路专用通路结构" class="headerlink" title="4.数据通路专用通路结构"></a>4.数据通路专用通路结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161649331.png" alt="image-20230416164908239" loading="lazy"></p><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1.概述"></a>4.1.概述</h2><p>如果数据通路采用 CPU 内部单总线，那么就意味着同一时间只允许两个部件进行数据交互。<strong>实际上，如果能使多个部件同时进行数据交互，那么指令的执行速度一定会的得到提升，实现这种需求一方面可以借助多总线的方式，另一方面还可以建立专用数据通路——在任何两个需要进行数据交互的部件之间建立数据通路</strong>。</p><p>如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647652.png" alt="image-20230416164703559" loading="lazy">  </p><p>取指周期如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161428320.png" alt="image-20230416142819239" loading="lazy"></p><h2 id="4-2-例题"><a href="#4-2-例题" class="headerlink" title="4.2.例题"></a>4.2.例题</h2><p>下图是一个简化了的 CPU 与主存连接结构示意图 (图中省略了所有的多路选择器)。其中有一个累加寄存器 (ACC)、一个状态数据寄存器和其他 4 个寄存器（MAR、MDR、PC 和 IR）。各部件及其之间的连线表示数据通路，箭头表示信息传递方向。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647475.png" alt="image-20230416164757386" loading="lazy"></p><p>完成以下问题：</p><ul><li><strong>请写出图中 a、b、C、d 4 个寄存器的名称</strong>。</li><li><strong>简述图中取指令的数据通路</strong>。</li><li><strong>简述数据在运算器和主存之间进行存 &#x2F; 取访问的数据通路。</strong></li><li><strong>简述完成指令 LDA X 的数据通路 (X 为主存地址，LDA 的功能为 (X)→ACC)。</strong></li><li><strong>简述完成指令 ADD Y 的数据通路 (Y 为主存地址，ADD 的功能为 (ACC)+ (Y)→ACC)。</strong></li><li>**简述完成指令 STA Z 的数据通路 (Z 为主存地址，STA 的功能为 (ACC)→Z)**。</li></ul><p><strong>（1）请写出图中 a、b、C、d 4 个寄存器的名称。</strong></p><p>首先 d 可以自动 “+1”，因此是 PC；PC 的内容是地址，送入 MAR，故 c 是 MAR；b 与微操作信号发生器相连，因此是 IR；相应的 a 就是 MDR。</p><ul><li>a：MDR</li><li>b：IR</li><li>c：MAR</li><li>d：PC</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161648003.png" alt="image-20230416164825907" loading="lazy"></p><p><strong>（2）简述图中取指令的数据通路。</strong></p><ul><li>(PC)-&gt;MAR</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;IR</li></ul><p><strong>（3）简述数据在运算器和主存之间进行存 &#x2F; 取访问的数据通路</strong>。</p><p>假设存 &#x2F; 取的数据放到 ACC 中，并且数据地址已经放入 MAR 中。</p><p><strong>取过程</strong></p><ul><li>M(MAR)-&gt;MDR</li><li>(MDR)-&gt;ALU-&gt;ACC</li></ul><p><strong>存过程</strong></p><ul><li>(ACC)-&gt;MDR</li><li>(MDR)-&gt;M(MAR)</li></ul><p><strong>（4）简述完成指令 LDA X 的数据通路 (X 为主存地址，LDA 的功能为 (X)→ACC)。</strong></p><ul><li>X-&gt;MAR</li><li>M(MAR)-&gt;MDR</li><li>(MDR)-&gt;ALU-&gt;ACC</li></ul><p><strong>（5）简述完成指令 ADD Y 的数据通路 (Y 为主存地址，ADD 的功能为 (ACC)+ (Y)→ACC)。</strong></p><ul><li>Y-&gt;MAR</li><li>M(MAR)-&gt;MDR</li><li>(MDR)-&gt;ALU，(ACC)-&gt;ALU</li><li>ALU-&gt;ACC</li></ul><p>**（6）简述完成指令 STA Z 的数据通路 (Z 为主存地址，STA 的功能为 (ACC)→Z)**。</p><ul><li>Z-&gt;MAR</li><li>(ACC)-&gt;MDR</li><li>(MDR)-&gt;M(MAR)</li></ul><h1 id="5-硬布线控制器"><a href="#5-硬布线控制器" class="headerlink" title="5.硬布线控制器"></a><a name="5.硬布线控制器">5.硬布线控制器</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161713047.png" loading="lazy"></p><h2 id="5-1-内容回顾和一些概念"><a href="#5-1-内容回顾和一些概念" class="headerlink" title="5.1.内容回顾和一些概念"></a>5.1.内容回顾和一些概念</h2><p>高级语言编写的程序会被翻译为与之等价指令序列，每条指令的执行，有可能会涉及如下四个周期：</p><ul><li><strong>取指周期</strong>：完成取指令。</li><li><strong>间指周期</strong>：如果采用间接寻址，需要将形式地址转变为真实地址。</li><li><strong>执行周期</strong>：执行指令。</li><li><strong>中断周期</strong>：处理中断信号。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652162.png" alt="image-20230416165212046" loading="lazy"></p><p>下图中<code>FE</code>、<code>IND</code>、<code>EX</code>和<code>INT</code>分别是上面四个周期的缩写，<strong>各自对应了如下四个触发器，如果某个触发器为 1 就表示指令处于某个周期内。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652735.png" alt="image-20230416165227648" loading="lazy"></p><p>一个指令周期内又需要若干<strong>微操作序列</strong>来完成该指令周期的工作，每个指令周期又由若干<strong>时钟周期</strong>组成（节拍），CU 会在每一个节拍内发出一个<strong>微命令</strong>，生成对应的微操作。</p><ul><li><strong>微命令和微操作是一一对应的</strong>：比如微命令 1 使得$ PC _{out}$ 、$MAR _{in}$ ​有效，完成对应的微操作 (PC)-&gt;MAR。</li></ul><p><strong>每个节拍内可以并行地完成互不冲突的微操作，而且同一个微操作也可能在不同指令的不同阶段被使用</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161653434.png" alt="image-20230416165312336" loading="lazy"></p><ul><li>上图采用的是<strong>定长周期</strong>的策略（即便执行周期和中断周期可以在两个节拍内完成，但是我们还是让其耗时三个节拍）。</li></ul><p>实际上，不同指令的执行周期所需要的节拍数是各不相同的，因此为了简化设计，选择定长的机器周期，<strong>以可能出现的最大节拍数为准</strong>（通常以访存所需要节拍数作为参考），若实际所需要节拍数较少，<strong>可以将微操作安排在机器周期末尾几个节拍上进行。</strong></p><h2 id="5-2-硬布线控制"><a href="#5-2-硬布线控制" class="headerlink" title="5.2.硬布线控制"></a>5.2.硬布线控制</h2><p><strong>硬布线控制：使用控制单元 CU 进行逻辑控制。</strong></p><h3 id="5-2-1-CU-如何发出微命令"><a href="#5-2-1-CU-如何发出微命令" class="headerlink" title="5.2.1.CU 如何发出微命令"></a>5.2.1.CU 如何发出微命令</h3><p><strong>可以看出，指令间区别最大的地方在于执行周期，像取指周期、间指周期和中断周期都是差不多的。所以，我们只要根据指令操作码、目前的指令周期、节拍信号以及机器状态条件就可以确定现在这个节拍下应该发出哪些微命令。具体来说</strong>：</p><ul><li><p><strong>STEP1：得让 CU 知道现在执行的是什么命令</strong>：首先需要把 IR 的 $n$位操作码送给<strong>操作码译码器</strong>（ $n$位操作码意味着有 $2 ^{n}$ 种不一样的指令，经过操作码译码器译码后对应的地址选择线就会被选通），<strong>CU 通过判断对应哪一个输入信号有效，来判断当前执行的是哪一条指令</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655637.png" alt="image-20230416165504542" loading="lazy"></p></li><li><p><strong>STEP2：得让 CU 知道当前执行到了该指令的哪一个机器周期</strong>：所以需要把<code>FE</code>、<code>IND</code>、<code>EX</code>和<code>INT</code>这四个触发器的二进制信息送给 CU，<strong>CU 通过判断对应的值是否为 1 来判断目前处于哪一个机器周期</strong>（需要注意这四个触发器实际上已经被集成在了 CPU 中）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655839.png" alt="image-20230416165540748" loading="lazy"></p></li><li><p><strong>STEP3：得让 CU 知道当前处在该机器周期的哪一个节拍</strong>：因此需要给 CU 输入一个节拍信号，节拍信号是通过<strong>节拍发生器</strong>给出的，时钟部件会有规律的发出脉冲信号，每个脉冲信号就是一个时钟周期。<strong>节拍发生器在接受到时钟部件发出的信号后，就会让其中的某个输出线导通</strong>、节拍信号是循环发出的，当$ T _{m} $结束后，就会回到 $T _{0}$，此时表示进入了新的机器周期  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124920.png" alt="image-20230416201559822" loading="lazy"></p></li><li><p><strong>STEP4：最后需要给 CU 提供机器状态条件</strong>：<strong>状态条件统称为标志，它们来自于执行单元的返回信息</strong>。比如前面说过的来自于运算器的 PSW（溢出判断就在这里）、来自于 ACC 的符号位等，也有可能来自于 I&#x2F;O 设备、主存等  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657694.png" alt="image-20230416165702583" loading="lazy"></p></li></ul><p><strong>这四组信息齐全后，CU 就可以给出当前节拍下应该发出的微命令</strong>：<strong>每个输出的控制信号对应一个微命令，也就是对应一个微操作</strong>。例如，如果$ C _{1} $对应微操作为 $(PC) $-&gt;MAR，那么只需让其接到 $PC  _{out}$​和 $MAR _{in} $​即可  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657883.png" alt="image-20230416165727760" loading="lazy"></p><h3 id="5-2-2-逻辑化表达式"><a href="#5-2-2-逻辑化表达式" class="headerlink" title="5.2.2.逻辑化表达式"></a>5.2.2.逻辑化表达式</h3><p>现在最困难的问题在于：<strong>CU 如何能知道现在应该发出哪条命令？</strong>。比如上面的例子中，$C _{1}$​被接通后就执行了 (PC)-&gt;MAR。</p><ul><li><p>$C _{1}$的比较好解释：因为所有指令在取指周期内，第一步需要做的事情就是 (PC)-&gt;MAR。于是硬件工程师规定：<strong>无论是哪一种指令，只要处于取指周期（FE&#x3D;1），同时还处于第一阶段（$T <em>{0} $）的话，就要完成 (PC)-&gt;MAR 这样的操作，也即是 $C <em>{1}$对应的操作，其对应的逻辑化表达式为 $C</em>{1} $&#x3D; $FE·T</em>{0} $</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657606.png" loading="lazy"></p></li></ul><p>说到这里大家可能就已经明白了，只要能写出某一个微命令对应的<strong>逻辑化表达式</strong>，然后设计相应的<strong>逻辑电路</strong>即可，但理想很美好，现实很骨感。上面那个例子的逻辑电路设计起来是非常简单的，而且最重要的是该微操作仅出现在取指周期的第一阶段；<strong>但有的微操作，例如 M(MAR)-&gt;MDR 它们使用的就非常频繁，那么他们应该怎么设计呢？这就是本节内容的核心</strong>。在学习硬件时大家要牢牢把握 “<strong>逻辑化表达式是电路的数学化描述</strong>” 这句话的深刻含义。</p><p>$M(MAR)-&gt;MDR$ 的逻辑化表达式和电路如下图所示：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161658376.png" alt="image-20230416165850266" loading="lazy"><br>逻辑化表达式为：  $FE· T_{1} +IND· T_{1} (  ADD+ STA+  LDA+  JMP+ BAN)+ EX· T_{1}(ADD+LDA) $</p><ul><li><p>$ FE· T_{1} $：与运算，如果结果为 1，就表示需要进行 M(MAR)-&gt;MDR 微操作  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017310.png" alt="image-20230416201715192" loading="lazy"></p></li><li><p>$EX· T_{1}(ADD+LDA) $：如果处在 ADD 加法命令或 LDA 命令的执行周期的 $T_{1}$​阶段也表示需要进行 M(MAR)-&gt;MDR 微操作  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161659864.png" alt="image-20230416165902772" loading="lazy"></p></li></ul><h2 id="5-3-硬布线控制器设计"><a href="#5-3-硬布线控制器设计" class="headerlink" title="5.3.硬布线控制器设计"></a>5.3.硬布线控制器设计</h2><ul><li><strong>注意</strong>：此部分内容在考试中基本不会涉及，但是对于理解硬布线控制却很有帮助。</li></ul><h3 id="5-3-1-硬布线控制器设计步骤"><a href="#5-3-1-硬布线控制器设计步骤" class="headerlink" title="5.3.1.硬布线控制器设计步骤"></a>5.3.1.硬布线控制器设计步骤</h3><p><strong>硬布线控制器设计步骤如下</strong>：</p><p><strong>①：分析各个阶段的微操作序列（取指，间指，执行、中断）</strong></p><ul><li>确定哪些指令在什么阶段、在什么条件下会使用到的微操作。</li></ul><p><strong>②：选择 CPU 的控制方式</strong></p><ul><li>采用定长机器周期还是不定长机器周期？每个机器周期安排几个节拍？</li><li>注意：后面讲解采用同步控制方式（定长机器周期），一个机器周期内安排 3 个节拍。</li></ul><p><strong>③：安排微操作时序</strong></p><ul><li>如何用 3 个节拍完成整个机器周期内的所有微操作。</li></ul><p><strong>④：电路设计</strong></p><ul><li>确定微操作命令的逻辑表达式，并用电路实现。</li></ul><h3 id="5-3-2-步骤一：分析各个阶段的微操作序列"><a href="#5-3-2-步骤一：分析各个阶段的微操作序列" class="headerlink" title="5.3.2.步骤一：分析各个阶段的微操作序列"></a>5.3.2.步骤一：分析各个阶段的微操作序列</h3><p><strong>如果我们能罗列出某个系统在各个阶段的微操作序列，就可以知道在什么情况下需要使用到这个微操作</strong>。</p><p><strong>取指周期</strong>（所有指令都一样）。</p><ul><li>PC-&gt;MAR</li><li>1-&gt;R</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;IR</li><li>OP(IR)-&gt;ID（ID 是指令译码器）</li><li>(PC)+1-&gt;PC</li></ul><p><strong>间址周期</strong>（所有指令都一样）。</p><ul><li>Ad(IR)-&gt;MAR（找寻真正地址）</li><li>1-&gt;R</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;Ad(IR)</li></ul><p><strong>执行周期</strong>（各不相同），例如：</p><p><strong>CLA</strong>：clear ACC 指令、ACC 清零。</p><ul><li>0-&gt;ACC</li></ul><p><strong>LDA X</strong>：取数指令，把 X 所指内容取到 ACC。</p><ul><li>Ad(IR)-&gt;MAR</li><li>1-&gt;R</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;ACC</li></ul><p><strong>JMP X</strong>：无条件转移。</p><ul><li>Ad(IR)-&gt;PC</li></ul><p><strong>BAN X</strong>：条件转移，当 ACC 为负时转移（属于机器状态条件）。</p><ul><li>$A_{0}⋅Ad(IR)+ \overline A_{0}⋅(PC)-&gt;CP$</li></ul><h3 id="5-3-3-步骤三：安排微操作时序"><a href="#5-3-3-步骤三：安排微操作时序" class="headerlink" title="5.3.3.步骤三：安排微操作时序"></a>5.3.3.步骤三：安排微操作时序</h3><ul><li><strong>注意</strong>：第二步已经完成，我们会采用定长机器周期，并且每个机器周期内安排三个节拍。</li></ul><p><strong>安排微操作时序有如下原则</strong>：</p><ul><li><strong>原则一</strong>：微操作的先后顺序不得随意更改（比如 PC-&gt;MAR 一定在 M(MAR)-&gt;MDR 之前完成）。</li><li><strong>原则二</strong>：被控对象不同的微操作尽量安排在一个节拍内完成（比如 PC-&gt;MAR 控制对象为寄存器，1-&gt;R 控制对象为主存，因此尽量安排在同一个节拍内完成）。</li><li><strong>原则三</strong>：占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序（比如寄存器之间的交互快于寄存器与主存的交互，因此如果可以的话尽量将其放在一个节拍完成）。</li></ul><p>比如<strong>取指周期</strong>，上面得到的微操作序列，在这种原则下是不合适的，因此更改如下：</p><ul><li>PC-&gt;MAR 和 1-&gt;R 由于被控对象不同的，所以放在一个节拍内。</li><li>(PC+1)-&gt;PC 位置随意，只要在 PC-&gt;MAR 之后即可，所以搭配一个 M(MAR)-&gt;MDR 让其在一个节拍内进行。<strong>不把 M(MAR)-&gt;MDR 放在后面的原因是因为这是从主存取数据，时间较长，起码得保证一个时钟周期</strong>。</li><li>后面两个是 CPU 内部寄存器的数据传送，<strong>因此速度很快，在一个时钟周期内是可以一次同时发出两个微命令的</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161700481.png" alt="image-20230416170059393" loading="lazy"></p><p><strong>间址周期安排如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161701021.png" alt="image-20230416170115936" loading="lazy"></p><p><strong>执行周期的设计可以说是整个设计的核心所在</strong>，不同指令的执行周期千差万别，具体如何设计是硬件工程师的任务，在这里我们只是简单了解即可。主要是想让大家明白一点，<strong>指令的设计是一个非常严谨的事情，它有哪几个周期，一个周期内有几个节拍，一个节拍要完成哪些微操作，这些都是必须要考虑到的事情</strong>。</p><ul><li>设计时会将指令分为<strong>非访存，访存和转移指令</strong>等。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161705356.png" alt="image-20230416170547257" loading="lazy"></p><h3 id="5-3-4-步骤四：组合逻辑设计（电路设计）"><a href="#5-3-4-步骤四：组合逻辑设计（电路设计）" class="headerlink" title="5.3.4.步骤四：组合逻辑设计（电路设计）"></a>5.3.4.步骤四：组合逻辑设计（电路设计）</h3><p><strong>①：列出操作时间表：也即列出在取指、间址、执行和中断周期， $T_{0}$​、 $T_{1}$​和 $T_{2}$节拍内有可能用到的所有微操作</strong></p><p><strong>对于取指周期：</strong></p><ul><li><strong>需要用到该微操作的填 “1”，否则空</strong></li><li>注意表格中的<strong>状态条件栏</strong>：如果填 “ $ I$”，表示该指令采用间接寻址，需要将间址特征送入，即 1-&gt;IND；如果填 “ $\overline I $”，表示该指令将直接进入执行周期，即<code> 1-&gt;EX</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708366.png" alt="image-20230416170802261" loading="lazy"></p><p><strong>对于间址周期</strong>：</p><ul><li><p>注意<strong>状态条件栏</strong>：如果填 “ $ \overline I \overline N \overline D $”，表示该指令采用多级间接寻址，直到该状态栏不填任何信息时，才表示结束了间接寻址，可以进入执行周期  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708736.png" alt="image-20230416170816638" loading="lazy"></p></li></ul><p>③对于执行周期：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709818.png" alt="image-20230416170923708" loading="lazy"></p><p><strong>②：写出微操作命令的最简表达式</strong>。</p><p><strong>从上面的表格中我们可以看到 M(MAR)-&gt;MDR 操作的使用频次。</strong></p><ul><li>对于<strong>取指周期</strong>，只要处在 $T_{1}$​，无论哪一个指令都要用到 M(MAR)-&gt;MDR，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li><li>对于<strong>间址周期</strong>，只要处在 $T_{1}$​，并且是 $ADD$、 $STA$、 $LDA$、 $JMP$ 。<br>、 $BAN $ 指令的话，就要用到 M(MAR)-&gt;MDR，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li><li>对于<strong>执行周期</strong>，只要处在 $T_{1}$​，并且是 $ADD$ 或 $LDA$ 的话，就要用到 <code>M(MAR)-&gt;MDR</code>，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162018083.png" alt="image-20230416201850969" loading="lazy"></p><p><strong>综上，当逻辑表达式：“ $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$” 为 1 时，就要执行<code> M(MAR)-&gt;MDR</code> 微操作</strong>。</p><p><strong>③：设计出逻辑表达式对应的电路图</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709168.png" alt="image-20230416170959038" loading="lazy"></p><h2 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4.总结"></a>5.4.总结</h2><p><strong>硬布线控制器的设计步骤如下</strong>：</p><p>1：分析每个阶段的微操作序列  。<br>2：选择 CPU 的控制方式  。<br>3：安排微操作时序  。<br>4：电路设计。</p><ul><li>列出操作时间表。</li><li>写出微操作命令的最简表达式。</li><li>画出逻辑图。</li></ul><p><strong>硬布线控制器的特点：</strong></p><ul><li>指令越多，设计和实现就越复杂，<strong>因此一般用于 RISC（精简指令集系统）</strong>。</li><li>如果扩充一条新的指令，则控制器的设计就需要大改，因此<strong>扩充指令困难。</strong></li><li>由于使用纯硬件实现控制，因此<strong>执行速度很快</strong>（微操作控制信号由组合逻辑电路即时产生）。</li></ul><h1 id="6-微程序控制器的基本原理"><a href="#6-微程序控制器的基本原理" class="headerlink" title="6.微程序控制器的基本原理"></a>6.微程序控制器的基本原理</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161719373.png" alt="image-20230416171943251" loading="lazy"></p><p>硬布线控制器，就是用纯硬件实现的控制器，电路非常复杂，也是整个计组中的难点之一，好在考试基本不考，而本节需要学习的<strong>微程序控制器倒是在大题中常有出现</strong>。</p><h2 id="6-1-微程序控制器的设计思路"><a href="#6-1-微程序控制器的设计思路" class="headerlink" title="6.1.微程序控制器的设计思路"></a>6.1.微程序控制器的设计思路</h2><ul><li>程序会被翻译为对等的机器指令。</li><li>机器指令又会被分为一个个的微操作序列。</li></ul><p><strong>微程序控制器的设计思路：把每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。所以微指令之于指令就等价于指令之于程序</strong>。</p><ul><li><strong>指令</strong>是对程序执行步骤的描述。</li><li><strong>微指令</strong>是对指令执行步骤的描述。</li><li><strong>微命令与微操作一一对应</strong>。</li><li><strong>微指令</strong>可能包含多个<strong>微命令（微操作）</strong>。</li></ul><p><strong>比如下图中的微指令 d，它指明了 “完成微操作 5、2”。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161714659.png" alt="image-20230416171442530" loading="lazy"><br><strong>每条指令对应一个微程序，这些微程序可以存到一个控制存储器中，用程序机器指令的办法来寻址每个微程序中的微指令。目前，大多计算机都采用微程序设计技术。</strong></p><p><strong>其中，存放微指令的控制存储器的单元地址称为微地址，一条微指令通常包含</strong>：</p><ul><li><strong>操作控制字段</strong>：又称操作码字段，用于产生某一步操作所需要的各种操作控制信号。</li><li><strong>顺序控制字段</strong>：又称微地址码字段，用于控制产生下一条要执行的微指令地址。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161715734.png" alt="image-20230416171506645" loading="lazy"></p><h2 id="6-2-微程序控制器的基本结构"><a href="#6-2-微程序控制器的基本结构" class="headerlink" title="6.2.微程序控制器的基本结构"></a>6.2.微程序控制器的基本结构</h2><h3 id="6-2-1-微程序控制器基本组成"><a href="#6-2-1-微程序控制器基本组成" class="headerlink" title="6.2.1.微程序控制器基本组成"></a>6.2.1.微程序控制器基本组成</h3><p><strong>微程序控制器基本组成:</strong></p><ul><li><p><strong>控制存储器 CM：</strong> 它是微程序控制器的核心部件，<strong>用于存放各指令对应的微程序，使用只读存储器 ROM 构成</strong>。每一条机器指令对应的微指令序列，由 CPU 厂商负责设计，并且在 CPU 出厂之前就已经把 ROM 里面的微程序数据全部写好了。</p></li><li><p><strong>微地址形成部件：</strong> 由于不同指令对应的微程序是不同的，<strong>因此需要根据该指令的操作码来确定它所对应的微程序的起始地址</strong>，以保证微指令的连续进行。</p></li><li><p><strong>微地址寄存器 CMAR：</strong> 有 MAR 就有 CMAR，和 MAR 一样，<strong>它用于接收微地址形成部件送来的微地址</strong>；同时 CMAR 还有一个别名，叫做 u u uPC，其实就是把 PC 和 MAR 整合到了一起。</p></li><li><p><strong>地址译码器：</strong> 有了地址就需要地址译码器，<strong>地址译码器会把地址码转换为存储单元控制信号。</strong></p></li><li><p><strong>微指令寄存器 CMDR：</strong> 有 MDR 就有 CMDR，它是微指令寄存器，别名叫做 u u uIR，<strong>用于存放从 CM 中取出的微指令，它的位数同微指令的字长。</strong></p></li><li><p><strong>顺序逻辑控制单元</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161716475.png" alt="image-20230416171648365" loading="lazy"></p><h3 id="6-2-1-微程序控制器工作过程"><a href="#6-2-1-微程序控制器工作过程" class="headerlink" title="6.2.1.微程序控制器工作过程"></a>6.2.1.微程序控制器工作过程</h3><p><strong>微程序控制器基本组成：当 CPU 取到一条指令之后，流程如下</strong>：</p><ol><li>把指令的<strong>操作码</strong>送给<strong>微地址形成部件</strong>，以确定<strong>微指令序列的起始地址</strong>。</li><li>根据<strong>顺序逻辑</strong>及其他标志信息等来确定<strong>接下来要执行的微指令的地址。</strong></li><li>将微指令地址<strong>放入到 CMAR</strong> 中。</li><li>经过地址译码器译码后就可以<strong>选中 CMAR 所指向的微指令</strong>。</li><li>取出该微指令，<strong>存放到 CMDR 中。</strong></li><li>(执行完该微指令后需要把微指令 “下地址” 信息送给顺序逻辑，结合其他信息用于判断下一个微指令)。</li><li>硬件电路需要根据该微指令的<strong>控制码部分</strong>，向 <strong>CPU 内部其他部件或系统总线</strong>发出控制信号（$PC_{out} ,MAR _{in}$，$1-&gt;R$ 等等）。</li></ol><h2 id="6-3-微程序控制器的工作原理"><a href="#6-3-微程序控制器的工作原理" class="headerlink" title="6.3.微程序控制器的工作原理"></a>6.3.微程序控制器的工作原理</h2><ul><li><p><strong>所有指令的取指周期、间址周期和中断周期几乎是一样的，所以这几个周期所对应的微指令序列也是可以共享的，因此在 CM 中只会存储一份</strong>。</p></li><li><p>取指周期的微程序段通常是公用的，所以 <strong>如果某指令系统中有 n 条机器指令，则 CM 中微程序段的个数至少是 n+1 个</strong>，而对于一些早期的 CPU，物联网设备的 CPU 由于其 CPU 可以不包含间址周期和中断周期，所以不包含进去。</p></li><li><p><strong>需要注意</strong>：物理上取指周期、执行周期看起来像两个微程序，但逻辑上应该将其看作一个整体。因此，“<strong>一条指令对应一个微程序</strong>” 的说法是正确的。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161718354.png" alt="image-20230416171824240" loading="lazy"></p><h1 id="7-微指令的设计"><a href="#7-微指令的设计" class="headerlink" title="7.微指令的设计"></a><a name="7.微指令的设计">7.微指令的设计</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161725625.png" alt="image-20230416172512509" loading="lazy"></p><h2 id="7-1-微指令的格式"><a href="#7-1-微指令的格式" class="headerlink" title="7.1.微指令的格式"></a>7.1.微指令的格式</h2><h3 id="7-1-1-水平型微指令"><a href="#7-1-1-水平型微指令" class="headerlink" title="7.1.1.水平型微指令"></a>7.1.1.水平型微指令</h3><p><strong>水平型微指令：是指一条微指令可以定义多个可并行执行的微命令</strong>。</p><ul><li><strong>优点：</strong> 微程序短，执行速度快。</li><li><strong>缺点：</strong> 微指令长，编写微程序较为麻烦。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721386.png" loading="lazy"></p><p><strong>水平型微指令其操作控制码部分较长，如果采用水平型微指令，那么指令的条数较少（一条微指令可以完成多个微操作或微命令），所以指令体积就会感觉很 “胖”</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721563.png" loading="lazy"></p><h3 id="7-1-2-垂直型微指令"><a href="#7-1-2-垂直型微指令" class="headerlink" title="7.1.2.垂直型微指令"></a>7.1.2.垂直型微指令</h3><p><strong>垂直型微指令：是指一条微指令只能定义一个微命令，由微操作码字段规定具体功能</strong>。</p><ul><li><strong>优点</strong>：微指令短、简单、规整、便于编写微程序。</li><li><strong>缺点</strong>：微程序长，执行速度慢，工作效率低。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721619.png" loading="lazy"></p><p><strong>垂直型微指令其操作控制码部分短，如果采用垂直型微指令，那么指令的条数较多（一条微指令只能定义一个微操作或微命令），所以指令体积就会感觉很 “瘦”。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722551.png" alt="image-20230416172209461" loading="lazy"></p><h3 id="7-1-3-混合型微指令"><a href="#7-1-3-混合型微指令" class="headerlink" title="7.1.3.混合型微指令"></a>7.1.3.混合型微指令</h3><p><strong>混合型微指令：在垂直型的基础上增加一些不复杂的并行操作。微指令较短，仍便于编写，形成的微程序也不长，执行速度加快。</strong></p><h2 id="7-2-微指令的编码方式"><a href="#7-2-微指令的编码方式" class="headerlink" title="7.2.微指令的编码方式"></a>7.2.微指令的编码方式</h2><p><strong>微指令的编码方式：又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目的是在保证速度的情况下，尽量缩短微指令字长。</strong></p><h3 id="7-2-1-直接编码（直接控制）"><a href="#7-2-1-直接编码（直接控制）" class="headerlink" title="7.2.1.直接编码（直接控制）"></a>7.2.1.直接编码（直接控制）</h3><p><strong>直接编码：直接编码无需译码，在微指令的操作控制字段中，每一位代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置为 1 或 0 即可，每个微命令对应并控制数据通路中的一个微操作。</strong></p><ul><li><strong>优点</strong>：简单、直观、执行速度快、操作并行性好。</li><li><strong>缺点</strong>：微指令字长过长，n 个微指令就要求微指令的操作字段有 n 位，造成控制存储器容量变得很大。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722368.png" alt="image-20230416172236277" loading="lazy"></p><ul><li>上图表示发出 (PC)-&gt;MAR 和 1-&gt;R 信号。</li></ul><h3 id="7-2-2-字段直接编码"><a href="#7-2-2-字段直接编码" class="headerlink" title="7.2.2.字段直接编码"></a>7.2.2.字段直接编码</h3><p><strong>字段直接编码：将微指令的微命令字段分成若干小字段，然后把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中</strong>。</p><ul><li><strong>互斥性微命令</strong>：不能并发执行（比如 PC-&gt;MAR 和 PC+1-&gt;PC）。</li><li><strong>相容性微命令</strong>：可以并发执行（比如 PC-&gt;MAR 和 1-&gt;R）。</li></ul><p><strong>每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723579.png" alt="image-20230416172300488" loading="lazy"></p><p><strong>微命令字段分段的原则为</strong>：</p><ul><li><strong>互斥性微命令分在同一段内，相容性微命令分在不同段内</strong>。</li><li>每个小段中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和移码时间。</li><li><strong>一般每个小段还要留出一个状态，表示本字段不发出任何微命令</strong>。因此当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，通常 000 表示不操作。</li></ul><p><strong>字段直接编码优缺点如下</strong></p><ul><li><strong>优点</strong>：可以缩短微指令字长。</li><li><strong>缺点</strong>：由于要通过译码电路后再发出微命令，因此比直接编码要慢。</li></ul><h3 id="7-2-3-字段间接编码"><a href="#7-2-3-字段间接编码" class="headerlink" title="7.2.3.字段间接编码"></a>7.2.3.字段间接编码</h3><p><strong>字段间接编码：一个字段的某些微命令需要用另一个字段中的某些微命令解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐编码。</strong></p><ul><li><strong>优点</strong>：可以进一步缩短微指令字长。</li><li><strong>缺点</strong>：削弱了微指令的并行控制能力，所以通常作为字段直接编码的一种辅助手段。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723204.png" alt="image-20230416172318107" loading="lazy"></p><h2 id="7-3-微指令的地址形成方式"><a href="#7-3-微指令的地址形成方式" class="headerlink" title="7.3.微指令的地址形成方式"></a>7.3.微指令的地址形成方式</h2><h3 id="7-3-1-下地址给出"><a href="#7-3-1-下地址给出" class="headerlink" title="7.3.1.下地址给出"></a>7.3.1.下地址给出</h3><p><strong>下地址给出：下一个微指令的地址直接由当前微指令的下地址字段指出。</strong></p><h3 id="7-3-2-操作码形成"><a href="#7-3-2-操作码形成" class="headerlink" title="7.3.2.操作码形成"></a>7.3.2.操作码形成</h3><p><strong>操作码形成：当机器指令取至指令寄存器之后，微指令的地址由操作码经微地址形成部件形成</strong>。</p><h3 id="7-3-3-增量计数法"><a href="#7-3-3-增量计数法" class="headerlink" title="7.3.3.增量计数法"></a>7.3.3.增量计数法</h3><p><strong>增量计数法：类似于 (PC+1)-&gt;PC，有 (CMAR+1)-&gt;CMAR。</strong></p><h3 id="7-3-4-分支转移"><a href="#7-3-4-分支转移" class="headerlink" title="7.3.4.分支转移"></a>7.3.4.分支转移</h3><p>有些微指令是转移指令，类似于 JMP。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723517.png" loading="lazy"></p><h3 id="7-3-5-通过测试网络"><a href="#7-3-5-通过测试网络" class="headerlink" title="7.3.5.通过测试网络"></a>7.3.5.通过测试网络</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161724375.png" alt="image-20230416172418278" loading="lazy"></p><h3 id="7-3-6-由硬件产生微程序入口地址"><a href="#7-3-6-由硬件产生微程序入口地址" class="headerlink" title="7.3.6.由硬件产生微程序入口地址"></a>7.3.6.由硬件产生微程序入口地址</h3><ul><li><strong>第一条微指令地址</strong>：由专门硬件产生（用专门的硬件记录取指周期微程序首地址）。</li><li><strong>中断周期</strong>：由硬件产生中断周期微程序首地址（用专门的硬件记录）。</li></ul><h1 id="8-微程序控制单元的设计"><a href="#8-微程序控制单元的设计" class="headerlink" title="8.微程序控制单元的设计"></a>8.微程序控制单元的设计</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161750234.png" alt="image-20230416175020091" loading="lazy"></p><h2 id="8-1-微程序控制单元设计步骤"><a href="#8-1-微程序控制单元设计步骤" class="headerlink" title="8.1.微程序控制单元设计步骤"></a>8.1.微程序控制单元设计步骤</h2><h3 id="8-1-1-第一步：分析每个阶段的微操作序列"><a href="#8-1-1-第一步：分析每个阶段的微操作序列" class="headerlink" title="8.1.1.第一步：分析每个阶段的微操作序列"></a>8.1.1.第一步：分析每个阶段的微操作序列</h3><p><strong>无论是组合逻辑设计还是微程序设计，对于相同的 CPU 结构，两种控制单元的位操作码和节拍安排都是极其相似的</strong>。以微程序控制单元在取指阶段发出的微操作命令及节拍安排如下：</p><ul><li>$T_{0}$​：PC-&gt;MAR，1-&gt;R（对应微指令 a）。</li><li>$T_{1}$​：M(MAR)-&gt;MDR，PC+1-&gt;PC（对应微指令 b）。</li><li>$T_{2}$：MDR-&gt;IR,OP(IR)-&gt; 微地址形成部件（对应微指令 c）。</li></ul><p>相比于硬布线控制，只是在 $T_{2}$节拍内的微操作命令有所不同：<strong>微程序控制单元在 $T_{2}$节拍内要将指令的操作码送至微地址形成部件（OP(IR)-&gt; 微地址形成部件），以形成该条机器指令的微程序首地址。而硬布线控制单元在 $T_{2}$节拍内要将指令的操作码送至指令译码器，以控制 CU 发出相应的微命令（OP(IR)-&gt;ID）</strong>。</p><p>若把一个节拍 $t$ 内的微操作安排在一条微指令中完成，上述微操作就对应了 3 条微指令。<strong>但是由于微程序控制的所有控制信号都来自于微命令，而微命令又存在于控制存储器中，因此欲完成这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。</strong></p><ul><li>在取指微程序中，除第一条微指令外，<strong>其余微指令的地址均由上一条微指令的下地址字段直接给出</strong>，因此上述每条微指令都需要增加一个<strong>将微指令下地址字段送至 CMAR</strong> 的微操作，也即 <strong>Ad(CMDR)-&gt;CMAR。</strong></li><li>取指微程序的最后一条微指令，<strong>其后继微指令的地址是由微地址形成部件形成的</strong>，即微地址形成部件 -&gt;CMAR。为了反映该地址与操作码有关，因此记为 <strong>OP(IR)-&gt; 微地址形成部件 -&gt;CMAR</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161738357.png" alt="image-20230416173804248" loading="lazy"></p><p><strong>总之，考虑到需要形成后继的微指令地址，上述取指操作应需要 6 条微指令</strong>：</p><ul><li>$T_{0}$​：<strong>PC-&gt;MAR，1-&gt;R</strong></li><li>$T_{1}$​：Ad(CMDR)-&gt;CMAR</li><li>$T_{2}$：<strong>M(MAR)-&gt;MDR,(PC+1)-&gt;PC</strong></li><li>$T_{3} $：Ad(CMDR)-&gt;CMAR</li><li>$T_{4} $：<strong>MDR-&gt;IR</strong></li><li>$T_{5} $​：<strong>OP(IR)-&gt; 微地址形成部件 -&gt;CMAR</strong></li></ul><h3 id="8-1-2-第二步：写出对应机器指令的微操作命令及节拍安排"><a href="#8-1-2-第二步：写出对应机器指令的微操作命令及节拍安排" class="headerlink" title="8.1.2.第二步：写出对应机器指令的微操作命令及节拍安排"></a>8.1.2.第二步：写出对应机器指令的微操作命令及节拍安排</h3><p><strong>首先写出每个周期所需要的微操作，也就是把可以并行的微操作安排在同一时序进行，这一点请参照：</strong><a href=""><a href="#5.硬布线控制器">5.硬布线控制器</a></a>。</p><p>安排微操作时序有如下原则：</p><ul><li>原则一：微操作的<font color='red'>先后顺序</font>不得随意更改（比如PC-&gt;MAR一定在M（MAR）-&gt;MDR之前完成）</li><li>原则二：<font color='red'>被控对象不同的微操作</font>尽量安排在<font color='red'>一个节拍内</font>完成（比如PC-&gt;MAR控制对象为寄存器，1&gt;R控制对象为主存，因此尽量安排在同一个节拍内完成）</li><li>原则三：<font color='red'>占用时间较短</font>的微操作尽量安排在<font color='red'>一个节拍内完成，并允许有先后顺序</font>（比如寄存器之间的交互快于寄存器与主存的交互，因此如果可以的话尽量将其放在一个节拍完成）</li></ul><p>比如取指周期，上面我们所列的微操作序列，在这种原则下是不合适的，因此更改如下：</p><p><strong>另外还要加入一些特有的操作</strong>：</p><ul><li><p>取指周期内，除了最后一条微指令，<strong>每一条微指令结束后都要根据当前微指令的下地址字段指出下一条微指令的地址</strong>，即 Ad(CMDR)-&gt;CMAR；取指周期的最后一条微指令执行完成之后，<strong>要根据指令操作码确定其执行周期的微程序首地址</strong>，即 OP(IR)-&gt; 微地址形成部件 -&gt;CMAR。</p></li><li><p>执行周期内，<strong>每一条微指令结束后都要根据当前微指令的下地址字段指出下一条微指令的地址</strong>，即 Ad(CMDR)-&gt;CMAR；<strong>执行周期最后一条微指令其下地址是 0，又会指向取指周期第一条微指令</strong>  。</p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161747220.png" style="zoom: 50%;" / loading="lazy"></li></ul><h3 id="8-1-3-第三步：确定微指令格式"><a href="#8-1-3-第三步：确定微指令格式" class="headerlink" title="8.1.3.第三步：确定微指令格式"></a>8.1.3.第三步：确定微指令格式</h3><ul><li><strong>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数</strong>。</li><li><strong>根据 CM 中存储的微指令总数，确定微指令的顺序控制字段的位数。</strong></li><li><strong>最后按操作控制字段位数和顺序控制字段位数就可以确定微指令字长</strong>。</li></ul><p>更多细节请看<a href="#7.微指令的设计">7.微指令的设计</a>。</p><h3 id="8-1-4-第四步：编写微指令码点"><a href="#8-1-4-第四步：编写微指令码点" class="headerlink" title="8.1.4.第四步：编写微指令码点"></a>8.1.4.第四步：编写微指令码点</h3><p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</p><h2 id="8-2-微程序设计分类"><a href="#8-2-微程序设计分类" class="headerlink" title="8.2.微程序设计分类"></a>8.2.微程序设计分类</h2><h3 id="8-2-1-静态微程序设计和动态微程序设计"><a href="#8-2-1-静态微程序设计和动态微程序设计" class="headerlink" title="8.2.1.静态微程序设计和动态微程序设计"></a>8.2.1.静态微程序设计和动态微程序设计</h3><ul><li><strong>静态</strong>：微程序无需改变，采用 ROM。</li><li><strong>动态</strong>：通过改变微指令和微程序改变机器指令，有利于仿真，采用 DPROM。</li></ul><h3 id="8-2-2-毫微程序设计"><a href="#8-2-2-毫微程序设计" class="headerlink" title="8.2.2.毫微程序设计"></a>8.2.2.毫微程序设计</h3><ul><li><strong>微程序设计</strong>：使用微程序解释机器指令。</li><li><strong>毫微程序设计</strong>：使用毫微程序解释微程序。</li></ul><h2 id="8-3-硬布线控制器和微程序控制器比较"><a href="#8-3-硬布线控制器和微程序控制器比较" class="headerlink" title="8.3.硬布线控制器和微程序控制器比较"></a>8.3.硬布线控制器和微程序控制器比较</h2><table><thead><tr><th></th><th><strong>微程序控制器</strong></th><th><strong>硬布线控制器</strong></th></tr></thead><tbody><tr><td><strong>工作原理</strong></td><td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td><td>微操作控制信号由组合逻辑电路根据当前的指令码，状态和时序即时产生</td></tr><tr><td><strong>执行速度</strong></td><td>慢</td><td>快</td></tr><tr><td><strong>是否规整</strong></td><td>是</td><td>否</td></tr><tr><td><strong>应用场合</strong></td><td>CISC 和 CPU</td><td>RISC 和 CPU</td></tr><tr><td><strong>易扩充性</strong></td><td>易于扩充</td><td>很难扩充</td></tr></tbody></table><h1 id="9-中断和异常"><a href="#9-中断和异常" class="headerlink" title="9.中断和异常"></a>9.中断和异常</h1><h2 id="9-1-中断的作用"><a href="#9-1-中断的作用" class="headerlink" title="9.1.中断的作用"></a>9.1.中断的作用</h2><p><strong>在操作系统引入核心态和用户态这两种工作状态后，就需要考虑它们之间的切换问题了。具体来讲，操作系统内核工作在核心态，用户程序工作在用户态，系统不允许用户程序使用核心态的功能，但是用户程序为了完成某些操作又必须使用这些功能。</strong></p><ul><li>比如 C 语言中的<code>printf</code>可以向屏幕打印一些内容。在屏幕上显示内容，这本就是操作系统才能做到的事情，所以你编写的程序在运行必须使用相关功能。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>因此，需要在核心态建立一些 “门”，以便实现从用户态进入核心态。而中断就是 CPU 运行上层程序时唯一能进入这些 “门” 的途径，同时中断也是让操作系统内核夺回 CPU 使用权的唯一途径。发生中断时，用户态会立即进入核心态，这是通过硬件实现的</strong>。</p><h2 id="9-2-中断的类型"><a href="#9-2-中断的类型" class="headerlink" title="9.2.中断的类型"></a>9.2.中断的类型</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752409.png" alt="image-20230416175223296" loading="lazy"></p><h3 id="9-2-1-外中断（中断）"><a href="#9-2-1-外中断（中断）" class="headerlink" title="9.2.1.外中断（中断）"></a>9.2.1.外中断（中断）</h3><p><strong>中断：也称为外中断，指中断信号来自于 CPU 外部，也即与当前执行的指令无关，例如</strong>：</p><ul><li><p><strong>时钟部件</strong>会每隔一个时间片给 CPU 发送一个<strong>时钟中断</strong>信号，防止某些程序长时间抢占 CPU。</p></li><li><p><strong>输入 &#x2F; 输出处理完成后，相关设备也会发送一个中断信号</strong>，希望处理机能够向设备发下一个输入 &#x2F; 输出请求，同时让完成输入 &#x2F; 输出后的程序继续运行  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752751.png" alt="image-20230416175236635" loading="lazy"></p></li></ul><h3 id="9-2-2-内中断（异常）"><a href="#9-2-2-内中断（异常）" class="headerlink" title="9.2.2.内中断（异常）"></a>9.2.2.内中断（异常）</h3><p><strong>内中断：也称为异常 (trap)，指中断信号来自于 CPU 内部，也即与当前执行的指令有关，例如</strong>：</p><ul><li>试图在用户态下执行特权指令。</li><li>执行除法指令时发现除数为 0。</li><li>应用程序想要请求操作系统内核为其提供服务，此时会执行一条特殊的指令——<strong>陷入指令（<code>trap</code>）</strong>，该指令会引发一个内中断信号（比如 C 语言中的<code>printf</code>）。</li></ul><p><strong>对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现异常应立即处理</strong>。</p><h2 id="9-3-中断的处理过程"><a href="#9-3-中断的处理过程" class="headerlink" title="9.3.中断的处理过程"></a>9.3.中断的处理过程</h2><p>此部分内容需要用到大量计组的知识，不是三言两语就能说清楚的，这里只是简单谈及，读者可以查阅文章最开始的链接进行学习  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161757080.png" loading="lazy"></p><ul><li><p><strong>关中断</strong>：在中断服务程序中，为了<strong>保护中断现场</strong> (即 CPU 主要寄存器中的内容) 期间不被新的中断所打断，必须关中断，从而<strong>保证被中断的程序在中断服务程序执行完毕后能接着正确地执行</strong>。</p></li><li><p><strong>保存断点</strong>：为保证在中断服务程序执行那个完毕后能<strong>正确地返回原来的程序</strong>，必须将原来程序的断点（即 PC 的内容）<strong>保存</strong>起来。这一点我们在<a href="#2.指令执行过程">2.指令执行过程</a>中有过详细介绍。</p></li><li><p><strong>引出中断服务程序</strong>：<strong>其实质是取出中断服务程序的入口地址并传送给程序计数器 PC。</strong></p></li><li><p><strong>保护现场：</strong> 保存<strong>通用寄存器和状态寄存器</strong>的内容（即保存 ACC 寄存器的值），以便返回原程序后可以<strong>恢复 CPU 环境</strong>，可以使用堆栈，也可以使用特定存储单元。</p></li><li><p><strong>中断服务：</strong> 主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲寄存器 （中断服务的过程中有可能会修改 ACC 寄存器的值）。</p></li><li><p><strong>恢复现场：</strong> 通过<strong>出栈指令或取数指令</strong>把之前保存的信息送回寄存器中（把原程序算到一般的 ACC 值恢复原样）。</p></li><li><p><strong>中断返回：通过中断返回指令回到</strong>原程序断点<strong>处。</strong></p></li></ul><h1 id="10-指令流水线基本概念性能指标"><a href="#10-指令流水线基本概念性能指标" class="headerlink" title="10.指令流水线基本概念性能指标"></a><a name="10.指令流水线基本概念性能指标">10.指令流水线基本概念性能指标</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161945862.png" alt="image-20230416194547727" loading="lazy"></p><h2 id="10-1-指令流水的定义"><a href="#10-1-指令流水的定义" class="headerlink" title="10.1.指令流水的定义"></a>10.1.指令流水的定义</h2><p><strong>前面说过，一条指令的执行过程可以分成多个阶段，不同的计算机有不同的分法，其中比较通用的划分方法就是划分为取指，分析和执行三个阶段</strong>。</p><ul><li><p><strong>取指</strong>：根据 PC 内容访问主存储器，取出一条指令送到 IR 中。</p></li><li><p><strong>分析</strong>：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址 EA，并存有效地址 EA 中取出操作数。</p></li><li><p><strong>执行</strong>：根据操作码字段完成指令规定的功能，即把运算结果写入到通用寄存器或主存中  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758588.png" loading="lazy"></p></li></ul><p>当多条指令在处理器中执行时，会有如下三种执行方式，称之为指令流水：</p><ul><li>顺序执行</li><li>一次重叠</li><li>二次重叠</li></ul><h3 id="10-1-1-顺序执行方式"><a href="#10-1-1-顺序执行方式" class="headerlink" title="10.1.1.顺序执行方式"></a>10.1.1.顺序执行方式</h3><p><strong>顺序执行方式：指令会按顺序执行，前一条指令执行完之后，才启动下一条指令。传统的冯诺依曼机便采用此种方式，又称其为串行执行方式</strong>。</p><ul><li><strong>优点</strong>：控制<strong>简单</strong>，硬件<strong>代价小。</strong></li><li><strong>缺点</strong>：执行指令的<strong>速度较慢</strong>，任何时刻，处理机中<strong>只有一条指令</strong>在执行，各功能部件<strong>利用率很低。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758581.png" loading="lazy"></p><p>**设取指、分析、执行 3 个阶段的时间都相等，用 $t$ 表示，那么顺序执行 $n$条指令所用时间为 $T&#x3D;3nt $**。</p><h3 id="10-1-2-一次重叠方式"><a href="#10-1-2-一次重叠方式" class="headerlink" title="10.1.2.一次重叠方式"></a>10.1.2.一次重叠方式</h3><p><strong>一次重叠方式：同时进行第 k 条指令的 “执行阶段” 和第 k+1 条指令的 “取指阶段”。</strong></p><ul><li><strong>优点</strong>：程序的执行时间<strong>缩短了 $ \frac{1}{3} $​</strong>，各功能部件的<strong>利用率明显提高</strong>。</li><li><strong>缺点</strong>：需要付出较大的<strong>硬件代价</strong>，控制过程也比顺序执行<strong>复杂。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758172.png" loading="lazy">  </p><p><strong>采用此种方式时，执行 $n$条指令所用时间为</strong>：</p><p>$T&#x3D;3t+(n-1)×2t&#x3D;(1+2n)t $</p><h3 id="10-1-3-二次重叠执行方式"><a href="#10-1-3-二次重叠执行方式" class="headerlink" title="10.1.3.二次重叠执行方式"></a>10.1.3.二次重叠执行方式</h3><p><strong>二次重叠方式：为了进一步提高指令的执行速度，可以把 “取 $K$+1 条指令” 提前到 “分析第 $K$ 条指令”的期间完成，使 “分析第 k+1 条指令” 与“执行第 k 条指令”同时进行</strong>。</p><ul><li><strong>优点</strong>：使指令的执行时间缩短了近 2&#x2F;3。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017986.png" loading="lazy"></p><p><strong>采用此种方式，执行 $n$条指令所用时间为</strong>：</p><p>$T&#x3D;3t+(n-1)×t&#x3D;(2+n)t $</p><p><strong>这是一种理想的指令执行方式，在正常情况下，处理机中同时有 3 条指令在执行. 若每条指令需要通过 4 个或 5 个执行步骤完成，则可以采取 3 次或 4 次重叠执行方式（考试常考 5 次）</strong>。</p><h2 id="10-2-流水线的表示方法"><a href="#10-2-流水线的表示方法" class="headerlink" title="10.2.流水线的表示方法"></a>10.2.流水线的表示方法</h2><h3 id="10-2-1-指令执行过程图"><a href="#10-2-1-指令执行过程图" class="headerlink" title="10.2.1.指令执行过程图"></a>10.2.1.指令执行过程图</h3><p><strong>指令执行过程图：该图用于描述指令的执行过程以及影响流水线的因素，横坐标表示时间、纵坐标表示指令序列。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161759655.png" alt="image-20230416175911550" loading="lazy"></p><h3 id="10-2-2-时空图"><a href="#10-2-2-时空图" class="headerlink" title="10.2.2.时空图"></a>10.2.2.时空图</h3><p><strong>指令执行过程图：在时空图中，横坐标表示时间（输入流水线中的各个任务在流水线中所经过的时间）；纵坐标表示空间，即流水线的每个流水段（对应各个执行部件）。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171125130.png" alt="image-20230416175942607" loading="lazy"></p><ul><li>从上图中可以看出，第一条指令 $I_{1}$在时刻 $t_{0}$​进入流水线，在时刻$ t_{4}$​流出流水线。</li><li>第二条指令$I_{2} $在时刻 $T_{1}$进入流水线，在时刻 $t_{5}$流出流水线。</li><li>以此类推，每经过一个Δt 时间，便有一条指令进入流水线，从时刻$ t_{4}$开始有一条指令流出流水线。</li></ul><h2 id="10-3-流水线性能指标"><a href="#10-3-流水线性能指标" class="headerlink" title="10.3.流水线性能指标"></a>10.3.流水线性能指标</h2><h3 id="10-3-1-吞吐率"><a href="#10-3-1-吞吐率" class="headerlink" title="10.3.1.吞吐率"></a>10.3.1.吞吐率</h3><p><strong>吞吐率：是指在单位时间内流水线所完成的任务数量，或是输出结果的数量</strong>。</p><p><strong>假设任务数为 n n n，处理完这 $n$个任务所用时间为 $ T_{k}$​，则计算流水线吞吐率（ $ TP$）的最基本公式为</strong></p><p>$ TP&#x3D;\frac{n}{T_{k}} $</p><p><strong>对应时空图如下</strong>：</p><ul><li><p>一条指令的执行分为 $K$ 个阶段，每个阶段耗时Δt，一般取Δt &#x3D; 一个时钟周期  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png" alt="image-20230416180116454" loading="lazy"></p></li></ul><p><strong>则流水线的实际吞吐率为</strong>：</p><p>$TP&#x3D;\frac{n}{(k+n-1)\Delta t} $</p><p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p><p>$ \lim\limits_{n \to \infty}TP&#x3D;\frac{n}{(k+n-1)\Delta t} $</p><p><strong>故</strong>：</p><p>$ TP_{max}&#x3D;\frac{1}{\Delta t} $</p><h3 id="10-3-2-加速比"><a href="#10-3-2-加速比" class="headerlink" title="10.3.2.加速比"></a>10.3.2.加速比</h3><p><strong>加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</strong></p><p><strong>设 $T_{0}$​表示不使用流水线时的执行时间，即顺序执行所有指令花费的时长； $ T_{k}$​表示使用流水线的执行时间，则计算流水线加速比 $S $ 的基本公式为</strong></p><p>$S&#x3D;\frac{T_{0}}{T_{k}} $</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png" loading="lazy"></p><p><strong>单独完成一个任务耗时为 $ k\Delta t$，则顺序完成 $n$个任务耗时为 $ T_{0}&#x3D;nk\Delta $，且 $ T_{k}&#x3D;(k+n-1)\Delta $，故实际加速比为</strong>：</p><p>$ S&#x3D;\frac{nk\Delta}{(k+n-1)\Delta}&#x3D;\frac{kn}{k+n-1} $</p><p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p><p>$ \lim\limits_{n \to \infty}S&#x3D;\frac{kn}{k+n-1} $</p><p><strong>故</strong>：</p><p>$ S_{max}&#x3D;k $</p><h3 id="10-3-3-效率"><a href="#10-3-3-效率" class="headerlink" title="10.3.3.效率"></a>10.3.3.效率</h3><p><strong>加速比：流水线的设备利用率称为流水线的效率。在时空图上，流水线的效率定义为： $n$个任务占用的时空区有效面积与 $n$个任务所用的时间与 $K$ 个流水段所围成的时空区域总面积之比</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161802331.png" alt="image-20230416180206228" loading="lazy"></p><p><strong>则流水线效率 ( $E$) 的一般公式为</strong>：</p><p>$ E&#x3D;\frac{n 个任务占用的时空区有效面积}{n 个任务所用的时间与 k 个流水段所围成的时空区域总面积}&#x3D;\frac{T_{0}}{kT_{k}} $</p><p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p><p>$ \lim\limits_{n \to \infty}E&#x3D;\frac{T_{0}}{kT_{k}} $</p><p><strong>故</strong>：</p><p>$ E_{max}&#x3D;1 $</p><h1 id="11-指令流水线影响因素分类"><a href="#11-指令流水线影响因素分类" class="headerlink" title="11.指令流水线影响因素分类"></a>11.指令流水线影响因素分类</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810973.png" alt="image-20230416181019839" loading="lazy"></p><h2 id="11-1-影响指令流水线的因素"><a href="#11-1-影响指令流水线的因素" class="headerlink" title="11.1.影响指令流水线的因素"></a>11.1.影响指令流水线的因素</h2><p><a href="#10.指令流水线基本概念性能指标">10.指令流水线基本概念性能指标</a>中所讲到的流水线都是理想情况，但在实际情况中流水线的衔接似乎不那么完美，那么这当中的影响因素都有哪些呢？</p><h3 id="11-1-1-结构相关（资源冲突）"><a href="#11-1-1-结构相关（资源冲突）" class="headerlink" title="11.1.1.结构相关（资源冲突）"></a>11.1.1.结构相关（资源冲突）</h3><h4 id="11-1-1-1-概述"><a href="#11-1-1-1-概述" class="headerlink" title="11.1.1.1.概述"></a>11.1.1.1.概述</h4><p><strong>结构相关（资源冲突）：由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关</strong>。</p><p>如下图所示，<code>Load</code>指令在进入<code>Mem</code>阶段时，<code>Instr3</code>指令才刚进入取指阶段，两者都会访问主存所以可能导致资源上的冲突。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161806136.png" alt="image-20230416180647002" loading="lazy"></p><h4 id="11-1-1-2-解决方法"><a href="#11-1-1-2-解决方法" class="headerlink" title="11.1.1.2.解决方法"></a>11.1.1.2.解决方法</h4><p><strong>结构相关（资源冲突）解决方法</strong>：</p><ul><li><p><strong>第一种解决方法</strong>：后一相关指令<strong>暂停一周期</strong>。</p></li><li><p><strong>第二种解决方法</strong>：进行资源重复配置，<strong>专门设立数据存储器和指令存储器</strong>，使访问数据和访问指令<strong>专属于不同的存储块</strong>，互不干扰  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161805535.png" loading="lazy"></p></li></ul><h3 id="11-1-2-数据相关（数据冲突）"><a href="#11-1-2-数据相关（数据冲突）" class="headerlink" title="11.1.2.数据相关（数据冲突）"></a>11.1.2.数据相关（数据冲突）</h3><h4 id="11-1-2-1-概述"><a href="#11-1-2-1-概述" class="headerlink" title="11.1.2.1.概述"></a>11.1.2.1.概述</h4><p><strong>数据相关（数据冲突）：在一个程序中，如果存在必须等前一条指令执行完才能执行后一条指令的情形，则这两条指令为数据相关</strong>。</p><p>如下图所示，众多指令在依次执行。<code>sub</code>、<code>and</code>、<code>or</code>和<code>xor</code>这些指令都会用到<code>r1</code>这个操作数。其中<code>add</code>指令会把<code>r2</code>和<code>r3</code>相加的结果放入<code>r1</code>，在这个过程中，如果<code>and</code>后面的指令在<code>and</code>指令还没有把<code>r1</code>放入内存时就访问了<code>r1</code>，那么就会导致<code>sub</code>、<code>and</code>和<code>or</code>这三个指令拿到错误的<code>r1</code>，而只有<code>xor</code>拿到了正确的<code>r1</code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807614.png" alt="image-20230416180729500" loading="lazy"></p><h4 id="11-1-2-2-解决方法"><a href="#11-1-2-2-解决方法" class="headerlink" title="11.1.2.2.解决方法"></a>11.1.2.2.解决方法</h4><p><strong>数据相关（数据冲突）解决方法</strong>。</p><ul><li><p><strong>第一种解决方法</strong>：把遇到数据相关的指令及其后续指令<strong>都暂停一至几个时钟周期</strong>，直至数据相关问题消失后再继续进行，可以分为 <strong>硬件阻塞 (stall)</strong> 和 <strong>软件插入 “NOP</strong>“ 两种方法  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809003.png" alt="image-20230416180919877" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161808032.png" alt="image-20230416180835875" loading="lazy"></p><p><strong>第二种解决方法</strong>：使用<strong>数据旁路技术</strong>，仔细观察，<code>r1</code>的正确结果其实已经在执行阶段结束之后就生成了，因此<strong>可以把该指令的计算结果作为 ALU 的一个输入来源</strong>，直接开始计算过程  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807591.png" alt="image-20230416180754468" loading="lazy"></p></li><li><p><strong>第三种解决方法</strong>：使用<strong>编译优化</strong>，通过编译器<strong>调整指令顺序</strong>，使得一些不需要该数据的后续指令先于这些指令执行。</p></li></ul><h3 id="11-1-3-控制相关（控制冲突）"><a href="#11-1-3-控制相关（控制冲突）" class="headerlink" title="11.1.3.控制相关（控制冲突）"></a>11.1.3.控制相关（控制冲突）</h3><h4 id="11-1-3-1-概述"><a href="#11-1-3-1-概述" class="headerlink" title="11.1.3.1.概述"></a>11.1.3.1.概述</h4><p><strong>控制相关（控制冲突）：当流水线遇到转移指令和其他改变 PC 值的指令而造成断流时，会引起控制相关、</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809667.png" alt="image-20230416180943551" loading="lazy"></p><h4 id="11-1-3-2-解决方法"><a href="#11-1-3-2-解决方法" class="headerlink" title="11.1.3.2.解决方法"></a>11.1.3.2.解决方法</h4><p><strong>控制相关（控制冲突）解决方法</strong>：</p><ul><li><strong>转移指令分支预测</strong>：简单预测（永久 true 或者 false）、动态预测（根据历史情况）动态调整。</li><li><strong>预期转移成功和不成功两个控制流方向上的目标指令。</strong></li><li><strong>加快和提前形成条件码。</strong></li><li><strong>提高转移方向的猜准率。</strong></li></ul><h2 id="11-2-流水线的分类"><a href="#11-2-流水线的分类" class="headerlink" title="11.2.流水线的分类"></a>11.2.流水线的分类</h2><h3 id="11-2-1-根据流水线使用的级别不同分类"><a href="#11-2-1-根据流水线使用的级别不同分类" class="headerlink" title="11.2.1.根据流水线使用的级别不同分类"></a>11.2.1.根据流水线使用的级别不同分类</h3><ul><li><p><strong>部件功能级流水</strong>：就是<strong>把复杂的算数逻辑运算组成流水线工作方式</strong>。例如可以把浮点加法操作分为求阶、对阶、尾数相加以及规格化 4 个子过程。</p></li><li><p><strong>处理机级流水</strong>：就是<strong>把一条指令解释过程分为多个子过程</strong>。例如我们经常提到的取指、译码、执行和访存及写回 5 个子过程。</p></li><li><p><strong>处理间流水</strong>：就<strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需要存放在与下一个处理器所共享的存储器中。</strong></p></li></ul><h3 id="11-2-2-根据流水线可以完成的功能分类"><a href="#11-2-2-根据流水线可以完成的功能分类" class="headerlink" title="11.2.2.根据流水线可以完成的功能分类"></a>11.2.2.根据流水线可以完成的功能分类</h3><ul><li><p><strong>单功能流水线</strong>：只能实现<strong>一种固定的专门功能</strong>的流水线。</p></li><li><p><strong>多功能流水线</strong>：通过<strong>各段间的不同连接方式可以同时或不同时地</strong>实现多种功能的流水线。</p></li></ul><h3 id="11-2-3-根据同一时间内各段之间的连接方式"><a href="#11-2-3-根据同一时间内各段之间的连接方式" class="headerlink" title="11.2.3.根据同一时间内各段之间的连接方式"></a>11.2.3.根据同一时间内各段之间的连接方式</h3><ul><li><p><strong>静态流水线</strong>：在同一时间内，流水线的各段<strong>只能按同一种功能</strong>的连接方式工作。</p></li><li><p><strong>动态流水线</strong>：在同一时间内，<strong>当某些段正在实现某种运算时，另一些段正在进行另一种运算</strong>。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</p></li></ul><h3 id="11-2-4-根据流水线的各个功能段之间是否有反馈信号"><a href="#11-2-4-根据流水线的各个功能段之间是否有反馈信号" class="headerlink" title="11.2.4.根据流水线的各个功能段之间是否有反馈信号"></a>11.2.4.根据流水线的各个功能段之间是否有反馈信号</h3><ul><li><p><strong>线性流水线</strong>：从输入到输出，<strong>每个功能段只允许经过一次</strong>，不存在反馈回路。</p></li><li><p><strong>非线性流水线</strong>：存在反馈回路，<strong>从输入到输出过程中，某些功能段将数次通过流水</strong>线，这种流水线适合进行线性递归的运算。</p></li></ul><h2 id="11-3-流水线多发技术"><a href="#11-3-流水线多发技术" class="headerlink" title="11.3.流水线多发技术"></a>11.3.流水线多发技术</h2><h3 id="11-3-1-超标量技术"><a href="#11-3-1-超标量技术" class="headerlink" title="11.3.1.超标量技术"></a>11.3.1.超标量技术</h3><p><strong>超标量技术：每个时钟周期内可以<font color='orange'>并发执行多条独立指令</font>，即以并行操作方式将两条或多条指令编译并执行，为此需要配置多个功能部件。超标量计算机<font color='orange'>不能调整指令的执行顺序</font>，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810398.png" alt="image-20230416181059298" loading="lazy"></p><h3 id="11-3-2-超流水技术"><a href="#11-3-2-超流水技术" class="headerlink" title="11.3.2.超流水技术"></a>11.3.2.超流水技术</h3><p>超流水技术：在<font color='yellow'>一个时钟周期</font>内<font color='yellow'>再分段</font>，在一个时钟周期内<font color='yellow'>一个功能部件使用多次</font>。<font color='yellow'>不能调整</font>指令的<font color='yellow'>执行顺序</font>，靠编译程序解决优化问题。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161811432.png" alt="image-20230416181152329" loading="lazy"></p><h3 id="11-3-3-超长指令字"><a href="#11-3-3-超长指令字" class="headerlink" title="11.3.3.超长指令字"></a>11.3.3.超长指令字</h3><p><strong>超流水技术：由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可以达到上百位），为此需要采用多个处理部件。</strong></p><h1 id="12-五段式指令流水线"><a href="#12-五段式指令流水线" class="headerlink" title="12.五段式指令流水线"></a>12.五段式指令流水线</h1><p><strong>本节会介绍如下 5 类指令的执行过程，它们在考试中经常出现</strong>：</p><ul><li>运算类指令</li><li>LOAD 指令</li><li>STORE 指令</li><li>条件转移指令</li><li>无条件转移指令</li></ul><p><strong>指令在执行过程中会涉及如下过程</strong>：</p><ul><li><code>IF</code>：取指</li><li><code>ID</code>译码 &amp; 取数</li><li><code>EX</code>执行</li><li><del><code>M</code>：访存</del></li><li><code>WB</code>：写回寄存器</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161947573.png" alt="image-20230416194733427" loading="lazy"></p><p><strong>注意</strong>：</p><ul><li>在 RISC 处理器中只有 LOAD 和 STORE 才能访问主存。</li><li>转移类指令通常采用相对寻址（相对于 PC）。</li></ul><h2 id="12-1-运算类指令的执行过程"><a href="#12-1-运算类指令的执行过程" class="headerlink" title="12.1.运算类指令的执行过程"></a>12.1.运算类指令的执行过程</h2><p><strong>下表展示了 2 个较为典型的运算类指令:</strong></p><table><thead><tr></th></tr></thead><tbody><tr><td>加法指令（另个寄存器相加）</td><td>ADD R<sub>s</sub>,R<sub>d</sub></td><td>(R<sub>s</sub>)+(R<sub>d</sub>)-&gt; R<sub>d</sub></td></tr><tr><td>加法指令（寄存器与立即数相加）</td><td>ADD #996,R<sub>d</sub></td><td>996+(R<sub>d</sub>)-&gt; R<sub>d</sub></td></tr><tr><td>算数左移指令</td><td>SHL R<sub>d</sub></td><td>(R<sub>d</sub>)&lt;&lt;&lt;2-&gt; R<sub>d</sub></td></tr></tbody></table><p><strong>运算类指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p><strong>运算类指令步骤二（<code>ID</code>）：取出操作数到 ID 段的锁存器。</strong></p><ul><li>ADD Rs,Rd：Rs 放到 $A$中、Rd 放到 $B$ 中。</li><li>ADD #996,Rd：Rd 放到 $A$中，966 放到 $Imm$ 中。</li><li>SHL Rd：Rd 放到 $A$中。</li></ul><p><strong>运算类指令步骤三（<code>EX</code>）：进行运算，将结果存入 EX 段锁存器</strong>。</p><p><strong>运算类指令步骤四（<code>M</code>） ：对于 RISC 系统，计算结果会直接放入寄存器，所以是空段，什么事情都不用做，但要消耗相应的时间</strong>。</p><p><strong>运算类指令步骤五（<code>WB</code>）：运算结果写回指定寄存器</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161948409.png" loading="lazy"></p><h2 id="12-2-LOAD-指令执行过程"><a href="#12-2-LOAD-指令执行过程" class="headerlink" title="12.2.LOAD 指令执行过程"></a>12.2.LOAD 指令执行过程</h2><p><strong>LOAD 指令的功能是取数，会把主存或寄存器中的内容取至寄存器中，有如下两种描述方式</strong>：</p><table><thead><tr></tr></thead><tbody><tr><td>LOAD R<sub>d</sub>, 996(R<sub>s</sub>)</td><td>(996+(R<sub>s</sub>)) -&gt;R<sub>d</sub></td></tr><tr><td>LOAD R<sub>d</sub>, mem</td><td>(mem)-&gt;R<sub>d</sub></td></tr></tbody></table><p><strong>LOAD 指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p>**LOAD 指令步骤二（<code>ID</code>）：将基址寄存器的值放到锁存器 A A A、将偏移量放到 $Imm$**。</p><p><strong>LOAD 指令步骤三（<code>EX</code>）：进行运算，得到有效地址。</strong></p><p><strong>LOAD 指令步骤四（<code>M</code>） ：从数据 Cache 中取数并放入锁存器。</strong></p><p><strong>LOAD 指令步骤五（<code>WB</code>）：将取出的数写回寄存器。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161950321.png" loading="lazy"></p><h2 id="12-3-STORE-指令执行过程"><a href="#12-3-STORE-指令执行过程" class="headerlink" title="12.3.STORE 指令执行过程"></a>12.3.STORE 指令执行过程</h2><p><strong>STORE 指令的功能是存数，有如下两种描述方式</strong>：</p><table><thead><tr></tr></thead><tbody><tr><td>STORE R<sub>s</sub>, 996(R<sub>d</sub>)</td><td>R<sub>s</sub>-&gt;996+(R<sub>d</sub>))</td></tr><tr><td>STORE R<sub>s</sub>, mem</td><td>R<sub>s</sub>-&gt;(mem)</td></tr></tbody></table><p><strong>Store 指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p>**Store 指令步骤二（<code>ID</code>）：将基址寄存器的值放到锁存器 A A A、将偏移量放到 $Imm$、将要存的数放到 $B$**。</p><p><strong>Store 指令步骤三（<code>EX</code>）：进行运算，得到有效地址，并将锁存器 $B$ 的内容放到锁存器 Store。</strong></p><p><strong>Store 指令步骤四（<code>M</code>） ：写入数据 Cache</strong>。</p><p><strong>Store 指令步骤五（<code>WB</code>） ：空段。</strong></p><h2 id="12-4-条件转移指令执行过程"><a href="#12-4-条件转移指令执行过程" class="headerlink" title="12.4.条件转移指令执行过程"></a>12.4.条件转移指令执行过程</h2><p><strong>如下</strong>：</p><ul><li><strong>beq Rs,Rt, #偏移量</strong>：若 (Rs)&#x3D;&#x3D;(Rt)，则 (PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC，否则有 (PC)+ 指令字长 -&gt;PC。</li><li><strong>bne Rs,Rt, #偏移量</strong>：若 (Rs)!&#x3D;(Rt)，则 (PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC，否则有 (PC)+ 指令字长 -&gt;PC。</li></ul><p><strong>条件转移指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器。</strong></p><p>**条件转移指令步骤二（<code>ID</code>）：进行比较的两个数放入锁存器 $A$和 $B$、偏移量放入 $Imm$**。</p><p><strong>条件转移指令步骤三（<code>EX</code>）：进行运算，比较两个数。</strong></p><p><strong>条件转移指令步骤四（<code>M</code>） ：将目标 PC 值写回 PC。</strong></p><p><strong><del>条件转移指令步骤五</del>（<code>WB</code>） ：空段</strong>。</p><h2 id="12-5-无条件转移指令执行过程"><a href="#12-5-无条件转移指令执行过程" class="headerlink" title="12.5.无条件转移指令执行过程"></a>12.5.无条件转移指令执行过程</h2><p><strong>如下</strong>：</p><ul><li><strong>jmp #偏移量</strong>：(PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC。</li></ul><p><strong>无条件转移指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p>**无条件转移指令步骤二（<code>ID</code>）：偏移量放入 $Imm$**。</p><p><strong>无条件转移指令步骤三（<code>EX</code>）：将目标 PC 值写回 PC。</strong></p><p><strong>无条件转移指令步骤四（<code>M</code>） ：空段。</strong></p><p><strong>无条件转移指令步骤五（<code>WB</code>） ：空段</strong>。</p><h1 id="13-多处理器基本概念"><a href="#13-多处理器基本概念" class="headerlink" title="13.多处理器基本概念"></a>13.多处理器基本概念</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162004915.jpg" alt="第5章 中央处理器" loading="lazy"></p><h2 id="13-1-SISD、SIMD、MIMD-基本概念"><a href="#13-1-SISD、SIMD、MIMD-基本概念" class="headerlink" title="13.1.SISD、SIMD、MIMD 基本概念"></a>13.1.SISD、SIMD、MIMD 基本概念</h2><p><strong>计算机体系结构分类：基于指令流的数量和数据流的数量，可以将计算机体系结构分为如下 4 类</strong>：</p><ul><li><strong>单指令单数据流 SISD</strong></li><li><strong>单指令多数据流 SIMD</strong></li><li><strong>多指令单数据流 MISD</strong></li><li><strong>多指令多数据流 MIMD</strong></li></ul><h3 id="13-1-1-单指令单数据流-SISD"><a href="#13-1-1-单指令单数据流-SISD" class="headerlink" title="13.1.1.单指令单数据流 SISD"></a>13.1.1.单指令单数据流 SISD</h3><p><strong>单指令单数据流 SISD：常规的单处理器便是 SISD，其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：①各指令序列<strong>只能并发而不能并行</strong>；②每条指令<strong>处理一两个数据</strong>；③不是<strong>数据级并行技术</strong>。</li><li><strong>硬件组成</strong>：①一个<strong>处理器</strong> + 一个<strong>主存储器</strong>；②若采用指令流水线，则<strong>需要设置多个功能部件，采用多模块交叉存储器</strong>。</li></ul><p>《<a href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86&spm=1001.2101.3001.7020">计算机组成原理</a>》这门课程一直研究的便是 SISD。如下，<strong>此 CPU 在同一时间段内仅能处理一个进程或线程的一个指令序列，每条指令只能处理一两个数据。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955615.png" alt="image-20230416195506504" loading="lazy"></p><h3 id="13-1-2-单指令多数据流-SIMD"><a href="#13-1-2-单指令多数据流-SIMD" class="headerlink" title="13.1.2.单指令多数据流 SIMD"></a>13.1.2.单指令多数据流 SIMD</h3><p><strong>单指令多数据流 SIMD：其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：①各指令序列<strong>只能并发而不能并行</strong>；②每条指令<strong>可以同时处理多个具有相同特征的数据</strong>；③是<strong>数据级并行技术</strong>。</li><li><strong>硬件组成</strong>：①一个<strong>指令控制部件</strong> + 多个<strong>处理单元 &#x2F; 执行单元</strong> + 一个<strong>主存储器</strong>；②每个执行单元有<strong>各自的寄存器组、局部存储器、地址寄存器</strong>；③不同执行单元<strong>执行同一条指令、处理不同的数据。</strong></li></ul><p>如下，在 SIMD 系统中，<strong>CU 每次会取出一条指令，根据此指令发出控制信号给各个执行部件（如 ALU），每个执行部件都有各自的寄存器（组）。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955174.png" alt="image-20230416195538067" loading="lazy"></p><p><strong>SIMD 系统善于对结构类似的大量数据做相同处理，例如</strong>：</p><ul><li>图像处理时，对每个像素点作 “高斯模糊”。</li><li>可用于优化 for 循环中对数组元素的重复处理。</li></ul><h3 id="13-1-3-多指令单数据流-MISD"><a href="#13-1-3-多指令单数据流-MISD" class="headerlink" title="13.1.3.多指令单数据流 MISD"></a>13.1.3.多指令单数据流 MISD</h3><p><strong>多指令单数据流 MISD：多条指令并行执行，处理同一个数据。现实中并不存在这种计算机。</strong></p><h3 id="13-1-4-多指令多数据流-MIMD"><a href="#13-1-4-多指令多数据流-MIMD" class="headerlink" title="13.1.4.多指令多数据流 MIMD"></a>13.1.4.<strong>多指令多数据流 MIMD</strong></h3><p><strong>多指令多数据流 MIMD：常规的多处理器便是 MIMD，其特性如下</strong>：</p><ul><li>各指令序列<strong>并行执行，分别处理多个不同的数据</strong>。</li><li>是一种<strong>线程级并行技术</strong>（甚至是线程级以上）。</li></ul><p><strong>MIMD 可以进一步分为：</strong></p><ul><li>多处理器系统</li><li>多计算机系统</li></ul><h4 id="13-1-4-1-多处理器系统"><a href="#13-1-4-1-多处理器系统" class="headerlink" title="13.1.4.1.多处理器系统"></a>13.1.4.1.多处理器系统</h4><p><strong>多处理器系统：是共享内存多处理器（SMP）的简称。其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：各处理器之间，可以通过 LOAD&#x2F;STORE 指令访问<strong>同一个主存储器</strong>，可以通过<strong>主存相互传送数据</strong>。</li><li><strong>硬件组成</strong>：①一台计算机内，有多个<strong>处理器</strong> + 一个<strong>主存储器</strong>；②多个处理器<strong>共享单一的物理地址空间。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161956973.png" alt="image-20230416195608820" loading="lazy"></p><h4 id="13-1-4-2-多计算机系统"><a href="#13-1-4-2-多计算机系统" class="headerlink" title="13.1.4.2.多计算机系统"></a>13.1.4.2.多计算机系统</h4><p><strong>多计算机系统：其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：各计算机之间，<strong>不可以通过 LOAD&#x2F;STORE 指令直接访问对方的存储器</strong>，只能通过<strong>消息传递相互传送数据</strong>。</li><li><strong>硬件组成</strong>：①由多台计算机组成，所以有多个<strong>处理器</strong> + 多个<strong>主存储器</strong>；②每台计算机拥有<strong>各自的私有存储器</strong>，物理地址空间<strong>相互独立。</strong></li></ul><p>实际应用中，可以把单个任务拆分为多个任务，分别指派给不同的计算机执行。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161957622.png" alt="image-20230416195712433" loading="lazy"></p><h2 id="13-2-向量处理器"><a href="#13-2-向量处理器" class="headerlink" title="13.2.向量处理器"></a>13.2.向量处理器</h2><p>向量处理机的LOAD指令，可以将一个向量取到向量寄存器中；加法指令，可以实现两个向量相加应用于：向量计算、大量浮点数计算，空气动力学、核物理学、巨型矩阵计算问题很多超级计算机如中国的“银河”就是向量处理器。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161959391.png" alt="image-20230416195929243" loading="lazy"></p><h1 id="14-硬件多线程的基本概念"><a href="#14-硬件多线程的基本概念" class="headerlink" title="14.硬件多线程的基本概念"></a>14.硬件多线程的基本概念</h1><p><strong>硬件多线程：在 <a href="">(王道 408 考研操作系统) 第二章进程管理 - 线程概念和多线程模型</a>这一节中我们说到了线程的一些缺点。线程粒度较进程来讲更细，而且线程切换包含很多开销，频繁切换线程必然会影响系统性能，所以为了减少开销便诞生了硬件多线程。在支持硬件多线程的 CPU 中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。共有如下 3 种实现方式</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162011405.png" alt="image-20230416201131263" loading="lazy"></p><p><strong>如下</strong>：</p><ul><li>对于<strong>不支持硬件多线程的 CPU</strong>：同一时刻只能有一个线程运行，线程切换时需要保护现场，产生额外开销。</li><li>对于<strong>支持硬件多线程的 CPU</strong>：不同线程运行在不同环境中。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012378.png" alt="image-20230416201232259" loading="lazy"></p><h2 id="14-1-细粒度多线程"><a href="#14-1-细粒度多线程" class="headerlink" title="14.1.细粒度多线程"></a>14.1.细粒度多线程</h2><p><strong>细粒度多线程：关键特征如下</strong>：</p><ul><li><strong>指令发射：轮流发射各线程的指令（每个时钟周期发射一个线程）</strong>。</li><li><strong>线程切换频率：每个时钟周期切换一次线程。</strong></li><li><strong>线程切换代价：低。</strong></li><li><strong>并行性：指令级并行、线程间不并行</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012684.png" alt="image-20230416201249567" loading="lazy"></p><h2 id="14-2-粗粒度多线程"><a href="#14-2-粗粒度多线程" class="headerlink" title="14.2.粗粒度多线程"></a>14.2.粗粒度多线程</h2><p><strong>粗粒度多线程：关键特征如下</strong>：</p><ul><li><strong>指令发射：连续几个时钟周期，都发射同一线程的指令序列。流水线阻塞时，才切换另一个线程</strong>。</li><li><strong>线程切换频率：只有流水线阻塞时才切换另一个线程。</strong></li><li><strong>线程切换代价：高（需要重载流水线）。</strong></li><li><strong>并行性：指令级并行、线程间不并行。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013395.png" alt="image-20230416201302277" loading="lazy"></p><h2 id="14-3-同时多线程"><a href="#14-3-同时多线程" class="headerlink" title="14.3.同时多线程"></a>14.3.同时多线程</h2><p><strong>同时多线程：关键特征如下</strong>：</p><ul><li><strong>指令发射：一个时钟周期内同时发射多个线程的指令</strong>。</li><li><strong>线程切换频率：NULL。</strong></li><li><strong>线程切换代价：NULL</strong>。</li><li><strong>并行性：指令级并行、线程级并行。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013448.png" alt="image-20230416201314329" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-CPU的基本功能和结构&quot;&gt;&lt;a href=&quot;#1-CPU的基本功能和结构&quot; class=&quot;headerlink&quot; title=&quot;1.CPU的基本功能和结构&quot;&gt;&lt;/a&gt;1.CPU的基本功能和结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.gith</summary>
      
    
    
    
    <category term="考研408" scheme="http://ccsu.top/categories/%E8%80%83%E7%A0%94408/"/>
    
    
    <category term="计算机组成原理" scheme="http://ccsu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="考研" scheme="http://ccsu.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>机组-第四章 指令系统</title>
    <link href="http://ccsu.top/posts/de459af/"/>
    <id>http://ccsu.top/posts/de459af/</id>
    <published>2023-04-07T16:00:00.000Z</published>
    <updated>2023-04-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-指令和指令格式"><a href="#1-指令和指令格式" class="headerlink" title="1.指令和指令格式"></a>1.指令和指令格式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152005362.png" alt="image-20230415200545273" loading="lazy"></p><h2 id="1-1-指令的概念及构成"><a href="#1-1-指令的概念及构成" class="headerlink" title="1.1.指令的概念及构成"></a>1.1.指令的概念及构成</h2><p><strong>指令（机器指令）：指示计算机执行某种操作的命令，是计算机运行的最小功能单位</strong>。</p><ul><li><p>指令集（指令系统）：一台计算机的所有指令的集合。</p></li><li><p><strong>注意</strong>：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。例如 X86 和 ARM。</p></li></ul><p><strong>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。指令通常包括操作码字段和地址码字段两个部分</strong>：</p><ul><li><p><strong>操作码：指明了该指令是一个什么类型的指令，也即它具有怎样的功能。它是识别指令，了解指令功能及操作数地址的关键信息</strong>。比如：操作码可以指出该操作是 “算数加” 还是 “算数减” 运算，是 “程序转移” 还是 “返回操作” 等等。</p></li><li><p><strong>地址码</strong>：<strong>给出了被操作的信息（指令或数据）的地址。</strong> 比如：“参与运算的一个和多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址” 等等  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151952547.png" alt="image-20230415195203431" loading="lazy"></p></li></ul><h2 id="1-2-指令字长、机器字长和存储字长"><a href="#1-2-指令字长、机器字长和存储字长" class="headerlink" title="1.2.指令字长、机器字长和存储字长"></a>1.2.指令字长、机器字长和存储字长</h2><ul><li><strong>指令字长</strong>：一条指令的<strong>总长度</strong>（可能会变），也即<strong>一条指令中所包含的二进制代码的位数</strong>，它取决于<strong>操作码的长度、操作数地址码的长度和操作数地址的个数</strong>。</li><li><strong>机器字长</strong>：CPU 进行<strong>一次运算所能处理的二进制数据的位数</strong>（通常和 ALU 直接相关）。</li><li><strong>存储字长</strong>：一个<strong>存储单元</strong>中的二进制代码位数（通常和 MDR 位数相同）。</li></ul><p><strong>注意</strong>：指令字长与机器字长<strong>没有固定的关系</strong>，它可以等于机器字长，也可以大于或小于。<strong>通常，把指令字长等于机器字长的指令称为单字长指令</strong>，相应地还有<strong>半字长指令、双字长指令</strong>。指令字长会影响取指令所需时间，例如，当机器字长 &#x3D; 存储字长 &#x3D; 16bit，则取一条双字长指令就需要两次访存操作。</p><h2 id="1-3-定长指令字和变长指令字"><a href="#1-3-定长指令字和变长指令字" class="headerlink" title="1.3.定长指令字和变长指令字"></a>1.3.定长指令字和变长指令字</h2><p><strong>定长指令字结构</strong>：在一个指令系统中，如果<strong>所有指令的长度都是相等的</strong>，则称为定长指令字结构。具有定长指令字结构的指令其<strong>执行速度快，控制简单。</strong></p><p><strong>变长指令字结构</strong>：各种指令的长度<strong>随指令功能而不同</strong>。由于主存一般是按字节编址的，所以指令字长多为<strong>字节的整数倍。</strong></p><h1 id="2-指令的分类"><a href="#2-指令的分类" class="headerlink" title="2.指令的分类"></a>2.指令的分类</h1><h2 id="2-1-按操作数地址码的数目不同进行分类"><a href="#2-1-按操作数地址码的数目不同进行分类" class="headerlink" title="2.1.按操作数地址码的数目不同进行分类"></a>2.1.按操作数地址码的数目不同进行分类</h2><h3 id="2-1-1-零地址指令"><a href="#2-1-1-零地址指令" class="headerlink" title="2.1.1.零地址指令"></a>2.1.1.零地址指令</h3><p><strong>零地址指令：它只给出了操作码 OP，没有给出显式地址，有以下两种情况</strong>：</p><ul><li><strong>该指令本身就不需要操作数</strong>：比如<strong>空操作</strong>、<strong>停机</strong>、<strong>关中断</strong>等等。</li><li><strong>零地址的运算类指令它仅仅会用于堆栈计算机中</strong>：通常参与运算的两个操作<strong>隐含地从栈顶和次栈顶弹出</strong>，送到运算器进行运算，运算结果再隐含地压入堆栈。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151954484.png" loading="lazy"></p><p>对于第二种情况，最为经典的例子就是后缀表达式的计算，扫描后缀表达式时遇到操作数就会压栈，遇到运算符就会取操作数再运算，结果仍会压入栈中  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955003.png" alt="image-20230415195551908" loading="lazy"></p><h3 id="2-1-2-一地址指令"><a href="#2-1-2-一地址指令" class="headerlink" title="2.1.2.一地址指令"></a>2.1.2.一地址指令</h3><p><strong>一地址指令：一地址指令有两种常见的形态，需要根据操作的含义确定究竟属于哪一种</strong>：</p><ul><li>**只有目的操作数：根据地址 $A_{1} $读取操作数，进行 $OP $操作后，结果存回原地址，也即 $OP(A_{1}) $-&gt; $A_{1} $**。比如常见的 “加 1、减 1、求反、求补” 等操作。完成一条指令需要3次访存：取指→读A1→写A1。</li><li><strong>需要两个操作数，但其中一个操作数隐含在某个寄存器中，比如 ACC：也即 $ (ACC)OP(A_{1})-&gt;A_{1} $，其中 $A_{1} $指某个主存地址， $ (A_{1}) $ 表示地址中的内容，可以类比 C 语言中的指针理解</strong>。完成一条指令需要2次访存：取指→读A1。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955085.png" loading="lazy"></p><h3 id="2-1-3-二、三地址指令"><a href="#2-1-3-二、三地址指令" class="headerlink" title="2.1.3.二、三地址指令"></a>2.1.3.二、三地址指令</h3><p>**二地址指令：二地址指令往往就是常见的算数和逻辑运算，它们需要使用两个操作数，也即目的操作数和。地址中会给出目的操作数和源操作数的地址，其中目的操作数地址还可用于保存本次运算的结果，也即$(A_{1})OP(A_{2}) $-&gt; $A_{1} $**。完成一条指令需要访存4次，取指→读A1→读A2→写A1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956996.png" loading="lazy"></p><p><strong>三地址指令：相比二地址指令，三地址指令需要新的地址来存储运算结果，也即 $ (A_{1})OP(A_{2}) $-&gt; $A_{3} $</strong>  。完成一条指令需要访存4次，取指→读A1→读A2→写A3。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956072.png" loading="lazy"></p><h3 id="2-1-4-四地址指令"><a href="#2-1-4-四地址指令" class="headerlink" title="2.1.4.四地址指令"></a>2.1.4.四地址指令</h3><p>**四地址指令：相比三地址指令，多了一个用于指明下一条指令地址的功能。这样就实现了指令的跳转功能（如果没有跳转，指令将会正常 + 1），也即$ (A_{1})OP(A_{2})- &gt; A_{3} $， $A_{4}&#x3D; 下一条指令的地址$**。完成一条指令需要访存4次，取指→读A1→读A2→写A3。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152001244.png" loading="lazy"></p><h2 id="2-2-按操作码长度分类"><a href="#2-2-按操作码长度分类" class="headerlink" title="2.2.按操作码长度分类"></a>2.2.按操作码长度分类</h2><p><strong>定长操作码：</strong>在指令字的最高位部分分配固定的若干位（定长）表示操作码。指令系统中<strong>所有指令的操作码长度都相同</strong>，有 $n $ 位就有 $2^{n} $条指令。定长操作码的控制器译码电路<strong>设计简单，但是灵活较差</strong>。</p><ul><li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。</li><li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</li></ul><p><strong>扩展操作码（不定长操作码）：</strong>全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。指令系统中<strong>各指令的操作码长度可变</strong>。可变长操作码控制器译码电路<strong>设计复杂，但灵活性很高</strong>。</p><ul><li>优：在指令字长有限的前提下仍保持比较丰富的指令种类。</li><li>缺：增加了指令译码和分析的难度，使控制器的设计复杂化。</li></ul><h2 id="2-3-按操作类型分类"><a href="#2-3-按操作类型分类" class="headerlink" title="2.3.按操作类型分类"></a>2.3.按操作类型分类</h2><p><strong>数据传送（进行主存与CPU之间的数据传送）</strong></p><ul><li><strong><code>LOAD</code>作用</strong>：把存储器中的数据放到寄存器。</li><li><strong><code>STORE</code>作用</strong>：把寄存器中的数据放到存储器。</li></ul><p><strong>算数逻辑操作（运算类）</strong></p><ul><li><strong>算数</strong>：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算等。</li><li><strong>逻辑</strong>：与、或、非、异或、位操作、位测试、位清除、位求反。</li></ul><p><strong>移位操作（运算类）</strong></p><ul><li>算数移位、逻辑移位、循环移位。</li></ul><p><strong>转移操作（程序控制类：改变程序执行的顺序）</strong></p><ul><li>无条件转移<code>JMP</code></li><li>条件转移（<code>JZ</code>: 结果为 0；<code>JP</code>：结果溢出；<code>JC</code>：结果有进位）。</li><li>调用和返回<code>CALL</code>及<code>RETURN。</code></li><li>陷阱（<code>Trap</code>）与陷阱指令。</li></ul><p><strong>输入和输出操作（输入输出类（I&#x2F;0）：进行CPU和I&#x2F;0设备之间的数据传送）</strong></p><ul><li>CPU 寄存器与 IP 端口之间的数据传送（端口即 IO 接口中的寄存器）。</li></ul><h1 id="3-扩展操作码指令格式"><a href="#3-扩展操作码指令格式" class="headerlink" title="3.扩展操作码指令格式"></a>3.扩展操作码指令格式</h1><h2 id="3-1-重述几个概念"><a href="#3-1-重述几个概念" class="headerlink" title="3.1.重述几个概念"></a>3.1.重述几个概念</h2><p><strong>指令格式：有两部分构成</strong>：</p><ul><li><strong>操作码</strong>。</li><li><strong>地址码。</strong></li></ul><p><strong>根据指令字长是否固定对指令分类：</strong></p><ul><li><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等。</li><li><strong>变长指令字结构</strong>：指令系统中各种指令的长度不固定。</li></ul><p><strong>根据操作码字段长度是否固定对指令分类：</strong></p><ul><li><strong>定长操作码</strong>：指令系统中所有指令的操作码长度都固定且相同。</li><li><strong>变长操作码</strong>：指令系统中各指令的操作码长度不固定。</li></ul><p><strong>所以这里会有以下四种类型：</strong></p><ul><li><strong>定长指令字定长操作码</strong>。</li><li><strong>定长指令字变长操作码：本节扩展操作码基于此类进行，也就是说不同地址数的指令会使用不同长度的操作码。</strong></li><li><strong>变长指令字定长操作码</strong>。</li><li><strong>变长指令字变长操作码。</strong></li></ul><h2 id="3-2-为什么要扩展操作码"><a href="#3-2-为什么要扩展操作码" class="headerlink" title="3.2.为什么要扩展操作码"></a>3.2.为什么要扩展操作码</h2><p>**如下图，假设指令字长为 16 位，其中前 4 位为操作码字段 $ OP $，另外有 3 个 4 位的地址字段 $A_{1} $、 $A_{2} $和 $ A_{3} $**。</p><p>如果 4 位操作码全部用于三地址指令，由于 $2^{4}&#x3D;16 $，所以该结构<strong>仅能表示 16 条指令</strong>。但这种方式是不合理的，因为所能表示的<strong>指令数是在是太少了</strong>。所以我们要做适当的处理，<strong>使其虽然不能涵盖全部的三地址指令，但是我能在牺牲有限条三地址指令的情况下向下扩展出更多的二地址、一地址、零地址指令，这样一来，所能表示的指令数目将会大大增大</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152009401.png" loading="lazy"></p><h2 id="3-3-扩展操作码方法"><a href="#3-3-扩展操作码方法" class="headerlink" title="3.3.扩展操作码方法"></a>3.3.扩展操作码方法</h2><h3 id="3-3-1-最常用方法"><a href="#3-3-1-最常用方法" class="headerlink" title="3.3.1.最常用方法"></a>3.3.1.最常用方法</h3><ul><li>以上图为例。</li></ul><p><strong>扩展二地址指令：</strong></p><ul><li><strong>三地址指令操作码范围为</strong><code>0000</code>~&#96;1111。&#96;</li><li>将<code>1111</code>留作扩展码，也即<code>1111</code>开头的指令不再代表三地址指令，此时三地址指令<strong>变更为 15 条</strong>，<strong>操作码范围为<code>0000</code>~&#96;1110。&#96;</strong></li><li>于是，二地址指令操作码将会以<code>1111</code>开头。</li><li><strong>实际上，CPU 在取得一条指令时，一定是直接读入 16 位，所以只需要根据所读入的是否为<code>1111</code>即可判断它是三地址还是二地址指令。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010007.png" loading="lazy"></p><p><strong>扩展一地址指令：</strong></p><ul><li><strong>此时二地址指令操作码范围为<code>1111</code> <code>0000</code>~&#96;1111<code> </code>1111。&#96;</strong></li><li>将<code>1111</code> <code>1111</code>留作扩展码，也即<code>1111</code> <code>1111</code>开头的指令不再代表二地址指令，<strong>此时二地址指令变更为 15 条，操作码范围<code>1111</code> <code>0000</code>~&#96;1111<code> </code>1110。&#96;</strong></li><li>于是，一地址指令操作码将会以<code>1111</code> <code>1111</code>开头。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010438.png" loading="lazy"></p><p><strong>扩展零地址指令：</strong></p><ul><li><p>**此时二地址指令操作码范围为<code>1111</code> <code>1111</code> <code>0000</code> ~&#96;1111<code> </code>1111<code> </code>1111&#96;**。</p></li><li><p>将<code>1111</code> <code>1111</code> <code>1111</code>留作扩展码，也即<code>1111</code> <code>1111</code> <code>1111</code>开头的指令不再代表一地址指令，<strong>此时一地址指令变更为 15 条，操作码范围为<code>1111</code> <code>1111</code> <code>0000</code> ~&#96;1111<code> </code>1111<code> </code>1110。&#96;</strong></p></li><li><p>于是，零地址指令操作码将会以<code>1111</code> <code>1111</code> <code>1111</code>开头。</p></li><li><p>由于<strong>零地址指令不需要再向后扩展</strong>，所以是 16 条，范围为<code>1111</code> <code>1111</code> <code>1111</code> <code>0000</code> ~ <code>1111</code> <code>1111</code> <code>1111</code> <code>1111。</code></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010492.png" loading="lazy"></p><p><strong>总之，在整个扩展过程中，操作码的位数会随着地址码位数的减少而增加。相比于之前的 16 条三地址指令。经过扩展，仅损失了一个三地址指令，却增加了 15 条二地址指令、15 条一地址指令和 16 条零地址指令，这是很划算的。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152029832.png" alt="image-20230415202944745" loading="lazy"></p><h3 id="3-3-2-其他方法"><a href="#3-3-2-其他方法" class="headerlink" title="3.3.2.其他方法"></a>3.3.2.其他方法</h3><p><strong>上面展示的是扩展操作码比较常用的一种方法，还有很多种设计方案。不过，不论使用哪种方法，在设计时一定要注意以下几点</strong>：</p><ul><li><strong>不允许短码是长码的前缀，也即短操作码不能与长操作码的前面部分相同</strong>：这一点，类似于<strong>哈夫曼树的前缀编码</strong>，比如<code>0011</code>和<code>0011</code> <code>0000</code>，如果这样设计就会产生歧义。</li><li><strong>各指令操作码不能重复。</strong></li></ul><p>通常情况下，<strong>对于使用频率较高的指令，分配较短的操作码；对使用频率较低的指令则分配较长的操作码</strong>，从而尽可能减少指令译码和分析的时间。</p><ul><li>这一点其实可通过哈夫曼树看出。</li></ul><h2 id="3-4-经典例题"><a href="#3-4-经典例题" class="headerlink" title="3.4.经典例题"></a>3.4.经典例题</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152030447.png" loading="lazy">  </p><p>设地址长度为 $n $，上一层留出 $m$种状态，则下一层可以扩展出 $ m×2^{n} $种状态。</p><h1 id="4-指令寻址"><a href="#4-指令寻址" class="headerlink" title="4.指令寻址"></a>4.指令寻址</h1><ul><li><p><strong>指令寻址</strong>：下一条欲执行指令的地址会由<strong>程序计数器 $PC $ <strong>给出，分为</strong>顺序寻址</strong>和<strong>跳跃寻址。</strong></p></li><li><p><strong>数据寻址</strong>：执行一条指令时，<strong>将地址码当作形式地址码，需要对其按照一定规则进行解释翻译，才能得到真实的地址</strong>。当按不同方式进行解释时，就会形成不同的数据寻址方式，共有十种。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png" alt="image-20230415205156229" loading="lazy"></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152049452.png" alt="image-20230415204957355" loading="lazy"></p><h2 id="4-1-什么是指令寻址"><a href="#4-1-什么是指令寻址" class="headerlink" title="4.1.什么是指令寻址"></a>4.1.什么是指令寻址</h2><ul><li>程序运行实则就是指令执行，<strong>指令可以顺序执行也可以跳跃执行</strong>，这就涉及到指令寻址的问题了。</li></ul><p><strong>指令寻址：我们编写的程序最终会被翻译等价的机器指令，指令和数据无差别地存放在主存当中。CPU 中有一个很重要的寄存器——程序计数器 PC（Program-Counter），它指明了下一条指令的存放地址，CPU 在执行完一条指令后会让程序计数器自动 + 1。</strong></p><ul><li><strong>注意</strong>：这里的 “+1” 不是简单的 + 1，下面会在顺序寻址中说明。</li></ul><p><strong>指令寻址有两类</strong>：</p><ul><li><p>顺序寻址。</p></li><li><p>跳跃寻址  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152039616.png" alt="image-20230415203927527" loading="lazy"></p></li></ul><h2 id="4-1-两类指令寻址"><a href="#4-1-两类指令寻址" class="headerlink" title="4.1.两类指令寻址"></a>4.1.两类指令寻址</h2><h3 id="4-1-2-顺序寻址"><a href="#4-1-2-顺序寻址" class="headerlink" title="4.1.2.顺序寻址"></a>4.1.2.顺序寻址</h3><p><strong>顺序寻址：顺序寻址可以简单的理解为：(PC)+“1”-&gt;PC，但是这里的 “1” 要理解为一个指令字长，要视具体的指令长度、编址方式的不同而定</strong>。</p><p><strong>只有在系统采用定长指令字结构，并且指令字长 &#x3D; 存储字长 &#x3D; 16bit&#x3D;2B，且主存按字编址时，PC 才能简单的 + 1。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152041940.png" alt="image-20230415204101855" loading="lazy"></p><p><strong>其余条件不变，如果主存按字节编址，即每一条指令会占两个地址，此时 PC 要 + 2</strong> 。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152043693.png" alt="image-20230415204343610" loading="lazy"></p><p><strong>如果采用变长指令字结构同时按字节编址，此时不同指令的字长是不一样的。由于 CPU 无法确定当前指向的指令占多少存储字，此时 CPU 可以先读入一个字，操作码一定会包含在其中，因此可以通过操作码来判断这是一个几地址的指令，就可以确定这条指令具体占的字节数 n，接着 PC+n 即可。</strong></p><ul><li><p>下图中相同颜色表示一条指令。</p></li><li><p><strong>注意</strong>：在这种方式下，由于 CPU 无法预先知道总字节数，所以可能会进行多次访存，每次读入一个字，对于一条指令可能要读多次才能读干净  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152044979.png" alt="image-20230415204409893" loading="lazy"></p></li></ul><h3 id="4-1-2-跳跃寻址"><a href="#4-1-2-跳跃寻址" class="headerlink" title="4.1.2.跳跃寻址"></a>4.1.2.跳跃寻址</h3><p><strong>跳跃寻址：所谓跳跃，是指下一条指令的地址码不再由程序计数器给出，而由本条指令给出下一条指令地址的计算方式。跳跃寻址通过转移类指令实现</strong>。</p><ul><li>无条件转移<code>JMP。</code></li><li>条件转移（<code>JZ</code>: 结果为 0；<code>JP</code>：结果溢出；<code>JC</code>：结果有进位）。</li><li>调用和返回<code>CALL</code>及<code>RETURN。</code></li><li>陷阱（<code>Trap</code>）与陷阱指令。</li></ul><p>如下，CPU 正常执行指令，<strong>在遇到无条件转移指令<code>JMP</code>时会把 PC 中的内容强制改为 7</strong>，意味着下次执行要从 7 的位置开始执行，这有点类似<code>goto</code> 语句。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152045696.png" alt="image-20230415204503605" loading="lazy"></p><h1 id="5-数据寻址"><a href="#5-数据寻址" class="headerlink" title="5.数据寻址"></a>5.数据寻址</h1><ul><li><p><strong>指令寻址</strong>：下一条欲执行指令的地址会由<strong>程序计数器 $PC $ <strong>给出，分为</strong>顺序寻址</strong>和<strong>跳跃寻址。</strong></p></li><li><p><strong>数据寻址</strong>：执行一条指令时，<strong>将地址码当作形式地址码，需要对其按照一定规则进行解释翻译，才能得到真实的地址</strong>。当按不同方式进行解释时，就会形成不同的数据寻址方式，共有十种。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png" loading="lazy"></p></li></ul><h2 id="5-1-什么是数据寻址"><a href="#5-1-什么是数据寻址" class="headerlink" title="5.1.什么是数据寻址"></a>5.1.什么是数据寻址</h2><h3 id="5-1-1-理解什么是数据寻址"><a href="#5-1-1-理解什么是数据寻址" class="headerlink" title="5.1.1.理解什么是数据寻址"></a>5.1.1.理解什么是数据寻址</h3><p><strong>数据寻址：借用上一节文章中最后一个例子，该程序是从主存地址为 0 的单元开始向后存储的，执行到<code>JMP</code>指令后会把 PC 改为 7，所以接下来会直接跳转到 7 这个地方，因此这里的 7 就是真实的地址，没有歧义。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053245.png" alt="image-20230415205335170" loading="lazy"></p><p><strong>但在实际情况中，几乎不可能保证当前运行的程序恰好就从主存位置为 0 的地方开始存储。比如下面，该程序是从主存位置为 100 的单元向后存储的。在这种情况下，如果<code>JMP</code>依旧采用之前的方式去理解，那么在 103 执行完毕之后，它仍然会跳转到 7 这个位置</strong>。</p><p><strong>这显然是不合理的，因为 7 的位置是一个未知区域，甚至有可能是别的程序正在使用的区域，这就属于非法越界了</strong>。<strong>因此这里的 7 则可以解释为基于程序开始位置 100 的偏移量，也即 107</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152054671.png" alt="image-20230415205420595" loading="lazy"></p><p>当然还有其它解释方式，例如下图可以解释为：<strong>JMP 执行完成之后 PC 会自动 + 1，然后从 PC 所指向的位置向后偏移 3 个单位开始执行</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152223607.png" alt="image-20230415222358516" loading="lazy"></p><h3 id="5-1-2-数据寻址分类"><a href="#5-1-2-数据寻址分类" class="headerlink" title="5.1.2.数据寻址分类"></a>5.1.2.数据寻址分类</h3><p><strong>可以发现，不同的解读方式下地址码会有不同的含义，也就会产生不同的寻址方式。所以，我们会在地址码的前边新加入寻址方式位（寻址特征）来标识该指令的地址会采用何种方式来解释（或寻址）。主要会有以下十种寻址方式。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152055941.png" loading="lazy"></p><h3 id="5-1-3-数据寻址指令格式"><a href="#5-1-3-数据寻址指令格式" class="headerlink" title="5.1.3.数据寻址指令格式"></a>5.1.3.数据寻址指令格式</h3><p><strong>共有十种寻址方式，所以寻址方式位（寻址特征）需要 4 个比特位。总之，根据寻址方式位（寻址特征）可以确定形式地址$ (A)$采用怎样的方式解读，得到相应的真实地址（称为有效地址 $ (EA) $）。</strong></p><ul><li><strong>注意</strong>：n 地址指令需要 n 个寻址特征。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053399.png" alt="image-20230415205302318" loading="lazy"></p><p><strong>在下面的介绍中，假设指令字长 &#x3D; 机器字长 &#x3D; 存储字长，且操作数为 3。</strong></p><h2 id="5-2-第一类数据寻址（将形式地址按照某种规则解释）"><a href="#5-2-第一类数据寻址（将形式地址按照某种规则解释）" class="headerlink" title="5.2.第一类数据寻址（将形式地址按照某种规则解释）"></a>5.2.第一类数据寻址（将形式地址按照某种规则解释）</h2><h3 id="5-2-1-直接寻址"><a href="#5-2-1-直接寻址" class="headerlink" title="5.2.1.直接寻址"></a>5.2.1.直接寻址</h3><p><strong>直接寻址：指令字中的形式地址 A 就是操作数的真实地址，即 EA&#x3D;A</strong>。</p><ul><li><p><strong>访存次数</strong>：取指令的 1 次 + 执行指令的 1 次 &#x3D;<strong>2 次</strong>（暂不考虑存结果）。</p></li><li><p><strong>优点：</strong> <strong>简单</strong>，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。</p></li><li><p><strong>缺点：</strong> A 的位数决定了该指令操作数的<strong>寻址范围</strong>，且操作数的地址<strong>不易修改</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152056041.png" alt="image-20230415205648964" loading="lazy"></p></li><li><p>上图是一个取数指令。</p></li></ul><h3 id="5-2-2-间接寻址"><a href="#5-2-2-间接寻址" class="headerlink" title="5.2.2.间接寻址"></a>5.2.2.间接寻址</h3><p>**间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数的有效地址所在存储单元的地址，也就是操作数地址的地址，即 EA&#x3D;(A)**。</p><ul><li><strong>访存次数</strong>：取指令的 1 次 + 执行指令的 2 次 &#x3D;<strong>3 次</strong>（暂不考虑存结果）。</li><li><strong>优点</strong>：可以<strong>扩大寻址范围</strong>（有效地址 EA 的位数大于形式地址 A 的位数）；便于<strong>编写程序</strong>（间接寻址方式可以很方便地完成子程序返回）。</li><li><strong>缺点：</strong>：指令在执行阶段要<strong>多次访存</strong>（一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存）。</li></ul><p>下图一次间接寻址：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057481.png" alt="image-20230415205716403" loading="lazy"></p><p>下图两次间接寻址 ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057887.png" alt="image-20230415205724809" loading="lazy"></p><h3 id="5-2-3-寄存器寻址"><a href="#5-2-3-寄存器寻址" class="headerlink" title="5.2.3.寄存器寻址"></a>5.2.3.寄存器寻址</h3><p><strong>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 EA&#x3D;Rs，所其操作数就在由 Rs 所指的寄存器内存放</strong>。</p><ul><li><strong>访存次数</strong>：取指令 1 次 + 执行指令 0 次 &#x3D;<strong>1 次</strong>（暂不考虑存结果）。</li><li><strong>优点</strong>：指令在执行阶段<strong>不访问主存</strong>，只访问寄存器；指令字段且执行<strong>速度快</strong>，支<strong>持向量 &#x2F; 矩阵</strong>运算。</li><li><strong>缺点</strong>：寄存器<strong>价格昂贵</strong>，<strong>个数有限。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057215.png" alt="image-20230415205755139" loading="lazy"></p><h3 id="5-2-4-寄存器间接寻址"><a href="#5-2-4-寄存器间接寻址" class="headerlink" title="5.2.4.寄存器间接寻址"></a>5.2.4.寄存器间接寻址</h3><p><strong>寄存器间接寻址：寄存器 Ri 中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA&#x3D;（R）。</strong></p><p><strong>访存次数：</strong> 取指令 1 次 + 执行指令 1 次 &#x3D;<strong>2 次</strong>（暂不考虑存结果）  。<br><strong>特点：</strong> 与一般间接寻址方式相比速度更快，但指令的执行阶段需要访问主存。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152058012.png" alt="image-20230415205826937" loading="lazy"></p><h3 id="5-2-5-隐含寻址"><a href="#5-2-5-隐含寻址" class="headerlink" title="5.2.5.隐含寻址"></a>5.2.5.隐含寻址</h3><p><strong>隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</strong></p><ul><li><strong>优点</strong>：有利于<strong>缩短指令字长。</strong></li><li><strong>缺点</strong>：需要<strong>增加存储操作数和隐含地址的硬件。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152059943.png" alt="image-20230415205938862" loading="lazy"></p><h3 id="5-2-6-立即寻址"><a href="#5-2-6-立即寻址" class="headerlink" title="5.2.6.立即寻址"></a>5.2.6.立即寻址</h3><p><strong>立即寻址：形式地址 A 就是操作数本身，又称为立即数，一般采用补码形式。它的寻址特征为<code>#</code>，<code>#</code>表示立即寻址特征。</strong></p><ul><li><strong>访存次数</strong>： 取指令 1 次 + 执行指令 0 次 &#x3D;<strong>1 次</strong>（暂不考虑存结果）。</li><li><strong>优点：</strong> 指令执行阶段不需要访问主存，<strong>指令执行时间最短。</strong></li><li><strong>缺点：</strong> A 的<strong>位数限制了立即数的范围</strong>  。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152100062.png" alt="image-20230415210026975" loading="lazy"></li></ul><h3 id="5-2-7-堆栈寻址"><a href="#5-2-7-堆栈寻址" class="headerlink" title="5.2.7.堆栈寻址"></a>5.2.7.堆栈寻址</h3><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出(LIFO)”原则管理的存储区，该存储区中被读&#x2F;写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。</p><p><strong>堆栈寻址：是指操作数存放在堆栈中，隐含使用堆栈指针 ($SP$) 作为操作数地址。其中，堆栈是存储器（或专用寄存器组）中一块特定的按 “先进后出” 原则管理的存储区，该存储区中被读 &#x2F; 写单元的地址由一个特定的寄存器给出的，也就是我们上面说到的堆栈指针（$SP$）。</strong></p><p><strong>如下，记栈顶单元为 $ M_{sp} $​，那么完成一次加法运算的过程为</strong>：</p><ul><li>首先是<code>POP ACC</code>，也就是将栈顶单元弹出并将其内容送入<code> ACC</code>，也即 $(M_{sp})-&gt;ACC$，同时栈顶指针向下移动，也即<code> (SP)+1=SP</code>，指向次栈顶元素。</li><li>接着是<code>POP X</code>，将操作数放到 <code>X </code>寄存器中，重复。</li><li>然后进行加法运算<code>ADD Y</code>，结果保存在变量 <code>Y</code> 中，也即<code> (ACC)+(X)-&gt;Y</code>。</li><li>接着进行压栈，结果压回栈顶<code>PUSH Y</code>，栈顶指针向上移动，结果送入此时的栈顶，也即 <code>(SP-1)-&gt;SP</code> 和$ (Y)-&gt;(M_{sp})$。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152105746.png" alt="image-20230415210524651" loading="lazy"></p><p><strong>堆栈可以分为硬堆栈和软堆栈两种（上面的例子属于硬堆栈）。</strong></p><ul><li><strong>硬堆栈</strong>：又称为寄存器堆栈，其成本较高，不适合做大容量的堆栈。</li><li><strong>软堆栈（最常用）</strong>：是指从主存中划分一段区域来做堆栈。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152107218.png" alt="image-20230415210726133" loading="lazy"></p><h1 id="6-第二类数据寻址（将形式地址视为偏移量）"><a href="#6-第二类数据寻址（将形式地址视为偏移量）" class="headerlink" title="6.第二类数据寻址（将形式地址视为偏移量）"></a>6.第二类数据寻址（将形式地址视为偏移量）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152221646.png" loading="lazy"></p><p>主要介绍以下三种数据寻址方式，它们都是将形式地址视为 “偏移量”。**</p><ul><li><strong>基址寻址</strong>：以程序的起始存放地址作为起点，即 <code>EA=(BR)+A</code>。</li><li><strong>变址寻址</strong>：程序员自己决定从哪里作为起点，即 <code>EA=(IX)+A</code>。</li><li><strong>相对寻址</strong>：以程序计数器 <code>PC</code> 所指地址作为起点，即<code> EA=(PC)+A</code>。</li></ul><h2 id="6-1-基址寻址"><a href="#6-1-基址寻址" class="headerlink" title="6.1.基址寻址"></a>6.1.基址寻址</h2><h3 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1.基本概念"></a>6.1.1.基本概念</h3><p>**基址寻址：将 CPU 中基址寄存器 BR 中的内容加上指令格式中的形式地址 A，从而形成操作数的有效地址，也即<code> EA=(BR)+A</code>**。</p><p><strong>如下，采用基址寻址，指令中会包含一个形式地址 A，BR 会指向当前程序存放的起始位置</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152111168.png" alt="image-20230415211139086" loading="lazy"></p><p>需要注意，有的计算机内部不会专门设计一个基址寄存器，而会使用<strong>通用寄存器</strong>代替基址寄存器。如果采用通用寄存器，除了要给明寻址特征外，<strong>指令中还要多出几位 ( $R_{0} $​) 用于说明要将哪个通用寄存器作为基址寄存器使用。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152112597.png" alt="image-20230415211214513" loading="lazy"></p><h3 id="6-1-2-基址寻址的作用"><a href="#6-1-2-基址寻址的作用" class="headerlink" title="6.1.2.基址寻址的作用"></a>6.1.2.基址寻址的作用</h3><p><strong>基址寻址作用：基址寻址利于程序浮动，程序存储位置可以更改，但指令内容不需要修改，只需要更改基址寄存器，让其始终指向程序的起始地址，这&#x3D;&#x3D;有利于多道程序并发运行&#x3D;&#x3D;；另外，采用基址寻址可以扩大寻址范围（因为基址寄存器的位数大于形式地址 A 的位数）。</strong></p><p>例如下面有这样一段 C 语言段程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>y<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻译为等价的机器指令</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152113336.png" alt="image-20230415211325256" loading="lazy"></p><p>下图中该程序从 <strong>主存 “100”</strong> 处开始存储，第一个指令是一个取数指令，目的是<strong>为了把 “105” 处的变量<code>a=2</code>取到 <code>ACC </code>中</strong>，此时该地址码就会被解释为<strong>偏移量</strong>，因此<strong>真实地址 &#x3D; 基址寄存器 + 地址码</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152114002.png" alt="image-20230415211429896" loading="lazy"></p><h2 id="6-2-变址寻址"><a href="#6-2-变址寻址" class="headerlink" title="6.2.变址寻址"></a>6.2.变址寻址</h2><h3 id="6-2-1-基本概念"><a href="#6-2-1-基本概念" class="headerlink" title="6.2.1.基本概念"></a>6.2.1.基本概念</h3><p><strong>变址寻址：有效地址 EA 等于形式地址 $A $与变址寄存器 IX 中的内容相加之和，也即 $ EA&#x3D;(IX)+A $。其中 IX 可以是专用的，也可以将通用寄存器用作变址寄存器</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152115537.png" alt="image-20230415211546457" loading="lazy"></p><p><strong>可以看出变址寄存器和基址寄存器非常相像，那么他们的区别又在哪里呢？</strong></p><ul><li><p><strong>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间无关性。在程序执行过程中，基址寄存器内容不变（作为基地址）、形式地址可变（作为偏移量）；另外，采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但是其内容仍然由操作系统确定</strong>。</p></li><li><p><strong>变址寄存器是面向用户的，在程序的执行过程中，变址寄存器中的内容可以由用户改变，其中 IX 作为偏移量，形式地址 A 不变，作为基地址，这一点和基址寄存器恰好相反</strong>。</p></li></ul><h3 id="6-2-2-变址寄存器的作用"><a href="#6-2-2-变址寄存器的作用" class="headerlink" title="6.2.2.变址寄存器的作用"></a>6.2.2.变址寄存器的作用</h3><p><strong>变址寻址作用：变址寻址特别适合编写循环程序，例如在下面所述的数组处理过程中，可将形式地址 A 设置为基地址，这里就是数组的首地址，而变址寄存器 $ IX $的内容为偏移量，也就是循环变量。</strong></p><p>依旧采用基址寻址，如下有一段 C 语言程序，其作用是对<code>a[0]~a[9]</code>进行求和，涉及到了循环语句。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻译为等价的机器指令：</p><ul><li>第 0 条指令是立即寻址，将 0 取到 ACC 中。</li><li>第 1 条第 10 条均为加法指令，从地址码指示位置取得操作数然后和 ACC 中内容相加并送入 ACC 中。</li><li>第 11 条是一个取数指令，将累加结果放回到 sum 中。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152116381.png" alt="image-20230415211627288" loading="lazy"></p><p>可以发现对于基址寻址，它在处理循环时显得不那么合适，一旦数组的内容成百上千，难道还要继续这样操作吗？答案显然不是这样的，这时候就要用到变址寻址了。</p><ul><li>第 0 条指令是取数指令，取到 <code>ACC</code> 中。</li><li>第 1 条指令是取数指令，取到<code> IX</code> 中。</li><li>第 2 条指令采用变址寻址，也即<code> EA=(IX)+A</code>。这条指令的 A 指向了 “7”，也就是数组的起始位置，此时执行这条指令的结果<strong>就是把 <code>ACC</code> 中的内容（目前为 0）加上$ IX$偏移 7 后所指内存单元中的内容（也即<code>a[0]</code>），然后再放到<code> ACC</code> 中，完成第一轮循环。</strong></li><li>第 3 条指令是 IX+1，对应于循环变量<code>i++。</code></li><li>第 4 条指令是 IX 与 10 做比较，来决定是执行第 5 条指令还是第 6 条指令。<strong>如果 IX&lt;10 参见第 5 条指令，如果 IX&gt;&#x3D;10 参见第 6 条指令。</strong></li><li>第 5 条指令是条件跳转，程序会跳转至 “2”，进行第 2 轮循环，然后依次类推。</li><li>第 6 条指令是存数指令，此时结束循环。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152117766.png" alt="image-20230415211759664" loading="lazy"></p><h3 id="6-2-3-复合寻址（基址-变址）"><a href="#6-2-3-复合寻址（基址-变址）" class="headerlink" title="6.2.3.复合寻址（基址 + 变址）"></a>6.2.3.复合寻址（基址 + 变址）</h3><p>实际上，基址和变址这两种寻址方式通常会配合使用，上面变址的例子中仅仅展示了当程序从主存 “0” 位置开始存储的情形，当然是没有问题的，<strong>但是一旦改变程序的起始位置，那么仅仅依靠变址寻址就不行了。</strong></p><p>基本规则如下：</p><ul><li><strong>基址寻址</strong>：<code>EA=(BR)+A</code>。</li><li><strong>变址寻址</strong>：<code>EA=(IX)+A</code>。</li><li><strong>先基址再变址</strong>：<code>EA=(IX)+((BR)+A)</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152119029.png" alt="image-20230415211930926" loading="lazy"></p><h2 id="6-3-相对寻址"><a href="#6-3-相对寻址" class="headerlink" title="6.3.相对寻址"></a>6.3.相对寻址</h2><h3 id="6-3-1-基本概念"><a href="#6-3-1-基本概念" class="headerlink" title="6.3.1.基本概念"></a>6.3.1.基本概念</h3><p><strong>相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，也即 <code>EA=(PC)+A</code>，其中 A 是相对于 PC 所指地址的偏移量，可正可负，使用补码表示</strong>。</p><p>前面说过，当前指令执行完毕之后，<strong>PC 会自动 +“1”</strong>（注意这里的 “1” 仅仅表示下一步的意思，并不是实际 + 1，这要视具体情况而定，具体细节读者可查看上一节）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152120334.png" alt="image-20230415212029247" loading="lazy"></p><h3 id="6-3-2-相对寻址作用"><a href="#6-3-2-相对寻址作用" class="headerlink" title="6.3.2.相对寻址作用"></a>6.3.2.相对寻址作用</h3><p><strong>相对寻址的作用：相对寻址中，操作数地址不是固定不变的，可以随 PC 值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序的浮动（注意区分基址寻址的浮动，这里的浮动是指&#x3D;&#x3D;一段代码在程序内部的浮动&#x3D;&#x3D;），相对寻址&#x3D;&#x3D;广泛应用在转移指令中&#x3D;&#x3D;。</strong></p><p>还是这样一段加和程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环部分对应的指令如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152121255.png" alt="image-20230415212116157" loading="lazy"></p><p>在编写程序时我们常常有跳转的需求，比如上面的那一段程序可能循环未结束，我们需要马上执行它下面的一段程序，那么在这种情况下如果进行跳转，会出现很大的问题  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152122415.png" alt="image-20230415212211319" loading="lazy">  </p><p>为了解决这样的问题，引入相对寻址。<strong>在上图中，执行完 “M+3” 处的指令后会自动跳转至 “M+4”，如果想要跳回至 “M” 处，那么就要将 “M+3” 中的地址码改为 - 4 即可</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152123253.png" alt="image-20230415212306147" loading="lazy">  </p><p>自此，这段程序就似乎自我形成了一个封闭的体系，无论你把程序放到什么位置，只要他们的相对位置不变，总能跳转到正确的位置。</p><h2 id="6-4-数据寻址总结"><a href="#6-4-数据寻址总结" class="headerlink" title="6.4.数据寻址总结"></a>6.4.数据寻址总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152126019.png" alt="image-20230415212429695" loading="lazy"></p><h1 id="7-高级语言、汇编语言、机器语言"><a href="#7-高级语言、汇编语言、机器语言" class="headerlink" title="7.高级语言、汇编语言、机器语言"></a>7.高级语言、汇编语言、机器语言</h1><p><strong>使用高级语言编写的源程程序会经过以下两步转变为与之对应的机器语言</strong>：</p><ul><li><strong>编译：</strong> 高级语言经<strong>编译程序</strong> 编译后 转变为汇编语言，<strong>一条高级语言语句可能对应多条汇编语言语句。</strong></li><li><strong>汇编：</strong> 汇编语言经<strong>汇编程序</strong> 汇编后 转变为机器语言，<strong>一条汇编语言语句对应一条机器语言语句</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152129027.png" alt="image-20230415212955901" loading="lazy"></p><h2 id="7-1-汇编程序简单入门"><a href="#7-1-汇编程序简单入门" class="headerlink" title="7.1.汇编程序简单入门"></a>7.1.汇编程序简单入门</h2><p>如下为一段 C 语言程序，输出 “Hello World”：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>  <span class="token keyword">int</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 gcc 生成汇编程序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>file <span class="token string">"hello.c"</span>       <span class="token punctuation">.</span>intel_syntax noprefix      <span class="token punctuation">.</span>section <span class="token punctuation">.</span>rodata  <span class="token punctuation">.</span>LC0<span class="token operator">:</span>      <span class="token punctuation">.</span>string <span class="token string">"Hello, world!"</span>      <span class="token punctuation">.</span>text      <span class="token punctuation">.</span>globl   main      <span class="token punctuation">.</span>type    main<span class="token punctuation">,</span> @function  main<span class="token operator">:</span>      push     rbp      mov      rbp<span class="token punctuation">,</span> rsp      sub      rsp<span class="token punctuation">,</span> <span class="token number">16</span>      mov      DWORD PTR <span class="token punctuation">[</span>rbp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> edi      mov      QWORD PTR <span class="token punctuation">[</span>rbp<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rsi      mov      edi<span class="token punctuation">,</span> OFFSET FLAT<span class="token operator">:</span><span class="token punctuation">.</span>LC0      call     puts      mov      eax<span class="token punctuation">,</span> <span class="token number">0</span>      leave      ret      <span class="token punctuation">.</span>size    main<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token operator">-</span>main      <span class="token punctuation">.</span>ident   <span class="token string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9)"</span>      <span class="token punctuation">.</span>section <span class="token punctuation">.</span>note<span class="token punctuation">.</span>GNU<span class="token operator">-</span>stack<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一个汇编程序由如下 4 个基本组件构成</strong>：</p><ul><li><p><strong>指令（instruction）</strong>：是 CPU 执行的<strong>实际操作</strong>。</p></li><li><p><strong>伪指令（directive）</strong>：告诉汇编工具生成特定数据，并<strong>将指令或数据放在指定的节。</strong></p></li><li><p><strong>标号（label）</strong>：在汇编工具中在<strong>汇编工具中引用指令或数据的符号名称。</strong></p></li><li><p><strong>注释（comment）</strong>：在汇编程序中，可以使用 <code>COMMENT</code> 伪指令来定义注释。</p></li><li><p>&#96;&#96;&#96;c<br>COMMENT [regexp] ; 在此处输入注释内容    </p><pre class="line-numbers language-none"><code class="language-none">  **例如**：| 类型   | 示例                  | 含义                            || ------ | --------------------- | ------------------------------- || 指令   | mov eax,0             | 给 eax 赋值为 0                 || 伪指令 | .section .text        | 将以下代码放入.text 节          || 伪指令 | .string &quot;foobar&quot;      | 定义包含&quot;foobar”的 ASCII 字符串 || 伪指令 | .long 0x12345678      | 定义一个双字 0x12345678         || 标号   | foo: .string &quot;foobar&quot; | 使用符号定义“foobar”&quot;字符串     || 注释   | #这是注释             | 可读注释                        |注意：上面的示例是伪指令和标号的示例，它们并不是实际的汇编代码。在实际的汇编代码中，指令和伪指令的顺序是固定的，并且伪指令和标号后面的字符串必须是唯一的。7.2.什么是 x86 架构------------**x86 架构：是微处理器执行的计算机语言指令集，指一个 intel 通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。1978 年 6 月 8 日，Intel 发布了新款 16 位微处理器 “8086”，也同时开创了一个新时代——x86 架构。**![image-20230415213903625](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152139726.png)7.3.x86 指令结构----------### 7.3.1.x86 的汇编层表示**x86 的汇编层表示：x86 指令通常表示为助记符 目标地址，源地址。***   **助记符**：是人类可读的机器指令表示。*   **源地址和目标地址**：指令的操作数。**如汇编指令&#96;mov rbx,rax&#96;就是将寄存器&#96;rax&#96;的值赋给&#96;rbx。&#96;**![image-20230415214114111](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152141207.png)### 7.3.2.x86 指令的机器级结构**x86 指令的机器级结构：由以下部分组成**：*   **前缀**（可选）：前缀**可以修改指令的行为**，如让一条指令重复执行多次或访问不同的内存段。*   **操作码**：是指令对其进行**操作的数据**。*   **寻址模式字节**（可选）：包含有关指令操作数类型的元数据，SIB（scale&#x2F;index&#x2F;base）字节和偏移（displacement）用来表示内存操作数，立即数字段（immediate）包含立即操作数（常量数值），**标识特定的寻址方式。**![](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152141551.png)### 7.3.3.x86 操作数来源**x86 中操作数有三个来源**：*   寄存器。*   内存。*   操作数。#### 7.3.3.1.寄存器操作数**x86 寄存器操作数：x86 下只需关注如下 8 个寄存器，每个寄存器以&#96;E&#96;开头，表示&#96;Extended&#96;，长度为 32bit。分为三类**：*   **以&#96;X&#96;结尾**：通用寄存器。*   **以&#96;I&#96;结尾**：变址寄存器。*   **以&#96;P&#96;结尾**：堆栈寄存器。![image-20230415214508206](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152145304.png)**对于上面的四个通用寄存器，也可以只使用低 16bit 或低 8bit。**![image-20230415214540807](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152145906.png)![image-20230415214552671](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152148376.png)#### 7.3.3.2.内存操作数**内存操作数：在 x86 中，可以用&#96;[base+index*scale+displacement]&#96;指定内存操作数**。*   &#96;base&#96;和&#96;index&#96;：是 64 位寄存器。*   &#96;scale&#96;：1、2、4 或 8 的整数值。*   &#96;displacement&#96;（偏移）：是 32 位常量或符号。**例如&#96;mov eax, dword ptr[af966h]&#96;就表示将内存地址 af996h 所指的 32bit 值复制到寄存器&#96;eax&#96;中**。*   &#96;dword ptr&#96;：双字（32bit）。*   &#96;word ptr&#96;：单字（16bit）。*   &#96;byte ptr&#96;：字节（8bit）。#### 7.3.3.1.立即数**立即数：立即数就是指令中硬编码的常量整数操作数，如指令&#96;add rax,42&#96;，其中 42 就是一个立即数。**7.4.x86 指令例子----------*   &#96;mov eax, ebx&#96;：将寄存器&#96;ebx&#96;的值复制到寄存器&#96;eax&#96;中。*   &#96;mov eax, 5&#96;：将立即数 5 复制到寄存器&#96;eax&#96;中。*   &#96;mov eax, dword ptr[af996h]&#96;：将内存地址 af996h 所指的 32bit 值复制到寄存器&#96;eax&#96;中。*   &#96;mov byte prt[af996h], 5&#96;：将立即数 5 复制到内存地址 af996h 所指的一字节中。*   &#96;mov eax, dword ptr[ebx]&#96;：将&#96;ebx&#96;所指主存地址的 32bit 复制到&#96;eax&#96;寄存器中。*   &#96;mov dword ptr[ebx], eax&#96;：将&#96;eax&#96;的内容复制到&#96;ebx&#96;所指主存地址的 32bit 中。*   &#96;mov eax byte ptr[ebx]&#96;：将&#96;ebx&#96;所指的主存地址的 8bit 复制到&#96;eax&#96;中。*   &#96;mov eax, [ebx]&#96;: 若未指明主存读写长度，默认 32 bit。*   &#96;mov [af996h], eax&#96;：将&#96;eax&#96;的内容复制到 af996h 所指的地址（未指明长度默认 32 bit）。*   &#96;mov eax, dword ptr[ebx+8]&#96;：将&#96;ebx+8&#96;所指主存地址的 32bit 复制到&#96;eax&#96;寄存器中。7.5.AT&amp;T 格式和 intel 格式对比---------------------![image-20230415220645899](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152206018.png)**表示 x86 机器指令的语法格式主要有两种，其中 intel 格式考试最为常见**：*   **AT&amp;T 格式**（Linux）：显式地在每个**寄存器名称**的前面加上 % 符号，每个**常量**前面加上 $ 符号；源操作数在目的操作数**前面**。*   **Intel 格式**（Windows）：相对简洁、不加符号；源操作数在目的操作数**后面。****区别一：操作数位置**。*   **AT&amp;T 格式源操作数在左，目的操作数在右面**：&#96;op s, d。&#96;*   **intel 格式目的操作数在左，源操作数在右面**：&#96;op d, s。&#96;**区别二：寄存器表示。***   **AT&amp;T 格式寄存器名之前必须加&#96;%&#96;**：&#96;mov %ebx, %eax。&#96;*   **intel 格式直接写寄存器名即可**： &#96;mov eax, ebx。&#96;**区别三：立即数表示**。*   **AT&amp;T 格式立即数之前必须加&#96;$&#96;**：&#96;mov $985, %eax。&#96;*   **intel 格式直接写立即数即可**： &#96;mov eax, 985。&#96;**区别四：主存地址表示。***   **AT&amp;T 格式使用中括号&#96;()&#96;表示主存地址**：&#96;mov $eax, (af996h)。&#96;*   **intel 格式使用中括号&#96;[]&#96;表示主存地址**： &#96;mov [af996], eax。&#96;**区别五：读写长度表示。***   **AT&amp;T 格式使用&#96;b&#96;、&#96;w&#96;、&#96;l&#96;分别代表&#96;byte&#96;、&#96;word&#96;、&#96;dword&#96;，写到指令的后面**：&#96;movb $5, (af997h)&#96;、&#96;movw $5, (af997h)&#96;、&#96;movl $5, (af997h)&#96;。*   **intel 格式在主存地址前面使用&#96;byte&#96;、&#96;word&#96;、&#96;dword&#96;说明**：&#96;mov byte ptr [af996h], 5&#96;、&#96;mov word ptr [af996h], 5&#96;、&#96;mov dword ptr [af996h], 5&#96;。**区别六：主存地址偏移量表示***   **AT&amp;T 格式使用&#96;偏移量(基址)&#96;或&#96;偏移量（基址,变址,比例因子）&#96;表示**：&#96;movl -8(%ebx), %eax&#96;、&#96;mov eax,[ebx+ecx*32+4]&#96;。*   **intel 格式使用&#96;[基址+偏移量]&#96;或&#96;[基址+变址*比例因子+偏移量]&#96;表示**： &#96;mov eax, [ebx-8]&#96;、&#96;mov eax, [ebx+ecx*32+4]&#96;。# 8.常用的x86汇编指令、选择和循环语句的机器级表示![image-20230415220429441](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152204539.png)8.1.常见的算数运算指令-----------**注意**：*   除法中&#96;s&#96;作除数，被除数会被**提前放置**到&#96;edx&#96;和&#96;eax&#96;当中。*   &#96;edx:eax&#96;：在进行除法运算之前，需要把被除数进行**位扩展**为 64bit，所以需要两个寄存器。&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文名&lt;&#x2F;th&gt;&lt;th&gt;英文名&lt;&#x2F;th&gt;&lt;th&gt;汇编指令&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;加&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;add&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;add d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;计算&lt;code&gt;d+s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;减&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;subtract&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;sub d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;计算&lt;code&gt;d-s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;乘&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;multiply&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;mul d,s&lt;&#x2F;code&gt; 和&lt;code&gt;imul d, s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;无符号数&lt;code&gt;d*s&lt;&#x2F;code&gt;和有符号数&lt;code&gt;d*s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;除&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;divide&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;div d,s&lt;&#x2F;code&gt;和&lt;code&gt;idiv d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;无符号数和有符号除法&lt;code&gt;edx:eax&#x2F;s&lt;&#x2F;code&gt; ，其中商存入&lt;code&gt;eax&lt;&#x2F;code&gt;，余数存入&lt;code&gt;edx&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;取负数&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;negative&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;neg d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;取负数，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;自增&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;increase&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;inc d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;也即&lt;code&gt;d++&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;自减&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;decrease&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;dec d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;也即&lt;code&gt;d--&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;**举例**：*   &#96;sub eax, 10&#96;：计算&#96;eax-10&#96;并存入&#96;eax&#96;。*   &#96;add byte ptr [var], 10&#96;：&#96;var&#96;所指内存地址一字节值与 10 相加，结果存入&#96;var&#96;所指内存地址处。8.2.常见的逻辑运算指令-----------&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文名&lt;&#x2F;th&gt;&lt;th&gt;英文名&lt;&#x2F;th&gt;&lt;th&gt;汇编指令&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;与&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;and&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;and d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位相与，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;或&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;or&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;or d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位相或，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;非&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;not&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;not d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逐位取反，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;异或&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;exclusive or&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;xor d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位异或，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;左移&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shift left&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shl d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逻辑左移&lt;code&gt;s&lt;&#x2F;code&gt;位，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;右移&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shift rightft&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shr d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逻辑右移&lt;code&gt;s&lt;&#x2F;code&gt;位，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;8.3.其他类型指令--------### 8.3.1.数据传送类指令*   &#96;mov&#96;：将第二个操作数 (寄存器的内容、内存中的内容或常数值) **复制**到第一个操作数 (寄存器或内存)。但不能用于直接从内存复制到内存。*   &#96;push&#96;：将**操作数压入内存的栈**，常用于函数调用。ESP 是栈顶，压栈前先将 ESP 值减 4 (栈增长方向与内存地址增长方向相反)，然后将操作数压入 ESP 指示的地址。*   &#96;pop&#96;：与 push 指令相反，pop 指令执行的是**出栈工作**，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4。### 8.3.2.控制流指令**指令指针寄存器 IP（相当于 ARM 型 CPU 中的程序计数器 PC）：x86 处理器维持着一个指示当前执行指令的指令指针 (IP)， 当一条指令执行后，此指针自动指向下一条指令。IP 寄存器不能直接操作，但可以用控制流指令更新。通常用标签 (label) 指示程序中的指令地址，在 x86 汇编代码中，可在任何指令前加入标签。***   &#96;jmp&#96;：**无条件转移指令**，控制 IP 转移到 **label 所指示的地址** (从 label 中取出指令执行)。*   &#96;jcondition&#96;：**条件转移指令**，依据 CPU 状态字中的一系列条件状态转移。CPU 状态字中包括指示最后一个算术运算结果是否为 0，运算结果是否为负数等。*   &#96;comp&#x2F;test&#96;：&#96;cmp&#96;指令用于**比较两个操作数的值**，&#96;test&#96; 指令**对两个操作数进行逐位与运算**，这两类指今都不保存操作结果，仅根据运算结果**设置 CPU 状态字中的条件码。***   &#96;call&#x2F;ret&#96;：**无条件转移指令**，分别用于实现子程序 (过程、函数等) 的调用及返回。**对于无条件转移指令&#96;call&#x2F;ret&#96;，其过程调用的执行步骤如下，假设$P$ 调用 $Q$***   $P$ 将入口参数 (实参) 放在 $Q$ 能访问到的地方。*   $P$ 将返回地址存到特定的地方，然后将控制转移到 $Q$。*   $Q$ 保存$P$ 的现场 (通用寄存器的内容)，并为自己的非静态局部变量分配空间*   执行过程 $Q$。*   $Q$ 恢复$P$ 的现场，将返回结果放到$P$ 能访问到的地方，并释放局部变量所占空间。*   $Q$ 取出返回地址，将控制转移到$P$。#### 8.3.2.1.无条件转移指令 jmp![image-20230415220911290](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152209403.png)**对于&#96;jmp&#96;指令，有如下四种使用方法**：*   &#96;jmp 128&#96;：地址由常数给出。*   &#96;jmp eax&#96;：地址可以来自于寄存器。*   &#96;jmp[999]&#96;：地址可以来自于主存。*   &#96;jmp NEXT&#96;：地址可以由 “标号” 给出，类似于 C 语言中的 goto 语句。&#96;&#96;&#96;cmov eax, 7mov ebx, 6jmp NEXTmov ecx, ebxNEXT:mov ecx, eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="8-3-2-2-条件转移指令-jcondition"><a href="#8-3-2-2-条件转移指令-jcondition" class="headerlink" title="8.3.2.2.条件转移指令 jcondition"></a>8.3.2.2.条件转移指令 jcondition</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209013.png" alt="image-20230415220928884" loading="lazy"></p><p><strong><code>jmp</code>指令是很不灵活的，无法实现一些复杂条件转移操作，所以需要借助条件转移指令<code>jcondition</code>来完成，同时要借助<code>cmp a, b</code>（比较<code>a</code>和<code>b</code>的大小）。</strong></p><ul><li><code>je &lt;地址&gt;</code>：若<code>a == b</code> 则跳转（ZF &#x3D;&#x3D; 1）。</li><li><code>jne &lt;地址&gt;</code>：若 <code>a != b</code> 则跳转（ZF &#x3D;&#x3D; 0）。</li><li><code>jg &lt;地址&gt;</code>：若 <code>a &gt; b</code> 则跳转（ZF &#x3D;&#x3D; 0 &amp;&amp; SF &#x3D;&#x3D; OF）。</li><li><code>jge &lt;地址&gt;</code>：若 <code>a &gt;= b</code> 则跳转（ SF &#x3D;&#x3D; OF）。</li><li><code>jl &lt;地址&gt;</code>：若 <code>a &lt; b</code> 则跳转（ SF !&#x3D; OF）。</li><li><code>jle &lt;地址&gt;</code>：若 <code>a &lt;= b</code> 则跳转（ SF !&#x3D; OF || ZF &#x3D;&#x3D; 1）。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">cmp eax<span class="token punctuation">,</span>ebx # 比较寄存器eax和ebx里的面的值jg NEXT #若eax<span class="token operator">></span>ebx则跳转至NEXT位置处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8-4-选择语句的机器级表示"><a href="#8-4-选择语句的机器级表示" class="headerlink" title="8.4.选择语句的机器级表示"></a>8.4.选择语句的机器级表示</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209886.png" alt="image-20230415220954778" loading="lazy"></p><p>如下是 C 语言中的<code>if-else</code>语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>c <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>c <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应机器级表示如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">mov eax<span class="token punctuation">,</span> <span class="token number">7</span>  # 变量a<span class="token operator">=</span><span class="token number">7</span>，存入eax中mov ebx<span class="token punctuation">,</span> <span class="token number">6</span>  # 变量b<span class="token operator">=</span><span class="token number">6</span>，存入ebx中cmp eax<span class="token punctuation">,</span> ebx  # 比较a和bjg NEXT  # 若a<span class="token operator">></span>b，跳转至NEXT处mov ecx<span class="token punctuation">,</span> ebx  # 使用ecx存入变量c，使c<span class="token operator">=</span>bjmp ENDNEXT<span class="token operator">:</span>mov ecx<span class="token punctuation">,</span> eax  # 使用ecx存入变量c，使c<span class="token operator">=</span>aEND：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-5-循环语句的机器级表示"><a href="#8-5-循环语句的机器级表示" class="headerlink" title="8.5.循环语句的机器级表示"></a>8.5.循环语句的机器级表示</h2><h3 id="8-5-1-使用条件转移指令实现循环"><a href="#8-5-1-使用条件转移指令实现循环" class="headerlink" title="8.5.1.使用条件转移指令实现循环"></a>8.5.1.使用条件转移指令实现循环</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214569.png" alt="image-20230415221409430" loading="lazy"></p><p><strong>使用条件转移指令实现循环由以下 4 部分构成</strong>：</p><ul><li>循环前的初始化。</li><li>是否直接跳过循环。</li><li>循环主体。</li><li>是否继续循环。</li></ul><p>如下代码是 C 语言中的<code>for</code>循环，用于求解 1+2+…+100。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>result <span class="token operator">+=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对应机器级表示如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">mov eax<span class="token punctuation">,</span><span class="token number">0</span>  # 使用eax保存result，初始值为<span class="token number">0</span>mov edx<span class="token punctuation">,</span><span class="token number">1</span>  # 使用edx保存i，初始值为<span class="token number">1</span>cmp edx<span class="token punctuation">,</span><span class="token number">100</span> # 比较i和<span class="token number">100</span>的大小jg L2 # 如果i<span class="token operator">></span><span class="token number">100</span>，跳转至L2处L1<span class="token operator">:</span> # 循环主体add eax<span class="token punctuation">,</span>edx # result <span class="token operator">+=</span> iinc edx # i<span class="token operator">++</span>cmp edx<span class="token punctuation">,</span><span class="token number">100</span> # 比较i和<span class="token number">100</span>的大小jle L1 # 如果i<span class="token operator">&lt;=</span><span class="token number">100</span>，跳转至L1处l2<span class="token operator">:</span>  # 结束循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-5-2-使用-loop-指令实现循环"><a href="#8-5-2-使用-loop-指令实现循环" class="headerlink" title="8.5.2.使用 loop 指令实现循环"></a>8.5.2.使用 loop 指令实现循环</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214515.png" alt="image-20230415221427405" loading="lazy"></p><p><strong>从理论上讲，能用 loop 指令实现的功能也一定能用条件转移指令实现。loop 指令的存在目的是为了使代码更加清晰、简洁，让其余分支语句区别更明显</strong>。</p><p>如下代码是 C 语言中的<code>for</code>循环，固定循环 500 次：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">do</span> something<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对应机器级表示如下，其中：</p><ul><li><code>loop Looptop</code>：等价于<code>dec ecx</code>、<code>cmp ecx, 0</code>、<code>jne Looptop</code>。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">mov ecx<span class="token punctuation">,</span> <span class="token number">500</span>  # ecx是循环变量Looptop<span class="token operator">:</span>  # 循环开始<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">do</span> something<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>loop Looptop  # ecx<span class="token operator">--</span>，若ecx <span class="token operator">!=</span> <span class="token number">0</span>，跳转至Looptop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-6-cmp指令的底层原理"><a href="#8-6-cmp指令的底层原理" class="headerlink" title="8.6.cmp指令的底层原理"></a>8.6.cmp指令的底层原理</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152213132.png" alt="image-20230415221302986" loading="lazy"></p><h1 id="9-CISC和RISC简单了解"><a href="#9-CISC和RISC简单了解" class="headerlink" title="9.CISC和RISC简单了解"></a>9.CISC和RISC简单了解</h1><p>指令系统的设计如今朝着两个截然不同的方向发展：</p><p><strong>一是增强原有指令的功能，设置为更复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC），典型的如 ×86 架构的计算机；二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC），典型的有 ARM，MIPS 架构的计算机</strong>。</p><h2 id="9-1-复杂指令系统计算机（CISC）"><a href="#9-1-复杂指令系统计算机（CISC）" class="headerlink" title="9.1.复杂指令系统计算机（CISC）"></a>9.1.复杂指令系统计算机（CISC）</h2><p>随着 VLSI 技术的发展，硬件成本不断降低，软件成本不断上升，促使人们在系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了 CISC。其主要特点如下：</p><ol><li>指令系统复杂庞大，指令数目一般为 200 条以上。</li><li>指令的长度不固定，指令格式多，寻址方式多。</li><li>可以访存的指令不受限制。</li><li>各种指令使用的频度相差很大。</li><li>各种指令执行时间相差很大，大多数指令需要多个时钟周期才能完成。</li><li>控制器大多数采用微程序编程。有的指令非常复杂，以至于无法采用硬连线控制。</li><li>难以用优化编译生成高效的目标代码途径。</li></ol><p>如此庞大的指令系统，对指令的设计提出了极高的要求，胭研制周期变得很长。后来人们发现一味地追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径。对传统 CISC 指令系统测试表明，各种指令的使用频率相差悬殊，从这一事实出发，人们开始了指令系统合理性的研究，于是 RISC 随之诞生。</p><h2 id="9-2-精简指令系统计算机（RISC）"><a href="#9-2-精简指令系统计算机（RISC）" class="headerlink" title="9.2.精简指令系统计算机（RISC）"></a>9.2.精简指令系统计算机（RISC）</h2><p>RISC 的中心思想是要求指令系统简化，尽量使用寄存器 - 寄存器操作指令，指令格式力求一致。其主要特点如下：</p><ol><li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令组合实现。</li><li>指令长度固定，指令格式种类少，寻址方式种类少。</li><li>只有 Load&#x2F;Store(取数 &#x2F; 存数) 指令访存，其余指令的操作都在寄存器之间进行。</li><li>CPU 中通用寄存器的数量相当多。</li><li>RISC 一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li><li>以硬布线控制为主，少用或者不用微程序控制。</li><li>特别重视编译优化工作，以减少程序执行时间。</li></ol><p>值得注意的是，从指令系统的兼容性来看，CISC 大多能够实现软件兼容，即高高档机包含了低档机的全部指令，并可以进行扩充。但 RISC 简化了指令系统，指令条数少，格式也不同于老机器，因此大多数 RISC 机不能与老机器兼容。由于 RISC 具有更强的实用性，因此应该是未来处理器发展的方向。但事实上，当今时代 Intex 几乎一统江湖，且早期很多软件都是根据 CISC 设计的，单纯的 RISC 将无法兼容。此外，现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分，其性能差距已经越来越小。CISC 可以提供更多的功能，这一点是程序设计所需要的。</p><h2 id="9-3-CISC-和-RISC-比较"><a href="#9-3-CISC-和-RISC-比较" class="headerlink" title="9.3.CISC 和 RISC 比较"></a>9.3.CISC 和 RISC 比较</h2><p>和 CISC 相比，RISC 的优点主要集中在以下几个方面：</p><ol><li><strong>RISC 更能充分利用 VLSI 芯片的面积</strong>。CISC 的控制器大多采用微程序控制，其控制存储器在 CPU 芯片内所占面积会达到 50% 以上，而 RISC 控制器采用组合逻辑控制，其硬布线逻辑只占 CPU 芯片面积的 10% 左右。</li><li><strong>RISC 更能提高运行速度</strong>。RISC 的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。</li><li><strong>RISC 便于设计</strong>，可以降低成本，提高可靠性。RISC 指令系统简单，因此机器设计周期短，其逻辑简单。</li><li><strong>RISC 有利于程序优化</strong>。RISC 指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更加高效化。</li></ol><p>RISC 和 CISC 具体区别如下 ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152216907.png" alt="image-20230415221635811" loading="lazy"></p><h2 id="9-4-计算机的工作过程"><a href="#9-4-计算机的工作过程" class="headerlink" title="9.4.计算机的工作过程"></a>9.4.计算机的工作过程</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152217826.png" alt="image-20230415221755716" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-指令和指令格式&quot;&gt;&lt;a href=&quot;#1-指令和指令格式&quot; class=&quot;headerlink&quot; title=&quot;1.指令和指令格式&quot;&gt;&lt;/a&gt;1.指令和指令格式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.co</summary>
      
    
    
    
    <category term="考研408" scheme="http://ccsu.top/categories/%E8%80%83%E7%A0%94408/"/>
    
    
    <category term="计算机组成原理" scheme="http://ccsu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="考研" scheme="http://ccsu.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>机组-第三章 存储系统</title>
    <link href="http://ccsu.top/posts/2dbdbfc/"/>
    <id>http://ccsu.top/posts/2dbdbfc/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2023-04-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-存储器概述"><a href="#1-存储器概述" class="headerlink" title="1.存储器概述"></a>1.存储器概述</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141356715.png" alt="image-20230414135654630" loading="lazy"></p><h2 id="1-1-存储器分类"><a href="#1-1-存储器分类" class="headerlink" title="1.1.存储器分类"></a><a name="存储器分类">1.1.存储器分类</a></h2><h3 id="1-1-1-按在计算机中的作用（层次）分类"><a href="#1-1-1-按在计算机中的作用（层次）分类" class="headerlink" title="1.1.1.按在计算机中的作用（层次）分类"></a>1.1.1.按在计算机中的作用（层次）分类</h3><ul><li><strong>主存储器</strong>：简称<strong>主存</strong>，又称<strong>内存</strong>；用来存放计算机运行期间所需的大量程序和数据；CPU 可以<strong>直接对其进行访问</strong>，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据；特点是<strong>容量较小，存储速度较快，造价高</strong>。</li><li><strong>辅助存储器</strong>：简称<strong>辅存</strong>，又称<strong>外存</strong>；是主存储器的后援存储器，用来存放<strong>当前暂时不用的程序和数据，以及一些需要永久性保存</strong>的信息，它不能与 CPU 直接交换信息；特点是<strong>容量极大，存储速度较慢，造价低。</strong></li><li><strong>高速缓冲存储器</strong>：简称 <strong>Cache</strong>；它位于主存和 CPU 之间，用来存放<strong>正在执行的程序段和数据</strong>，以便 CPU 能够高速地使用它们；Cache 的读取速度可以和 CPU 相匹配，但<strong>存储容量小，价格高，目前会被集成在 CPU 当中</strong>。</li></ul><h3 id="1-1-2-按照存储介质分类"><a href="#1-1-2-按照存储介质分类" class="headerlink" title="1.1.2.按照存储介质分类"></a>1.1.2.按照存储介质分类</h3><ul><li><strong>磁表面存储器</strong>：如磁盘、磁带等。</li><li><strong>磁心存储器半导体存储器</strong>：如 MOS 型存储器、双极型存储器。</li><li><strong>光存储器</strong>：如光盘。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355109.png" loading="lazy"></p><h3 id="1-1-3-按存储方式分类"><a href="#1-1-3-按存储方式分类" class="headerlink" title="1.1.3.按存储方式分类"></a>1.1.3.按存储方式分类</h3><ul><li><strong>随机存储器（RAM）</strong>：存储器的任何一个存储单元的内容都可以<strong>随机存取</strong>，而且<strong>存取时间与存储单元的物理位置无关</strong>；其优点是<strong>读写方便，使用灵活，主要用作主存或高速缓冲存储器</strong>；RAM 又分为<strong>静态 RAM</strong>（以触发器原理寄存信息）和<strong>动态 RAM</strong>（以电容充电原理寄存信息）。</li><li><strong>只读存储器（ROM）</strong>：存储器的内容<strong>只能随机读出而不能写入</strong>；<strong>信息一旦写入存储器就固定不变，即使断电内容也不会丢失</strong>。因此通常用它存放固定不变的程序，常数和汉字字库，甚至用于操作系统的固化。<strong>它与随机存储器可以共同作为主存的一部分，统一构成主存的地址域。</strong></li><li><strong>串行访问存储器</strong>：对存储单元进行 I&#x2F;O 操作时，<strong>需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）</strong>。</li></ul><p><strong>注意</strong>：</p><ul><li><strong>顺序存储寄存器</strong>的内容<strong>只能按照某种顺序存取</strong>，存取时间的长短与信息在存储体的<strong>物理位置</strong>有关，其特点是<strong>存储速度慢，例如：磁带；</strong></li><li><strong>直接存取存储器</strong>既不像 RAM 那样随机访问任何一个存储单元，又不像顺序存取存储器那样完全按照顺序存取，而是介于两者之间，存取信息是<strong>通常先寻找整个存储器中的某个小区域，再在小区域内顺序查找，例如：机械硬盘</strong>。</li></ul><h3 id="1-2-4-按信息的可保存性分类"><a href="#1-2-4-按信息的可保存性分类" class="headerlink" title="1.2.4.按信息的可保存性分类"></a>1.2.4.按信息的可保存性分类</h3><ul><li><strong>易失性存储器</strong>：断电后，存储的信息<strong>会消失</strong>，如 RAM；</li><li><strong>非易失性存储器</strong>：断电后，存储的信息<strong>仍然会保持</strong>，如 ROM。</li></ul><p><strong>注意：</strong></p><ul><li><strong>破坏性读出</strong>：某个存储单元所存储的信息被读出时，原存储信息被破坏；具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个<strong>再生</strong>操作，以便恢复被破坏的信息，例如：DRAM（栅极电容）。</li><li><strong>非破坏性读出</strong>某个存储单元所存储的信息被读出时，原存储信息不被破坏，例如：SRAM（双稳态触发器）。</li></ul><h2 id="1-2-多级存储系统"><a href="#1-2-多级存储系统" class="headerlink" title="1.2.多级存储系统"></a>1.2.多级存储系统</h2><p><strong>多级存储系统：为了缓解存储系统容量、速度和成本这三者之间的矛盾。在计算机系统中，存储器系统通常会采用多级结构，如下图所示，从上至下</strong>：</p><ul><li><strong>价格</strong>越来越低。</li><li><strong>速度</strong>越来越慢。</li><li><strong>容量</strong>越来越大。</li><li><strong>CPU 访问的频度</strong>越来越低。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355824.png" loading="lazy"></p><p><strong>实际上，存储系统的层次结构主要体现在 “Cache - 主存” 和 “主存 - 辅存” 这两层</strong>：</p><ul><li><strong>“Cache - 主存”</strong>：主要解决 <strong>CPU 和主存速度</strong>不匹配的问题。</li><li><strong>“主存 - 辅存”</strong>：主要解决<strong>存储系统的容量</strong>问题。</li></ul><p><strong>在多级存储系统中</strong>：</p><ul><li>Cache、主存可以和 CPU 直接交换信息。</li><li>辅存则要通过主存和 CPU 交换信息。</li><li>主存与 CPU、Cache、辅存都能交换信息。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355061.png" loading="lazy">  </p><p><strong>多级存储系统的核心思想是：让上一层的存储器作为下一层存储器的高速缓存</strong>。</p><ul><li>“<strong>Cache - 主存</strong>” 层速度接近于 Cache，容量和价位却接近于主存。</li><li>“<strong>主存 - 辅存</strong>” 层速度接近于主存，容量和价位却接近于辅存。</li></ul><p><strong>另外注意</strong>：</p><ul><li>主存和 Cache 之间的数据调动是由<strong>硬件自动完成的</strong>，对所有程序员透明。</li><li>主存和辅存之间的数据调动则是<strong>由硬件和操作系统共同完成的</strong>，对应用程序员是透明。</li></ul><h2 id="1-3-存储器性能指标"><a href="#1-3-存储器性能指标" class="headerlink" title="1.3.存储器性能指标"></a>1.3.存储器性能指标</h2><p><strong>存储器有以下三个性能指标（相互制约），通过协调这三个指标，设计者尽可能地设计大容量、低成本和高速度的存储器系统</strong>。</p><ul><li>存储容量。</li><li>单位成本。</li><li>存储速度。</li></ul><h3 id="1-3-1-存储容量"><a href="#1-3-1-存储容量" class="headerlink" title="1.3.1.存储容量"></a>1.3.1.存储容量</h3><p><strong>存储容量 &#x3D; 存储字数 × 字长（如 1M×8 位）。</strong></p><ul><li>单位换算：<strong>1B(Byte，字节)&#x3D;8b(bit，位)。</strong></li><li>存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。</li></ul><h3 id="1-3-2-单位成本"><a href="#1-3-2-单位成本" class="headerlink" title="1.3.2.单位成本"></a>1.3.2.单位成本</h3><p><strong>每位价格 &#x3D; 总成本 ÷ 总容量</strong>。</p><h3 id="1-3-3-存储速度"><a href="#1-3-3-存储速度" class="headerlink" title="1.3.3.存储速度"></a>1.3.3.存储速度</h3><p><strong>数据传输率 &#x3D; 数据的宽度 ÷ 存储周期</strong>。</p><ul><li><strong>存取时间（ $T_{a} $​）</strong>：是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li><li><strong>存取周期 ( $ T_{m} $​)<strong>：</strong>存取周期</strong>又称<strong>读写周期</strong>或<strong>访问周期</strong>。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储操作（读或写操作）之间所需的最小时间间隔。</li><li><strong>主存带宽（ $ B_{M} $）</strong>: 主存宽度又称为数据传输率，表示每秒从主存进出信息的最大容量，单位为字 &#x2F; 秒，字节 &#x2F; 秒 (B&#x2F;s) 或位 &#x2F; 秒(b&#x2F;s)。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355072.png" loading="lazy"></p><h1 id="2-主存储器"><a href="#2-主存储器" class="headerlink" title="2.主存储器"></a>2.主存储器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408552.png" alt="image-20230414140744990" loading="lazy"></p><h2 id="2-1-基本的半导体元件及原理"><a href="#2-1-基本的半导体元件及原理" class="headerlink" title="2.1.基本的半导体元件及原理"></a><a name="锚点名称">2.1.基本的半导体元件及原理</a></h2><p>在 <a href="">(计算机组成原理) 第一章计算机系统概述 - 计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这篇文章中说到：<strong>一个存储器由存储体、MAR（地址寄存器）和 MDR（数据寄存器） 构成，这三部分会在时序逻辑电路 的控制下相互配合进行工作</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408302.png" loading="lazy"></p><p><strong>存储体是用来存放二进制数据的，它由多个存储单元构成，而存储单元又有存储元构成，下图就是一个存储元，由 MOS 管和电容实现</strong>。</p><ul><li><strong>MOS 管</strong>：可以理解为一种电控开关，输入电压达到 ** 某个阈值时，**MOS 管就可以接通。</li><li><strong>电容</strong>：当产生电压差时就会充电，可以<strong>保存一定电荷</strong>。<strong>电容带电和不带电分别对应两种状态</strong>，也即二进制中的 0 和 1。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359286.png" loading="lazy"></p><p><strong>利用 MOS 管和电容可以进行如下操作</strong>：</p><ul><li><p><strong>读出二进制</strong>：假如电容有电，此时当 MOS 管接通时，<strong>电荷就可以顺着导线向 MOS 管右侧流动</strong>，当在该侧检测到电流时相当于输出了 1，反之则输出了 0  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408799.png" loading="lazy"></p></li><li><p><strong>写入二进制</strong>：在 MOS 管右侧接入电压，然后导通 MOS 管，<strong>这样电流就会从右向左流动</strong>，此时电容一端接地，于是两块板子上有电压差，<strong>电荷就会被 “装载” 进去</strong>，接着再把 MOS 管断开，这样电荷就跑不出去了 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359707.png" loading="lazy"></p></li></ul><p><strong>上述仅仅是一个存储元，如果把多个存储元按照一定方式连接，那么就能一次性读出或者写入多位数据，比如下图</strong>：</p><ul><li><p>下图中<strong>红色导线连接了每个存储元的 MOS 管</strong>，因此如果给其加上电压，就意味着所有存储元的 MOS 管都可以被导通。</p></li><li><p>当 MOS 管导通后，<strong>电容里存储的电荷就可以顺着绿色的线导出</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408417.png" loading="lazy"></p></li></ul><p><strong>于是按照上述方式就可以读出一整行存储元所存储的数据信息，而这一行其实就是存储单元（也即一个存储字），多个存储单元组合便构成了存储体</strong>。</p><ul><li>为什么存储器每次读写操作的单位是一个存储字：<strong>因为同属于一个存储字的存储元它们的 MOS 管一端接的都是同一根线。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359359.png" loading="lazy"></p><h2 id="2-2-存储器芯片的基本原理"><a href="#2-2-存储器芯片的基本原理" class="headerlink" title="2.2.存储器芯片的基本原理"></a>2.2.存储器芯片的基本原理</h2><ul><li>读出和写入的功能有了，那么下一个问题就是<strong>如何决定我们要读或者写的具体是哪一个存储字呢</strong>，这就要涉及到<strong>译码器</strong>的概念了。</li></ul><p><strong>译码器</strong>：当给出 $n$ 位地址时，<strong>这 $n$ 位地址就会对应 $2^{n} $ 个存储单元（因为是地址是二进制）</strong>，所以<strong>译码器会根据 MAR</strong>（它和 CPU 连接）里面给出的这几位地址，<strong>将其转化为某一条字选线的高电平信号。</strong></p><ul><li>例如：MAR 送过来的地址是<code>000</code>，对应十进制的 0，所以译码器会给第 0 根字选线一个高电平，<strong>此时第一个存储字对应的存储元件都会被选通</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408186.png" loading="lazy"></p><p>如下，<strong>当第 0 根字选线被接通后，就可以通过数据线（也叫位线，绿色），把每一位的二进制信息传送到 MDR 当中</strong>，然后 <strong>CPU 会通过数据总线（宽度等于存储字长）从 MDR 当中取走这一存储字的数据。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631446.png" loading="lazy">  </p><p><strong>为此，我们需要新增一个控制电路来控制 MAR、MDR 和译码器</strong>：</p><ul><li><strong>控制 MAR</strong>：当 CPU 通过地址总线把地址送入 MAR 时，由于使用的是电信号，而电信号<strong>容易紊乱</strong>，因此<strong>在 MAR 中电信号稳定之前，该地址不能被送入译码器当中</strong>。</li><li><strong>控制 MDR</strong>：和 MAR 相同，稳定时才能输出。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408664.png" loading="lazy"></p><p><strong>另外，存储芯片还需要向外提供片选线，用 $  \overline C $ $ \overline S $（芯片选择信号）或 $ \overline C $ $\overline E $（芯片使能信号）表示（横线表示低电平有效）</strong>。</p><p><strong>当然，控制电路还需要提供读控制线和写控制线</strong>：</p><ul><li><p>$ \overline W $$ \overline E $：低电平时，表示正在进行<strong>写操作</strong>，也就是要把 MDR 里保存的数据把它输入到电容中。</p></li><li><p>$ \overline O $$ \overline E$：低电平时，进行<strong>读操作。</strong></p></li><li><p>下图中读写控制线分为两根，也可以整合为一根， $ \overline W $ $\overline E $就表示<strong>低电平写，高电平读</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141403668.png" loading="lazy"></p><p><strong>最后屏蔽内部实现细节后，存储器芯片会这样表示</strong> ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141403640.png" loading="lazy"></p><p><strong>最后再次说明一下片选线的作用</strong>：下图是内存条，一个内存条由很多存储芯片组成（如果是 8G，那么每个存储芯片大概就是 1G），<strong>因此片选线就是为了操作指定的存储芯片</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141407141.png" alt="image-20230414140709086" loading="lazy"></p><p>同时上面原理图中讲到的每一根线其实就是对应了芯片的<strong>引脚</strong>。</p><ul><li><p>$n$ 位地址就对应了 $2^{n} $ 个存储单元，因此总容量 &#x3D; 存储单元个数 × 存储字长</p></li><li><p>有时我们会见到这样的描述，<strong>8×8 位的存储单元</strong>，比如 8K×8 位，就是 $2^{13}×8bit $</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408214.png" loading="lazy"></p></li></ul><h2 id="2-3-寻址"><a href="#2-3-寻址" class="headerlink" title="2.3.寻址"></a>2.3.寻址</h2><p>如下矩阵方格中每一个方格表示 8bit 的信息，<strong>每一行表示一个存储字</strong>，为 4B 大小，该矩阵共有 256 行，大小为 1KB </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141405823.png" loading="lazy"></p><p>现代计算机通常是<strong>按照字节寻址</strong>的，因此 1 个小方格就对应 1 个地址，这里有 1K 个字节那么就有 1K 个地址。既然有 1K 个地址，那么根据之前叙述，应该就有 10 根地址线（ $2^{10} $）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408887.png" loading="lazy"></p><p>虽然是按照字节编址的，但还可以按照字、半字、双字等方式寻址：</p><ul><li><strong>按字节寻址</strong>：1K 个单元，每个单元 1B。</li><li><strong>按字寻址</strong>：256 个单元，每个单元 4B。</li><li><strong>按半字寻址</strong>：512 个单元，每个单元 2B。</li><li><strong>按双字寻址</strong>：128 个单元，每个单元 8B。</li></ul><blockquote><ul><li><strong>位（bite）</strong>: 音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。</li><li><strong>字节（byte）</strong>：一个字节等于8位，即1Byte&#x3D;8bit。</li><li><strong>字</strong>：一串数码作为一个整体来处理运算，被称为一个字，字的位数称为字长，一个字通常有若干个字节，例如286微机的字由2个字节组成，它的字长为16；486微机的字由4个字节组成，它的字长为32位机。 计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。</li></ul></blockquote><h1 id="3-SRAM芯片和DRAM芯片"><a href="#3-SRAM芯片和DRAM芯片" class="headerlink" title="3.SRAM芯片和DRAM芯片"></a>3.SRAM芯片和DRAM芯片</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141618171.png" loading="lazy"></p><p><strong>本节会在上节的基础上，介绍两种重要的存储器芯片：DRAM 和 SRAM</strong>。</p><ul><li><strong>DRAM(Dynamic-Random- Access -Memory)：动态 DRAM，主要用于主存。</strong></li><li><strong>SRAM(Static- Random -Access -Memory)：静态 RAM，主要用于 Cache</strong>。</li></ul><p><strong>注意</strong>：DRAM 芯片已经过时了，现在主存通常采用 SDRAM（如 DDR3 和 DDR4）。</p><h2 id="3-1-存储器元件不同导致的特性差异"><a href="#3-1-存储器元件不同导致的特性差异" class="headerlink" title="3.1.存储器元件不同导致的特性差异"></a>3.1.存储器元件不同导致的特性差异</h2><p>上一节介绍的芯片实则就是 <strong>DRAM 芯片</strong>，主要被用于制作主存。<strong>其实 DRAM 芯片和 SRAM 芯片的核心区别点就在于他们的存储元制作材料不一样。</strong></p><ul><li><p><strong>DRAM</strong>：使用<strong>栅极电容</strong>。</p></li><li><p><strong>SRAM</strong>：使用<strong>双稳态触发器</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619753.png" loading="lazy"></p></li></ul><h3 id="3-1-1-栅极电容"><a href="#3-1-1-栅极电容" class="headerlink" title="3.1.1.栅极电容"></a>3.1.1.栅极电容</h3><p><strong>栅极电容：当给字选择线一高电平时，MOS 管会接通，然后给数据线一高电平，由于电容一端接地，因此电容板之间产生电压差，于是电荷被 “写入” 电容</strong>。</p><ul><li><strong>1</strong>：表示电容内<strong>存储</strong>了电荷。</li><li><strong>0</strong>：表示电容内<strong>未存储</strong>电荷。</li></ul><p><strong>在读出时，如果电容里面有电荷，那么当 MOS 管接通后，一定会在数据线位置检测到电流信号，反之则不会，分别对应数据 1 和数据 0。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619128.png" loading="lazy"></p><h3 id="3-1-2-双稳态触发器"><a href="#3-1-2-双稳态触发器" class="headerlink" title="3.1.2.双稳态触发器"></a>3.1.2.双稳态触发器</h3><ul><li><strong>关于双稳态触发器具体原理请点击链接跳转</strong>：<a href="http://www.360doc.com/content/19/0827/18/2289804_857407763.shtml">双稳态触发器</a>。</li></ul><p><strong>双稳态触发器：是一种具有记忆功能的逻辑单元电路，它能储存一位二进制码。它有两个稳定的工作状态，在外加信号触发下电路可从一种稳定的工作状态转换到另一种稳定的工作状态</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619373.png" loading="lazy"></p><p><strong>相比栅极电容，双稳态触发器有两根数据线。当给字选择线一高电平信号后</strong>：</p><ul><li><strong>如果里面存储的是 1</strong>，那么将会在 BLX 这条线上输出低电平信号（左边没有）。</li><li><strong>如果存储的是 0</strong>，那么将会在 BL 这条线上输出低电平信号（右边没有）。</li></ul><p><strong>同时在写入时</strong>：</p><ul><li><strong>如果要写入数据 0</strong>：那么只需要给 BL 一<strong>低电平信号</strong>，同时给 BLX 一<strong>高电平信号</strong>。</li><li><strong>如果要写入数据 1</strong>，那么只需要给 BL 一<strong>高电平信号</strong>，同时给 BLX 一<strong>低电平信号。</strong></li></ul><h3 id="3-1-3-SRAM-和-DRAM-对比"><a href="#3-1-3-SRAM-和-DRAM-对比" class="headerlink" title="3.1.3.SRAM 和 DRAM 对比"></a>3.1.3.SRAM 和 DRAM 对比</h3><p><strong>关于读写速度</strong>：</p><ul><li><strong>DRAM 使用栅极电容的充放电来完成读写操作</strong>：电容的物理特性就决定了其充放电是一种<strong>破坏性读出</strong>，读出后应该<strong>有重写操</strong>作，也就是需要重新充电，也称之为<strong>再生</strong>，读写<strong>速度较慢</strong>。</li><li><strong>SRAM 使用双稳态触发器</strong>：在读写数据时，触发器的状态是<strong>保持稳定的</strong>，因此属于<strong>非破坏性读出</strong>，无需进行<strong>重写操作</strong>，读写速度<strong>也就更快。</strong></li></ul><p><strong>2：关于成本和功耗</strong></p><ul><li><strong>DRAM</strong>：单个存储元制造成本<strong>低</strong>，集成度<strong>高</strong>，功耗<strong>低。</strong></li><li><strong>SRAM</strong>：单个存储元制造成本更<strong>高</strong>，集成度<strong>低</strong>，功耗<strong>大</strong>。</li></ul><p><strong>3：其它区别</strong></p><table><thead><tr><th>类型 / 特点</th><th>SRAM（静态 RAM）</th><th>DRAM（动态 RAM）</th></tr></thead><tbody><tr><td><strong>存储原理</strong></td><td>触发器</td><td>电容</td></tr><tr><td><strong>是否是破坏性读出</strong></td><td>否</td><td>是</td></tr><tr><td><strong>是否需要重写</strong></td><td>否</td><td>是</td></tr><tr><td><strong>运行速度</strong></td><td>快</td><td>慢</td></tr><tr><td><strong>集成度</strong></td><td>低</td><td>高</td></tr><tr><td><strong>发热量</strong></td><td>大</td><td>小</td></tr><tr><td><strong>成本</strong></td><td>高</td><td>低</td></tr><tr><td><strong>是否是易失性存储器</strong></td><td>是</td><td>是</td></tr><tr><td><strong>是否需要 “刷新”</strong></td><td>否</td><td>是</td></tr><tr><td><strong>送行列地址</strong></td><td>同时送</td><td>分两次</td></tr><tr><td><strong>用途</strong></td><td>Cache</td><td>主存</td></tr></tbody></table><ul><li>刷新：<strong>电容里面的电荷不能永久存在</strong>，一般只能维持 2ms，因此即使不断电，2ms 后信息也会丢失，因此对于 DRAM 需要 “刷新”，也就是再充电；而 SRAM 只要不断电，触发器的状态就不会改变。</li></ul><h2 id="3-2-DRAM-的刷新"><a href="#3-2-DRAM-的刷新" class="headerlink" title="3.2.DRAM 的刷新"></a>3.2.DRAM 的刷新</h2><h3 id="3-2-1-译码器需要使用行列地址"><a href="#3-2-1-译码器需要使用行列地址" class="headerlink" title="3.2.1.译码器需要使用行列地址"></a>3.2.1.译码器需要使用行列地址</h3><p>上一节说到了译码器的作用：<strong>把某一位的地址，转化为相应的选通线的高电平信号， $n$位地址就对应 $2^{n} $ 个选通线。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622269.png" loading="lazy"></p><p><strong>当地址数变多时，选通线数量级将会非常大</strong>，例如仅 20 个地址就需要 $ 2^{20}&#x3D;1 048 576 $ 根选通线，这已接近百万了。</p><p><strong>解决方法就是：将原来的单纯的一维的地址，改变为行列地址，也就是一个矩阵，分别交给行地址译码器和列地址译码器管理，这样的话每个译码器只需处理一半的地址信息，也就是 1024 根选通线</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622248.png" loading="lazy"></p><p>例如地址<code>0000</code> <code>0000</code>，如果采用之前的方案，那么经过译码器译码后，第 0 根选通线会被选中 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622141.png" loading="lazy"></p><p>而如果采用行列译码器的方案，<strong>地址<code>0000</code> <code>0000</code>的低四位将会交给列地址译码器，高四位将会交给行地址译码，每个存储单元只有列选通线和行选通线同时被选中时才能被选中</strong>，因此<code>(1,1)</code>位置的存储单元此时会被选中。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622038.png" loading="lazy">  </p><p><strong>对于八位地址，原本需要使用 $2^{8}&#x3D;256 $ 根选通线，而现在只需要$2^{4}+2^{4}&#x3D;16+16&#x3D;32$根选通线，所以使用行列地址的本质就是要减少选通线数量</strong>。</p><h3 id="3-2-2-分散刷新、集中刷新和异步刷新"><a href="#3-2-2-分散刷新、集中刷新和异步刷新" class="headerlink" title="3.2.2.分散刷新、集中刷新和异步刷新"></a>3.2.2.分散刷新、集中刷新和异步刷新</h3><h4 id="3-2-2-1-DRAM-刷新"><a href="#3-2-2-1-DRAM-刷新" class="headerlink" title="3.2.2.1.DRAM 刷新"></a>3.2.2.1.DRAM 刷新</h4><p><strong>关于 DRAM 的刷新，这里有 4 个问题需要回答</strong>：</p><ul><li><strong>多久刷新一次</strong>：一般为 2ms。</li><li><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元。</li><li><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用 1 个读写周期。</li><li><strong>什么时候刷新</strong>：分散刷新、集中刷新和异步刷新（接下来介绍）。</li></ul><h4 id="3-2-2-2-分散刷新、集中刷新和异步刷新特点"><a href="#3-2-2-2-分散刷新、集中刷新和异步刷新特点" class="headerlink" title="3.2.2.2.分散刷新、集中刷新和异步刷新特点"></a>3.2.2.2.分散刷新、集中刷新和异步刷新特点</h4><p>假设 DRAM 内部结构排列形式为 128×128，存储周期为 0.5 $us $，电容最多坚持 2ms，因此对应 2ms&#x2F;0.5 $us $&#x3D;4000 个周期，有 128 行，刷新每一行都需要 0.5 $us $，同时注意以下内容：</p><ul><li>刷新对 CPU 是透明的，也即<strong>刷新不依赖于外部的访问</strong>。</li><li>DRAM 刷新单位是行，因此<strong>刷新操作时仅需要行地址。</strong></li><li>刷新操作类似于读操作，但又有所不同：<strong>刷新操作仅给栅极电容补充电荷，不需要信息输出，另外刷新时不需要进行选片，即整个存储器中的所有芯片同时被刷新。</strong></li></ul><p>一共有<strong>分散刷新、集中刷新和异步刷新</strong>这三种方式：</p><ul><li><p><strong>分散刷新</strong>：把对每行的刷新分散到各个工作周期当中，这样，一个存储器的系统工作周期就分为了两个部分，<strong>前半部分用于正常读写或保持；后半部分用于刷新某一行</strong>。这种刷新方式增加了系统的存取周期，增加为 1 $us $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622334.png" loading="lazy"></p></li><li><p><strong>集中刷新</strong>：<strong>是指利用一段固定的时间，依次对存储器的所有行进行逐一再生，存储周期不变</strong>，在刷新期间内会停止对存储器的访问，因此称之为 “死时间”，又称访存 “死区” 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141623410.png" loading="lazy"></p></li><li><p><strong>异步刷新</strong>：它是前两种刷新方式的结合。<strong>具体做法是用刷新周期除以行数，得到两次刷新操作之间的时间间隔 t（2ms&#x2F;128&#x3D;15.6 $us $）</strong>，接着利用逻辑电路每隔该时间间隔 t(15.6 $us $) 产生一次刷新请求，因此每 15.6 $us $ 内会有 0.5 $us $ 的死时间。所以死时间会分散在整个过程中，而且可以在译码阶段刷新 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632079.png" loading="lazy"></p></li></ul><h4 id="3-2-2-3-分散刷新、集中刷新和异步刷新优缺点"><a href="#3-2-2-3-分散刷新、集中刷新和异步刷新优缺点" class="headerlink" title="3.2.2.3.分散刷新、集中刷新和异步刷新优缺点"></a>3.2.2.3.分散刷新、集中刷新和异步刷新优缺点</h4><p><strong>集中刷新</strong>：</p><ul><li><strong>优点</strong>：读写操作不受刷新工作的影响，因此系统的<strong>存取速度较高</strong>。</li><li><strong>缺点</strong>：是在集中刷新期间（死区）不能访问存储器。</li></ul><p><strong>分散刷新</strong>：</p><ul><li><strong>优点</strong>：是<strong>没有死区。</strong></li><li><strong>缺点</strong>：是加长了系统的存取周期<strong>降低了整体速度。</strong></li></ul><p><strong>异步刷新</strong>：综合最优。</p><ul><li>可以避免使 CPU 连续等待过长的时间，而且减少了刷新次数，从根本上<strong>提高了整机的工作效率</strong>；</li><li>同时如果将刷新安排在不需要访问存储器的译码阶段，则<strong>既不会加长存取周期，又不会产生 “死时间”</strong>，这是分散刷新的方式的发展，也称之为 “<strong>透明刷新</strong>”。</li></ul><h2 id="3-3-DRAM-的地址线复用技术"><a href="#3-3-DRAM-的地址线复用技术" class="headerlink" title="3.3.DRAM 的地址线复用技术"></a>3.3.DRAM 的地址线复用技术</h2><ul><li>前面说过 SRAM 需要同时送行列地址，也即<strong>行列地址信息会同时丢给行译码器和列译码器。</strong></li></ul><p>而 DRAM 由于用于主存，所以容量可能较大，因此地址线可能也会更多，<strong>所以为了使地址线电路变得更简单，会采用一种地址线的复用技术，也就是分两次送。</strong></p><p><strong>这种技术可以使行列地址分两次前后进行传送，传送时只需要一半地址，先传送至缓冲区，再传送给译码器即可，这样会使地址线更少</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703887.png" loading="lazy"></p><h1 id="4-只读存储器"><a href="#4-只读存储器" class="headerlink" title="4.只读存储器"></a>4.只读存储器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141625901.png" alt="image-20230414162516788" loading="lazy"></p><h2 id="4-1-只读存储器（ROM）特点"><a href="#4-1-只读存储器（ROM）特点" class="headerlink" title="4.1.只读存储器（ROM）特点"></a>4.1.只读存储器（ROM）特点</h2><p><strong>只读存储器（ROM）：前文说到的 SRAM 和 DRAM 都属于 RAM 芯片，RAM 芯片属于数据易失性芯片，断电后数据将会消失。但很多情况下需要对数据进行长期保存，所以就要使用到 ROM 芯片。它有两个显著的特点</strong>：</p><ul><li>结构简单，所以位密度比可读存储器的高。</li><li>具有非易失性，可靠性高。</li></ul><h2 id="4-2-ROM-的类型"><a href="#4-2-ROM-的类型" class="headerlink" title="4.2.ROM 的类型"></a>4.2.ROM 的类型</h2><ul><li><strong>掩模式只读存储器（MROM）</strong>：MROM 的内容由<strong>半导体制造厂家按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人无法改变其内容</strong>。优点是<strong>可靠性高、集成度高、价格便宜</strong>；缺点则是灵活性差。</li><li><strong>一次可编程只读存储器（PROM）</strong>：PROM 是可以实现一次性编程的只读存储器，允许用户<strong>利用专门的设备写入自己的程序</strong>，一旦写入，内容无法改变。</li><li><strong>可擦除可编程只读存储器（EPROM）</strong>：EPROM <strong>可以让用户利用编程器写入信息，而且内容也可以进行多次改写</strong>。如果需要修改 EPROM 内容，则先将其全部内容擦除，然后再编程。EPROM 又可以分为<strong>紫外线擦除（UVEPROM）</strong>和电擦除<strong>（$E  ^{2} PROM$）</strong>。EPROM 虽然既可以读又可以写，但是它不能取代 RAM，因为 EPROM 的编程次数有限，且写入时间过长。</li><li><strong>闪存存储器（Flash Memory）</strong>：Flash Memory 是在 EPROM 与 $E  ^{2} PROM$ 的基础上发展起来的，其主要特点是<strong>即可以在不加电的情况下长期保存信息，又能在线进行快速擦除和重写</strong>。需要注意的是<strong>闪存需要先擦除再写入，因此闪存的写速度要比读速度更慢</strong>。</li><li><strong>固态硬盘（SSD）</strong>：基于闪存，<strong>由控制单元和存储单元组成</strong>。保留了闪存长期保存信息，快速擦除与重写的特性。对比传统的硬盘也具有读写速度快，功耗低，其缺点就是价格高。</li></ul><h2 id="4-3-计算机内的重要-BIOS"><a href="#4-3-计算机内的重要-BIOS" class="headerlink" title="4.3.计算机内的重要 BIOS"></a>4.3.计算机内的重要 BIOS</h2><p><strong>BIOS：是计算机主板一个非常重要的 ROM 芯片，它存储了 “自举装入程序”，负责引导装入操作系统，进行开机操作。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141633488.png" alt="如何在BIOS中设置USB第一启动项_AwardBIOS" loading="lazy"></p><h1 id="5-主存储器和CPU的连接"><a href="#5-主存储器和CPU的连接" class="headerlink" title="5.主存储器和CPU的连接"></a>5.主存储器和CPU的连接</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141634276.png" loading="lazy"></p><p><strong>现代计算机中，MAR 和 MDR 通常集成在 CPU 的内部，而存储芯片内的仅是一个普通的寄存器。主存储器与 CPU 的连接示意图如下</strong>：</p><ul><li>主存储器通过<strong>数据总线、地址总线和控制总线</strong>与 CPU 连接。</li><li>数据总线的位数与工作频率的乘积正比于<strong>数据传输率。</strong></li><li><strong>地址总线的位数</strong>决定了可寻址的最大内存空间。</li><li><strong>控制总线</strong>（读或写）指出总线周期的类型和本次输入输出操作完成的时刻。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703006.png" loading="lazy"></p><h2 id="5-1-单块存储芯片与-CPU-的连接"><a href="#5-1-单块存储芯片与-CPU-的连接" class="headerlink" title="5.1.单块存储芯片与 CPU 的连接"></a>5.1.单块存储芯片与 CPU 的连接</h2><p>下图是前文中讲到过的一<strong>单个存储芯片的内部构造</strong>（<a href="#锚点名称">2.1.基本的半导体元件及原理</a>），它和 CPU 通过以下总线连接（<strong>具体过程会在 “二：多块存储芯片与 CPU 的连接 -（1）位扩展 -①：单个连接” 中进行描述</strong>）。</p><ul><li><strong>数据总线（绿色线）</strong>：用于传送数据。</li><li><strong>地址总线（红色线）</strong>：用于传送地址。</li><li><strong>控制总线（橙色线）</strong>：用于发出控制信号。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703643.png" loading="lazy"></p><h2 id="5-2-多块存储芯片与-CPU-的连接"><a href="#5-2-多块存储芯片与-CPU-的连接" class="headerlink" title="5.2.多块存储芯片与 CPU 的连接"></a>5.2.多块存储芯片与 CPU 的连接</h2><p><strong>上图展示的只是一个 8×8 位的存储芯片，仅能存储 8B 的数据，所以会存在以下问题</strong>：</p><ul><li>问题一：存储字长为 8 位，也即 CPU 一次只能读或写 8 位，而现代计算机数据总线宽度至少是 64 位，严重不匹配。因此问题在于如何<strong>增加存储字长，使 CPU 一次能读或写多位数据</strong> （对应<strong>位扩展</strong>）。</li><li>问题二：只有 8 个地址，地址数目太少。因此问题在于如何<strong>扩展地址空间，使地址数目变多</strong>（对应<strong>字扩展</strong>）。</li></ul><p><strong>这里，为了后续描述方便，为一块存储芯片的输入输出信号进行命名</strong>：</p><ul><li><strong>地址线</strong>：有可能输入多位的地址，因此地址用$A_{n} $表示， $n$从 0 开始，表示从地址低位到地址高位</li><li><strong>数据线</strong>：用 $ D_{n} $表示， $n$从 0 开始，表示从数据低位到数据高位。</li><li><strong>片选线</strong>：片选信号通常用 $\overline C\overline S $ 或 $ \overline C\overline E $ 表示，其中的横线表示低电平有效，高电平无效。</li><li><strong>读写控制线</strong>：该信号用 $\overline W\overline E $ 或 $ \overline W\overline R $ 表示，其中的横线表示低电平写，高电平读。（注意有些地方也可能将读写分开，分别为 $\overline O\overline E $ 或 $ \overline W\overline E $，低电平表示有效，高电平无效）。</li></ul><h3 id="5-2-1-位扩展"><a href="#5-2-1-位扩展" class="headerlink" title="5.2.1.位扩展"></a>5.2.1.位扩展</h3><h4 id="5-2-1-1-单个连接"><a href="#5-2-1-1-单个连接" class="headerlink" title="5.2.1.1.单个连接"></a><a name="5.2.1.1.单个连接">5.2.1.1.单个连接</a></h4><p>下图是买来的一块 8K×1 位的存储芯片。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703104.png" loading="lazy"></p><p>该存储芯片有 8K 个存储单元，由于 $ 2^{13}&#x3D;8192 $，这意味着至少需要 <strong>13 根地址线</strong>才能表示这么多地址，<strong>因此该存储芯片要向外暴露出 13 个地址引脚</strong>，然后 CPU 会把它想要访问的地址通过<strong>地址总线</strong>送过来。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703711.png" loading="lazy"></p><p>左下角的 “ $W E $” 表示<code>Write Enable</code>，上方没有横线，那么就表示<strong>低电平读、高电平写</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703778.png" loading="lazy"></p><p>上图显示 CPU 一次是可以读写 8 位数据的，<strong>但是由于存储芯片字长的限制，所以一次最多只能进行一位</strong>，这导致数据总线没有被充分利用。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703722.png" loading="lazy"></p><p>还有一个片选线 $C S$ ，表示高电平有效，这里暂时先给一个高电平，具体作用后面会说。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703968.png" loading="lazy">  </p><p>至此，单个芯片的连接已经完成了。<strong>但是由于存储字长为 1，一次只能读写一位数据，所以数据总线利用率很差</strong>，因此在这种情况下可以进行<strong>位扩展</strong>。</p><h4 id="5-2-1-2-多个连接"><a href="#5-2-1-2-多个连接" class="headerlink" title="5.2.1.2.多个连接"></a>5.2.1.2.多个连接</h4><p>接着又买到了一个和上面相同规格的存储芯片。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703307.png" loading="lazy"></p><p>对于地址线，<strong>我们从刚才连接的每一个地址线分别分流出一根线连接到该存储芯片的引脚上，这意味着一个地址可以同时选中两个存储单元。</strong></p><p>对于读写控制线也是这样连接，这意味着它们是<strong>同时读或者同时写</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703345.png" loading="lazy"></p><p>对于数据线，<strong>该存储芯片的引脚可以连接在 CPU 的$D_{1} $位置</strong>。</p><p>最后，也给片选$CS $ 线给一高电平。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703536.png" loading="lazy"></p><p>至此，两块芯片连接完成。现在，<strong>从整体上看存储字长被扩展为了 2 位，也即可以同时读或写两位的信息了</strong>。</p><p>最后，再买来 6 块芯片，连接好即可。</p><ul><li><p>每块芯片都有 8 个存储单元，CPU 发出的 $A_{0}$$A_{12} $的这 13 位的地址信息会同时送给 8 片存储芯片 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703902.png" loading="lazy"></p></li></ul><h3 id="5-2-2-字扩展"><a href="#5-2-2-字扩展" class="headerlink" title="5.2.2.字扩展"></a>5.2.2.字扩展</h3><h4 id="5-2-2-1-线选法"><a href="#5-2-2-1-线选法" class="headerlink" title="5.2.2.1.线选法"></a>5.2.2.1.线选法</h4><p>如下是买来的一块 8K×8 位的存储芯片 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703763.png" loading="lazy"></p><p>单个芯片的连接过程同 “<a href="#5.2.1.1.单个连接">5.2.1.1.单个连接</a>”，可自行研究。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703177.png" loading="lazy"></p><p>这个芯片明显不需要进行位扩展。但其问题在于：<strong>此 CPU 的寻址能力很大，可以达到$ 2^{16} $，但却只利用了其中一部分，有 3 位没有被利用，所以在这情况下就要采用字扩展的方式来解决问题。</strong></p><p>再买来一块相同规格的存储芯片，先采用之前的位扩展的规则进行连接，如下图：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703432.png" loading="lazy">  </p><p>可以发现采用这种方式连接将会产生很大的问题：<strong>两块芯片会被同时选中，比如读数据时，两块存储芯片的 8 位数据会同时传给 CPU，因此存在数据冲突</strong>。</p><p><strong>解决方法就在于片选信号$CS $。现在，将 $ A_{13}$​连接到左边存储芯片的片选信号$CS $ 上，将 $ A_{14}$连接到右边存储芯片的片选信号$CS $ 上。由于是高电平有效，因此当地址位为 1 时表示该存储芯片工作。</strong></p><p><strong>$ A_{13}$​和 $ A_{14}$只有两位，故取值只会有四种情况：01、10、11、00</strong>。</p><ul><li><p><strong>如果是 01（注意 $ A_{14}$是 0 $ A_{13}$​是 1， $ A_{14}$是地址高位）</strong>：此时左边芯片工作，右边片不工作。因此现在 <strong>CPU 提供的这 13 位的地址只会读取左边存储芯片对应的 8 位的数据</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703773.png" loading="lazy"></p></li><li><p><strong>如果是 10</strong>：此时右边芯片工作，左边芯片不工作；因此现在 <strong>CPU 提供的这 13 位的地址只会读取右边存储芯片对应的 8 位的数据</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703922.png" loading="lazy"></p></li><li><p><strong>如果是 11 或 00</strong>：这种情况又会出现刚才的矛盾，因此<strong>不能出现</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703111.png" loading="lazy"></p></li></ul><p><strong>这样操作后，芯片所表示的地址范围会发生改变</strong>：</p><ul><li><strong>左边芯片</strong>：010 0000 0000 0000~011 1111 1111 1111。</li><li><strong>右边芯片</strong>：100 0000 0000 0000~101 1111 1111 1111。</li></ul><p><strong>这种连接方法称之为 “线选法”，其缺点在于以 00 和 11 开头的地址是不能用的。</strong></p><ul><li>注意：不是仅有两个地址，是以 00 和 11 开头的所有地址均不可用，其数量是相当多的。</li></ul><h4 id="5-2-2-2-译码片选法"><a href="#5-2-2-2-译码片选法" class="headerlink" title="5.2.2.2.译码片选法"></a>5.2.2.2.译码片选法</h4><ul><li><strong>译码片选法会在线选法的基础上做一定改进，只需要加入一个非门。</strong></li></ul><p><strong>以 $ A_{13}$​为例，让它分别连接左边芯片和右边芯片的片选信号$CS $ 上，但是在第二个线路中加入一个非门，这样当 $ A_{13}$​为 1 时，左边会被选中，右边由于非门的取反作用会变为不工作</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703041.png" loading="lazy"></p><p>这样的话，<strong>左边芯片的地址范围就为：10 0000 0000 0000~11 1111 1111 1111；右边的则为：00 0000 0000 0000 ~01 1111 1111 1111，整个主存地址空间是连续的。</strong></p><p>上面用到的非门叫做 “<strong>1-2 译码器</strong>”，这种方法叫做<strong>译码片选法</strong>，<strong>如果 CPU 有 n 条多余的片选线，那么他可以对应 $2^{n} $ 个片选信号。</strong></p><ul><li>译码器编号：1-2 译码器是输入 1 个对应 2 个，2-4 译码器是输入两个对应 4 个，以此类推。</li></ul><p>讲完上面的操作，现在可以使用真正使用字扩展了。<strong>这里采用一个 2,4 译码器，也就是输入两个信号，输出 4 个信号，接着加入 4 个 8×8 位的存储芯片，每块存储芯片都会接受 CPU 发过来的低 13 位的地址信息</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703842.png" loading="lazy"></p><ul><li>注意上方图片中，每个存储芯片所有的地址信息都是直接来自于 CPU 的，不是从左边相邻的芯片传递过来的，这里是这样画只是为了整洁。</li><li>在电路图中，当需要表示低电平有效时，通常会在上面画一个 “小圆”。</li></ul><p>当 $ A_{13}$​， $ A_{14}$为均为 0 时，就表示第一根线为 1，剩余为 0，但是经过译码器后，由于是取反，所以第一根为 0，其余为 1，而正好 0 表示存储芯片工作，所以这种情况第一个存储芯片工作，其余不工作 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703002.png" loading="lazy">  </p><p>类似的，当 $ A_{13}$​为 1， $ A_{14}$为 0 时，就表示第二根线为 1，剩余为 0，但是经过译码器后，由于是取反，所以第二根为 0，其余为 1，而正好 0 表示存储芯片工作，所以这种情况就表示第二个存储芯片工作，其余不工作 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703889.png" loading="lazy">  </p><p>因此：</p><p><strong>要访问第一块存储芯片，就要保证 $ A_{13}$​为 0， $ A_{14}$为 0，此时地址范围为：<code>000 0000 0000 0000 到 001 1111 1111 1111</code><br>要访问第二块存储芯片，就要保证 $ A_{13}$​为 1， $ A_{14}$为 0，此时地址范围为：<code>010 0000 0000 0000 到 011 1111 1111 1111</code><br>要访问第三块存储芯片，就要保证 $ A_{13}$​为 0， $ A_{14}$为 1，此时地址范围为：<code>100 0000 0000 0000 到 101 1111 1111 1111</code><br>要访问第四块存储芯片，就要保证 $ A_{13}$​为 1， $ A_{14}$为 1，此时地址范围为：<code>110 0000 0000 0000 到 111 1111 1111 1111</code></strong></p><p><strong>所以这样的操作就能保证主存地址范围从全 0 到全 1，而且是连续的</strong>。</p><p>另外还需要注意的是，考试时可能不会是连续的 $ A_{13}$​和 $ A_{14}$，有可能是 $ A_{13}$​和 $ A_{15}$，<strong>但是无论怎么样，只要不选中，就不影响选片操作，是 0 是 1 不用管，只看选中的那几位</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703422.png" loading="lazy"></p><p>最后，这里的 $ A_{15}$没有被启用，如果要使用的话那么就需要一个 3-8 译码器，然后再增加 4 个相同规格的存储芯片即可。</p><h4 id="5-2-2-3-字位同时扩展"><a href="#5-2-2-3-字位同时扩展" class="headerlink" title="5.2.2.3.字位同时扩展"></a>5.2.2.3.字位同时扩展</h4><p>位扩展可以使得存储芯片的字长变得更长，从而更好的发挥<strong>数据总线的传输能力</strong>；字扩展可以增加存储器的存储字数，从而更好利用 <strong>CPU 的寻址能力</strong>。既然二者都有的优点，那么就可以将它们综合起来，这种方法就是<strong>字位同时扩展。</strong></p><p>如下图有 8 块芯片，共有 4 组，每组两块，每组芯片实现了位扩展。</p><ul><li>前面的可以连接 $D_{0}-D_{3} $​, 后面的可以连接前面的可以连接$D_{4}-D_{7}$。</li></ul><p>这是一个 16K 的存储芯片，因此将 $A_{0}-A_{13} $作为片内地址， $ A_{14}-A_{15} $介入 2,4 译码器（因为有 4 组）。<strong>一个芯片是 16K×4 位，一组就是 16K×8 位，整体就是 64×8 位。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703507.png" loading="lazy"></p><h2 id="5-3-译码器-补充知识点"><a href="#5-3-译码器-补充知识点" class="headerlink" title="5.3.译码器(补充知识点)"></a>5.3.译码器(补充知识点)</h2><p>1：需要注意的是片选信号和译码器要配合使用，一定要注意是高电平有效还是低电平有效 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702454.png" loading="lazy">  </p><p>2：译码器往往还有一个 (还有可能是多个) 和$CS $ 类似功能的控制端，叫做使能端，即$EN $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702965.png" loading="lazy"></p><ul><li>下面两个必须是低电平，上面必须是高电平才能工作。如果是其他非法状态，译码器右侧输出将会是全 1。</li></ul><p>3：在实际场景中，CPU 上还会有一个 MREQ（访问存储器的控制信号），CPU 会通过它来控制访问存储器。如下，只有当 MREQ 发出高电平时，经过非门，变为低电平后，译码器使能端变为低电平，此时译码器工作，地址才会被映射。</p><ul><li>之所以 CPU 需要控制，是因为这些地址信息都是电信号，开始时电信号是不稳定的，因此需要等稳定后才能 “打开” 译码器。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702120.png" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702333.png" loading="lazy">  </p><p>4：注意 74ls138</p><h1 id="6-双端口RAM和多模块存储器"><a href="#6-双端口RAM和多模块存储器" class="headerlink" title="6.双端口RAM和多模块存储器"></a>6.双端口RAM和多模块存储器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141716857.png" alt="image-20230414171604726" loading="lazy"></p><p>之前在<a href="">存储器分类、多级存储系统和存储器性能指标</a> 这篇文章中讲到了存取周期的概念：：<strong>存取周期又称读写周期或访问周期，它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储操作（读或写操作）之间所需的最小时间间隔</strong>。对于 DRAM芯片，它的恢复时间是比较长的，有时有可能会到达存取周期的几倍，而现代计算机 CPU 通常都是多核的，<strong>那么这么多 CPU 核心究竟应该怎样访问主存才能解决恢复时间过长带来的问题呢</strong>？主要有两种思路：</p><ul><li>双端口 RAM。</li><li>多模块存储器。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702109.png" loading="lazy"></p><p><strong>双端口 RAM：是指同一个存储器有左右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。该项技术可以优化多核 CPU 访问一根内存条的速度</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702087.png" loading="lazy"></p><p><strong>两个端口对同一主存操作时无外乎有以下四种情况</strong>：</p><ul><li><strong>两个端口不同时对同一地址单元读出数据</strong>：没有错误。</li><li><strong>两个端口同时对同一地址单元读出数据</strong>：没有错误。</li><li><strong>两个端口同时对同一地址单元写入数据</strong>：发生写入错误。</li><li><strong>两个端口同时对同一地址单元操作，一个写入，一个读出</strong>：发生读出错误。</li></ul><p>其解决方法为：<strong>置 “忙” 信号 $ \overline B\overline U\overline S\overline Y $为 0</strong>，由判断逻辑决定暂时关闭一个端口（延时）。<strong>未被关闭的端口正常访问，被关闭的延长一个很短的时间段后再访问。</strong></p><p><strong>多模块存储器：多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。有两种编址方式</strong>：</p><ul><li><strong>高位交叉编址</strong>。</li><li><strong>低位交叉编址。</strong></li></ul><h2 id="6-1-高位交叉编址"><a href="#6-1-高位交叉编址" class="headerlink" title="6.1.高位交叉编址"></a>6.1.高位交叉编址</h2><p><strong>高位交叉编址：高位地址表示体号，低位地址为体内地址。在这种编址方式下，总是把低的体内地址送到由高位体号所确定的模块内进行译码。访问一个连续的主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU 总是按顺序访问存储模块，存储模块不能并行访问，因此不能提高存储器的吞吐率。</strong></p><p>如下图，存储器共有 4 个模块 $ M_{0}-M_{3} $（可以将其理解为 “4 根内存条”），按照这种方式编址后，<strong>地址前两位（高位）表示的是某根内存条，后面部分（低位）表示的是该内存条中的具体地址</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702942.png" loading="lazy"></p><p>假设每个存储体的存取周期为 $T$，存取时间为 $r$，且 T&#x3D;4r。如果多体存储器采用高位交叉编址，那么 CPU 真正花在读数据上的时间只有 $r$，但却要再花费 3r 的时间用来等待，效率不高。<strong>也就是说连续读取 $n$个存储字，就要耗时 $ nT $</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702048.png" alt="image-20230414170230959" loading="lazy"></p><h2 id="6-2-低位交叉编址"><a href="#6-2-低位交叉编址" class="headerlink" title="6.2.低位交叉编址"></a>6.2.低位交叉编址</h2><p><strong>低位交叉编址：低位地址表示体号，高位地址为体内地址。在这种编址方式下，总是把高位的体内地址送到由低位体号所确定的模块内进行译码。程序连续存放在相邻的模块中，将采用此编址方式的存储器称为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器带宽</strong>。</p><p>如下图，存储器共有 4 个模块$ M_{0}-M_{3}$（可以将其理解为 “4 根内存条”），<strong>每个模块的模块号 &#x3D; 单元地址 %4</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632277.png" loading="lazy"></p><p>**采用低位交叉编址的存储器连续读取 $n$个存储字，耗时为 $ T+(n-1)r $<strong>。CPU 每经过时间 $r$ 后会启动下一模块，</strong>因此交叉存储器要求其模块数必须大于等于 $\frac{T}{r} $**，以保证某模块后经过$ T $ 时间后再次启动该模块时，其上次的存取周期已到（也就是已经恢复） 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632248.png" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632896.png" loading="lazy"></p><h1 id="7-磁盘存储器（磁盘的基本结构，磁盘阵列）"><a href="#7-磁盘存储器（磁盘的基本结构，磁盘阵列）" class="headerlink" title="7.磁盘存储器（磁盘的基本结构，磁盘阵列）"></a>7.磁盘存储器（磁盘的基本结构，磁盘阵列）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141717032.png" alt="image-20230414171734928" loading="lazy"></p><h2 id="7-1-磁盘存储器"><a href="#7-1-磁盘存储器" class="headerlink" title="7.1.磁盘存储器"></a>7.1.磁盘存储器</h2><p><strong>计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。所谓 “磁表面存储”，是把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。</strong></p><p><strong>磁表面存储器有以下优点</strong>：</p><ul><li>存储容量大，价位低。</li><li>记录介质可以重复使用。</li><li>记录信息可以长期保存而不丢失，甚至可以脱机存档。</li><li>非破坏读出，读出时不需要再生。</li></ul><p><strong>磁表面存储器有以下缺点</strong>：</p><ul><li>存取速度慢。</li><li>机械结构复杂。</li><li>对环境要求较高。</li></ul><h3 id="7-1-1-磁盘设备组成"><a href="#7-1-1-磁盘设备组成" class="headerlink" title="7.1.1.磁盘设备组成"></a>7.1.1.磁盘设备组成</h3><h4 id="7-1-1-1-存储区域"><a href="#7-1-1-1-存储区域" class="headerlink" title="7.1.1.1.存储区域"></a>7.1.1.1.存储区域</h4><p><strong>存储区域：一块硬盘含有若干记录面，每个记录面划分为若干条磁道，每条磁道又划分为若干扇区，扇区（也称之为块）是磁盘读写的最小单位，也就是磁盘是按块存取。</strong></p><ul><li><p><strong>磁头数：也即记录面数，表示硬盘总共有多个磁头，磁头分为读磁头和写磁头，每个磁头对应一个记录面。</strong></p></li><li><p><strong>柱面数：表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面</strong>。</p></li><li><p><strong>扇区数：表示每一条磁道上有多少个扇区。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141709066.png" alt="22cc501b8cef4462a2a98f52726b64d7" loading="lazy"></p><h4 id="7-1-1-2-硬盘存储器的构成"><a href="#7-1-1-2-硬盘存储器的构成" class="headerlink" title="7.1.1.2.硬盘存储器的构成"></a>7.1.1.2.硬盘存储器的构成</h4><p><strong>硬盘存储器的构成：由磁盘驱动器，磁盘控制器和盘片组成。</strong></p><ul><li><p><strong>磁盘驱动器：核心部件是磁头组件和硬件组件，温彻斯特是一种可移动磁头固定盘片的硬盘存储器</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141710265.png" loading="lazy"></p></li><li><p><strong>磁盘控制器：硬盘存储器和主机的接口，主流的标准有 IDE,SCSI,SATA 等</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141711584.png" alt="1" loading="lazy"></p></li></ul><h3 id="7-1-2-磁盘性能指标"><a href="#7-1-2-磁盘性能指标" class="headerlink" title="7.1.2.磁盘性能指标"></a>7.1.2.磁盘性能指标</h3><p><strong>①：磁盘容量：一个磁盘所能存储的字节总数。磁盘容量有格式化容量和非格式化容量之分</strong>。</p><ul><li><strong>非格式化容量</strong>：磁记录表面可以利用的磁化单元总数。</li><li><strong>格式化容量</strong>：是指按照某种特定的记录格式所能存储信息的总量。</li></ul><p><strong>②：记录密度：是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。</strong></p><ul><li><p><strong>道密度</strong>：沿磁盘半径方向单位长度上的磁道数。</p></li><li><p><strong>位密度</strong>：是磁道单位长度上所能记录的二进制代码的位数。</p></li><li><p><strong>面密度</strong>：是道密度和位密度的乘积  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141712979.png" alt="1" loading="lazy"></p></li></ul><p><strong>磁盘所有磁道记录的信息量一定是相等的，并不是说圆越大记录的信息就越多，因此越靠近里面的磁道位密度就越大。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141716338.png" alt="image-20230414171641252" loading="lazy"></p><h3 id="7-1-3-平均存取时间"><a href="#7-1-3-平均存取时间" class="headerlink" title="7.1.3.平均存取时间"></a>7.1.3.平均存取时间</h3><p><strong>平均存取时间：一次磁盘读写花费的时间由以下三种时间决定</strong>：</p><p><strong>①：寻道时间 $ T_{S} $：在读 &#x2F; 写数据前，将磁头移动到指定磁道所花费时间</strong>。</p><ul><li><strong>启动磁头臂花费时间</strong>：$ s $（约为 2ms）。</li><li><strong>移动磁头花费时间：</strong> 假设磁头匀速移动，每跨越一个磁道耗时为 $ m$（约为 0.2ms），总共需要跨越 $n$条磁道。</li><li><strong>总花费时间： $ T_{S} $​&#x3D; $ s$+ $ m$× $ n$。</strong></li></ul><p><strong>②：延迟时间 T R T_{R} TR​：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</strong></p><ul><li><strong>磁盘转速为</strong> $r$(单位为 “转 &#x2F; 秒” 或“转 &#x2F; 分”，典型转速为 5400r&#x2F;min 或 7200r&#x2F;min)。</li><li><strong>转一圈所需要时间</strong>： $ \frac{1}{r} $。</li><li><strong>目标扇区平均需要转半圈</strong>： $ \frac{1}{2}$。​</li><li>**总花费时间： $ T_{R} $&#x3D; $\frac{1}{2} $​× $\frac{1}{r} $​&#x3D; $r \frac{1}{2r} $**。</li></ul><p><strong>③：传输时间 $T_{t} $：从磁盘读出或向磁盘写入数据所经历的时间</strong>。</p><ul><li><strong>每个磁道可以存储 $n$字节的数据，因此对于$ b $字节的数据需要的磁道数为</strong>： $\frac{b}{N} $。</li><li><strong>读写一个磁道所需要的时间刚好又是转一圈所需要的时间</strong>： $\frac{1}{r} $。</li><li><strong>总花费时间：$ T_{t} $&#x3D; $ \frac{1}{r} $× $ \frac{b}{N} $&#x3D; $ \frac{b}{rN} $。</strong></li></ul><p><strong>因此：总的平均存储时间 $T_{a} $&#x3D; 寻道时间 + 延迟时间 + 传输时间 &#x3D; $ T_{s} $​+ $ \frac{1}{2r} $+ $ \frac{b}{rN} $​</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141714919.png" alt="0" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632827.png" loading="lazy"></p><ul><li>寻道时间为 6ms。</li><li>10000r&#x2F;min，所以 166r&#x2F;s，因此转一圈大约 6ms，所以半圈 3ms，所以延迟时间为 3ms。</li><li>传输时间为 4(KB)&#x2F;20(MB\s)&#x3D;0.2ms。</li><li>其他时间为 0.2ms。</li><li>所以平均时间为 9.4ms。</li></ul><h3 id="7-1-4-磁盘地址"><a href="#7-1-4-磁盘地址" class="headerlink" title="7.1.4.磁盘地址"></a>7.1.4.磁盘地址</h3><p><strong>主机会向磁盘发送地址信息，格式如下</strong>：</p><table><thead><tr><th>驱动器号</th><th>柱面（磁道）号</th><th>盘面号</th><th>扇区号</th></tr></thead><tbody><tr><td>确定是哪一个硬盘</td><td>用于移动寻道</td><td>激活某个磁头</td><td>旋转扇区划过磁头</td></tr></tbody></table><p>如果系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道，16 个盘面，每个盘面划分为 16 个扇区，则每个扇区地址要 18 位二进制代码，分布如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632236.png" loading="lazy"></p><h3 id="7-1-5-磁盘工作过程"><a href="#7-1-5-磁盘工作过程" class="headerlink" title="7.1.5.磁盘工作过程"></a>7.1.5.磁盘工作过程</h3><p><strong>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151633673.gif" loading="lazy"></p><p>需要注意的是硬盘属于机械式部件，其读写操作是并行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。所以是需要串 - 并变换电路的 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630537.png" alt="image-20230415163009440" loading="lazy"></p><h2 id="7-2-磁盘阵列"><a href="#7-2-磁盘阵列" class="headerlink" title="7.2.磁盘阵列"></a>7.2.磁盘阵列</h2><p><strong>磁盘阵列：RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储，并行访问，具有更好的存储性能，可靠性和安全性</strong>。</p><p><strong>RAID 的分级如下。在 RAID1~RAID5 几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。</strong></p><ul><li><p><strong>RAID0</strong>：无冗余和无校验的磁盘阵列（逻辑上相邻的两个扇区在物理上存到两个磁盘）。</p></li><li><p><strong>RAID1</strong>：镜像磁盘阵列（直接存两份数据）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630116.png" alt="image-20230415163024022" loading="lazy"></p></li><li><p><strong>RAID2</strong>：逻辑上连续的几个 bit 物理上分散存储在各个盘中，4bit 信息为 + 3bit 海明校验位，可纠正一位错误  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630970.png" alt="image-20230415163045848" loading="lazy"></p></li><li><p><strong>RAID3</strong>：位交叉奇偶校验码的磁盘阵列。</p></li><li><p><strong>RAID4</strong>：块交叉奇偶校验的磁盘阵列。</p></li><li><p><strong>RAID5</strong>：无独立校验的奇偶校验磁盘阵列。</p></li></ul><p><strong>总之，RAID 通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量了通过镜像功能，提高安全可靠性；通过数据校验，提高容错能力</strong>。</p><h2 id="7-3-光存储器"><a href="#7-3-光存储器" class="headerlink" title="7.3.光存储器"></a>7.3.光存储器</h2><p><strong>光盘存储器是利用光学原理读 &#x2F; 写信息的存储装置，它采用聚集激光束对盘式介质以非接触的方式记录信息</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631878.png" loading="lazy"></p><h1 id="8-固态硬盘"><a href="#8-固态硬盘" class="headerlink" title="8.固态硬盘"></a>8.固态硬盘</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141718909.png" alt="image-20230414171800773" loading="lazy"></p><p><strong>在微小型高档笔记本电脑中，采用高性能 Flash Memory 作为硬盘记录数据——固态硬盘</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151623950.png" alt="img" loading="lazy"></p><h2 id="8-1-固态硬盘（SSD）概述"><a href="#8-1-固态硬盘（SSD）概述" class="headerlink" title="8.1.固态硬盘（SSD）概述"></a>8.1.固态硬盘（SSD）概述</h2><p><strong>固态硬盘（SSD）：它是一种基于闪存技术的存储器，与 U 盘并无本质区别，属于电可擦除 ROM，也即 EEPROM。传统机械硬盘与固态硬盘内部构造如下图所示</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151624494.png" alt="img" loading="lazy"></p><p><strong>SSD 有以下特点</strong>：</p><ul><li><strong>SSD 读写速度较快，随机访问性能高，用电路控制访问位置</strong>（机械硬盘则是通过移动磁臂旋转磁盘控制访问位置）。</li><li><strong>SSD 安静无噪音、耐摔抗震、能耗低、造价更高</strong>。</li><li><strong>SSD 容易出现坏块（读写次数过多可能会导致）。</strong></li></ul><h2 id="8-2-固态硬盘（SSD）组成"><a href="#8-2-固态硬盘（SSD）组成" class="headerlink" title="8.2.固态硬盘（SSD）组成"></a>8.2.固态硬盘（SSD）组成</h2><h3 id="8-2-1-闪存翻译层"><a href="#8-2-1-闪存翻译层" class="headerlink" title="8.2.1.闪存翻译层"></a>8.2.1.闪存翻译层</h3><p><strong>闪存翻译层：主要作用是负责翻译逻辑块号，找到对应页。具体来说，I&#x2F;O 总线会给出系统所要读 &#x2F; 写的逻辑块号，然后闪存翻译层会把逻辑块号映射为对应的物理地址。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151627038.png" loading="lazy"></p><h3 id="8-2-2-存储介质"><a href="#8-2-2-存储介质" class="headerlink" title="8.2.2.存储介质"></a>8.2.2.存储介质</h3><p><strong>存储介质：上面 SSD 构造图中的黑色块状部分为闪存芯片，多个闪存芯片构成 SSD 的闪存芯片组。每个闪存芯片内由多个数据块组成（每个数据块大小为 16KB<del>512KB）、每个数据块又有多个页组成（每个页大小为 512B</del>4KB）。这里特别注意 “逻辑块” 在不同的存储器下有不同的含义：</strong></p><ul><li><strong>如果是磁盘</strong>：逻辑块指的就是磁盘的块或扇区。</li><li><strong>如果是 SSD</strong>：逻辑块指的就是 SSD 的页。</li><li><strong>所以，SSD 的一个页相当于磁盘的一个扇区、SSD 的一个块相当于磁盘的一个磁道。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151627683.png" loading="lazy"></p><h2 id="8-3-固态硬盘（SSD）的读写"><a href="#8-3-固态硬盘（SSD）的读写" class="headerlink" title="8.3.固态硬盘（SSD）的读写"></a>8.3.固态硬盘（SSD）的读写</h2><p><strong>固态硬盘（SSD）的读写：主要由以下特点</strong>：</p><ul><li><strong>以页为单位进行读写</strong>。</li><li><strong>以块为单位进行擦除，擦干净的块，其中的每页都可以写一次，读无限次。</strong></li><li><strong>支持随机访问，也即系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址。</strong></li><li><strong>SSD 读速度要快于写速度，这是因为要写的页如果有数据则需要先将块内其他页全部复制到一个新的块中，再写入新的页</strong>。</li></ul><h2 id="8-4-磨损均衡技术"><a href="#8-4-磨损均衡技术" class="headerlink" title="8.4.磨损均衡技术"></a>8.4.磨损均衡技术</h2><p><strong>磨损均衡技术：由于反复写会导致闪存快磨损，所以引入磨损均衡技术，闪存翻译层有一个平均磨损逻辑试图通过将擦除平均分布在所有块上来最大化每个块的寿命。有如下两种方式</strong>：</p><ul><li><p><strong>动态磨损均衡</strong>：写入数据时，优先选择<strong>累计擦除次数少</strong>的新闪存块。</p></li><li><p><strong>静态磨损均衡</strong>：SSD 监测并自动进行数据分配、迁移。让<strong>老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务。</strong></p></li></ul><h1 id="9-高速缓冲存储器Cache"><a href="#9-高速缓冲存储器Cache" class="headerlink" title="9.高速缓冲存储器Cache"></a>9.高速缓冲存储器Cache</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142146250.png" loading="lazy"></p><p><strong>由于程序的转移概率和数据分布的离散性很大，所以想要仅仅通过提高主存系统的并行性以此来提升存储器带宽的想法是不现实的。因此这就我们必须从系统结构上加以改进，也即采用<a href="#存储器分类">1.1存储器分类</a>中讲到的多级存储体系</strong>。</p><ul><li>Cache - 主存层次。</li><li>主存 - 辅存层次。</li></ul><h2 id="9-1-Cache-基本原理"><a href="#9-1-Cache-基本原理" class="headerlink" title="9.1.Cache 基本原理"></a>9.1.Cache 基本原理</h2><p>以微信为例，当你打开微信时，与微信有关的数据和代码将会被加载进主存，比如文字数据、支付数据、运动数据等等。这些数据很多，涉及各个功能，但有的人使用微信可能只偏好于某些方面（比如视频聊天）。所以在这样的情况下，CPU 在较长时间内使用到的只是微信的部分程序和数据 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142139806.png" alt="image-20230414213910707" loading="lazy"></p><p><strong>所以可以把把这一部分的数据复制一份给 Cache，由于 Cache 的速度和 CPU 十分接近，这样的话 CPU 会直接和 Cache 交流，整机性能会有明显提升</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142139431.png" alt="image-20230414213956332" loading="lazy"></p><h2 id="9-2-程序访问的局部性原理"><a href="#9-2-程序访问的局部性原理" class="headerlink" title="9.2.程序访问的局部性原理"></a>9.2.程序访问的局部性原理</h2><p>如下是一段简单的 C 语言程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> M <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>j<span class="token operator">++</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该程序在运行后会被加载进内存，程序的本质就是<strong>指令和数据</strong>，所以这段程序在主存中分布情况可能是下面这样：</p><ul><li><p>假定 M、N 为 2048，按字节编址，int 占用 4 个字节。</p></li><li><p>这个二维数组看似是二维的，实则在主存中是一维的，相当于把第二行接到了第一行的尾巴后面。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142142096.png" alt="image-20230414214251984" loading="lazy"></p></li></ul><p><strong>程序访问的局部性原理包括空间局部性和时间局部性</strong>：</p><p><strong>空间局部性</strong>：<strong>是指最近未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的</strong>。例如上例中形参是一个数组，在一个元素访问完毕之后，下一个元素的物理位置和它其实是相邻的。</p><p><strong>时间局部性</strong>：<strong>是指最近未来要用到的信息，很可能就是现在正在使用的信息</strong>。比如上例中 for 循环内的<code>sum+=a[i][j]</code>，这一条语句明显会被重复使用多次。</p><p><strong>Cache + 局部性原理：可以把 CPU 目前正在访问的元素的邻近数据放到 Cache 中，之后 CPU 的访存操作大多数就会针对 Cache 进行，程序的执行速度的也会得到提升。</strong></p><p>下面是一个空间局部性很差的程序，它只是在上面程序的基础上把 “<strong>一行一行的访问” 变为了 “一列一列的访问</strong>”。之前，访问完<code>a[0][0]</code>，下一个访问的就是<code>a[0][1]</code>，而现在下一个却变成了<code>a[1][0]</code>了。因为每次访问都要跳过 2048 个数组元素，也就是 8192 字节，假如主存与 Cache 的交换单位较小，<strong>那么每访问一个数组元素都需要装入一个主存块到 Cache 中</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> M<span class="token punctuation">;</span>j<span class="token operator">++</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-3-主存块"><a href="#9-3-主存块" class="headerlink" title="9.3.主存块"></a>9.3.主存块</h2><p><strong>主存块：这是主存与 Cache 之间交换数据的最小单位。也即将主存的存储空间分块，比如每 1KB 为一块，主存与 Cache 之间就会以块为单位进行数据交换。</strong></p><p>例如下图数组，对于<code>a[0][0]</code>我们先判断它属于哪一块，确定好之后再将它所在的块复制到 Cache 中去。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142144189.png" alt="image-20230414214417102" loading="lazy"></p><p><strong>假设主存大小为 4M，每 1KB 为一块，由于 4M&#x3D;4096KB，因此会被分为 4096 块，然后对其编号（0-4095）</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142145548.png" alt="image-20230414214502471" loading="lazy"></p><p>**由于 $2^{22}&#x3D;4 194 $，所以这些地址至少需要 22 位才能全部表示，我们将 22 位地址拆分为两个部分，前 12 位表示块号（ $ 2^{12}&#x3D;4096 $），后 10 位表示块内地址（ $ 2^{10}&#x3D;1024 $)**。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142145283.png" alt="image-20230414214539186" loading="lazy"></p><h2 id="9-4-命中率和缺失率"><a href="#9-4-命中率和缺失率" class="headerlink" title="9.4.命中率和缺失率"></a>9.4.命中率和缺失率</h2><p><strong>命中率 $H$： CPU 欲访问的信息已经在 Cache 中的比率</strong>。</p><p><strong>缺失率： CPU 欲访问的信息未经在 Cache 中的比率，为 $1-H$。</strong></p><ul><li><p>假设某程序执行期间，Cache 的的总命中次数为 $ N_{c} $，访问主存的总次数为 $ N_{M} $，<strong>那么 $H$&#x3D; $ \frac{N_{c}}{N_{c}+N{m}} $。​​</strong></p></li><li><p><strong>命中率 $H$ 越接近 1 越好</strong>。</p></li><li><p>设 $ t_{c} $为命中时的 Cache 访问时间， $ t_{m} $为未命中时的访问时间, 则 <strong>Cache - 主存系统的平均访问时间 $ T_{a}&#x3D;Ht_{c}+(1-H)t_{m} $。​</strong></p></li></ul><h1 id="10-Cache和主存的映射方式"><a href="#10-Cache和主存的映射方式" class="headerlink" title="10.Cache和主存的映射方式"></a><a name="10.Cache和主存的映射方式">10.Cache和主存的映射方式</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142201730.png" alt="image-20230414220104642" loading="lazy"></p><p>前面说过，Cache 中保存的实际是主存中的数据副本，所以这里就会涉及一个很重要的问题：<strong>主存内容和 Cache 中的内容是如何对应，也即是如何映射的？</strong> 地址映射的方法有以下三种：</p><ul><li><strong>全相联映射</strong>：主存块可以放在 Cache 的<strong>任何位置</strong>。</li><li><strong>直接映射</strong>：每个主存块<strong>只能放到一个特定的位置</strong>，由<strong>主存块号 %Cache 总块数</strong>来确定。</li><li><strong>组相联映射</strong>：将 Cache 块分为<strong>若干组</strong>，每个主存块可以放到<strong>特定分组中的任意一个位置</strong>，其中<strong>组号 &#x3D; 主存块号 % 分组数。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142149568.png" alt="image-20230414214921473" loading="lazy"></p><p>把主存块放到 Cache 中后：</p><ul><li><p><strong>要给每个 Cache 块增加一个 “标记位”</strong>，记录<strong>对应的主存块号</strong>。</p></li><li><p><strong>再给每个 Cache 块增加一个 “有效位”</strong>，用于<strong>控制其是否生效</strong>，以免产生冲突 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142150662.png" alt="image-20230414215019584" loading="lazy"></p></li></ul><p><strong>分块后需要对主存进行编号，假设某个计算机的主存地址空间大小为 256MB，按字节编址，Cache 有 8 个 Cache 行（也即 Cache 块），行长（也即块大小）为 64B。</strong></p><ul><li><strong>主存块号编号</strong>：块大小为 $64B&#x3D;2^6B$、主存大小为 $256MB&#x3D;2^28B$，那么就有 $2^{28}&#x2F;2^6$ 个主存块，所以主存编号为从 0 到 $2^{22}-1$。</li><li><strong>块内地址</strong>：这 22 位是用于区分主存块的，所以剩下的 28-22&#x3D;6 位则为每个主存块的地址范围（或空间）。也即先利用高 22 位确定是哪一块，然后在该块中用低 6 位确定地址。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142153801.png" alt="image-20230414215317711" loading="lazy"></p><h2 id="10-1-全相联映射"><a href="#10-1-全相联映射" class="headerlink" title="10.1.全相联映射"></a>10.1.全相联映射</h2><h3 id="10-1-1-如何映射"><a href="#10-1-1-如何映射" class="headerlink" title="10.1.1.如何映射"></a>10.1.1.如何映射</h3><p><strong>全相联映射：主存块可以放在 Cache 的任何位置。</strong></p><p>例如下图中的 0 号主存块，它就可以放置到 Cache 的 3 号位置，每行的标记号用于指出该行取自主存的哪一块，同时将对应的有效位置为 1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142153856.png" alt="image-20230414215356771" loading="lazy"></p><h3 id="10-1-2-如何访存"><a href="#10-1-2-如何访存" class="headerlink" title="10.1.2.如何访存"></a>10.1.2.如何访存</h3><p><strong>以上图紫色主存块为例，其地址为 1…1101001110，在全相联映射下，CPU 访存时首先会取该地址的前 22 位，也即主存块号，来和 Cache 中每一行的标记进行对比</strong>。</p><ul><li><strong>若标记号 &#x3D; 块号且有效位为 1</strong>：说明 <strong>Cache 命中</strong>，也就是说此时访问的数据在 Cache 中是有副本的，接着<strong>只需在 Cache 中访问后 6 位地址所定位的单元</strong>即可。</li><li><strong>若标记号不匹配或匹配但有效位为 0</strong>：此时说明 <strong>Cache 未命中</strong>，则正常访问主存，也即要从主存中取数据。</li></ul><h2 id="10-2-直接映射"><a href="#10-2-直接映射" class="headerlink" title="10.2.直接映射"></a>10.2.直接映射</h2><h3 id="10-2-1-如何映射"><a href="#10-2-1-如何映射" class="headerlink" title="10.2.1.如何映射"></a>10.2.1.如何映射</h3><p><strong>直接映射：每个主存块只能放到一个特定的位置，由主存块号 %Cache 总块数来确定</strong>。</p><p>例如下图中的 0 号主存块，由于 0%8&#x3D;0，因此它<strong>只能放到 Cache 的 0 号位置</strong>；对于 8 号主存块，由于 8%8&#x3D;0，所以它也要放到 0 号位置，<strong>而且需要把之前的 0 号主存块给腾空</strong>，相应的标记位也要修改 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142155753.png" alt="image-20230414215559659" loading="lazy"></p><p><strong>“%” 运算具有一些特性，这里 Cache 块数 &#x3D; 8&#x3D;$2^3$，其指数部分为 3，这意味着主存块号中的后 3 位直接反映了该主存块在 Cache 中的位置。例如上图中的 0 号和 8 号，其主存块号的后三位均为 000，这正好对应了它们在 Cache 的第 0 行</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142157753.png" alt="image-20230414215737664" loading="lazy">  </p><p><strong>因此标记可以直接取主存块号的前 19 位，相应地址形式会变化为下面这样</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142158500.png" alt="image-20230414215838387" loading="lazy"></p><h3 id="10-2-2-如何访存"><a href="#10-2-2-如何访存" class="headerlink" title="10.2.2.如何访存"></a>10.2.2.如何访存</h3><p><strong>以上图橙色主存块为例，其地址为 0…01000001110。在直接映射下，CPU 访存时首先会根据主存块号的后三位确定 Cache 行（而不用挨个比较），接着会判断前 19 位和标记号是否匹配并同时判断有效位是否为 1</strong>。</p><h2 id="10-3-组相联映射"><a href="#10-3-组相联映射" class="headerlink" title="10.3.组相联映射"></a>10.3.组相联映射</h2><h3 id="10-3-1-如何映射"><a href="#10-3-1-如何映射" class="headerlink" title="10.3.1.如何映射"></a>10.3.1.如何映射</h3><p><strong>组相联映射：将 Cache 块分为若干组，每个主存块可以放到特定分组中的任意一个位置，其中组号 &#x3D; 主存块号 % 分组数。</strong></p><p>以 2 路组相联为例（2 块为一组，分为四组）。对于下图中 1 号主存块，由于 1%4&#x3D;1，因此它会被放入<strong>第一组的任意位置</strong>；对于 222-3 号主存块也会放入第一组，它会放到该组另一个空闲位置 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142159993.png" alt="image-20230414215932900" loading="lazy"></p><p><strong>和直接映射一样，由于 “%” 的运算特性，这里分组数 &#x3D; 4&#x3D;22，这意味着主存块号中的后 2 位反映了该主存块在哪一个组。所以标记号只需取前 20 位，相应地址形式会变化为下面这样</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142200971.png" alt="image-20230414220008881" loading="lazy"></p><h3 id="10-3-2-如何访存"><a href="#10-3-2-如何访存" class="headerlink" title="10.3.2.如何访存"></a>10.3.2.如何访存</h3><p><strong>以上图橙色主存块为例，其地址为 1…0100001110。在组相联映射下，CPU 访存时首先会根据主存块号的后两位确定所属分组号，接着会判断主存块号的前 20 位与分组内的某个标记号是否匹配同时判断有效位是否为 1</strong>。</p><h2 id="10-4-三种方式各自优缺点"><a href="#10-4-三种方式各自优缺点" class="headerlink" title="10.4.三种方式各自优缺点"></a>10.4.三种方式各自优缺点</h2><p><strong>全相联映射</strong>：</p><ul><li><strong>优点</strong>：Cache 存储空间利用充分，命中率高。</li><li><strong>缺点</strong>：查找慢，有时可能要比对所有行的标记。</li></ul><p><strong>直接映射</strong>：</p><ul><li><strong>优点</strong>：对于任意一个位置，只需对比一个标记，速度最快。</li><li><strong>缺点</strong>：缺点就是 Cache 存储空间利用不充分，命中率低。</li></ul><p><strong>组相联映射</strong>：<strong>综合效果较好。</strong></p><h1 id="11-Cache替换算法"><a href="#11-Cache替换算法" class="headerlink" title="11.Cache替换算法"></a><a name="11.Cache替换算法">11.Cache替换算法</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151527611.png" alt="image-20230415152732490" loading="lazy"></p><p>在<a href="#10.Cache和主存的映射方式"><strong>10.Cache和主存的映射方式</strong></a>中我们讲到了 Cache 和主存之间的映射关系，细致分析了三种映射方式各自的特点。那么下一个亟待解决的问题就是：<strong>Cache 是很小的，主存却很大，如果 Cache 满了应该怎么办？</strong> 这就是本节的主题——<strong>Cache 的替换算法</strong>。当然，不同的映射方式其替换机制也会有所不同。</p><ul><li><strong>全相联映射：Cache 完全满了才需要替换，需要在全局中选择替换哪一块</strong>。</li><li><strong>直接映射：如果对应位置为空则直接替换，无需考虑替换算法。</strong></li><li><strong>组相联映射：分组内满了才需要替换，需要在分组内选择替换哪一块。</strong></li></ul><p><strong>本节以全相联映射为例，介绍以下四种替换算法</strong>：</p><ul><li><strong>随机算法（RAND）</strong>。</li><li><strong>先进先出算法（FIFO）。</strong></li><li><strong>近期最少使用算法（LRU）。</strong></li><li><strong>最不频繁使用算法（LFU）</strong>。</li></ul><p><strong>在讲解之前大家一定明白一点，CPU 每访问一个内存块，都会立即把该内存块调入 Cache 中</strong>。</p><h2 id="11-1-随机算法（RAND）"><a href="#11-1-随机算法（RAND）" class="headerlink" title="11.1.随机算法（RAND）"></a>11.1.随机算法（RAND）</h2><p><strong>随机算法（RAND）：若 Cache 已满，则随机选择一块进行替换。</strong></p><ul><li><strong>通过以下叙述可知：随机算法十分简单，但是它完全没有考虑到局部性原理，命中率很低，实际效果很不稳定。</strong></li></ul><p>如下有 4 个 Cache 块，初始状态下 4 个 Cache 块均为空，采用<strong>全相连映射</strong>，CPU 访问主存块的顺序为：{1,2,3,4,1,2,5,1,2,3,4,5}，CPU <strong>每访问一个内存块，都会立即把该内存块调入 Cache 中</strong>，前四次调入时由于都有空闲 Cahce 块，所以不会发生替换。</p><table><thead><tr><th >访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr></thead><tbody><tr><td><strong>Cache #0</strong></td><td bgcolor="red">1</td><td>1</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>Cache #1</strong></td><td></td><td bgcolor="red">2</td><td>2</td><td>2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>Cache #2</strong></td><td></td><td></td><td bgcolor="red">3</td><td>3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>Cache #3</strong></td><td></td><td></td><td></td><td bgcolor="red">4</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>是否命中？</strong></td><td>否</td><td>否</td><td>否</td><td>否</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>是否替换？</strong></td><td>否</td><td>否</td><td>否</td><td>否</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>继续访存，{1,2,3,4,<strong>1,2</strong>,5,1,2,3,4,5}。由于 1,2 主存块已经被调入了 Cache，所以<strong>直接命中。</strong></p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。对于 5 号主存块，它并没有调入 Cache 中，因此需要立即被调入，<strong>但此时已经没有空闲 Cache 块了，所以需要使用替换算法选择一块换出，然后再把 5 号主存块调入。这里采用的是随机算法，所以我们可以任意挑选一块调入，比如把 3 号主存块给替换出去</strong>。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,<strong>1,2</strong>,3,4,5}。直接命中。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。和上面一样，随机挑选一块换出。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。和上面一样，随机挑选一块换出。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">4</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>访存结束，{1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。直接命中。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>    </tr>  </tbody></table><h2 id="11-2-先进先出算法（FIFO）"><a href="#11-2-先进先出算法（FIFO）" class="headerlink" title="11.2.先进先出算法（FIFO）"></a>11.2.先进先出算法（FIFO）</h2><p><strong>先进先出算法（FIFO）：若 Cache 已满，则替换最先被调入 Cache 的块</strong>。</p><ul><li><strong>通过以下叙述可知：先进先出算法实现也很简单，但该算法依然没有考虑到局部性原理，因为最先被调入的 Cache 块也有可能是会频繁访问到的。而且此算法容易产生抖动现象（—刚换上去的块又立马被换下）。</strong></li></ul><p>仍然采用之前的例子，直接进行到这一步。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。对于 5 号主存块，它并没有调入 Cache 中，因此需要立即被调入，但此时已经没有空闲 Cache 块了，所以需要使用替换算法选择一块换出，然后再把 5 号主存块调入。<strong>这里采用的是 FIFO 算法，根据先进先出原则，最先被调入 Cache 的最先被替换，因此 1 号被替换</strong>。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,<strong>1</strong>,2,3,4,5}。此时应该替换 2 号。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td bgcolor="red">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>后续步骤不再详细演示，最终结束状态如下：</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>是</td>      <td>是</td>        <td>是</font></td>      <td>是</td>      <td></td>    </tr>  </tbody></table><h2 id="11-3-近期最少使用算法（LRU）——效率最高"><a href="#11-3-近期最少使用算法（LRU）——效率最高" class="headerlink" title="11.3.近期最少使用算法（LRU）——效率最高"></a>11.3.近期最少使用算法（LRU）——效率最高</h2><p><strong>近期最少使用算法（LRU）：该算法会为每一个 Cache 块设置一个计数器，用于记录每个 Cache 块究竟有多长时间没有被访问了。在替换时直接选取计数器最大的替换即可。</strong></p><ul><li><strong>通过以下叙述可知：LRU 算法是基于局部性原理的，近期访问过的主存块，在不久的将来很有可能会被再次访问到，因此这种淘汰机制是合理的。LRU 算法的实际运行效果也很优秀，Cache 命中率也高</strong>。</li></ul><p><strong>计数器的变化规则如下</strong>：</p><ul><li><strong>命中时：所命中的块的计数器清零，计数器比其低的块的计数器 + 1，其余不变</strong>。</li><li><strong>未命中且还有空闲块时：新装入的块的计数器置为 0，其余非空闲块的计数器全 + 1。</strong></li><li><strong>未命中且没有空闲块时：计数器最大的块被淘汰，新装入块的计数器置为 0，其余块的计数器 + 1。</strong></li></ul><p>如下表格表示初始状态：</p><table><thead><tr><th>计时器</th><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr></thead><tbody><tr><td>0</td><td><strong>Cache #0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #2</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #3</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否命中？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否替换？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>继续访存，{<strong>1</strong>,2,3,4,1,2,5,1,2,3,4,5}。由于 1 装入了第一个 Cache 块，属于<strong>未命中且还有空闲块</strong>，因此该块计数器置为 0，其余非空闲块计数器全 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,<strong>2</strong>,3,4,1,2,5,1,2,3,4,5}。情况同上。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>第三、四个主存块亦是如此。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>3</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,<strong>1</strong>,2,5,1,2,3,4,5}。<strong>此时 Cache 命中，因此需要将所命中块的计数器清零，比其低的块的计数器 + 1，其余不变。</strong></p><ul><li>这一点其实就体现了 LRU 算法的核心，它能保证最近访问的块的计数器一定很低。</li></ul><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,<strong>2</strong>,5,1,2,3,4,5}，情况同上。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。此时属于 <strong>“未命中且没有空闲行”，所以计数器最大的块会被淘汰（淘汰 3 号主存块），新装入块的计数器置为 0，其余块计数器全 + 1。</strong></p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,<strong>1</strong>,2,3,4,5}。直接命中。</p><ul><li><strong>注意</strong>：只需要将 “比该块计数器值小的块的计数器 + 1” 即可，大的不变，因此上面表格中的 3 号 Cache 的计时器就不用动了，这里很容易犯错。</li></ul><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>4</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,1,<strong>2</strong>,3,4,5}。直接命中。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>5</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。未命中，且没有空行。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。未命中，且没有空行。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>3</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">4</td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。未命中，且没有空行。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>是</td>      <td></td>    </tr>  </tbody></table><h2 id="11-4-最不经常使用算法（LFU）"><a href="#11-4-最不经常使用算法（LFU）" class="headerlink" title="11.4.最不经常使用算法（LFU）"></a>11.4.最不经常使用算法（LFU）</h2><p><strong>最不经常使用算法（LFU）：该算法会为每一个 Cache 块设置一个计数器，用于记录每个 Cache 块被访问过几次。在替换时直接选取计数器最小的替换即可。</strong></p><ul><li><strong>通过以下叙述可知：LFU 算法并没有很好地遵循局部性原理，比如微信聊天相关的块，在某个时间段内使用率会很高，但是一段时间后使用率会很低，并不科学。</strong></li></ul><p><strong>计数器的变化规则为：</strong></p><ul><li><strong>新调入的块计数器为 0，之后每访问一次计数器就 + 1。需要替换时，选择计数器最小的一行替换。</strong></li><li><strong>若有多个计数器最小的行，可以按照行号递增或 FIFO 策略进行选择。</strong></li></ul><table><thead><tr><th>计时器</th><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr></thead><tbody><tr><td>0</td><td><strong>Cache #0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #2</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #3</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否命中？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否替换？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>继续访存，也即 {<strong>1,2,3,4</strong>,1,2,5,1,2,3,4,5}。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,**1,2,**5,1,2,3,4,5}。发生命中，计数器 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。<strong>选择计数器最小的那一行，但是这里有两行相同（都是 0），所以再按照 FIFO 策略选择 3 号主存块淘汰。</strong></p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,<strong>1,2</strong>,3,4,5}。1,2 命中，计数器 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。需要进行替换，<strong>这里我们再采用行号递增的规则淘汰 5 号主存块。</strong></p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">3</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。命中，计时器 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="green">4</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。需要替换，只剩一个最小的了，替换 3 号主存块即可。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="green">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td></td>    </tr>  </tbody></table><h1 id="12-Cache的写策略"><a href="#12-Cache的写策略" class="headerlink" title="12.Cache的写策略"></a>12.Cache的写策略</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151543520.png" alt="image-20230415154310416" loading="lazy"></p><p>在<a href="https://blog.csdn.net/qq_39183034/article/details/119967515?spm=1001.2014.3001.5501"><a href="#10.Cache和主存的映射方式">10.Cache和主存的映射方式</a></a>和<a href="https://blog.csdn.net/qq_39183034/article/details/120016603?spm=1001.2014.3001.5501"><a href="#11.Cache替换算法">11.Cache替换算法</a></a>这两篇文章中分别探讨了主存、Cache 之间的映射关系以及 Cache 的替换算法。关于 Cache，最后需要解决的一个问题就是：<strong>如何保持 Cache 与数据母体的一致性</strong>？因为我们知道，Cache 中保存的只是<strong>主存数据的副本</strong>，一旦对 Cache 进行写操作就一定会导致两部分数据出现不一致，而对于读操作则不关心。这就是 Cache 写策略所要探讨的问题。</p><p><strong>Cache 写策略分写命中和写不命中两种情况</strong>：</p><ul><li><strong>写命中</strong>：有全写法和写回法。</li><li><strong>写不命中</strong>：有写分配法和非写分配法两种。</li></ul><h2 id="12-1-写命中"><a href="#12-1-写命中" class="headerlink" title="12.1.写命中"></a>12.1.写命中</h2><p><strong>写命中：写命中时主存块被调入 Cache 中，也即要被修改的单元在 Cache 中。此时有两种方法</strong>：</p><ul><li>写回法。</li><li>全写法。</li></ul><h2 id="12-1-1-写回法-write-back"><a href="#12-1-1-写回法-write-back" class="headerlink" title="12.1.1.写回法 (write-back)"></a>12.1.1.写回法 (write-back)</h2><p><strong>写回法 (write-back)：是指当 CPU 写命中时，只修改 Cache 中的内容，而不立即写入主存，只有当此块被换出时才写回主存。如下图，绿色主存块写命中，修改时只在 Cache 上修改，而不立即写入主存，只有当绿色块被替换时才会写回主存</strong>。</p><ul><li><strong>优点</strong>：减少了访存次数。</li><li><strong>缺点</strong>：存在数据不一致的隐患。</li></ul><p><strong>这种方法需要判断 Cache 是否被修改过，因此在对应 Cache 块还会增加一个 “脏位”，用于标识是否修改过，如果对应位为 1 表示修改过，那么在被替换时该 Cache 块中的内容会被写回至标记位所定位的主存块上</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151537514.png" alt="image-20230415153708377" loading="lazy"></p><h2 id="12-1-2-全写法-write-through"><a href="#12-1-2-全写法-write-through" class="headerlink" title="12.1.2.全写法 (write-through)"></a>12.1.2.全写法 (write-through)</h2><p><strong>全写法 (write-through)：是指当 CPU 写命中时，必须把数据同时写入 Cache 和主存。当某一块需要替换时，不必把这一块写回主存，新调入的块直接覆盖即可</strong>。</p><ul><li><strong>优点</strong>：实现简单，更能保持数据的一致性。</li><li><strong>缺点</strong>：增加了访存次数，降低了 Cache 的效率。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151538715.png" alt="image-20230415153819596" loading="lazy"></p><p><strong>为了减少全写法直接写入主存时所产生时间损耗，通常会在 Cache 和主存之间加入写缓冲（Write Buffer）。CPU 同时写数据到 Cache 和写缓冲中，写缓冲再控制将内容写入主存，写缓冲是一个 FIFO 队列，可以解决速度不匹配的问题。</strong></p><ul><li><p>注意频繁写会导致缓冲区溢出 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631121.png" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151539724.png" alt="image-20230415153919610" loading="lazy"></p></li></ul><h2 id="12-2-写不命中"><a href="#12-2-写不命中" class="headerlink" title="12.2.写不命中"></a>12.2.写不命中</h2><p><strong>写不命中：写不命中时被修改的单元不在 Cache 中。此时有两种方法</strong>：</p><ul><li>写分配法。</li><li>非写分配法。</li></ul><h3 id="12-2-1-写分配法-write-allocate"><a href="#12-2-1-写分配法-write-allocate" class="headerlink" title="12.2.1.写分配法 (write-allocate)"></a>12.2.1.写分配法 (write-allocate)</h3><p><strong>写分配法：是指当写不命中时，会把主存的块加载到 Cache 中，然后更新此 Cache 块，通常会结合写回法使用。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151540924.png" alt="image-20230415154008820" loading="lazy"></p><h3 id="12-2-2-非写分配法（not-write-allocate）"><a href="#12-2-2-非写分配法（not-write-allocate）" class="headerlink" title="12.2.2.非写分配法（not-write-allocate）"></a>12.2.2.非写分配法（not-write-allocate）</h3><p><strong>非写分配法：是指当写不命中时，CPU 直接对主存的块进行修改，而不调入 Cache 中（注意只有读操作才将主存块调入 Cache 中），通常会结合全写法使用</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151541097.png" alt="image-20230415154128984" loading="lazy"></p><h1 id="13-多级-Cache"><a href="#13-多级-Cache" class="headerlink" title="13.多级 Cache"></a>13.多级 Cache</h1><p>现代计算机的 Cache 一般是多级的（通常三级）。对于三级 Cache，<strong>按离 CPU 的远近可命名为 L1 Cache、 L2 Cache、 L3Cache，离 CPU 越远，访问速度就越慢，容量也越大，反之相反。</strong> 其中指令 Cache 与数据 Cache 分离一般在 L1 级，此时通常<strong>为写分配法和写回法</strong>合用。</p><p>下图是一个含有两级的 Cache 系统，<strong>L1 对 L2 使用全写法，L2 对主存使用写回法</strong>，由于 L2 的存在，其访问速度远大于主存，因此避免了因频繁写时导致的缓冲区溢出 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151541752.png" loading="lazy"></p><p>如下图是资源管理器中显示的 Cache 信息。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151542250.png" alt="image-20230415154239158" loading="lazy"></p><h1 id="14-虚拟存储器"><a href="#14-虚拟存储器" class="headerlink" title="14.虚拟存储器"></a>14.虚拟存储器</h1><h2 id="14-1-页式存储器"><a href="#14-1-页式存储器" class="headerlink" title="14.1.页式存储器"></a>14.1.页式存储器</h2><p>前面说过主存和 Cache 之间是以块作为数据的传输单位的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151551467.png" alt="image-20230415155133378" loading="lazy"></p><p>我们知道，应用程序运行时需要加载进主存。比如说微信，假如它有 1GB 大小，那么想要在主存中找到连续的 1GB 空间是很困难的，并且就算加载进去了，也会极大的破坏主存的利用率，产生很多碎片。</p><p><strong>因此为了提高主存利用率，可以将程序（所谓程序就是数据、指令的集合体）分为一个个大小相同的 “页”，每个页面的大小和“物理块” 的大小是相同的。给每个页面编号后，就可以分散在主存中</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151552958.png" alt="image-20230415155241848" loading="lazy">  </p><p>所以页式存储系统是这样的：<strong>一个程序（操作系统中称为进程)在逻辑上被分为若干大小相同的 “页面”，“页面” 大小与 “块” 大小相同，每个页面可以离散地放入不同的主存块</strong>。</p><ul><li>页面的划分属于逻辑角度，主存和 Cache 块的划分属于物理角度。</li></ul><h2 id="14-2-逻辑地址和物理地址"><a href="#14-2-逻辑地址和物理地址" class="headerlink" title="14.2.逻辑地址和物理地址"></a>14.2.逻辑地址和物理地址</h2><ul><li><strong>逻辑地址</strong>：程序员视角中看到的地址。</li><li><strong>物理地址</strong>：数据在主存中真实的地址。</li></ul><p>我们编写程序时，所操作的数据其显示的地址均为虚拟地址，真实的地址需要操作系统进行映射。那么为什么需要虚拟地址呢？</p><p>早期的计算机启动进程时，会将进程或程序所包含的东西全部加载进内存，而且访问的就是真实的物理内存。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151556888.png" loading="lazy"></p><p><strong>但是这种粗暴的操作有很大弊端</strong>，比如说经典的<strong>野指针</strong>问题在这种情况下就很容易产生，而且进程在运行中会产生大量数据，这些数据一旦不能连续存放，就会另外开辟空间，这无疑增加了异常访问的情况。</p><p>所以计算机设计者意识到了这种模式缺陷，想到了一种方法：增加一个中间层，利用中间层映射物理内存。程序访问内存时不直接访问物理内存，先访问中间层，如果中间层访问没有问题，那么操作系统就会将中间层映射到物理层，完成正常执行。</p><p><strong>一个进程创建之后，操作系统会为这个进程分配一个专属于它的大小为 4GB 的虚拟进程地址空间（4GB 是因为 32 位系统中，指针是 4 个字节），与它相对的是一片真实的物理地址空间，操作系统在映射虚拟内存时只会映射到那一片物理空间，而且需要特别注意这个虚拟空间并不是真的有 4GB，它只是虚拟的 。由于每一个进程都有自己的虚拟的进程地址空间，所以它只能访问自己的进程的数据，这样做实现了隔离，也就是进程之间的相互独立。并且把虚拟地址空间划分为这样、那样的区，也能实现数据的连续存放。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151557336.png" loading="lazy"></p><p>操作系统负责分页操作，该过程对程序员是不可见的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151604882.png" alt="image-20230415160453779" loading="lazy"></p><p>站在程序员的视角上，对于一个打包好的 4KB 程序，<strong>我们肯定是知道它的大小的，由于 4KB&#x3D;$ 2^{12}B $，因此可以编址，其范围为：000000000000~111111111111</strong>  。<br><strong>假设该程序中有一个变量 $x$ 的逻辑地址为：001000000011，另外一个变量 y 的逻辑地址为：110000001010</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151605640.png" loading="lazy"></p><p>在学习第一章时，我们知道取变量 $x$ 到 $ ACC $ 寄存器的操作对应的机器指令是：**000001 001000000011，分别对应操作码和地址码（逻辑地址)**，我们指明的仅仅是一个相对的地址，并不是说 $x$ 的地址真的就在那里。</p><p><strong>每个页的大小是 1KB。也就是 $2  ^{10} $B，因此可以将变量 $x$ 的逻辑地址分为两个部分：一个表示页号，一个表示页内地址，其中页内地址的大小取决于每个页面的大小，如果是 1KB，那么就需要 10 个比特位</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151605544.png" loading="lazy"></p><p>因此 $x$ 的逻辑地址：001000000011 就表示它在第 0 页，<strong>而 $x$ 的真实的物理地址可以用该页所在的主存的块号（12 位）+ 页内地址表示</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151606954.png" alt="image-20230415160639824" loading="lazy"></p><ul><li>此例中，第 0 页放在了主存的第 2 块，因此 $x$ 的真实地址为：0000000000101000000011。</li></ul><h2 id="14-3-页表和地址变换过程"><a href="#14-3-页表和地址变换过程" class="headerlink" title="14.3.页表和地址变换过程"></a>14.3.页表和地址变换过程</h2><h3 id="14-3-1-页表"><a href="#14-3-1-页表" class="headerlink" title="14.3.1.页表"></a>14.3.1.页表</h3><p>所以我们见到的地址均为虚拟的地址，给出逻辑地址后，操作系统必须将其转化为真实的物理地址再进行访存，<strong>其中最基本的一个操作就是把页号映射为块号</strong>，所以为了记录这样的映射关系，操作系统会建立一张页表 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151607454.png" alt="image-20230415160728373" loading="lazy"></p><p><strong>值得注意的是，页表中存放的数据是保存在主存中的，因此进行地址转换时还要要进行访存操作</strong>。</p><p>地址的变化过程大致如下：</p><ul><li><strong>拆分逻辑地址为页号和页内地址</strong>。</li><li><strong>CPU 中的页表基址寄存器指明了页表在主存中的存放位置</strong>（以地址为 1058 为例，就表示当前运行的程序其所对应的页表是从 1058 后的存储单元开始存储的，由于每个页表项的大小相同，所以只需顺次读取即可）。</li><li><strong>查询页表找到逻辑页面对应的主存块。</strong></li><li><strong>块号 + 页内地址 &#x3D; 物理地址</strong>。</li><li><strong>进行访存操作</strong>（Cache 未命中时进入主存）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151609908.png" alt="image-20230415160914781" loading="lazy"></p><h3 id="14-3-2-快表"><a href="#14-3-2-快表" class="headerlink" title="14.3.2.快表"></a>14.3.2.快表</h3><p><strong>依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项放在一个高速缓冲器中，称之为页表（TLB）中，则明显可以提高效率，相应地把放在主存中的页表称为慢表（Page）。</strong></p><p><strong>相应地在进行地址转换时，首先查快表，若命中，则无需访问主存中的页表；否则查询主存中完整的页表，查询之后为了以后便于访问将其加入到快表中</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151610663.png" alt="image-20230415161038540" loading="lazy">  </p><p>结合之前的 Cache，整个访存操作可以是如下流程 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151612532.png" alt="image-20230415161248408" loading="lazy"></p><h2 id="14-4-页式虚拟存储器"><a href="#14-4-页式虚拟存储器" class="headerlink" title="14.4.页式虚拟存储器"></a>14.4.页式虚拟存储器</h2><p>我们知道，运行一个程序时，需要将该程序调入主存，然后根据局部性原理，主存中的部分相关数据会调入 Cache 以提高性能。那么现在的问题是，<strong>一个程序调入主存时需要全部调入吗，还是只需要调入一部分就可以了呢？答案是部分即可</strong>。这一点大家可以联系我们日常使用的手机就能明白，手机内存有限，但是可以同时运行多个大体积程序。<strong>这就是虚拟存储系统：实际物理内存很有限，但是运行时似乎很大很大</strong>。</p><ul><li>Tips：游戏开局（比如英雄联盟）前面，会有一段加载资源的过程，也就是 “loading”，其实其中绝大部分的工作就是将相关数据从辅存调入主存。</li></ul><p>这一点其实与前面讲过的主存和 Cache 之间的关系比较相似，<strong>操作系统仍然会将程序分页，程序加载进主存时，会加载一部分，也就是说有的页已经加载进了主存，有的页还留在辅存中</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151614663.png" alt="image-20230415161451555" loading="lazy"></p><p>有分页自然也有负责映射的页表，只不过这里的页表和前面所讲的页表稍有不同，除了完成最基本的映射工作外，这里的页表还会增加以下选项：</p><ul><li><strong>有效位</strong>：该有效位如果为 1 表示该页已经被加载进了主存，如果为 0 表示仍然留在辅存中。</li><li><strong>外存块号</strong>：为了方便以后快速找到需要加载的页的位置，所以也会将辅存进行分块，并且记录其块号。这样以后程序在运行时，如果需要该数据就会能快速找到并加载进主存。</li><li><strong>访问位</strong>：前面说过 Cache 被填满后就要执行 Cache 替换算法。而访问位涉及到的就是<strong>页面置换算法</strong>，主存相较于辅存很小，注定只能保存一部分辅存的副本，所以主存很容易会被填满，当其填满时就要进行替换。访问位可以记录最近一段时间内，该页被访问了多少次，因此淘汰页面时可以优先淘汰次数最少的页面。</li><li><strong>脏位</strong>：如果脏位为 1 表示进行了更改，如果淘汰页面时则需要写回主存。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151615172.png" alt="image-20230415161547083" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151616896.png" loading="lazy">  </p><p>置于主存和辅存更详细的过程就需要在操作系统这么课中深究了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151617181.png" alt="image-20230415161744067" loading="lazy"></p><h2 id="14-5-段式虚拟存储器"><a href="#14-5-段式虚拟存储器" class="headerlink" title="14.5.段式虚拟存储器"></a>14.5.段式虚拟存储器</h2><p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两个部分：<strong>段号和段内地址</strong>。虚拟地址到实地址之间的变换是由段表实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变所以段表中要给出各段的起始地址和段的长度。</p><p>CPU 根据虚拟地址访存时，首先根据段号与该段基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存。已调入主存时，从段表读出该段在主存中的起始地址与段内地址（偏移量）相加，得到对应的主存实地址 。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151618608.png" alt="image-20230415161833520" loading="lazy"></p><p>段式虚拟存储器的<strong>优点</strong>是：段的分界与程序的自然分界对应，因为具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享  。<br><strong>缺点</strong>则是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p><h2 id="14-6-段页式虚拟存储器"><a href="#14-6-段页式虚拟存储器" class="headerlink" title="14.6.段页式虚拟存储器"></a>14.6.段页式虚拟存储器</h2><p><strong>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器</strong>。在段页式虚拟存储器中，每个程序对应一个段表， 每段对应一个页表， 段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</p><p>虚地址分为<strong>段号、段内页号、页内地址</strong>三部分。CPU 根据虚地址访存时，首先根据段号得到段表地址; 然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址; 最后从页表中取出实页号，与页内地址拼接形成主存实地址。</p><p>段页式虚拟存储器的<strong>优点</strong>是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。<strong>缺点</strong>是在地址变换过程中需要两次查表，系统开销较大。</p><h2 id="14-7-虚拟存储器与-Cache-比较"><a href="#14-7-虚拟存储器与-Cache-比较" class="headerlink" title="14.7.虚拟存储器与 Cache 比较"></a>14.7.虚拟存储器与 Cache 比较</h2><h3 id="14-7-1-相同"><a href="#14-7-1-相同" class="headerlink" title="14.7.1.相同"></a>14.7.1.相同</h3><ol><li>最终目的都是为了<strong>提高系统性能</strong>，两者都有<strong>容量、速度和价格</strong>的梯度。</li><li>都把数据分为<strong>小的信息块，并作为基本的传递单位</strong>，虚拟存储器系统的信息块更大。</li><li>都有地址的<strong>映射、替换算法和更新</strong>策略等问题。</li><li>依据程序的局部性原理应用 “<strong>快速缓存的思想</strong>”，将活跃的数据放在相对高速的部件中。</li></ol><h3 id="14-7-2-不同"><a href="#14-7-2-不同" class="headerlink" title="14.7.2.不同"></a>14.7.2.不同</h3><ol><li>Cache 主要为了解决<strong>系统的速度</strong>，而虚拟存储器则为了解决<strong>主存容量。</strong></li><li><strong>Cache 全由硬件实现</strong>，是硬件存储器，对程序员透明；<strong>而虚拟存储器由 OS 和硬件共同实现</strong>，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</li><li>由于 CPU 的速度约为 Cache 的 10 倍，主存的速度约为硬盘的 100 倍以上，<strong>因此虚拟存储器系统不命中时对系统的性能影响很大。</strong></li><li><strong>CPU 与 Cache 和主存都建立了直接访问的通路，而辅存与 CPU 没有直接通路</strong>。也就是说在 Cache 不命中时主存能和 CPU 直接通信，同时将数据调入 Cache；而虚拟存储器系统不命中时，只能先由硬盘调入内存，而不能直接和 CPU 通信。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-存储器概述&quot;&gt;&lt;a href=&quot;#1-存储器概述&quot; class=&quot;headerlink&quot; title=&quot;1.存储器概述&quot;&gt;&lt;/a&gt;1.存储器概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wushua</summary>
      
    
    
    
    <category term="考研408" scheme="http://ccsu.top/categories/%E8%80%83%E7%A0%94408/"/>
    
    
    <category term="计算机组成原理" scheme="http://ccsu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="考研" scheme="http://ccsu.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>机组-第二章 数据的表示和运算</title>
    <link href="http://ccsu.top/posts/189f252b/"/>
    <id>http://ccsu.top/posts/189f252b/</id>
    <published>2023-04-03T16:00:00.000Z</published>
    <updated>2023-04-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数制与编码"><a href="#1-数制与编码" class="headerlink" title="1.数制与编码"></a>1.数制与编码</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912268.png" alt="image-20230413140118235" loading="lazy"></p><h2 id="1-1-进位计数法"><a href="#1-1-进位计数法" class="headerlink" title="1.1.进位计数法"></a>1.1.进位计数法</h2><h3 id="1-1-1-进位计数法"><a href="#1-1-1-进位计数法" class="headerlink" title="1.1.1.进位计数法"></a>1.1.1.进位计数法</h3><p><strong>进位计数法</strong>：进位计数法是一种计数的方法。常用的有十进制、二进制、八进制和十六进制等。日常生活中最常使用的就是十进制，其余则主要是计算机在运算是时使用。在进行计数法中，每个数所用到的不同数码的个数称为<strong>基数</strong>。</p><ul><li>例如：十进制的基数为 0~9，每个数位计满 10 后就会向高位进位。</li></ul><p><strong>每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加</strong>。</p><p><strong>例如</strong>：一个<code>r</code>进制数$(K_nK_{n-1}…K_0K_{-1}…K_{-m})$的数值可以表示为<br>具${K_nr^2+K_{n-1}r^{n-1}+…+K_0r^0+K_{-1}r^{-1}+…+K_{-m}r^{-m}&#x3D;\sum_{i&#x3D;n}^{-m} k_ir^i}$，具体来说：</p><ul><li><p><strong>十进制</strong>：例如 975</p><p>$975.36 &#x3D; 9 × 100 + 7 × 10 + 5 × 1 + 3 × 0.1 + 6 × 0.01 $ ，也即 $975 &#x3D; 9 × 1 0 ^2 + 7 × 1 0 ^1 + 5 × 1 0^ 0 + 3 × 1 0 ^{− 1} + 6 × 1 0 ^{− 2} $</p></li><li><p><strong>二进制</strong>：只有 0 和 1 两种数字符号，“逢 2 进 1”，其任意数位的权为$2^i$ ，<code>i </code>为所在位数。</p></li><li><p><strong>八进制</strong>：八进制作为二进制的一种书写形式，其基数是 8，有 0~7 共 8 个不同的数字符号，“逢 8 进 1”。由于$ r&#x3D;8&#x3D;2^{3}$。</p></li><li><p><strong>十六进制</strong>：其基数为 16，“逢 16 进 1”，其中 A、B、C、D、E、F 分别表示 10、11、12、13、14、15. 由于$r&#x3D;16&#x3D;2^{4}$。</p></li></ul><h3 id="1-1-2-计算机采用二进制编码的原因"><a href="#1-1-2-计算机采用二进制编码的原因" class="headerlink" title="1.1.2.计算机采用二进制编码的原因"></a>1.1.2.计算机采用二进制编码的原因</h3><p><strong>原因如下</strong>：</p><ul><li><strong>二进制只有两种状态</strong>：使用有两个稳定状态的器件就可以表示二进制数的每一位，制造成本较低。比如可以利用高低电平和电荷正负表示 0 和 1。</li><li><strong>二进制的 1 和 0 正好与逻辑值真和假相对应</strong>：这为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。</li><li><strong>二进制的编码和运算规则很简单</strong>：通过逻辑门电路可以方便地实现算数运算。</li></ul><h2 id="1-2-进制转换"><a href="#1-2-进制转换" class="headerlink" title="1.2.进制转换"></a>1.2.进制转换</h2><p><strong>进制转换黄金原则（看完下面再看）：一切转换均可借助二进制作为媒介完成</strong>。</p><ul><li><strong>八进制、十六进制和二进制之间是有位数对应的关系的。</strong></li><li><strong>十进制和二进制可以直接通过权值累加得到。</strong></li></ul><h3 id="1-2-2-其他进制数转换为十进制"><a href="#1-2-2-其他进制数转换为十进制" class="headerlink" title="1.2.2.其他进制数转换为十进制"></a>1.2.2.其他进制数转换为十进制</h3><p><strong>其他进制数转换为十进制：其他进制数转化为十进制较为简单，只需代入下面的公式即可<br>${K_nr^2+K_{n-1}r^{n-1}+…+K_0r^0+K_{-1}r^{-1}+…+K_{-m}r^{-m}&#x3D;\sum_{i&#x3D;n}^{-m} k_ir^i}$</strong></p><p><strong>例如</strong>：要把一个二进制数转为十进制数，那么上式中的 $r$ 就设为 2， 然后用二进制数的每一位乘以 $ r^{n} $，这个 n 表示的是位权（小数点左侧从右向左由 0 递增，小数点右侧从左至右由 - 1 递减），再举几个例子：</p><ul><li><p><strong>二进制数 10010010.100 转化为十进制数：</strong> $10010010.110 &#x3D; 1×2^{7}+1×2^{4}+1×2^{1}+1×2^{-1}+1×2^{-2}&#x3D;146.75 $</p></li><li><p>**八进制数 251.5 转化为十进制数：$251.5 &#x3D;2×8^{2}+5×8^{1}+1×8^{0}+5×8^{-1} $。</p></li><li><p><strong>十六进制数 AE86.1 转化为十进制数：</strong> $AE86.1&#x3D;10×16^{3}+14×16^{2}+8×16^{1}+6×16^{0}+1×16^{-1}&#x3D;44678.0625 $</p></li></ul><h3 id="1-2-2-十进制数转化为其他进制数"><a href="#1-2-2-十进制数转化为其他进制数" class="headerlink" title="1.2.2.十进制数转化为其他进制数"></a>1.2.2.十进制数转化为其他进制数</h3><p><strong>十进制数转化为其他进制数：需要把整个过程分为求整数部分和求小数两部分</strong>。</p><ul><li><strong>求整数：第 i 次除以基数 b 所得到的的余数即为 $A_i$，然后继续利用所得商运算，直到所得商为 0，其中$i\in (1,n) $，最后结果反着写。</strong></li><li><strong>求小数： 第 i次乘以基数 b 所得的整数部分即为$A_{-i}$​，其中 $i\in (1,n)$，需要注意每次乘法之后要把个位处置 0。</strong></li></ul><p><strong>例如</strong>：7562.03125 转化为 16 进制数。</p><p>首先，列一个表格计算整数部分：</p><ul><li>整数部分为 1D8A。</li></ul><table><thead><tr><th>除以 16</th><th>所得商</th><th>所得余数</th><th>对应符号</th></tr></thead><tbody><tr><td>7562/16</td><td>472</td><td>10</td><td>A</td></tr><tr><td>472/16</td><td>29</td><td>8</td><td>8</td></tr><tr><td>29/16</td><td>1</td><td>13</td><td>D</td></tr><tr><td>1/16</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>然后计算小数部分：</p><ul><li><strong>注意</strong>：再进行下一次乘积运算时，要取上一次乘积的小数部分作为新的乘数进行运算，比如第二次运算乘积为 8，下一次运算时直接要取小数部分进行运算。</li><li>小数部分为 08。</li></ul><table><thead><tr><th>乘以 16</th><th>所得乘积</th><th>取乘积整数位</th><th>对应符号</th></tr></thead><tbody><tr><td>0.03125×16</td><td>0.5</td><td>0</td><td>0</td></tr><tr><td>0.5×16</td><td>8.0</td><td>8</td><td>8</td></tr><tr><td>0×16</td><td>0.0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>到这里转换完成，答案为 1D8A.08</strong>。</p><p>上述方法是比较通用的方法。在实际情况中，尤其涉及编程、网络时，会频繁涉及到 10 进制数转化为 2 进制数的问题，<strong>所以这里还可以使用拼凑法，首先你需要牢记常用 $ 2^{n} $ 的值</strong>。</p><table><thead><tr><th>2 10 2^{10}</th><th>2 9 2^{9}</th><th>2 8 2^{8} </th><th>2 7 2^{7}</th><th>2 6 2^{6}</th><th>2 5 2^{5} </th><th>2 4 2^{4}</th><th>2 3 2^{3}</th><th>2 2 2^{2} </th><th>2 1 2^{1} </th><th>2 0 2^{0} </th><th>2 − 1 2^{-1} </th><th>2 − 2 2^{-2} </th><th>2 − 3 2^{-3} </th></tr></thead><tbody><tr><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr></tbody></table><p>转换时，只需要目测估值即可，比如 260.75，260&#x3D;256+4，同时 0.75 等于 0.5+0.25，相应位置填 1 即可。</p><table><thead><tr><th>2 10 2^{10}</th><th>2 9 2^{9}</th><th>2 8 2^{8} </th><th>2 7 2^{7}</th><th>2 6 2^{6}</th><th>2 5 2^{5} </th><th>2 4 2^{4}</th><th>2 3 2^{3}</th><th>2 2 2^{2} </th><th>2 1 2^{1} </th><th>2 0 2^{0} </th><th>2 − 1 2^{-1} </th><th>2 − 2 2^{-2} </th><th>2 − 3 2^{-3} </th></tr></thead><tbody><tr><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>所以  $(260.75)<em>{10}\rightarrow (100000100.11)</em>{2} $</p><h3 id="1-2-3-二进制、八进制和十六进制的相互转换"><a href="#1-2-3-二进制、八进制和十六进制的相互转换" class="headerlink" title="1.2.3.二进制、八进制和十六进制的相互转换"></a>1.2.3.二进制、八进制和十六进制的相互转换</h3><p><strong>二进制、八进制和十六进制的相互转换：这几个进制之间是具有对应关系的，所以可以快速转换。</strong></p><ul><li><strong>八进制</strong>：八进制作为二进制的一种书写形式，其基数是 8，有 0~7 共 8 个不同的数字符号，“逢 8 进 1”。由于$ r&#x3D;8&#x3D;2^{3} $，<strong>所以 3 位二进制数码与 1 位八进制数码相对应</strong>。</li><li><strong>十六进制</strong>：其基数为 16，“逢 16 进 1”，其中 A、B、C、D、E、F 分别表示 10、11、12、13、14、15. 由于 $r&#x3D;16&#x3D;2^{4}$，<strong>所以 4 位二进制数码与 1 位十六进制数码相对应。</strong></li></ul><p><strong>因此转换时，以小数点作为起始点，向左向右分别进行划分，如果是八进制就是三位，如果是十六进制就是 4 位。</strong></p><ul><li>如果位数不足要把 “0” 补上，防止误判。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912461.png" loading="lazy"></p><p>再比如：</p><ul><li>$ (251.5)<em>{8}\rightarrow (010 101 001 . 101)</em>{2} $</li><li>$(AE86.1)<em>{16}\rightarrow (1010111010000110.0001 )</em>{2} $</li></ul><h2 id="1-3-真值和机器数（考纲已删除）"><a href="#1-3-真值和机器数（考纲已删除）" class="headerlink" title="1.3.真值和机器数（考纲已删除）"></a>1.3.真值和机器数（考纲已删除）</h2><p><strong>真值：日常生活中，对于正数和负数我们可以使用正号 (通常省略) 和负号来表示，如 15 和 - 8。</strong>这种带 “+” 和“-”符号的数称为真值，真值是机器数所代表的实际值。</p><p><strong>机器数：在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。例如后面需要学习的原码，补码和反码。这几种表示法都将数据的符号数字化，通常用 “0” 表示正，用 “1” 表示负</strong>。</p><h1 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2.BCD码"></a>2.BCD码</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912380.png" alt="image-20230413140143728" loading="lazy"></p><h2 id="2-1-什么是-BCD-码"><a href="#2-1-什么是-BCD-码" class="headerlink" title="2.1.什么是 BCD 码"></a>2.1.什么是 BCD 码</h2><p><strong>BCD 码 (Binary-Coded Decimal)：</strong>是指二进制编码的十进制数。我们可以用 4 位二进制数来表示一位十进制数中的 0~9，这种编码方法使得二进制数和十进制数之间的转换得以快速进行。4 位二进制数最多有 16 种组合，足以表示 0 到 9 这十个数，所以<strong>有 6 种状态为冗余状态</strong>。</p><h2 id="2-2-常用的-BCD-码"><a href="#2-2-常用的-BCD-码" class="headerlink" title="2.2.常用的 BCD 码"></a>2.2.常用的 BCD 码</h2><h3 id="2-1-1-8421-码（最常用）"><a href="#2-1-1-8421-码（最常用）" class="headerlink" title="2.1.1.8421 码（最常用）"></a>2.1.1.8421 码（最常用）</h3><p><strong>A：8421 码表示</strong></p><p><strong>8421 码 (Binary-Coded Decimal)：它是一种有权码，设其每一位的数值为$b1,b2,b3,b4 $，则权值从高到低依次为 8 , 4 , 2 , 1 ，它表示的十进制数为 $D&#x3D;8b_{3}+4b_{2}+2b_{1}+1b_{0}$​</strong>。</p><ul><li>例如 985 的 8421 码为<code>1001</code> <code>1000</code> <code>0101</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912137.png" loading="lazy"></p><p><strong>B：8421 码运算规则</strong></p><p><strong>8421 码运算规则：</strong></p><ul><li><strong>如果两个 8421 码相加之和小于等于$(1001)_{2}$不需要修正</strong>。</li><li><strong>如果两个 8421 码相加之和大于$ (1001)_{2} $则需要修正</strong>：<strong>修正时需要 + 6</strong>。</li></ul><p>以 5+8 为例：  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912688.png" loading="lazy"></p><h3 id="2-1-2-余-3-码"><a href="#2-1-2-余-3-码" class="headerlink" title="2.1.2.余 3 码"></a>2.1.2.余 3 码</h3><p>余 3 码：余 3 码是一种<strong>无权码</strong>，是在 8421 码的基础上加$(3)<em>{10}$，也即$ (0011)</em>{2}$形成的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913061.png" loading="lazy"></p><h3 id="2-1-3-2421-码"><a href="#2-1-3-2421-码" class="headerlink" title="2.1.3.2421 码"></a>2.1.3.2421 码</h3><p>2421 码：这是一种<strong>有权码</strong>。权值由高到低分别为 2 4 2 1，特点是<strong>大于等于 5 (5<del>9)<strong>的 4 位二进制数中最高位为 1，</strong>小于 5 (0</del>4</strong>)的最高位为 0。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913503.png" loading="lazy"></p><h1 id="3-无符号数的表示和运算"><a href="#3-无符号数的表示和运算" class="headerlink" title="3.无符号数的表示和运算"></a>3.无符号数的表示和运算</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913478.png" alt="image-20230413140703670" loading="lazy"></p><h2 id="3-1-机器数的定点表示"><a href="#3-1-机器数的定点表示" class="headerlink" title="3.1.机器数的定点表示"></a>3.1.机器数的定点表示</h2><p>根据小数点的位置是否固定，在计算机中有两类数据表示方法：<strong>定点表示和浮点表示</strong>。浮点表示类似于科学计数法，将在第三节介绍。</p><p><strong>机器数的定点表示：定点表示就是约定机器数中的小数点位置固定不变，小数点不再使用<code>.</code>表示，而是约定其位置。理论上，小数点位置固定在任何一位都可以，但是在计算机中通常采用两种简单的约定：</strong></p><ul><li><p>定点整数：将小数点的位置固定在数据的最低位之后。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913271.png" alt="在这里插入图片描述" loading="lazy"></p></li><li><p>定点小数：将小数点的位置固定在数据的最高位之前。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913416.png" alt="在这里插入图片描述" loading="lazy"></p></li></ul><h2 id="3-2-无符号整数的概念及其在计算机中的应用"><a href="#3-2-无符号整数的概念及其在计算机中的应用" class="headerlink" title="3.2.无符号整数的概念及其在计算机中的应用"></a>3.2.无符号整数的概念及其在计算机中的应用</h2><p>**无符号整数（无符号数）：无符号整数是指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值，它就是我们常说的自然数； n 位无符号数其范围为$(0，2^{n}-1)$**。</p><p>在 C 语言中，使用关键字<code>unsigned</code>修饰后，该变量即为无符号数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>以下讨论中假设机器字长为 8 位。</li></ul><p><strong>无符号整数硬件表示：由于无符号整数全部二进制位均为数值位，没有符号位，所以数值位均有位权，也即之前说到过的二进制。注意</strong>：</p><ul><li><p><strong>最小的无符号整数为全 0</strong>。</p></li><li><p><strong>最大的无符号整数为全 1。</strong></p></li><li><p>$n$位无符号数其范围为$(0,2^{n}-1)$<strong>，一旦超出则会溢出。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913535.png" alt="image-20230413140452529" loading="lazy"></p><h2 id="3-3-加法运算"><a href="#3-3-加法运算" class="headerlink" title="3.3.加法运算"></a>3.3.加法运算</h2><p><strong>无符号整数加法运算规则：从低位开始，按位相加，向更高位进位</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913538.png" alt="image-20230413140521323" loading="lazy"></p><h2 id="3-4-减法运算"><a href="#3-4-减法运算" class="headerlink" title="3.4.减法运算"></a>3.4.减法运算</h2><p><strong>无符号整数减法运算规则：由于减法电路实现较加法电路困难，所以成本较高，因此会将减法运算转换为加法运算来完成运算。具体来说：</strong></p><ul><li><strong>被减数不变，减数按位取反、末位 + 1。</strong></li><li><strong>从低位开始，按位相加，向更高位进位。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913568.png" alt="image-20230413140618463" loading="lazy"></p><ul><li>注意高位被丢弃了。</li></ul><h1 id="4-有符号数的表示和运算"><a href="#4-有符号数的表示和运算" class="headerlink" title="4.有符号数的表示和运算"></a>4.有符号数的表示和运算</h1><h2 id="4-1-有符号数的概念及其在计算机中应用"><a href="#4-1-有符号数的概念及其在计算机中应用" class="headerlink" title="4.1.有符号数的概念及其在计算机中应用"></a>4.1.有符号数的概念及其在计算机中应用</h2><p>有符号数：由于计算机是无法直接识别数的正负的，所以可以将<strong>符号数值化</strong>。规定：对于有符号数，用 <strong>“0” 表示正</strong>，<strong>用 “1” 表示负</strong>，且<strong>通常约定二进制数位的最高位为符号位</strong>。<strong>有符号数</strong>分为<strong>定点整数</strong>和<strong>定点小数</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913802.png" alt="image-20230413143308253" loading="lazy"></p><p><strong>定点整数和定点小数可以原码、反码、补码和移码(只有定点整数有)来表示。假设真值为<code>x</code>，则：</strong></p><ul><li><strong>原码</strong>： $[x]_{原}$</li><li><strong>反码</strong>： $[x]_{反}$</li><li><strong>补码</strong>： $ [x]_{补} $</li><li><strong>移码</strong>： [$[x]_{移}$</li></ul><h2 id="4-2-有符号数的表示"><a href="#4-2-有符号数的表示" class="headerlink" title="4.2.有符号数的表示"></a>4.2.有符号数的表示</h2><h3 id="4-2-1-原码"><a href="#4-2-1-原码" class="headerlink" title="4.2.1.原码"></a>4.2.1.原码</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913076.png" alt="image-20230413142430182" loading="lazy"></p><p><strong>原码：原码是一种比较简单、直观的机器数表示法。用机器数的最高位表示该数的符号，其余的各位表示数的绝对值，其中 0 表示正，1 表示负</strong>。</p><p>以 <code>19.75 </code> 为例，假设机器字长为 8 位：</p><ul><li>整数部分：19</li><li>小数部分：0.75</li></ul><h4 id="4-2-1-1-定点整数的原码表示"><a href="#4-2-1-1-定点整数的原码表示" class="headerlink" title="4.2.1.1.定点整数的原码表示"></a>4.2.1.1.定点整数的原码表示</h4><p>①：表示方法</p><p><strong>定点整数的原码表示方法</strong>：按照二进制的位权书写即可，不足位可以用 0 补齐。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913783.png" loading="lazy"></p><p>②：原码整数的表示范围</p><p><strong>原码整数的表示范围</strong>：假如机器字长为<code>n</code>位，那么原码整数的表示范围为$ -(2^{n-1}-1) \leqslant x \leqslant 2^{n-1}-1 $。</p><p>③：真值 0</p><ul><li>真值 0 有 <code>+ 0 0 0</code> 和 <code>- 0 0 0 </code><strong>两种形式。</strong></li></ul><h4 id="4-2-1-2-定点小数的原码表示"><a href="#4-2-1-2-定点小数的原码表示" class="headerlink" title="4.2.1.2.定点小数的原码表示"></a>4.2.1.2.定点小数的原码表示</h4><p>①：表示方法</p><p><strong>定点小数的原码表示方法</strong>：按照二进制的位权书写即可，不足位可以用 0 补齐。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913110.png" loading="lazy"></p><p>②：原码小数的表示范围</p><p><strong>原码小数数的表示范围</strong>：假如机器字长为 <code>n </code> 位，那么原码小数数的表示范围为$ -(1-2^{-n+1}) \leqslant x \leqslant 1-2^{-n+1} $。</p><p>③：真值 0</p><ul><li>真值 0 有<code>+ 0 0 0</code>和<code> - 0 0 0</code> <strong>两种形式</strong>。</li></ul><h3 id="4-2-2-反码"><a href="#4-2-2-反码" class="headerlink" title="4.2.2.反码"></a>4.2.2.反码</h3><p><strong>反码：反码是原码转换为补码的一个中间状态。</strong></p><p><strong>①：如果是正数，则反码与原码相同</strong></p><ul><li><p>例如 + 19D，其$ [x]<em>{原}&#x3D;0,0010011 [x] $， $ [x]</em>{反}&#x3D;0,0010011 $</p></li><li><p>例如 + 0.75D，其$[x]<em>{原}&#x3D;0.1100000 $， $[x]</em>{反}&#x3D;0.1100000$</p></li></ul><p><strong>②：如果是负数，则除符号位外，其他位按位取反</strong></p><ul><li><p>例如 - 19D，其$ [x]<em>{原}&#x3D;1,0010011$， $[x]</em>{反}&#x3D;1,1101100 [x] $</p></li><li><p>例如 - 0.75D，其 $ [x]<em>{原}&#x3D;1.1100000$， $[x]</em>{反}&#x3D;1.0011111 [x] $</p></li></ul><p><strong>③：特别注意真值 0 的 + 0 和 - 0 所对应的形式</strong></p><ul><li><p>[$ [+0]<em>{原}&#x3D;00000000 [+0] $，$[+0]</em>{反}&#x3D;00000000$</p></li><li><p>$ [-0]<em>{原}&#x3D;10000000$，$ [-0]</em>{反}&#x3D;11111111$</p></li></ul><h3 id="4-2-3-补码"><a href="#4-2-3-补码" class="headerlink" title="4.2.3.补码"></a>4.2.3.补码</h3><p><strong>①：如果是正数，则补码和原码一致</strong></p><ul><li><p>例如 + 19D，其 $ [x]<em>{原}&#x3D;0,0010011$， $ [x]</em>{反}&#x3D;0,0010011$， $[x]_{补}&#x3D;0,0010011$</p></li><li><p>例如 + 0.75D，其$[x]<em>{原}&#x3D;0.1100000 [x] $， $[x]</em>{反}&#x3D;0.1100000 [x] $， $ [x]_{补}&#x3D;0.1100000$</p></li></ul><p><strong>②：如果是负数，则补码 &#x3D; 反码 + 1（注意进位）</strong></p><ul><li><p>例如 - 19D，其$ [x]<em>{原}&#x3D;1,0010011 $，$[x]</em>{反}&#x3D;1,1101100 [x] $， $ [x]_{补}&#x3D;1,1101101 $</p></li><li><p>例如 - 0.75D，其 $ [x]<em>{原}&#x3D;1.1100000 $， $ [x]</em>{反}&#x3D;1.0011111 [x] $， $ [x]_{补}&#x3D;1.0100000$</p></li></ul><p><strong>③：特别注意的是补码的真值 0 只有一种表现形式</strong></p><p>因为 $ [-0]<em>{原}&#x3D;10000000 $， $ [-0]</em>{反}&#x3D;11111111 [−0] $，其补码如果在此基础再加 1，就会超出机器数位的限制（这里假定 8 位），变为$1,00000000 $。这样一来，低八位就又变成了 $00000000$，反而和 <code>+ 0 0 0 </code>冲突了，并且显得浪费，所以把我们这个**特殊的补码直接规定为 $−128$*<em>。所以这里如果机器字长为 n 位，那么</em>补码整数的表示范围就为（多了一个<code>-128</code>）：  </p><p>​                                $ -(2^{n-1}) \leqslant x \leqslant 2^{n-1}-1 $</p><p>相应的，<strong>补码小数 1.00000000 1.00000000 1.00000000 的表示范围会变为（多了一个 - 1）</strong>。<br>                                $-1 \leqslant x \leqslant 1-2^{-n+1} $</p><h3 id="4-2-4-移码"><a href="#4-2-4-移码" class="headerlink" title="4.2.4.移码"></a>4.2.4.移码</h3><blockquote><p><strong>移码只能用来表示整数，而不能表示小数</strong>。</p></blockquote><p><strong>移码：移码是在补码的基础上将符号位取反，需要注意移码只能用于表示整数，且移码和补码的真值 0 是保持一致的</strong></p><ul><li><p>例如 + 19D，其$ [x]<em>{原}&#x3D;0,0010011 $，$ [x]</em>{反}&#x3D;0,0010011 [x] $， $ [x]<em>{补}&#x3D;0,0010011 $， $ [x]</em>{移}&#x3D;1,0010011 $</p></li><li><p>例如 - 19D，其 $ [x]<em>{原}&#x3D;1,0010011 $， $ [x]</em>{反}&#x3D;1,1101100 [x] $， $ [x]<em>{补}&#x3D;1,1101101 $，$ [x]</em>{移}&#x3D;0,1101101 $</p></li></ul><p><strong>移码是补码的符号位取反，可以将其看做一个无符号数，因此真值增大时移码也在增大，可以很方便的使用移码对数的大小进行比较</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913671.png" loading="lazy"></p><h2 id="4-3-原码、反码、补码总结"><a href="#4-3-原码、反码、补码总结" class="headerlink" title="4.3.原码、反码、补码总结"></a>4.3.原码、反码、补码总结</h2><h3 id="4-3-1-原码、补码运算技巧"><a href="#4-3-1-原码、补码运算技巧" class="headerlink" title="4.3.1.原码、补码运算技巧"></a>4.3.1.原码、补码运算技巧</h3><ul><li>如果已经知道 X 的补码，让你求 - X 的补码，只需<strong>所有位全部取反，末位 + 1 即可</strong>。</li><li>负数补码是在反码末位 + 1 后得到的，所以这就导致反码最右边连续的 1 都会因为进位而变为 0，直到进位碰到第一个 0 为止。因此，负数补码中，<strong>最右边的（最后一个 1）及其右面与原码相同，而其左面则与反码相同。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913413.png" alt="image-20230413143849083" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913974.png" alt="image-20230413143041534" loading="lazy"></p><h3 id="4-3-2-原码、反码、补码、移码特性（整数）"><a href="#4-3-2-原码、反码、补码、移码特性（整数）" class="headerlink" title="4.3.2.原码、反码、补码、移码特性（整数）"></a>4.3.2.原码、反码、补码、移码特性（整数）</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913053.png" alt="image-20230413143152103" loading="lazy"></p><h3 id="4-3-3-定点小数和定点整数对比"><a href="#4-3-3-定点小数和定点整数对比" class="headerlink" title="4.3.3.定点小数和定点整数对比"></a>4.3.3.定点小数和定点整数对比</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913125.png" alt="image-20230413143430341" loading="lazy"></p><h2 id="4-4-引入补码的目的"><a href="#4-4-引入补码的目的" class="headerlink" title="4.4.引入补码的目的"></a>4.4.引入补码的目的</h2><h3 id="4-4-1-直接使用原码进行运算的弊端"><a href="#4-4-1-直接使用原码进行运算的弊端" class="headerlink" title="4.4.1.直接使用原码进行运算的弊端"></a>4.4.1.直接使用原码进行运算的弊端</h3><p>对于<strong>无符号数</strong>，直接使用原码进行运算是没有问题的，如下图：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913854.png" loading="lazy"></p><p> 但对于<strong>有符号数</strong>，由于最高位表示的是符号位，所以下面计算的结果<strong>明显是错误的</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913956.png" loading="lazy">  </p><p>要想得到正确的运算结果，那就得要求计算机能够识别加减运算，也即算术逻辑单元 ALU 不只需要加法器，还得需要减法器才行。<strong>但由于减法器实现比较困难且成本巨大，所以一个可行的方案就是使用加法代替减法。</strong></p><h3 id="4-4-2-如何使用加法实现减法"><a href="#4-4-2-如何使用加法实现减法" class="headerlink" title="4.4.2.如何使用加法实现减法"></a>4.4.2.如何使用加法实现减法</h3><p><strong>如下是一个时钟，指针开始时指向的是 10，如果要让其指向 7，那么有两种方法</strong>：</p><ul><li><strong>逆时针旋转至 7</strong>：相当于做了减法，即<code>10-3=7</code>。</li><li><strong>顺时针旋转至 7</strong>：相当于做了加法，但这里应该加多少呢？可以加 9，然后由于表盘最大数为 12，所以<code>19%12=7</code>，便指向了 7。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913736.png" loading="lazy"></p><p><strong>这个例子说明了一个道理：一个减法操作可以转换为一个与之对应的加法操作，而这里采用的是取余</strong></p><ul><li>-3 和 + 9 在 <strong>mod 12</strong> 这样的情况下是等价的，而这两个数相差正好就是 12。还有很多这样的数，比如 21、33、-15 等等，<strong>这些数之间的差距均为 12 或其倍数。</strong></li></ul><p>其实，上例中的 - 3 和 9 <strong>互为补数</strong>，因为<strong>这两个数的绝对值之和为 12。</strong></p><p>$ -a(a&gt;0) 的补数 &#x3D; 模 -|a| $</p><p><strong>补数的性质非常重要，假设互为补数的两数之和为 <code> m</code>，那么在 <code>mod m</code> 的条件下，若能找到负数的补数，就可以用正数的加法代替减法</strong></p><p>如下例  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913069.png" loading="lazy"> </p><p>按照上面所述，要完成运算，<strong>只需要找到 - 14 的补数即可</strong>。这里机器字长为<code>8bit</code>，所以可以表示的数范围为$2^{8}− 1 $，这个$2^{8}− 1 $就相当于表盘上的 12，<strong>所以当某数大于 $2^{8}− 1 $ 时，由于机器字长的限制，计算机便帮助我们 “自动” 进行了一个 mod 运算，该数会被重新映射到合法范围内</strong>。</p><ul><li><code>mod 12</code>把数映射到了 0-11 这个范围内，<code>mod</code> $2^{8}$把数映射到了 $ 0-2^{8}-1 $这个范围内。</li></ul><p>因此，**-14 的补数为 $+ 1 , 00000000 - 00001110 &#x3D; 11110010 $<strong>，</strong>大家认真观察就可以发现 -14 的补数其实就是 - 14 的补码**。</p><p>最后，使用 11110010 11110010 11110010 替换原来的减法完成运算，其结果就是 0（截断）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914467.png" loading="lazy"></p><h2 id="4-5-有符号数补码运算"><a href="#4-5-有符号数补码运算" class="headerlink" title="4.5.有符号数补码运算"></a>4.5.有符号数补码运算</h2><ul><li>原码运算不用多说，以下运算中必须把运算数全部转换为<strong>补码</strong>进行（特指负数）。</li></ul><h3 id="4-5-1-定点整数的补码运算"><a href="#4-5-1-定点整数的补码运算" class="headerlink" title="4.5.1.定点整数的补码运算"></a>4.5.1.定点整数的补码运算</h3><h4 id="4-5-1-1-加法运算"><a href="#4-5-1-1-加法运算" class="headerlink" title="4.5.1.1.加法运算"></a>4.5.1.1.加法运算</h4><p><strong>定点整数补码加法运算规则：从最低位开始，按位相加（符号位参与运算），向更高位进位</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914964.png" alt="image-20230413144152183" loading="lazy"></p><h4 id="4-5-1-2-减法运算"><a href="#4-5-1-2-减法运算" class="headerlink" title="4.5.1.2.减法运算"></a>4.5.1.2.减法运算</h4><p><strong>定点整数补码减法运算规则：$ [A]<em>{补} - [B]</em>{补}&#x3D;  [A]<em>{补} +  [-B]</em>{补}$，重点问题在于已知 $ [B]<em>{补} $如何求$ [-B]</em>{补}$，如下</strong>  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922275.png" alt="image-20230413144231881" loading="lazy"></p><p><strong>这样一来，减法就转变为了加法，剩余步骤同上</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914938.png" alt="image-20230413144349687" loading="lazy"></p><h3 id="4-5-2-定点小数的补码运算"><a href="#4-5-2-定点小数的补码运算" class="headerlink" title="4.5.2.定点小数的补码运算"></a>4.5.2.定点小数的补码运算</h3><h4 id="4-5-2-1-加法运算"><a href="#4-5-2-1-加法运算" class="headerlink" title="4.5.2.1.加法运算"></a>4.5.2.1.加法运算</h4><ul><li>同定点整数运算规则</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914914.png" loading="lazy"></p><h4 id="4-5-2-2-减法运算"><a href="#4-5-2-2-减法运算" class="headerlink" title="4.5.2.2.减法运算"></a>4.5.2.2.减法运算</h4><ul><li>同定点整数运算规则</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914546.png" loading="lazy"></p><h2 id="4-6-溢出判别方法"><a href="#4-6-溢出判别方法" class="headerlink" title="4.6.溢出判别方法"></a>4.6.溢出判别方法</h2><p>如下，求 $ [A+C]<em>{补} $和 $ [B-C]</em>{补} $​。运算过后你会得到一非常奇怪的结果。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914234.png" loading="lazy"></p><p>这是因为<strong>发生了溢出</strong>，溢出分为上溢和下溢：</p><ul><li><p><strong>正数 + 正数导致上溢</strong>：正 + 正 &#x3D; 负  。</p></li><li><p><strong>负数 + 负数导致下溢</strong>：负 + 负 &#x3D; 正  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914548.png" loading="lazy"></p></li></ul><h3 id="4-6-1-采用一位符号位依据溢出表达式判断"><a href="#4-6-1-采用一位符号位依据溢出表达式判断" class="headerlink" title="4.6.1.采用一位符号位依据溢出表达式判断"></a>4.6.1.采用一位符号位依据溢出表达式判断</h3><p>对于上面的例子：</p><ul><li>$[A+C]_{补}&#x3D;0,0001111+0,1111100&#x3D;1,0001011$，真值 - 117</li><li>$ [B-C]_{补}&#x3D;1,1101000+1,0000100&#x3D;0,1101100$，真值 + 108</li></ul><p>假设 A 的符号位为 $A_{s} $， B  的符号位为$ B_{S} $，其运算结果符号位为 $S_{s} $，则<strong>溢出逻辑表达式为</strong>：</p><ul><li>$V&#x3D;0 $表示无溢出。</li><li>$ V&#x3D;1$ 表示有溢出。</li></ul><p>​                                $V&#x3D;(A_{s}B_{s}(\overline S_{s} ))+ ((\overline A_{s})( \overline B_{s})S_{s}) $</p><blockquote><p>注意逻辑运算规则：</p><ul><li><strong>与</strong>： $A B C$表示与运算，A 与 B 与 C，当 A、B、C 全部为 1 时结果为 1，有一个为 0 结果为 0</li><li><strong>或</strong>： $A+B+C $ 表示或运算，A 或 B 或 C，当 A、B、C 全部为 0 时结果为 0，有一个为 1 结果为 1</li><li><strong>非</strong>： $\overline A $ 表示非运算，比如 $A $为 1 则 $  \overline A$ 为 0</li></ul></blockquote><p>在上面的例子中：</p><ul><li>$ [A]<em>{补}$​符号位为 <strong>0</strong>， $ [C]</em>{补} $符号位为 <strong>0</strong>， $ S_{s}&#x3D; [ A + C]<em>{补} $​符号位为 <strong>1</strong>，则 $\overline S</em>{s} $为 0 ，因此$A_{s}C_{s}\overline S_{s}$逻辑运算结果为 0；</li><li>$ \overline [A]<em>{补} $​为 <strong>1</strong>，$ \overline[C]</em>{补} $为 <strong>1</strong>, 则$ (\overline A_{s})( \overline C_{s})S_{s}$结果为 1。</li></ul><p>于是 $ V&#x3D;000 + 111&#x3D;0+1&#x3D;1$（有溢出），其实这也对应了正数 + 正数必有溢出的结论。</p><ul><li>负数 + 负数，也即 [ B − C ] 补 [B-C]_{补} [B−C] 补​读者可以根据上面的逻辑自行验证，会发现也是溢出的。</li></ul><p><strong>逻辑表达式有了，接着就可以设计与之对应的电路结构，计算机在判断溢出时可根据此逻辑进行判断</strong>。</p><h3 id="4-6-2-采用一位符号位依据数据位的进位情况判断"><a href="#4-6-2-采用一位符号位依据数据位的进位情况判断" class="headerlink" title="4.6.2.采用一位符号位依据数据位的进位情况判断"></a>4.6.2.采用一位符号位依据数据位的进位情况判断</h3><p><strong>这里有两个进位需要区别开来</strong>：</p><ul><li><p>**符号位的进位$ C_{s}$**：最高数值位向符号位进的位。</p></li><li><p><strong>最高数值位的进位 $C_{1} $​</strong>：最高数值位得到的进位。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914829.png" loading="lazy"></p></li></ul><p><strong>溢出判断规则为：</strong></p><ul><li><strong>上溢</strong>： $C_{s}&#x3D;0 $， $ C_{1}&#x3D;1$。</li><li><strong>下溢</strong>：$ C_{s}&#x3D;1 $， $C_{1}&#x3D;0$。</li></ul><p>比如$ [A+C]<em>{补} $会上溢，所以运算时有$C</em>{s}&#x3D;0 $，$ C_{1}&#x3D;1 $ 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914087.png" loading="lazy"></p><p>可以发现只要发生溢出$C_{s} 和 C_{1} $一定是不同的，计算机在判断时会<strong>使用异或运算</strong>。</p><ul><li>$V &#x3D; 0 $表示无溢出。</li><li>$V &#x3D; 1 $ 表示有溢出。</li></ul><p>$V&#x3D;C_{s}⊕C_{1}$</p><h3 id="4-6-3-采用双符号位判断（常考）"><a href="#4-6-3-采用双符号位判断（常考）" class="headerlink" title="4.6.3.采用双符号位判断（常考）"></a>4.6.3.采用双符号位判断（常考）</h3><p>之前符号位都是一位，这种方法将符号位扩展为了 2 位。</p><ul><li><strong>“00” 表示正数</strong></li><li><strong>“11 表示负数”</strong></li></ul><p>如下为运算过程：</p><ul><li>$[A+C]_{补}&#x3D;00,0001111+00,1111100&#x3D;01,0001011$，真值 - 117。</li><li>$ [B-C]_{补}&#x3D;11,1101000+11,0000100&#x3D;10,1101100 $，真值 + 108。</li></ul><p>运算结果符号位自然也有两位，<strong>这两个符号位第一位表示本来应该的符号，第二位符号表示实际得到的符号</strong>。比如<code>A+C </code> 结果中本来正数 + 正数应该是正数，但是实际是负数，所以判断溢出，而且是上溢。</p><p><strong>记这两个符号位为$S_{s1}S_{s2} $​，则溢出表达式为</strong>：</p><ul><li>$V &#x3D; 0 $ 无溢出。</li><li>$V &#x3D; 1$ 有溢出。</li></ul><p>$ V&#x3D;S_{s1}⊕S_{s2} $</p><h2 id="4-7-符号扩展"><a href="#4-7-符号扩展" class="headerlink" title="4.7.符号扩展"></a>4.7.符号扩展</h2><p>从上面的叙述中可以看出，溢出现象发生的本质原因就是机器字长不够。所以最容易想到的一个方式就是把<strong>短数据扩展为长数据</strong>，比如<code>int-&gt;long</code>，那么这又带来一个新的问题就是：<strong>多出来的那些位应该如何填补</strong>？</p><p>对于<strong>定点正整数</strong>来说，由于其原码、反码和补码都一样，因此直接补<code> 0</code> 即可  。<br>如 <code>0,1011010 0,1011010 0,1011010—&gt; 0,000000001011010 0,00000000 1011010 0,000000001011010</code>。</p><p>对于<strong>定点负整数</strong>来说，原码补 <code>0</code>，反码则对应位置补 <code>1</code>，而补码根据前面讲到的规则从右向左数第一个 1 开始（包括）左侧部分同补码  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914877.png" loading="lazy">  </p><p>对于<strong>定点正小数</strong>，最后面补 0 即可  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914071.png" loading="lazy"></p><p>对于<strong>定点负小数</strong>，和定点负整数同理  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914648.png" loading="lazy"></p><h1 id="5-字符与字符串在计算机中的表示详解（考纲删除了解即可）"><a href="#5-字符与字符串在计算机中的表示详解（考纲删除了解即可）" class="headerlink" title="5.字符与字符串在计算机中的表示详解（考纲删除了解即可）"></a>5.字符与字符串在计算机中的表示详解（考纲删除了解即可）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914193.png" loading="lazy"></p><p>现代计算机不仅要处理数值领域的问题，而且还要处理大量<strong>非数值领</strong>域的问题。这样一来，必然要引入<strong>文字、字母及某些专用符号</strong>，以便表示文字语言、逻辑语言等信息。例如，人机交换信息时使用英文字母、标点符号、十进制数及诸如<code>$</code>、<code>%</code>、<code>+</code>等符号。然而，<strong>数字计算机只能处理二进制数据</strong>，因此，上述信息应用到计算机中时，<strong>都必须编写成二进制格式的代码，也就是字符信息用数据表示，称为符号数据</strong>。</p><h2 id="5-1-字符编码与-ASCII-编码"><a href="#5-1-字符编码与-ASCII-编码" class="headerlink" title="5.1.字符编码与 ASCII 编码"></a>5.1.字符编码与 ASCII 编码</h2><p><strong>ASCII 编码：这是目前国际上普遍采用的一种字符系统，其美国版称为 ASCII 码 (美国国家信息交换标准字符码)。它包括 10 个十进制数码，26 个英文字母和一定数量的专用符号，如<code>$</code>、<code>%</code>、<code>+</code>等，总共 128 个元素。因此二进制编码需要 7 位，再加上一个校验位，共 8 位，刚好为一个字节</strong>。</p><p><strong>ASCII 码字符排布情况如下</strong>：</p><ul><li>0~31 为控制字符, 用于通信控制和设备的功能控制。</li><li>127 是 DEL 码。</li><li><strong>32 是空格码。</strong></li><li>32~196 共 95 个字符为可打印字符。</li><li><strong>65~90 为大写字母范围。</strong></li><li><strong>97~122 位小写字母范围</strong>。</li><li>数字 0-9 的 ASCII 码为 48(011 0000) 到 57(011 1001)。注意去掉高三位后剩余部分正好是它们对应的 BCD 码形式。<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914754.png" alt="ASCII码表" loading="lazy"></li></ul><h2 id="5-2-汉字的表示和编码"><a href="#5-2-汉字的表示和编码" class="headerlink" title="5.2.汉字的表示和编码"></a>5.2.汉字的表示和编码</h2><p><strong>汉字编码：在不同情况下需要使用到不同搞得汉字编码，主要有：</strong></p><ul><li><strong>输入码</strong>：为了<strong>方便汉字输入</strong>而采取的编码方式。</li><li><strong>内码</strong>：为了在<strong>计算机内部表示汉字</strong>而采取的编码方式。</li><li><strong>输出码（字模码）</strong>：为了<strong>显示、打印汉字</strong>而采取的编码方式。</li></ul><h3 id="5-2-1-汉字的输入编码"><a href="#5-2-1-汉字的输入编码" class="headerlink" title="5.2.1.汉字的输入编码"></a>5.2.1.汉字的输入编码</h3><p><strong>汉字的输入编码：为了能直接使用西文标准键盘把汉字输入到计算机，就必须为汉字设计相应的输入编码方法，主要有以下三类：</strong></p><ul><li><p><strong>数字编码（主要使用）</strong>：数字编码用<strong>数字串</strong>代表一个汉字输入。常用的是<strong>区位码</strong>，区位码是将国家标准局公布的 6763 个两级汉字分为 94 个区，每个区 94 位。也就说把汉字表示成二维数组，<strong>每个汉字在数组的下</strong>标就是区位码。<strong>区码和位码</strong>总共是两位十进制数字，<strong>所以输入一个汉字需要键入四次</strong>。例如下面的 “啊” 字位于第 16 区 01 位，所以它的区位码就是 1601。使用数字编码方式输入<strong>无重码，且与内码转换较为方便</strong>，但缺点即使代码<strong>太难记忆</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914304.png" loading="lazy"></p></li><li><p><strong>拼音码</strong>：拼音码是以<strong>汉语拼音</strong>为基础的输入方法，只要掌握汉语拼音就可以轻松输入。但由于<strong>汉字同音字太多，所以输入的重码率会很高，输入速度也会受到影响。</strong></p></li><li><p><strong>字形编码</strong>：汉字总数虽然很多，但所有汉字都由最基本的笔画构成，因此全部汉字的部件和笔画是有限的。所以可以把<strong>汉字的笔画部件用字母或数字进行编码</strong>，按笔画的顺序依次输入就可以表示一个汉字。例如<strong>五笔打字。</strong></p></li></ul><h3 id="5-2-2-汉字内码"><a href="#5-2-2-汉字内码" class="headerlink" title="5.2.2.汉字内码"></a>5.2.2.汉字内码</h3><h4 id="5-2-2-1-国际码（交换码）"><a href="#5-2-2-1-国际码（交换码）" class="headerlink" title="5.2.2.1.国际码（交换码）"></a>5.2.2.1.国际码（交换码）</h4><p><strong>国际码（交换码）：上面说到的区位码还考虑一个问题，那就是必须要避开 ASCII 字符中 0~32 的不可显示字符和空格字符。因此会在区位码的基础上让其向后偏移 32，也就是加上 20H（十六进制），形成国际码。</strong></p><ul><li><strong>注意</strong>：区码和位码必须同时加上 20H（因为区码和位码分别代表一个字节）。也即<strong>国际码 &#x3D;(区位码)16+20H</strong></li></ul><h4 id="5-2-2-2-汉字内码"><a href="#5-2-2-2-汉字内码" class="headerlink" title="5.2.2.2.汉字内码"></a>5.2.2.2.汉字内码</h4><p><strong>国际码（交换码）</strong>：国标码还不能直接在计算机上使用，因为它还<strong>会和 ASCII 中的除控制字符外的其他字符冲突</strong></p><ul><li>这里 以<code>“中”</code>字为例，其国标码中的高位字节为 86，这会与 ASCII 中大写字母’V’冲突，低位字节为 80，会与’P’冲突。</li></ul><p>因此，为避免这种情况，<strong>规定：国标码中的每个字节的最高位都从 0 换成 1，相当于每个字节都再加上 128(十六进制为 80，即 80H；二进制为 1000 0000)<strong>，从而得到国标码的 “</strong>机内码</strong>” 表示，简称 <strong>“内码”</strong>。也即 <strong>汉字内码 &#x3D;(国际码)16+ 80 H 80H 80H</strong>。</p><ul><li>另外，由于 ASCII 码只用了一个字节的低 7 位，所以，<strong>一旦首位为 1 就表示这是汉字编码，若为 0 就是这是 ASCII 字符</strong>。</li></ul><p><strong>总之它们的关系如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914575.png" loading="lazy"></p><h4 id="5-2-2-3-汉字输出码（字模码）"><a href="#5-2-2-3-汉字输出码（字模码）" class="headerlink" title="5.2.2.3.汉字输出码（字模码）"></a>5.2.2.3.汉字输出码（字模码）</h4><p><strong>汉字输出码（字模码）</strong>： 为了显示或输出汉字，我们把汉字按图形符号设计成<strong>点阵图</strong>，就得到了相应的<strong>点阵代码 (字形码)<strong>。具体来说是用 0、1 表示汉字的字形，然后将汉字放入 $n$行 × $n$列的正方形 (<a href="https://so.csdn.net/so/search?q=%E7%82%B9%E9%98%B5&spm=1001.2101.3001.7020">点阵</a>) 内，该正方形共有 n 2 n^{2} n2 个小方格，</strong>每个小方格用一位二进制表示，凡是笔划经过的方格值为 1，未经过的值为 0</strong>。</p><ul><li>**字节数 &#x3D; 点阵行数 ×(点阵列数 &#x2F; 8)**。</li></ul><p>同时，汉字信息处理系统还需要配有<strong>汉字字形库，也称字模库，简称字库</strong>，它集中了汉字的字形信息。当显示输出或打印输出时才检索字库，输出子模点阵，得到字形。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914040.gif" alt="点阵描述字形" loading="lazy"></p><h4 id="5-2-2-4总结"><a href="#5-2-2-4总结" class="headerlink" title="5.2.2.4总结"></a>5.2.2.4总结</h4><p><strong>综上所述，这三类码关系如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915178.jpeg" loading="lazy"></p><h2 id="5-3-字符串（考纲已删除）"><a href="#5-3-字符串（考纲已删除）" class="headerlink" title="5.3.字符串（考纲已删除）"></a>5.3.字符串（考纲已删除）</h2><p><strong>字符串</strong>：字符串是指<strong>连续的一串字符</strong>。通常情况下，它们占用主存连续的多个字节，<strong>每个字节存一个字符</strong>。</p><p><strong>英文字符，以 “abc” 为例。</strong></p><ul><li><p>计算机按字节编址，每个内存地址对应一个字节，最后一个字符往往是结束标志  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915296.png" loading="lazy">  </p><p><strong>中文字符，以 “abc 啊” 为例</strong>。</p></li><li><p>两字节表示一个汉字  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915632.png" loading="lazy"></p></li></ul><h1 id="6-校验码（考纲删除但计网会用建议学习）"><a href="#6-校验码（考纲删除但计网会用建议学习）" class="headerlink" title="6.校验码（考纲删除但计网会用建议学习）"></a>6.校验码（考纲删除但计网会用建议学习）</h1><h2 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1.基本概念"></a>6.1.基本概念</h2><h3 id="6-1-1-校验码"><a href="#6-1-1-校验码" class="headerlink" title="6.1.1.校验码"></a>6.1.1.校验码</h3><p><strong>校验码：校验码是指能够发现或自动纠正错误的数据编码，也称检错纠错编码。具体实现时，校验码会增加一些冗余码，来帮助检验或纠错</strong>。</p><h3 id="6-1-2-码字和码距"><a href="#6-1-2-码字和码距" class="headerlink" title="6.1.2.码字和码距"></a>6.1.2.码字和码距</h3><p><strong>为了实现网络传输，会把原信息进行编码，形成二进制序列，这里就会涉及两个概念。</strong></p><ul><li><strong>码字</strong>：由若干位代码组成的<strong>一个字</strong>称为码字，比如下图中 “00”，“01”。</li><li><strong>码距</strong>：将两个码字逐位比较，<strong>具有不同的位的个数称为两个码字的距离</strong>，比如下图中 “00” 和“10”距离就是 1；<strong>一种编码方法可能有若干合法码字，各合法码字之间的最小距离称为 “码距”</strong>，下图所示编码方案其码距为 1。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915122.png" loading="lazy"></p><p><strong>码距大小与校验码的检错和纠错能力直接相关</strong>。</p><ul><li>码距为 1 <strong>无检错能力</strong>。</li><li>码距大于等于 2 具有<strong>检错能力</strong>。</li><li><strong>码距越大，检错、纠错能力就越强。</strong></li><li>检错能力总大于等于纠错能力。</li></ul><h1 id="6-2-常见校验码"><a href="#6-2-常见校验码" class="headerlink" title="6.2.常见校验码"></a>6.2.常见校验码</h1><h2 id="6-2-1-奇偶校验码"><a href="#6-2-1-奇偶校验码" class="headerlink" title="6.2.1.奇偶校验码"></a>6.2.1.奇偶校验码</h2><p><strong>在原编码的基础上增加一个校验码，它的码距为 2，可以检测出一位错误 (或奇数位错误)，但不能确定出错位置，也不能检测出偶数位出错，增加的冗余位称为奇偶校验位</strong>。</p><p>实现方法：由若干位有效信息（比如 1B，0001 1011），再加上一个二进制位（检验位）组成校验码。如下图所示，<strong>校验位的取值为 0 或 1，它的加入使整个校验码中 “1” 的个数要么是奇数要么是偶数，所以就有两种可选的校验规律</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915807.png" loading="lazy"></p><ul><li><strong>奇校验码</strong>：整个检验码中 “1” 的个数为奇数。</li><li><strong>偶校验码</strong>：整个校验码中 “1” 的个数为偶数。</li></ul><p>举个例子，1001101 的奇校验码和偶校验码设置如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915862.png" loading="lazy">  </p><p>奇偶校验具有很大的局限性，<strong>只能发现数据代码中的奇数位出错的情况</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915796.jpeg" loading="lazy">  </p><p>校验原理：传输前，发送端和接收端会协议确定彼此之间采用奇校验还是偶校验。以偶校验为例，<strong>计算机首先会将二进制所有位进行异或运算，所得结果就是偶校验位</strong>，比如上面信息 “1001101”，进行异或运算“1⊕0⊕0⊕1⊕1⊕0⊕1&#x3D;0”，这表明 1 的个数为偶数个，故偶校验位为 0；<strong>接收端再接受信息后会进行异或运算，一旦结果出现 1 表明错误</strong>，比如上图中第一个例子，再接受到之后进行异或运算 “0⊕1⊕0⊕1⊕1⊕1⊕0⊕1&#x3D;1”，所以结果错误（同时大家也可以发现如果再更改一位为 1，那么最终结果仍然是，这就是奇偶校验的局限性)。</p><h2 id="6-2-海明校验码"><a href="#6-2-海明校验码" class="headerlink" title="6.2.海明校验码"></a>6.2.海明校验码</h2><p>海明码是一种广泛采用的有效的校验码，本质是一种多重奇偶校验码。<strong>其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到奇偶校验组中。当某一位出现错误后，就会引起有关的几个校验位的值发生变化。它不但可以发现错误位置，还可以为自动纠错提供依据。</strong></p><h3 id="6-2-1-纠错理论"><a href="#6-2-1-纠错理论" class="headerlink" title="6.2.1.纠错理论"></a>6.2.1.纠错理论</h3><p><strong>假设信息位为 <code> n</code>，校验位为<code> k</code>，因此 <code> k</code> 个比特位一共可以映射$2^{k} $ 种状态；海明码由信息位和校验位组成，因此共有 $n + k$ 位， $n+k$ 位每一个位置都有可能出现错误，因此这$2^{k} $种状态要把这$n+k $ 种全部映射到，但是要注意其中还要包含一种全部正确的情况。</strong></p><p>综上所述，得出下面的重要不等式：</p><p>$2^{k}\geqslant n+k+1 $</p><h3 id="6-2-2-求解海明码"><a href="#6-2-2-求解海明码" class="headerlink" title="6.2.2.求解海明码"></a>6.2.2.求解海明码</h3><p><strong>范例：求 1010 的海明码</strong>，具体流程如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915363.png" loading="lazy"></p><p><strong>6.2.2.1.确定海明码位数</strong></p><p>此二进制序列信息位$n&#x3D;4$，根据前述不等式 ： $2^{k}\geqslant n+k+1$，可知$ k $ 为 3 时不等式方可成立。</p><ul><li><p>除了实际计算，也可以熟悉下面这张表，从而快速写出  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915112.png" loading="lazy"></p></li></ul><p>为了区分信息位和校验位，我们用$D_{4}D_{3}D_{2}D_{1} $表示<strong>信息位</strong>（对应$1010$）；用 $ P_{3}P_{2}P_{1} $表示<strong>校验位</strong>；整个<strong>海明码</strong>序列可以表示为 $ H_{7}H_{6}H_{5}H_{4}H_{3}H_{2}H_{1} $。</p><p><strong>6.2.2.2.确定校验位分布</strong></p><p><strong>海明码中校验位不能直接放在信息位的头部和尾部</strong>。 </p><p>规定：<strong>校验位 $p_{i}$应该放在海明码 $H_{2^{i-1}} $​的位置</strong>，因此 $P_{1}P_{2}P_{3} $​分别对应 $ H_{1}H_{2}H_{4}$​，其实也就是 2 进制的权值。</p><p>校验位分布如下，首先放入校验位，信息位从低到高依次补全空位。</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td></td><td>0</td><td></td><td></td></tr></tbody></table><p>接下来，<strong>由于校验位为 3 位，因此信息位需要根据校验位分为 3 组，每个分组分别进行偶校验</strong>。</p><p><strong>6.2.2.3.求校验位的值</strong></p><p>首先，<strong>我们需要海明码中对应位置为信息位的下标（也就是所处位置）转为二进制序列</strong>，比如上面表格中，$H_{7} $对应位置为信息，其下标为<code>7 </code>，对应二进制序列为 <code>111</code>。</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>信息位值</strong></td><td>1</td><td>0</td><td>1</td><td></td><td>0</td><td></td><td></td></tr></tbody></table><p><strong>然后我们需要根据二进制序列确定每个校验位所在组包括哪些信息位</strong>。</p><p><strong>前面我们说过， $P_{3}P_{2}P_{1} $实则对应的是二进制的权值<code>421</code>，而分组依据就是根据这个权值，比如 $P_{1} $​表示所有二进制序列第 0 位为 1 的分到该组，  所以 $ H_{3}H_{5}H_{7} $就分到了这一组</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915457.jpeg" loading="lazy"></p><p>分为三个组后，我们就要对每一组进行偶校验。<strong>上面内容提到，偶校验码计算实则通过异或运算完成，因此对每组进行异或运算，确定 <code>P </code> 的取值</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915299.jpeg" loading="lazy">  </p><p>填充表格如下：</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td><strong>0</strong></td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table><p><strong>6.2.2.4.校验纠错</strong></p><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查。这里是偶校验，如果$S_{3}S_{2}S_{1}$​为 “000”，表明无错误。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915348.jpeg" loading="lazy">  </p><p>如果 $ S_{3}S_{2}S_{1}$​为 “010”，表明第 2 位出现错误  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915986.jpeg" loading="lazy">  </p><p>其原理可以用下面的这张图解释。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915616.jpeg" loading="lazy"></p><ul><li>比如$D_{3} $信息位发生变化，由于$D_{3} $包含于 $ P_{2} 和 P_{3} $​，同时 $ P_{2} 和 P_{3}$​又在 $ S_{2}S_{3}$​的校验方程中，导致 $ S_{3}S_{2}S_{1} $为 <code>110 </code>， 也就是$ H_{6} $发生改变。</li><li>再比如校验位 $ P_{2} $发生改变时，其只存在于$S_{2}$的校验方程中，所以 $ S_{3}S_{2}S_{1} $​为 $ 010 $，也就是 $H_{2} $发生改变。</li></ul><h3 id="6-2-2-4-补充-全校验位"><a href="#6-2-2-4-补充-全校验位" class="headerlink" title="6.2.2.4.补充 - 全校验位"></a>6.2.2.4.补充 - 全校验位</h3><p><strong>海明码具有 1 位的纠错能力和 2 位的检错能力</strong></p><p>刚才设计的海明码，在使用时还是有一定问题的，比如发送刚数据为：</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table><p>发送中， $ P_{2}P_{1} $这两个校验位发生改变。</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>0</strong></td><td><strong>1</strong></td></tr></tbody></table><p>那么按照之前的校验规则，$ S_{3}S_{2}S_{1} $的值为 “110”，表明$H_{3} $位置发生错误。很明显发现，判断错误，此时发生的是两个比特位的改变。<strong>所以之前的方案是没有办法区分 1 位错误，还是 2 位错误的。</strong></p><p><strong>为此，在使用时我们在海明码首部加入 “全校验位”，对整体统一进行一次偶校验</strong>。</p><p>发送方数据：</p><table><thead><tr><th>海明码位置</th><th> H8​</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td>二进制</td><td></td><td>111</td><td>110</td><td>101</td><td></td><td>011</td><td></td><td></td></tr><tr><td><strong>分布情况</strong></td><td>P 全​</td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table><ul><li>如果此时接收方校验后 $S_{3}S_{2}S_{1} $的值为 “000”，并且全体偶校验成功，表明没有错误；</li><li>如果$S_{3}S_{2}S_{1}$​的值不为 “000”，并且全体偶校验失败，表明有 1 位错误，纠正即可；</li><li>如果 $S_{3}S_{2}S_{1} $​的值不为 “000”，并且全体偶校验成功，很明显产生了两位错误，此时无法纠正，需要重传。</li></ul><h2 id="6-3-循环冗余校验码（CRC-码）"><a href="#6-3-循环冗余校验码（CRC-码）" class="headerlink" title="6.3.循环冗余校验码（CRC 码）"></a>6.3.循环冗余校验码（CRC 码）</h2><p>举个例子，A 要向 B 传送数据<code>882</code>，为了校验数据是否准确，A 和 B 约定了一个除数<code>7</code>，<code>882</code>除以<code>7</code>是可以出除尽的。在 B 接受到数据之后用，使用 882 除以 7，如果没有余数，表示数据可能正确，<strong>但如果有余数那么一定错误</strong>。</p><p>其实，CRC 的基本思想和刚才的除法思想基本一致。<strong>发送方和接收方提前约定好一个数，作为除数（这里的数自然指的是二进制序列），在 <code>K </code>个信息位后拼接 <code>R</code>个校验位作为被除数（添加校验位需要保证除法余数为 0），接受方在接收到数据之后进行相应除法运算，检查余数是否为 0。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915952.png" loading="lazy"></p><p><strong>一般来说题目会将除数表现一种多项式的形式</strong>，比如：**设多项式 $ G(x)&#x3D;x^{3}+x^{2}+1 $**，信息码为 $101001$，求对应的$ C R C$ 码。</p><p>多项式 $G (x) $的<strong>完整形式</strong>实则为 $G(x)&#x3D;1\times x^{3}+1\times x^{2}+0\times x^{1}+1\times x^{0} $，<strong>取系数</strong>，指明除数为 $1101 $。</p><p><strong>1：确定<code>K</code>、 <code>R </code>以及生成多项式对应的二进制码</strong></p><p>其中 $R&#x3D; 生成多项式最高幂次 &#x3D; 3 $， $K&#x3D; 信息码长度的 &#x3D; 6 $，于是整个编码位数$N&#x3D;K+R&#x3D;9 $<br>多项式$ G (x) $对应二进制码为$ 1101 $</p><p><strong>2：移位</strong></p><p>现在我们要确保添加的 <code>3</code> 位校验位形成的被除数可以整除除数，<strong>因此首先将信息码 <code>101001 </code>左移 R 位，低位补 0，也即 <code>101001000</code>，称其为新信息码。</strong></p><p><strong>3：相除</strong><br>对于新信息码，用生成多项式进行<strong>模 2 除</strong>法，产生余数。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915441.png" loading="lazy"></p><ul><li><p>举个例子，用 1001000 作为被除数，1011 作为除数，模 2 除法为的是求余数，不关心商。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922316.png" loading="lazy"></p><p>首先商为 1，得出结果  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915361.png" loading="lazy"></p><p>此时不应该做减法，而应该做对应为的异或运算  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915631.png" loading="lazy">  </p><p>接着如果高位为 0，就抹去一位，同时后面用被除数的补齐一位  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922276.png" loading="lazy">  </p><p>这里经过异或运算，然后抹位补位得到的结果（比如上图 0100）中，如果首位为 0 就商 0，首位为 1 就商 1  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915177.png" loading="lazy">  </p><p>继续异或，然后抹位，补位后  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915336.png" loading="lazy">  </p><p>继续  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915213.png" loading="lazy">  </p><p>运算到这里，其实可以进行快捷操作。异或后前面有多少 0 都全部扔掉，再从被除数哪里补齐相应位即可。但是这里很明显只能取一个，于是就得到下面的结果，此时也是最终结果，<strong>因为余数位数小于除数</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915005.png" loading="lazy"></p></li></ul><p>好的，回到正题。此时运算出的余数为 001，作为校验位。于是整个 CRC 码即为$信息码 + 校验码 &#x3D; 101001001 $。</p><p><strong>4：检验纠错</strong></p><p>接收方接受到到数据后，使用约定的除数进行模 2 除运算，如果余数为 000，结果正确。<br>如果接收方数据为<code> 101001011</code>（导数第二位出现错误），计算结果为 010，对应是十进制数为 2，表示第二位出现错误，<strong>但是特别注意这只是巧合，出错位置与计算结果没有必然联系，但是也有一定联系</strong>。</p><p>我们把每一个位置出错的情况统计如下，大家可以发现，余数为 3 位最多映射 8 种情况，因此第 1-7 位是属于一个周期，但是从第 8 位又开始了一个新的周期，因此 010 有可能对应第 2 位出错，也有可能是第 9 位  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915877.png" loading="lazy"></p><p>难道说 CRC 码不能确定出错位置吗？其实也不是的，出现这种情况的原因主要在于信息位过长，无法一一映射。所以要想确定纠错位置就要选择合适的多项式 (纠错 1 位)，具体关系如下面不等式：</p><p>​                                                                    $ 2^{R}\geq K+R+1$</p><p>其实这和海明码类似。但是实际应用中，尤其在网络中主要用来检错。</p><h1 id="7-算数逻辑单元和电路基本知识以及基本逻辑运算和全加器"><a href="#7-算数逻辑单元和电路基本知识以及基本逻辑运算和全加器" class="headerlink" title="7.算数逻辑单元和电路基本知识以及基本逻辑运算和全加器"></a>7.算数逻辑单元和电路基本知识以及基本逻辑运算和全加器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916535.png" alt="image-20230413170602808" loading="lazy"></p><h2 id="7-1-算数逻辑单元-ALU"><a href="#7-1-算数逻辑单元-ALU" class="headerlink" title="7.1.算数逻辑单元 ALU"></a>7.1.算数逻辑单元 ALU</h2><p>数字运算过程中一直离不开一个十分重要的部件——<strong>运算器</strong>，其构成如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916032.png" loading="lazy"></p><p>其中有一个<strong>核心部件——算数逻辑单元 ( Arithmetic and Logic Unit )，也即 ALU</strong>，其作用主要有以下三类</p><ul><li><strong>算数运算</strong>：如加、减、乘、除等。</li><li><strong>逻辑运算</strong>：如与、或、非、异或等。</li><li><strong>辅助功能</strong>：如移位、求补等。</li></ul><p>大家在课本中见到的 ALU 经常会被画成这样：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916244.png" loading="lazy"></p><ul><li>$A_{i}B_{i} $：是<strong>输入信号</strong>，这是一种电信号。通过高低电平，输入不同的电信号。</li><li>$F_{i} $：这是<strong>输出信号</strong>，也就是运算结果。</li><li>$K_{i} $​：这<strong>是控制信号</strong>，由控制单元发出 (CU)；控制单元负责解析指令，比如这个运算是什么类型的运算等等。</li></ul><p>上面是抽象图，下面是一个比较具体的图象，经典的 74181 芯片，是一个 4 位的 ALU  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916276.png" loading="lazy"> </p><p>上面的 M 会指明当前是一个逻辑运算还是算数运算（M&#x3D;1 是逻辑运算，M&#x3D;0 是算数运算)。<strong>总之，ALU 是在输入输出和控制信号下工作的</strong>。</p><h2 id="7-2-最基本的逻辑运算"><a href="#7-2-最基本的逻辑运算" class="headerlink" title="7.2.最基本的逻辑运算"></a>7.2.最基本的逻辑运算</h2><h3 id="7-2-1-与、或、非"><a href="#7-2-1-与、或、非" class="headerlink" title="7.2.1.与、或、非"></a>7.2.1.与、或、非</h3><p><strong>无论是多复杂的逻辑还是算数运算，都是通过最基本的逻辑运算复合而成的，这里最基本的逻辑运算指的是一个位的运算，他们分别是 “与”、“或” 和非。</strong></p><ul><li><strong>与：全 1 才是 1，有 0 就是 0。</strong></li><li><strong>或：全 0 才是 0，有 1 就是 1</strong>。</li><li><strong>非：0 为，1 为 0。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916466.png" loading="lazy"></p><p><strong>上面是从数学抽象的角度来描述的，它们对应的真实电路是如下三个门电路（从左到右依次为：与、或和非）</strong>：</p><ul><li><p><strong>与：只有 A 和 B 全部输入为高电平时，Y 才会是高电平，只要有一个是低电平 Y 就会是低电平。</strong></p></li><li><p><strong>或：如果 A 和 B 输入中有一个是高电平时，Y 就会是高电平，只有全部输入为低电平时，输出才会是低电平</strong>。</p></li><li><p><strong>非：输入的是高输出的就是低，反之亦然</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916740.png" loading="lazy"></p></li></ul><p><strong>另外需要注意这几个运算的表达式：</strong></p><ul><li><strong>与</strong>： $ Y&#x3D;A▪B$</li><li><strong>或</strong>： $ Y&#x3D;A+B$</li><li><strong>非</strong>： $&#x3D;A+\bar{B} $</li></ul><p><strong>其中与的优先级要大于或，也就是对于 $ AB+CD $，要先计算与再计算或，他们也满足一些计算定律</strong>：</p><ul><li><strong>分配律</strong>： $ A(C+D)&#x3D;AC+AD $</li><li><strong>结合律</strong>： $ABC&#x3D;A(BC) $、$A+B+C&#x3D;A+(B+C) $</li></ul><p><strong>在掌握与、或、非这三种基本运算后，我们就可以实现任何一种复杂的逻辑运算了</strong>。</p><p><strong>例如：实现 $ AC+AD$</strong></p><p>这是一个逻辑运算，可以让 A 和 C 以及 A 和 D 分别进行与运算然后结果再进行或运算 。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916389.png" loading="lazy"></p><p>也可以转变为等价的运算，即$A(C+D) $，先让 C 和 D 进行或运算，然后再和 A 进行与运算，这样一来还节省了一个电路元件  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916563.png" loading="lazy"></p><h3 id="7-2-2-与非、或非、异或、同或"><a href="#7-2-2-与非、或非、异或、同或" class="headerlink" title="7.2.2.与非、或非、异或、同或"></a>7.2.2.与非、或非、异或、同或</h3><ul><li><strong>与非：实则是与运算取反；也就是说全 1 则为 0，全 0 则为 1，有 1 则是 1。</strong></li><li><strong>或非：实则是或运算取反；也就是说全 1 则为 0，全 0 则为 1，有 0 则是 0</strong>。</li><li><strong>异或：相同数异或运算结果为 0,0 异或任何数是任何数。</strong></li><li><strong>同或：相同数异或运算结果为 1,1 异或任何数是任何数。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916756.png" loading="lazy"></p><p><strong>他们对应的电路符号分别为</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916619.png" loading="lazy"></p><h2 id="7-3-一位全加器"><a href="#7-3-一位全加器" class="headerlink" title="7.3.一位全加器"></a>7.3.一位全加器</h2><p><strong>一位全加器：一位全加器（FA）是最基本的加法单元，首先注意以下两个概念</strong>。</p><ul><li><strong>本位</strong>：<strong>指的是当前运算的那一位</strong>。</li><li><strong>本位的和</strong>：<strong>包括本位对应的两个数和来自低位向本位的进位。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916443.png" loading="lazy"></p><p><strong>运算时是按照一位一位的方式加的，来自本位的两个数和来自低位的进位会确定本位的和，同时确定向高位进位的数值。</strong></p><p><strong>因此输入共有三个</strong>：</p><ul><li>$A_{i} $和 $B_{i} $以及$ C_{i-1}$</li></ul><p><strong>输出共有两个：</strong></p><ul><li>**第一个是$ S_{i} $**：由于是二进制，因此$ S_{i} $只能是 1 或者是 0，所以就可以使用异或运算确定输入中 1 的奇偶个数，如果有奇数个 1 那么结果为 1，否则为 0，也即$ S_{i}&#x3D;A_{i}⊕B_{i}⊕C_{i-1}$。</li><li><strong>第二个是 $C_{i} $<strong>：</strong>第一种情况</strong>就是 $ A_{i}&#x3D;1 且 B_{i}&#x3D;1 $，那么无论进位为多少都要进一位；<strong>第二种情况</strong>就是$A_{i} 和 B_{i}$中有一个本位为 1 并且来自低位的进位是 1。这两种情况属于或的关系，因此逻辑表达式为：$ C_{i}&#x3D;A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}$</li></ul><p><strong>因此电路表示可以为</strong>  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916294.png" loading="lazy">  </p><p><strong>屏蔽内部实现细节后：</strong>  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916482.png" loading="lazy"></p><h2 id="7-4-串行加法器和并行加法器"><a href="#7-4-串行加法器和并行加法器" class="headerlink" title="7.4.串行加法器和并行加法器"></a>7.4.串行加法器和并行加法器</h2><h3 id="7-4-1-串行加法器"><a href="#7-4-1-串行加法器" class="headerlink" title="7.4.1.串行加法器"></a>7.4.1.串行加法器</h3><p><strong>串行加法器：串行加法器中只有一个全加器，数据会逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算</strong>。</p><ul><li><strong>缺点</strong>：如果操作数为 <code>n</code>位，加法就要分 <code>n </code>次进行，每次产生一位和并且串行逐位送回寄存器中，所以效率非常低。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916944.png" loading="lazy"></p><h3 id="7-4-2-并行加法器（串行进位）"><a href="#7-4-2-并行加法器（串行进位）" class="headerlink" title="7.4.2.并行加法器（串行进位）"></a>7.4.2.并行加法器（串行进位）</h3><p><strong>串行进位的并行加法器：最简单的并行加法器是串行进位的并行加法器：是将多个加法器串联在一起，这样就能同时输入两个 $n$位的数，每一位都可以使用一个加法器进行就算，且低位加法器产生的进位，会作为下一个高位加法器的输入信号</strong>。</p><ul><li><p><strong>缺陷</strong>：电信号的传递时需要时间的，因此高位的操作会受到低位的限制  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917673.png" loading="lazy"></p></li></ul><h3 id="7-4-3-并行加法器（并行进位）"><a href="#7-4-3-并行加法器（并行进位）" class="headerlink" title="7.4.3.并行加法器（并行进位）"></a>7.4.3.并行加法器（并行进位）</h3><p><strong>并行加法器（并行进位）：与串行进位的并行加法器相比，并行进位的并行加法器的各级进位信号同时生成，即同时进位</strong>。</p><p>如下，记 $G_{i}&#x3D;A_{i}B_{i} $， $P_{i}&#x3D;A_{i}⊕B_{i} $，则由</p><p>$ C_{i}&#x3D;A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}&#x3D;G_{i}+P_{i}C_{i-1} $</p><p><strong>所以 $G_{i} $和 $P_{i}$会被同时送入加法器，大大提高了效率</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917827.png" loading="lazy"></p><h1 id="8-补码加减运算器和标志位的生成"><a href="#8-补码加减运算器和标志位的生成" class="headerlink" title="8.补码加减运算器和标志位的生成"></a>8.补码加减运算器和标志位的生成</h1><h2 id="8-1-补码加减运算器"><a href="#8-1-补码加减运算器" class="headerlink" title="8.1.补码加减运算器"></a>8.1.补码加减运算器</h2><h3 id="8-1-1-补码加-x2F-减法运算规则回顾（即手算方法）"><a href="#8-1-1-补码加-x2F-减法运算规则回顾（即手算方法）" class="headerlink" title="8.1.1.补码加 &#x2F; 减法运算规则回顾（即手算方法）"></a>8.1.1.补码加 &#x2F; 减法运算规则回顾（即手算方法）</h3><ul><li>n bit 补码 $X$+ $Y$：直接按位相加即可。</li><li>n bit 补码 $X$- $Y$：<strong>将$ [Y]_{补} $​全部按位取反，末位 + 1</strong>，得到$ [-Y]_{补} $​，使<strong>减法变为加法</strong>。</li></ul><p><strong>例如：$X&#x3D;-8 $， $Y&#x3D;7 $，即 $ [X]<em>{补}&#x3D;1000 $， $ [Y]</em>{补}&#x3D;0111$，则</strong></p><ul><li>$X+Y&#x3D;1111$</li><li>$ X-Y&#x3D;1000+(1000+1)&#x3D;0001$（溢出）</li></ul><p><strong>例如： $X&#x3D;3 $，$Y&#x3D;4 $，即$ [X]<em>{补}&#x3D;0011$，$ [Y]</em>{补}&#x3D;0100$，则</strong></p><ul><li>$X+Y&#x3D;0111 $</li><li>$X-Y&#x3D;0011+(1011+1)&#x3D;1111$（溢出）</li></ul><h2 id="8-2-补码加减运算器原理"><a href="#8-2-补码加减运算器原理" class="headerlink" title="8.2.补码加减运算器原理"></a>8.2.补码加减运算器原理</h2><h3 id="8-2-1-普通加法器回顾"><a href="#8-2-1-普通加法器回顾" class="headerlink" title="8.2.1.普通加法器回顾"></a>8.2.1.普通加法器回顾</h3><p><strong>下图是前面讲过的普通加法器原理图，并没有实现补码加减功能，其中</strong>：</p><ul><li>$ A$ 和 $B$：这是两个 n bit 的操作数，它们需要按位相加。</li><li>$Cin$：这是来自低位的进位，该进位需要加在 $ A$ 和 $B$ 的最低位。</li><li>$F$：这是运算后产生的结果。</li><li>$Cout $：这是运算后产生的进位，该进位由 $ A$ 和 $B$ 的最高位运算后给出。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917825.png" loading="lazy"></p><h3 id="8-2-2-补码加减运算器"><a href="#8-2-2-补码加减运算器" class="headerlink" title="8.2.2.补码加减运算器"></a>8.2.2.补码加减运算器</h3><p><strong>如下是补码加减运算器，其中红色线上方和普通的加法器是一样的，下方是为实现补码运算所增加的电路。在进行补码运算时，对加减运算的区分会由信号 Sub 给出（0 为加，1 为减），该信号会传送给多路选择器 MUX，让其接通加法或减法电路</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917852.png" loading="lazy"></p><h4 id="8-2-2-1-加法功能"><a href="#8-2-2-1-加法功能" class="headerlink" title="8.2.2.1.加法功能"></a>8.2.2.1.加法功能</h4><p><strong>实现加法功能时，Sub 为 0，多路选择器直接连接 $Y$ 的一端会被选通，让 cin 为 0，然后进行运算即可。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922277.png" loading="lazy"></p><h4 id="8-2-2-2-减法功能"><a href="#8-2-2-2-减法功能" class="headerlink" title="8.2.2.2.减法功能"></a>8.2.2.2.减法功能</h4><p><strong>实现减法功能时，Sub 为 1， $Y$ 会进入带有非门的一端，经过非门后 $Y$ 会被取反，然后让 cin 为 1，相当于取反后再 + 1，接着完成运算即可。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917448.png" loading="lazy"></p><h2 id="8-3-标志位的生成"><a href="#8-3-标志位的生成" class="headerlink" title="8.3.标志位的生成"></a>8.3.标志位的生成</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917021.png" alt="image-20230413170657697" loading="lazy"></p><p><strong>加法器在产生运算结果 $F$ 的同时，还会产生如下 4 个标志位，用于辅助后续运算判断</strong>：</p><ul><li><strong>$OF $（Overflow Flag 溢出标志）：溢出为 1，否则为 0</strong>，<strong>对于无符号数运算，OF没有意义。</strong></li><li><strong>$ SF $（sign Flag 符号标志）：结果是负为 1，否则为 0</strong>，<strong>对于无符号数运算，SF没有意义。</strong></li><li><strong>$ ZF $（Zero Flag 零标志）：运算结果是 0 位 1，否则为 0</strong>，<strong>无符号数和带符号数运算，ZF都有意义。</strong></li><li><strong>$ CF $（Carry Flag进位 &#x2F; 借位标志）：进位 &#x2F; 借位时为 1，否则为 0</strong>，<strong>判断是否发生溢出。</strong></li></ul><h3 id="8-3-1-OF-硬件产生方法"><a href="#8-3-1-OF-硬件产生方法" class="headerlink" title="8.3.1.OF 硬件产生方法"></a>8.3.1.OF 硬件产生方法</h3><p><strong>OF 硬件产生方法：$最高位产生的进位 C_{s} ⊕ 次高位产生的进位C_{1} $</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917468.png" loading="lazy"></p><p><strong>例如</strong>：$ [A+C]<em>{补}&#x3D;0,0001111+0,1111100&#x3D;1,0001011 $，真值 - 117。由于 $C</em>{s}&#x3D;0 $， $ C_{1}&#x3D;1 $，所以溢出。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917366.png" loading="lazy"></p><h3 id="8-3-2-SF-硬件产生方法"><a href="#8-3-2-SF-硬件产生方法" class="headerlink" title="8.3.2.SF 硬件产生方法"></a>8.3.2.SF 硬件产生方法</h3><p><strong>SF 硬件产生方法：它等于最高位的本位和，注意 SF 对无符号数加减无意义</strong>。</p><h3 id="8-3-3-ZF-硬件产生方法"><a href="#8-3-3-ZF-硬件产生方法" class="headerlink" title="8.3.3. ZF 硬件产生方法"></a>8.3.3. ZF 硬件产生方法</h3><p><strong>ZF 硬件产生方法：只有当运算结果所有比特位全为 0 时，ZF 才等于 1</strong>。</p><h3 id="8-3-4-CF-硬件产生方法"><a href="#8-3-4-CF-硬件产生方法" class="headerlink" title="8.3.4. CF 硬件产生方法"></a>8.3.4. CF 硬件产生方法</h3><p><strong>CF 硬件产生方法：$最高位产生的进位 C_{s} ⊕ sub $信号，注意 CF 对有符号数的加减法无意义</strong>。</p><h3 id="8-4-5-总结"><a href="#8-4-5-总结" class="headerlink" title="8.4.5.总结"></a>8.4.5.总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917217.png" loading="lazy"></p><h1 id="9-定点数的移位运算"><a href="#9-定点数的移位运算" class="headerlink" title="9.定点数的移位运算"></a>9.定点数的移位运算</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917274.png" alt="image-20230413172430011" loading="lazy"></p><p><strong>定点数的移位运算：根据操作对象的不同可以划分为</strong></p><ul><li><p><strong>算数移位：</strong> <strong>有符号数</strong>的移位。</p></li><li><p><strong>逻辑移位：</strong> 操作对象是逻辑代码，可视为<strong>无符号数</strong>。</p></li></ul><p><strong>其实我们很早之前就已经接触过移位运算了</strong>。</p><ul><li>比如 $ 985.211 × 10^{1} &#x3D;9852.11 $就相当于小数点右移 <code>1</code> 位。</li><li>比如 $985.211 \div 10^{1}&#x3D;98.5211 $ 就相当于小数点左移 <code>1</code>位。</li></ul><p><strong>移位的本质：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。</strong></p><h2 id="9-1-算数移位"><a href="#9-1-算数移位" class="headerlink" title="9.1.算数移位"></a>9.1.算数移位</h2><p><strong>算数移位：</strong> 算数移位的对象是<strong>有符号数</strong>，在移位的过程中<strong>符号位保持不变</strong>。</p><h3 id="9-1-1-原码的算数移位"><a href="#9-1-1-原码的算数移位" class="headerlink" title="9.1.1.原码的算数移位"></a>9.1.1.原码的算数移位</h3><p><strong>算数右移：</strong></p><ul><li>如果移出去的是 0，那么算数右移相当于<strong>除以了 2。</strong></li><li>如果移出去的是 1，<strong>会丢失精度。</strong></li></ul><p>如下是 - 20 的原码：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917705.png" loading="lazy">  </p><p>算数右移时：<strong>符号位不动，向右移动 1 位，高位补 0</strong>。</p><ul><li><p>由于移出去的是 0，所以 - 20 变为了 - 10,-10 变为了 - 5 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917782.png" loading="lazy"></p></li></ul><p>此时最低位为 1，再次右移一位，其结果为 - 2。</p><ul><li><p>移出去的是 1，精度丢失  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917943.png" loading="lazy"></p></li></ul><p><strong>算数左移：</strong></p><ul><li>如果移出去的是 0，那么算数左移相当于<strong>乘以了 2。</strong></li><li>如果移出去的是非 0，<strong>会丢失精度。</strong></li></ul><p>算数左移时：<strong>符号位不动，低位补 0</strong>。</p><ul><li><p>由于移出去的是 0，所以 - 20 变为了 - 40，-40 变为了 - 80  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917345.png" loading="lazy"></p></li></ul><p>此时最高位为 1，再次左移一位，出现严重误差。</p><ul><li><p>左移时，要将高位的 1 抛弃，而 7 位二进制表示范围为 - 128~128，理想的结果 - 160，自然超出了范围  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917641.png" loading="lazy"></p></li></ul><h3 id="9-1-2-反码的算术移位"><a href="#9-1-2-反码的算术移位" class="headerlink" title="9.1.2.反码的算术移位"></a>9.1.2.反码的算术移位</h3><p><strong>正数的反码算数移位和原码相同</strong>。</p><p><strong>负数的反码算数移位</strong>：反码除了符号位外其余各位和原码是一一取反的，因此反码的 1 对应原码的 0，反码的 0 对应原码的 1。<strong>所以反码算数右移时高位补 1，低位舍弃；算数左移时低位补 1，高位舍弃</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918673.png" loading="lazy"></p><h3 id="9-1-3-补码的算数移位"><a href="#9-1-3-补码的算数移位" class="headerlink" title="9.1.3.补码的算数移位"></a>9.1.3.补码的算数移位</h3><p><strong>正数的补码算数移位和原码相同。</strong></p><p><strong>负数的补码算数移位</strong>：负数补码是在反码末位 + 1 后得到的，所以这就导致<strong>反码最右边连续的 1 都会因为进位而变为 0，直到进位碰到第一个 0 为止</strong>。因此，负数补码中，<strong>最右边的（最后一个 1）及其右面与原码相同，而其左面则与反码相同。</strong></p><p>因此，<strong>补码算数右移时和反码相同，也即高位补 1，低位舍弃；而算数左移时又会和原码相同，也就是低位补 0，高位舍弃</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918036.png" loading="lazy"></p><h3 id="9-1-4-总结"><a href="#9-1-4-总结" class="headerlink" title="9.1.4.总结"></a>9.1.4.总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918762.png" loading="lazy"></p><h2 id="9-2-逻辑移位"><a href="#9-2-逻辑移位" class="headerlink" title="9.2.逻辑移位"></a>9.2.逻辑移位</h2><p><strong>逻辑移位：</strong> 逻辑移位比较简单，可以看作是<strong>对 “无符号数” 的算数移位。</strong></p><ul><li><p><strong>逻辑右移时高位补 0，低位舍弃。</strong></p></li><li><p><strong>逻辑左移时低位补 0，高位舍弃</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918072.png" loading="lazy"></p></li></ul><h2 id="9-3-循环移位"><a href="#9-3-循环移位" class="headerlink" title="9.3.循环移位"></a>9.3.循环移位</h2><p><strong>循环移位：循环移位分为如下两种</strong></p><ul><li>带<strong>进位标志位 CF</strong> 的循环移位（大循环）。</li><li><strong>不带进行标志位</strong>的循环移位（小循环）。</li></ul><p><strong>循环移位的特点是：移出的数位又被移入数据中，是否需要进位则看有没有将进位标志加入循环位移。循环位移十分适合将数据的低字节和高字节之间进行互换</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918039.png" loading="lazy"></p><h1 id="10-定点数乘法运算（原码-x2F-补码一位乘法）"><a href="#10-定点数乘法运算（原码-x2F-补码一位乘法）" class="headerlink" title="10.定点数乘法运算（原码&#x2F;补码一位乘法）"></a>10.定点数乘法运算（原码&#x2F;补码一位乘法）</h1><h2 id="10-1-乘法运算基本思想"><a href="#10-1-乘法运算基本思想" class="headerlink" title="10.1.乘法运算基本思想"></a>10.1.乘法运算基本思想</h2><p>关定点数的乘法，其实我们在小学就学习过，就是经典<strong>列竖式相乘</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922278.png" loading="lazy"></p><p>其中，我们印象最深的应该就是计算过程中的<strong>错位问题</strong>了。</p><p>在计算机中，相乘时使用的二进制，其基本逻辑和竖式相乘一致。如下是两个二进制数相乘，其中被乘数为<code>0.1101</code>，乘数为 <code>0.1011</code> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918651.png" loading="lazy"></p><p>我们将乘数看作为位权之和，即$ 0.1011&#x3D;1×2^{-1}+0×2^{-2}+1×2^{-3}+1×2^{-4} $。<br>，被乘数写成 $ A$ 与$ 2^{n} $相乘的形式，即 $ 0.1101&#x3D;1101×2^{-4}$。</p><p>那么此乘法过程可以等价为下面的形式  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918767.png" loading="lazy"> </p><p>把竖式写全也就是下面的这个样子  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918421.png" loading="lazy"></p><p><strong>由于二进制的乘数每一位只可能出现 0 或 1，因此每次运算的结果要么是全 0，要么只是被乘数乘以 $2^{n}$，实际结果只是小数点的不同，而计算机处理小数点位置非常方面，使用移位操作即可完成</strong>。</p><h2 id="10-2-原码一位乘法"><a href="#10-2-原码一位乘法" class="headerlink" title="10.2.原码一位乘法"></a>10.2.原码一位乘法</h2><h3 id="10-2-1-实现原理"><a href="#10-2-1-实现原理" class="headerlink" title="10.2.1.实现原理"></a>10.2.1.实现原理</h3><p>逻辑看似很简单，但是如何让机器实现这是一个问题。如果要实现这一问题，必须解决以下三个问题：</p><ul><li>实际数字有正有负，符号位应当如何处理？</li><li>乘积运算时位数扩大很厉害，如何处理？</li><li>每次运算时的结果都要保存下来，如果相加？</li></ul><p>其中符号位很方便处理，符号位 &#x3D; $s &#x3D;x_{s}⊕y_{s} $即可判断，让数值位取绝对值进行乘法运算即可。</p><p><strong>case：机器字长为 $n+1&#x3D;5$位， $ [x]<em>{原}&#x3D;0.1101，[y]</em>{原}&#x3D;0.1011 $，采用原码一位乘法求 $xy $。</strong></p><p>还记得 <a href="">(计算机组成原理) 第一章计算机系统概述 -计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这一节我们讲到过的运算器的组成吗？其中涉及乘法时会用到 $ACC $， $MQ $， $X$ 这三个寄存器  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918572.png" loading="lazy">  </p><p>接下来我们详细叙述一下这个过程。<strong>开始， $X$ 是被乘数， $Y$ 是乘数，因此 $X$ 位于 X 寄存器中， $Y$ 位于 MQ 寄存器中，并且运算开始前要将 ACC 置为 0</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918982.png" loading="lazy"></p><p>对应我们竖式乘法的逻辑，<strong>此时从低位到高位，依次用乘数的每一位乘被乘数</strong>，因此在这里进行第一次运算时我们把 MQ 寄存器中参与运算的那一位方块的颜色加深  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918842.png" loading="lazy">  </p><p><strong>如果当前参与运算的乘数的这一位是 1，则 $ACC $ 加上被乘数；如果当前位是 0，则 $ACC $ 加上 0</strong>，也即<code>(ACC)+(X)-&gt;(ACC)</code>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918152.png" loading="lazy"></p><p>在进行下一位竖式运算时，必须偏移一个位置，对应于计算机处理时则是<strong>让 ACC 和 MQ 中的数据统一逻辑右移一位</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918274.png" loading="lazy"></p><ul><li>这样做本质实现的就是错位相加。</li></ul><p>接着次低位来到了最低位的位置，再次进行<code>(ACC)+(X)-&gt;(ACC)</code>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918007.png" loading="lazy"></p><p>  <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918789.png" loading="lazy">  </p><p>剩余的步骤均重复上述过程。</p><h3 id="10-2-2-手算模拟"><a href="#10-2-2-手算模拟" class="headerlink" title="10.2.2.手算模拟"></a>10.2.2.手算模拟</h3><p>考试的时候，如果出到这样的题目，<strong>具体步骤如下</strong>  ：</p><p>设 $s [X]<em>{原}&#x3D;x</em>{s}$，$ s [Y]<em>{原}&#x3D;y</em>{s}$</p><ol><li>被乘数和乘数均取绝对值参与运算，符号位为 $ x_{s}⊕y_{s}$。</li><li>部分积的长度同被乘数，取 $n+1 $位，以便存放乘法过程中绝对值大于等于的值，初值为<code> 0</code>。</li><li><strong>从乘数的最低位 $y_{n}$​开始判断：若$y_{n}&#x3D;1$，则部分积加上被乘数 $|x| $，然后右移一位；若 $y_{n}&#x3D;0 $，则部分积加上 0，然后右移一位。</strong></li><li>重复步骤 3，判断 $n$次。</li></ol><p>注意：</p><ul><li>由于乘积的数值部分是两数绝对值相乘的结果，<strong>因此原码一位乘法运算过程中的右移均为逻辑右移</strong>。</li><li>考虑到运算时可能出现绝对值大于 1 的情况（但并非溢出），<strong>所以部分积和被乘数取双符号</strong>。</li></ul><p>**case: 设机器字长为 5 位（n+1）, $ x&#x3D;-0.1101$，$ y&#x3D;0.1011$，采用原码一位乘法求解 $xy $**。</p><p>解： $|x|&#x3D;00.1101 $, $ |y|&#x3D;00.1011$，过程如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918065.png" loading="lazy"></p><p>**因此符号位为 $ P_{s}&#x3D;x_{s}⊕y_{s}&#x3D;1&#x3D;1⊕0&#x3D;1 $，得 $ x·y&#x3D;-0.10001111 $**。</p><h1 id="11-补码一位乘法（-Booth算法，考察重点）"><a href="#11-补码一位乘法（-Booth算法，考察重点）" class="headerlink" title="11.补码一位乘法（ Booth算法，考察重点）"></a>11.补码一位乘法（ Booth算法，考察重点）</h1><p>定点数乘法中最有可能考察的便是补码一位乘法。因为机器做加减法时采用的是补码，倘若做乘法前再将补码转为原码，计算完成之后再转化为补码，那就很麻烦了，还不如直接用补码计算。</p><p>补码一位乘法主要分为<strong>校正法和比较法</strong>，校正法了解即可，而比较法（又叫Booth算法）则是考察的重点。具体规则如下：</p><p>①：<strong>被乘数与部分积一般取双符号位，并且符号位参与运算</strong>。</p><ul><li>一个原因是一旦符号位参与运算就一定要使用多符号位，因为一旦溢出，单符号位就会出错</li><li>另一个原因是，补码的右移时要看符号位而定的，如果采用单符号位，一旦数值部分的进位把符号给移掉了，下次移位就不知道该怎么办了。</li></ul><p>②：<strong>乘数取单符号位以决定最后一步是否需要校正，也即是否需要加$[-x]_{补}$​</strong><br>③：<strong>乘数末尾增设辅助位，$y_{n+1} $，初始值为 0</strong><br>④：<strong>根据 ($y_{n} $，$ y_{n+1} $)判断位，进行运算，步骤和上面原码一位乘法一致</strong><br>⑤：<strong>按上述算法进行 n+1, 其中最后一步也即 n+1 步不再移位，仅根据 $ y_{0},y_{1} $​比较结果决定是否需要加减 $ x_[补] $</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918334.png" loading="lazy">  </p><p>从上面图中大家可以看出 MQ 中的最低位现在是辅助位，这里就和原码乘法的最低位不一致了，<strong>所以这里我们用带有双引号的——“最低位” 表示运算时真正的最低位，而不是辅助位</strong></p><ul><li>辅助位<strong>减</strong> “最低位”&#x3D;1 时，$ (ACC)+[x]_{补}$</li><li>辅助位<strong>减</strong> “最低位”&#x3D;0 时，$ (ACC)+0$</li><li>辅助位<strong>减</strong> “最低位”&#x3D;-1 时， $ (ACC)+[-x]_{补}$</li></ul><p>**$case $: 假设机器字长为 5 位（含 1 位符号位，$n&#x3D;4 $）， $x&#x3D;-0.1101$，$y&#x3D;0.1011$，采用 $Booth$ 算法求 $xy $**。</p><p>解：$[x]<em>{补}&#x3D;11.0011$，$ [-x]</em>{补}&#x3D;00.1101$，$ [y]_{补}&#x3D;0.1011 $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918042.jpeg" loading="lazy"></p><h1 id="12-定点数除法运算（原码-x2F-补码一位除法）"><a href="#12-定点数除法运算（原码-x2F-补码一位除法）" class="headerlink" title="12.定点数除法运算（原码&#x2F;补码一位除法）"></a>12.定点数除法运算（原码&#x2F;补码一位除法）</h1><h2 id="12-1-除法运算基本思想"><a href="#12-1-除法运算基本思想" class="headerlink" title="12.1.除法运算基本思想"></a>12.1.除法运算基本思想</h2><p>关于定点数的除法，我们在小学其实就已经学习过了，就是<strong>列竖式除法</strong>, 比如 $0.211÷0.985 $，我们首先习惯同时扩大 $n$倍。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919136.png" loading="lazy">  </p><p>在上面的例子中， $ 0.211÷0.985&#x3D;0.214 $ 余 210，<strong>它就等价于</strong> $0.211&#x3D;0.985×0.214+0.000210 $，也就是说这可以转为成乘法的，也即  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919337.png" loading="lazy">  </p><p>在计算机中，运算时使用的是二进制，比如$ x&#x3D;0.1011$（被除数），$y&#x3D;0.1101$（除数)， $ x÷y $ 如下：</p><p><strong>运算时忽略小数点，每确定一位商就进行一次减法，得到 4 位余数，在余数末尾补 0，再确定下一位商，确定 5 位商即可停止（这里机器字长是 5 位）</strong>。</p><ul><li>如果补位后所得余数部分大于除数，那么就商 1。</li><li>如果补位后所得余数部分小于余数，那么就商 0。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919520.png" loading="lazy"></p><p>和乘法一样，补全位数后就是下面这样  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919343.png" loading="lazy"></p><p>因此 $x÷y$ 结果为 0.1101，余数为 $0.00000111$。</p><h2 id="12-2-原码一位除法-恢复余数法"><a href="#12-2-原码一位除法-恢复余数法" class="headerlink" title="12.2.原码一位除法(恢复余数法)"></a>12.2.原码一位除法(恢复余数法)</h2><h3 id="12-2-1-实现原理"><a href="#12-2-1-实现原理" class="headerlink" title="12.2.1.实现原理"></a>12.2.1.实现原理</h3><p>逻辑看似很简单，但是如何让机器实现这是一个问题。其中符号位的处理就不用再强调了，和乘法一样，仍然使用异或完成，于是实际运算时采用两个数的绝对值完成。</p><p>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $x÷y$</p><ul><li>$∣x∣&#x3D;0.1011$</li><li>$ |y|&#x3D;0.1101$</li><li>$ [|y|]_{补}&#x3D;0.1101$</li><li>$[-|y|]_{补}&#x3D;1.0011 $</li></ul><p>还记得 <a href="">(计算机组成原理) 第一章计算机系统概述 - 计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这一节我们讲到过的运算器的组成吗，其中涉及除法时会用到 $ACC $， $MQ $， $X$ 这三个寄存器  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919010.png" loading="lazy"></p><p>开始的时候， <strong>$Y$ 是除数，位于 X 寄存器内，ACC 寄存器存放的是被除数（x）或余数，MQ 中存放商，MQ 中灰色加重的方格表示当前要确定的一位商</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919493.png" loading="lazy"></p><p>前面手算时，每一位商到底取 0 还是 1，<strong>是通过判断当前余数和除数的大小确定的</strong>，因此很显然，我们的 ACC 寄存区和 X 寄存区天然就存储了余数和除数。但实际情况是，<strong>计算机并不会进行比较，它会不管三七二十一直接商 1，如果出错再改为商 0，并恢复余数。</strong></p><ul><li>商 1 时，其实就是余数减去除数, 也即是<code>(ACC)-(X)-&gt;ACC</code>。</li></ul><p>于是，这里首先计算机先商 1（但是本应该先商 0），因此此时就会求余数：<code>(ACC)-(X)-&gt;ACC</code>, 也即$[-|y|]_{补} $（计算机依靠加法实现减法），也即$ 01011+10011&#x3D;11110 $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919072.jpeg" loading="lazy"></p><p><strong>此时符号位 1，计算机察觉错误，于是改为商 0，同时既然是商 0，那么就不应该减去除数，而应该减去 0（什么也不做），所以这里直接采取逆过程，加上除数即可。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919393.jpeg" loading="lazy"></p><p><strong>所以现在我们就完成了一位的商，在手算中，我们商完一位后会错位一位补位，然后再商下一位，而在这里对应的就是将 ACC 和 MQ 中的内容逻辑左移即可</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919526.png" loading="lazy"></p><p>接着计算机再次商 1，此时检查符号位为 0，说明是正的，说明计算机没有商错误，那么不需要恢复余数  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919777.png" loading="lazy"></p><p>剩下的就是不断左移，运算的过程了。 </p><p>最后我们假定的机器字长为 5 位，因此只能求 5 位的商。<strong>不过需要注意的是，如果最后一位商 1 后，导致了 ACC 出现负数，那么仍然需要改为 0，并恢复余数</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919658.png" loading="lazy">  </p><p><strong>最后，我们这里举的例子是小数，所以其小数点的位置隐含在符号位后面。最后实际的余数是 $2^{-n} $（ $n$为机器字长）</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919947.png" loading="lazy"></p><h3 id="12-2-2-手算模拟"><a href="#12-2-2-手算模拟" class="headerlink" title="12.2.2.手算模拟"></a>12.2.2.手算模拟</h3><p>考试的时候，如果出到这样的题目，<strong>具体步骤如下</strong> 。<br>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $x÷y$</p><ul><li>$∣x∣&#x3D;0.1011$</li><li>$ |y|&#x3D;0.1101$</li><li>$ [|y|]_{补}&#x3D;0.1101$</li><li>$[-|y|]_{补}&#x3D;1.0011 $</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922279.png" loading="lazy"></p><h2 id="12-3-原码一位除法：加减交替法（不恢复余数法）"><a href="#12-3-原码一位除法：加减交替法（不恢复余数法）" class="headerlink" title="12.3.原码一位除法：加减交替法（不恢复余数法）"></a>12.3.原码一位除法：加减交替法（不恢复余数法）</h2><p>可以看出恢复余数法实际还是挺繁琐的，主要是当余数为负时，它还要加上除数，恢复到上一状态再左移。</p><p>而加减交替法是恢复余数的优化，具体规则为：<strong>若余数为负，直接商 0，并让余数左移 1 位再加上除数</strong></p><p>$case$ : 设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $X$÷ $Y$</p><ul><li>$∣x∣&#x3D;0.1011$</li><li>$ |y|&#x3D;0.1101$</li><li>$ [|y|]_{补}&#x3D;0.1101$</li><li>$[-|y|]_{补}&#x3D;1.0011 $</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922280.png" loading="lazy"></p><p><strong>注意：最后一步如果出现负数，仍然需要恢复余数！！！</strong></p><h2 id="12-4-补码一位除法"><a href="#12-4-补码一位除法" class="headerlink" title="12.4.补码一位除法"></a>12.4.补码一位除法</h2><p>补码除法采用加减交替法完成，与原码除法的有所区别的是：</p><ul><li><strong>符号位参与运算。</strong></li><li>被除数（余数）、除数采用双符号位。</li></ul><p>运算的具体细节区别如下：</p><ul><li>原码除法，首先一上来就会让被除数减去除数的绝对值的补码；<strong>在补码除法中，若被除数和除数同号，则被除数减去除数，如果异号，则被除数加上除数</strong>。</li><li>得到新的余数后判断：<strong>若余数和除数同号，则商 1，余数左移一位减去除数；若余数和除数异号，则商 0，余数左移一位加上除数。</strong></li><li>在原码除法中如果最后一步余数出现负值，那么需要进行恢复余数；<strong>在补码除法中，我们直接把最后一位商置为 1 即可，这样做很省事，其精度也不会超过 $2^{-n} $。</strong></li></ul><p>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位），$+x&#x3D;0.1000 $， $y&#x3D;-0.1011 $，采用补码加减交替法求 $x÷y$</p><ul><li>$ [x]_{补}&#x3D;00.1000 $</li></ul><ul><li>$ [y]_{补}&#x3D;11.0101 $</li><li>$ [-y]_{补}&#x3D;00.1011 $</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922281.png" loading="lazy"></p><p>因此最后的结果$[x&#x2F;y]_{补}&#x3D;1.0101$，余数为 $0.0111×2^{-4} $。</p><h2 id="12-5-总结"><a href="#12-5-总结" class="headerlink" title="12.5.总结"></a>12.5.总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922282.png" alt="image-20230413183656017" loading="lazy"></p><h1 id="13-详解C语言中的强制类型转换"><a href="#13-详解C语言中的强制类型转换" class="headerlink" title="13.详解C语言中的强制类型转换"></a>13.详解C语言中的强制类型转换</h1><h2 id="13-1-无符号数和有符号数"><a href="#13-1-无符号数和有符号数" class="headerlink" title="13.1.无符号数和有符号数"></a>13.1.无符号数和有符号数</h2><p>有如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">short</span> x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span><span class="token comment">//短整型，顶点负整数</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span><span class="token comment">//无符号短整型</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道在计算机中数据是以<a href="https://so.csdn.net/so/search?q=%E8%A1%A5%E7%A0%81&spm=1001.2101.3001.7020">补码</a>的形式保存的，因此变量<code>x</code>的补码形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0001</span> <span class="token number">1111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二句代码进行强制类型转换，把一个有符号转换为了无符号，并用无符号变量保存；<strong>在这个过程中数据的内容是没有被改变的，只是改变了解释的方式</strong>，也就说说变量 y 的内容依然是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0001</span> <span class="token number">1111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>但是在解释是计算机会把第一位的符号位当作数值位，因此 y 对应的真值是 61215</strong>。</p><h2 id="13-2-长整数变为短整数"><a href="#13-2-长整数变为短整数" class="headerlink" title="13.2.长整数变为短整数"></a>13.2.长整数变为短整数</h2><p>有如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">165537</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token operator">-</span><span class="token number">34991</span><span class="token punctuation">;</span><span class="token comment">//整形</span><span class="token keyword">short</span> c<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span><span class="token keyword">short</span> d<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token comment">//强制类型转换，长整形转为短整型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个例子中短整型为 16 位，整形为 32 位，因此将长整形转换为短整型，短整型的变量肯定不能完全保存，会丢失精度。具体规则为：<strong>高位截断，保留低位</strong>。</p><p>比如 a 的十六进制为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x000286a1</span><span class="token number">0010</span> <span class="token number">1000</span> <span class="token number">0110</span> <span class="token number">1010</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 c 保存后，值为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x86a1</span><span class="token number">1000</span> <span class="token number">0110</span> <span class="token number">1010</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>1000 0110 1010 0001</code>是 c 的补码，属于有符号数，是一个负数，其原码（负数原码等于补码除符号位按位取反后 + 1）为<code>1111 1001 0101 1111</code>，对应真值 - 31071。</p><p>再比如，b 的十六进制为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0xffff7751</span><span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">0111</span> <span class="token number">0111</span> <span class="token number">0101</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 d 保存后，值为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x7751</span><span class="token number">0111</span> <span class="token number">0111</span> <span class="token number">0101</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>0111 0111 0101 0001</code>是 d 的补码，属于有符号数，是一个正数，其原码（正数原码和补码一致）为<code>0111 0111 0101 0001</code>，对应真值 30545。</p><h2 id="13-3-短整数变为长整数"><a href="#13-3-短整数变为长整数" class="headerlink" title="13.3.短整数变为长整数"></a>13.3.短整数变为长整数</h2><p>有如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">short</span> x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span><span class="token comment">//短整型</span><span class="token keyword">int</span> m<span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment">//使用整形保存短整型</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> n<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span><span class="token comment">//将x强制转为为无符号，然后复制给无符号短整型</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> p <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token comment">//把无符号短整型n变为无符号整形</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这属于之前讲到过的符号扩展问题。<strong>这里 x 是一个负数，所以会在符号位和原有的数值位之间添上 1</strong>，这样做最后的结果不改变，只是补码的长度发生改变  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922283.png" loading="lazy">  </p><p><code>unsigned short n=(unsigned short)x</code>将 x 这个有符号短整型转换为了无符号短整型，<strong>计算机会将其补码原封不动的赋值给 n，但是会按照无符号的规则解析真值</strong>，真值为 61215。</p><p><code>unsigned int p = n</code>属于无符号到无符号的转换，<strong>直接填 0 即可</strong>。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922285.png" loading="lazy"></p><h1 id="14-数据的存储和排列"><a href="#14-数据的存储和排列" class="headerlink" title="14.数据的存储和排列"></a>14.数据的存储和排列</h1><h2 id="14-1-大小端模式"><a href="#14-1-大小端模式" class="headerlink" title="14.1.大小端模式"></a>14.1.大小端模式</h2><p>在存储数据的时候，数据从低位到高位可以从左到右排列，也可以按从右到左的方式排列。因此，我们无法用最左或最右来表征数据的最高位或最低位，<strong>通常用最低有效字节（$LSB $）和最高有效字节 ( $ MSB $) 来分别表示数的低位和高位</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922286.png" loading="lazy"></p><p><strong>现代计算机基本采用字节编址，即每个地址编号存放一个字节</strong>。不同类型的数据占用的字节数不同，（int 和 float 的数据占用 4 个字节，double 则占用 8 个字节等），但程序中的每个数据只给定了一个地址。假设变量 i 的地址为 80 00H，字节 01H、23H、45H、67H 应该各有一个内存地址，<strong>那么地址 0800H 对应 4 字节中哪字节的地址呢？这就是字节排列顺序的问题了。</strong></p><p><strong>多字节数据都存放在连续的字节序列当中，根据数据中各字节在连续字节序列中的排列顺序不同，可以有两种方式：大端方式（bid endian）和小端方式 (little endian)</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922287.png" loading="lazy"></p><ul><li><strong>大端方式</strong>：按照最高有效字节到最低有效字节的顺序存储数据，符合人类阅读习惯。</li><li><strong>小端方式</strong>：按照最低有效字节到最高有效字节的顺序存储数据。</li></ul><p>也可以这样描述 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922288.png" loading="lazy"></p><ul><li><strong>大端方式</strong>：数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地中；</li><li><strong>小端方式</strong>：数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中</li></ul><p>我们的计算机一般都是小端机，采用小端方式是有好处的，方便计算机处理。</p><p>例如下面机器代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">400</span>d3<span class="token operator">:</span> <span class="token number">01</span> <span class="token number">05</span> <span class="token number">64</span> <span class="token number">94</span> <span class="token number">04</span> <span class="token number">08</span>       add <span class="token operator">%</span> eax<span class="token punctuation">,</span><span class="token number">0x8049464</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>4004d3</code>：十六进制表示的地址。</li><li><code>01 05 43 0b 20 00</code>：指令的机器代码。</li><li><code>add %eax,0x8049464</code>：指令的汇编形式，该指令的操作数是一个立即数<code>0x8049464。</code></li></ul><p>执行指令时，从指令代码的后 4 字节取出该立即数，立即数存放的字节序列为 64H,94H,04H,08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到 08049464H，去掉开头 0，得到值 0x8049464，<strong>在阅读小端存储方式机器代码时，注意是相反顺序</strong>，比如下面：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922289.png" loading="lazy"></p><h2 id="14-2-内存（边界）对齐"><a href="#14-2-内存（边界）对齐" class="headerlink" title="14.2.内存（边界）对齐"></a>14.2.内存（边界）对齐</h2><p>假设存储字长为 32 位，<strong>可按照字节、半字节和字寻址</strong>。<strong>对于机器字长为 32 位的计算机，数据以边界对齐方式存储，半字地址一定是 2 的整数倍，子地址一定是 4 的整数倍，这样无论所取的数据是字节、半字还是字，均可以一次取出，当存储的数据不满足上述要求时，通常填充空白字节使其符合要求</strong>，典型的以空间换时间的做法。</p><p>如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919060.png" loading="lazy">  </p><p>更多关于内存对齐的问题，可以移步这篇文章 <a href="https://blog.csdn.net/qq_39183034/article/details/116457144?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162823137816780269873401%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162823137816780269873401&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-116457144.pc_v2_rank_blog_default&utm_term=%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90&spm=1018.2226.3001.4450">C 语言重难点：内存对齐和位段</a></p><h1 id="15-浮点数的表示"><a href="#15-浮点数的表示" class="headerlink" title="15.浮点数的表示"></a>15.浮点数的表示</h1><p><strong>浮点表示法是指以适当的方式将比例因子表示在数据中，让小数点的位置根据需要而浮动</strong> 。<br>这样，在位数有限的情况下，即扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量（$9×10^{-28}g $）或太阳的质量（$ 2×3^{33}g $）是非常不方便的。</p><h2 id="15-1-浮点数的表示格式"><a href="#15-1-浮点数的表示格式" class="headerlink" title="15.1.浮点数的表示格式"></a>15.1.浮点数的表示格式</h2><p>在小学学习科学计数时，我们知道对于： $ +302657264526 $这么长的数字可以用科学计数法表示为：  </p><ul><li>$+3.026×10^{11} $</li></ul><p>而浮点数的表示格式与科学计数法有异曲同工之妙  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919061.png" loading="lazy"></p><ul><li><strong>阶码</strong>：反映浮点数的表示范围及小数点的实际位置。</li><li><strong>尾数</strong>：其数值部分的位数 $n$反映了浮点数的精度  。<br>因此，通常浮点数表示为：<br>$N&#x3D;r^{E}×M$</li></ul><p>其中 <code>r</code> 是浮点数阶码的底（隐含），与尾数的基数相同（二进制中 $ r&#x3D;2$），<strong>E 是阶码，是一个常用补码或移码表示的定点整数，M 是尾数，是一个常用原码或补码表示的定点小数。</strong></p><p>因此，这种格式可以这样理解：<strong>尾数给出了一个小数（数符指明其正负性），同时阶码指明了小数点要向前（阶符为负）还是向后（阶符为正）移动几位</strong>。</p><p>$ case1: $: 例如浮点数 a 的阶码（补码）为 $ 0,01 $，尾数（补码）为$ 1.1001$，空间中存储的方式就是下面这样的  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919062.png" loading="lazy"></p><p>a 的阶码对应的真值为 + 1，$尾数对应的真值为 &#x3D;-(  2^{-2}+2^{-3}+2^{-4})&#x3D;- 0.0111 $，则 a 的真值为：$ 2^{1}×(-0.0111)&#x3D;-0.111 $</p><p>$case2 $：例如 b 的阶码（补码）为 0 , 10 0,10 0,10，尾数（补码）为 $ 0.01001$，空间存储如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919063.png" loading="lazy"></p><ul><li>上述后面 1 被抛弃了，精度丢失。</li></ul><p>b 的阶码对应真值为 + 2，尾数对应真值为 $ +(2^{-2}+2^{5})&#x3D;+0.01001 $，因此 b 的真值为： $2^{2}×(+0.01001)&#x3D;+1.001 $。</p><h1 id="15-2-浮点数尾数的规格化"><a href="#15-2-浮点数尾数的规格化" class="headerlink" title="15.2.浮点数尾数的规格化"></a>15.2.浮点数尾数的规格化</h1><h2 id="15-2-1-左规和右规"><a href="#15-2-1-左规和右规" class="headerlink" title="15.2.1.左规和右规"></a>15.2.1.左规和右规</h2><p>可以看到，上面的 $case 2 $ 中，由于尾数位数不够，因此最后一位 1 丢失，<strong>导致该种表示方法下的浮点数精度丢失</strong>。就像我们在学习科学计数法的时候要求过的一样，尽量保证不要有$0.003×10^{13} $ 这样的形式出现，必须保证最高位是一个有效位，因为无效的 0 不但不会增加精度，反而会占用位数。</p><p><strong>因此为了提高运算的精度，需要充分利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值</strong>。非规格化浮点数<strong>需要进行规格化操作</strong>才能变成规格化浮点数。所谓规格化操作，是指通过调整一个非规划浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高位上保证是一个有效值。</p><p>规格化方法主要有两种：</p><ul><li><strong>左规</strong>：<strong>将尾数算数左移一位，阶码就减 1（基数为 2</strong>），<strong>左规可能要进行多次</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919064.png" loading="lazy"></p><ul><li><strong>右规</strong>：当浮点数运算的结果尾数出现溢出（双符号位为 01 或 10）时，<strong>将尾数算数右移一位，阶码加 1（基数为 2 时）</strong> 的方法称为右规，<strong>右规只需进行一次。</strong></li></ul><p>下面是一个需要右规的例子  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919065.png" loading="lazy"></p><h2 id="15-2-2-规格化浮点数的特点"><a href="#15-2-2-规格化浮点数的特点" class="headerlink" title="15.2.2.规格化浮点数的特点"></a>15.2.2.规格化浮点数的特点</h2><p>规格化浮点数的尾数 M M M 的绝对值应该满足 $ \frac{1}{r} \leq |M| \leq 1 $，若 <code>r</code>为 2，则有 $ \frac{1}{2} \leq |M| \leq 1 $。规格化表示的尾数形式如下：</p><p><strong>1：原码规格化后</strong></p><p>_规格化的原码尾数，最高数值位一定是 1_。</p><ul><li><strong>正数</strong>：形式为<code>0.1××...×</code>，其最大值表示为<code>0.111...1</code>，最小值表示为<code>0.100...0</code>，尾数的表示范围为 $ \frac{1}{2} \leq M \leq (1-2^{-n}) $</li><li><strong>负数</strong>：形式为<code>1.1××...×</code>，其最大值表示为<code>1.10×××0</code>，最小值表示为<code>1.111...1</code>，尾数的表示范围为 $ -\frac{1}{2} \geq M \geq -(1-2^{-n}) $</li></ul><p><strong>2：补码规格化后</strong></p><p>_规格化的补码尾数，符号位与最高数值位一定相反_。</p><ul><li><strong>正数</strong>：形式为<code>0.1××...×</code>，其最大值表示为<code>0.111...1</code>，最小值表示为<code>0.100...0</code>，尾数的表示范围为 $ \frac{1}{2} \leq M \leq (1-2^{-n}) $。</li><li><strong>负数</strong>：形式为<code>1.0××...×</code>，其最大值表示为<code>1.01×××1</code>，最小值表示为<code>1.00...0</code>，尾数的表示范围为 $-1 \leq M \leq -(\frac{1}{2}+2^{-n}) $。</li></ul><p>$ case3：$若某浮点数的阶码，尾数用补码表示，共 4+8 位：<code>0.110;1.1110100</code>，问如何规格化？</p><p>答：在这个例子中，阶数为 + 6，前面说过我们规定规格化的补码尾数的负数形式一定为<code>1.0××...×</code>，因此可以将<code>1.1110100</code>算数左移三位（补码的算数左移是低位补 0，算数右移是高位补 1），结果为<code>1.010000</code>，阶码变为 + 3。</p><h2 id="15-3-浮点数表示范围（408-考试大纲已删除）"><a href="#15-3-浮点数表示范围（408-考试大纲已删除）" class="headerlink" title="15.3.浮点数表示范围（408 考试大纲已删除）"></a>15.3.浮点数表示范围（408 考试大纲已删除）</h2><p>如下图所示，运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称为上溢。<strong>数据一旦产生上溢，计算机必须进行中断操作，进行溢出处理</strong>。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919066.png" loading="lazy"></p><p>当运算结果在 0 到最小正数之间时称为正下溢，在 0 到绝对值最小负数之间时称为负下溢，正下溢和负下溢统称为下溢，<strong>数据下溢时，浮点数区域 0，计算机仅将其当做机器零处理</strong>。</p><h1 id="16-IEEE754标准"><a href="#16-IEEE754标准" class="headerlink" title="16.IEEE754标准"></a>16.IEEE754标准</h1><h2 id="16-1移码"><a href="#16-1移码" class="headerlink" title="16.1移码"></a>16.1移码</h2><h3 id="16-1-1-移码回顾"><a href="#16-1-1-移码回顾" class="headerlink" title="16.1.1.移码回顾"></a>16.1.1.移码回顾</h3><p>本节内容涉及移码，有关移码的基础内容请移步</p><blockquote><p><a href="">(计算机组成原理) 第二章数据的表示和运算 - 定点数的表示（原码、反码、补码和移码）</a></p></blockquote><h3 id="16-1-2-偏置值"><a href="#16-1-2-偏置值" class="headerlink" title="16.1.2.偏置值"></a>16.1.2.偏置值</h3><p>前面我们说过：<strong>移码是在补码的基础上将符号位取反得到的。</strong></p><p>其实移码的真正定义为：<strong>移码 &#x3D; 真值 + 偏置值</strong>，只不过前面的讲述中我们的偏置值取定为了$2^{7}&#x3D;128$，也即 1000 0000。所以，假如真值为 - 127，也即 1000 0001，那么其所对应的移码就是 1000 0001+1000 0000&#x3D;0000 0001。其余数值也是这样，从下面的表格中可以看出，移码只是将补码的符号位取反了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919067.png" loading="lazy"></p><p>其实，偏置值也是可以设置为其他值的。<strong>比如今天我们学习的浮点数当中的 IEEE754 标准中，就用移码表示阶码，其偏置值取$ 2^{n-1}-1$，也即 0111 1111（127）。</strong></p><p>这样的偏置值就导致移码会产生两个非常特殊的状态：<strong>1111 1111 和 0000 0000（真值 - 128 和 - 127），它们都对应无符号数 255；从真值 - 126 开始，对应无符号数 1，一直到无符号数 254</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920163.png" loading="lazy"></p><h2 id="16-2-IEEE-754-标准"><a href="#16-2-IEEE-754-标准" class="headerlink" title="16.2.IEEE 754 标准"></a>16.2.IEEE 754 标准</h2><h3 id="16-2-1-IEEE-754-标准格式"><a href="#16-2-1-IEEE-754-标准格式" class="headerlink" title="16.2.1.IEEE 754 标准格式"></a>16.2.1.IEEE 754 标准格式</h3><p>IEEE 754 将浮点数分为<strong>短浮点数、长浮点数和临时浮点数</strong>三类，C 语言遵循这个标准，因此它们分别对应<code>float</code>、<code>double</code>和<code>long double。</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920765.png" loading="lazy"></p><ul><li><strong>数符</strong>：表示了整个浮点数的正负性。</li><li><strong>阶码</strong>：采用移码表示，<strong>并且短浮点数的偏置值为 127</strong>。所以原本 8 位的移码表示的真值范围为 - 128~127，但是 127 的偏置值会使真值 - 127 和 - 128 较为特殊，其移码是全 0 和全 1，全 0 和全 1 在该标准下具有特殊作用，<strong>所以实际上 8 位的阶码表示真值的范围应该是 - 126 到 127</strong>。</li><li><strong>尾数</strong>：注意采用原码表示。并且我们知道使用原码表示浮点需要进行规格化，也就是最高位格式应该是<code>1.M</code>，<strong>所以短浮点数这里尾数部分写的虽然是 23 位，但是实则是 24 位</strong>，一位暗含。</li></ul><h3 id="16-2-2-转换方法"><a href="#16-2-2-转换方法" class="headerlink" title="16.2.2.转换方法"></a>16.2.2.转换方法</h3><p>我们知道移码等于真值阶码 + 偏置值，那么自然而然阶码真值 &#x3D; 移码 - 偏置值  。<br>因此 IEEE 754 标准中，规格化的短浮点数和长浮点数的真值分别为：<br>$ (-1)^{s}×1.M×2^{E-127} $                                </p><p>$ (-1)^{s}×1.M×2^{E-1023} $</p><p>上式中， $s&#x3D;0$ 表示正数，$ s&#x3D;1$ 表示负数。</p><p><strong>$ case:$ 将十进制数 - 0.75 转化为 IEEE 754 的单精度浮点数格式表示（十进制转换为浮点数）</strong><br>答：转换步骤如下</p><ul><li><strong>将十进制数转化为二进制数并规格化</strong>： $ (-0.75)<em>{10} \xrightarrow{转换为二进制}(-0.11)</em>{2} \xrightarrow{浮点数规格化}(-1.1)_{2}×2^{-1}$</li><li><strong>确定数符号</strong>：可以看出是负数，因此数符为 1。</li><li><strong>确定尾数部分</strong>：前面说过暗含了高位为 1，因此尾数部分是<code>.100000...</code></li><li><strong>确定阶码真值</strong>：基数指数部分是 - 1，因此阶码真值是 - 1。</li><li><strong>确定偏移值</strong>：127</li><li><strong>确定移码</strong>：移码 &#x3D;-1+ 0111 1111&#x3D;0111 1110（126，注意凑够 8 位）。</li><li><strong>最终形式</strong>（红色是数符，蓝色是阶码，绿色是尾数）：1 01111110 10000000000000000000000000000000。</li></ul><p><strong>$case$：IEEE 754 的单精度浮点数 C0 A0 00 00 的值为多少</strong> ?</p><p>答：转换步骤如下：</p><ul><li><strong>将十六进制转化为二进制</strong>（红色是数符，蓝色是阶码，绿色是尾数）：1100 0000 1010 0000 0000 0000 0000 0000</li><li><strong>数符为 1</strong>：这是个负数</li><li><strong>确定尾数部分</strong>：<code>.01000</code>，因此尾数真值为 $1.01_{2} $</li><li><strong>确定移码</strong>：是<code>10000001</code>，可看作无符号数 129</li><li><strong>确定偏移值</strong>：127</li><li><strong>确定阶码真值</strong>：$阶码真值 &#x3D; 移码 - 偏移值 &#x3D; 1000 0001-0111 1111&#x3D;(0000 0010)<em>{2} &#x3D;  (2)</em>{10} $</li><li><strong>确定浮点数真值</strong>：根据公式 $ (-1)^{s}×1.M×2^{E-127} $，可得真值 &#x3D;$ (-1)^{1}×(1.01)_{2}×2^{129-127}$。</li></ul><h3 id="16-2-3-表示范围"><a href="#16-2-3-表示范围" class="headerlink" title="16.2.3.表示范围"></a>16.2.3.表示范围</h3><p>IEEE 754 单精度浮点型表示的最小绝对值和最大绝对值。</p><ul><li><strong>最小绝对值</strong>：尾数全为 0，阶码真值最小为 - 126，对应机器数为 0000 0001，此时整体的真值为 $(1.0)_{2}×2^{-126}$</li><li><strong>最大绝对值</strong>：尾数全为 1，阶码真值最大为 - 127，对应机器数为 1111 1110，此时整体的真值为$ (1.111….11)_{2}×2^{127} $。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920285.png" loading="lazy"></p><p>当然即便这样，还是有溢出的问题的，<strong>因此前面提到的阶码全 0 和全 1 就派上用途了。</strong></p><ul><li>当阶码全为 0，尾数不全为 0 时，表示<strong>非规格化小数</strong>，也即$ (+&#x2F;-)(0.××××)_{2}×2^{-126} $，阶码的隐含最高位为 0。</li><li>当阶码全为 0，尾数全为 0 时，表示<strong>真值正负 0。</strong></li><li>当阶码全为 1，尾数全为 0 时，<strong>表示无穷大（正负）。</strong></li><li>当阶码全为 1，尾数不全为 0 时，<strong>表示非数值 NaN（Not a Number）</strong>，比如 0&#x2F;0。</li></ul><h1 id="17-浮点数加减运算"><a href="#17-浮点数加减运算" class="headerlink" title="17.浮点数加减运算"></a>17.浮点数加减运算</h1><h2 id="17-1-以十进制下的科学计数法的加减运算为例说明浮点数加减运算"><a href="#17-1-以十进制下的科学计数法的加减运算为例说明浮点数加减运算" class="headerlink" title="17.1.以十进制下的科学计数法的加减运算为例说明浮点数加减运算"></a>17.1.以十进制下的科学计数法的加减运算为例说明浮点数加减运算</h2><p>比如有浮点数 $ 9.85211×10^{12}+9.96007×10^{10} $，其运算基本步骤如下：</p><p><strong>1：对阶</strong><br>所谓对阶就是对齐两个浮点数的阶数，由于计算机内部尾数是定点小数，<strong>所以对阶是一律向大阶看齐</strong><br>也即 $ 9.85211×10^{12}+0.0996007×10^{12} $。</p><p><strong>2：尾数相减</strong><br>也即 $ 9.9517107×10^{12} $。</p><p><strong>3：规格化</strong><br>由于我们已经对阶了，所以这里就不用规格化了。</p><ul><li>如果尾加减出现了 $ 0.0099517×10^{12} $，就需要左规；如果尾数加减出现了 $99.517107×10^{12} $时，需要右规。</li></ul><p><strong>4：舍入</strong><br>假如规定了机器只能保持 6 位有效尾数，<strong>则 $ 9.9517107×10^{12}$中多余尾数部分应该砍掉</strong>，也即 $ 9.95171×10^{12} $。</p><ul><li>也可以采用四舍五入，也即 $9.95171×10^{12} $。</li><li>也可以采用 “若砍掉部分非 0，则入 1” 的原则，即 $ 9.95172×10^{12}$。</li></ul><p><strong>5：判溢出</strong><br><strong>假如规定了阶码不能超过两位，若运算后的阶码超出范围则溢出</strong>。比如 $ 9.85211×10^{99}+9.96007×19^{99}&#x3D;19.81218×10^{99} $，规格化后并采用四<br>舍五入原则保留 6 位尾数得：$ 1.98122×10^{100} $，因此这里产生了溢出。</p><ul><li>需要注意的是<strong>尾数溢出并不是真正的溢出</strong>，因为有可能通过规格化来拯救。</li></ul><h2 id="17-2-浮点数的加减运算（不舍入）"><a href="#17-2-浮点数的加减运算（不舍入）" class="headerlink" title="17.2.浮点数的加减运算（不舍入）"></a>17.2.浮点数的加减运算（不舍入）</h2><p><strong>$ case$：已知十进制数 $X&#x3D;-\frac{5}{256}$、 $ Y&#x3D;+\frac{59}{1024} $，按机器补码浮点运算规则计算$ X-Y $，结果用二进制表示，浮点数格式如下</strong>：</p><ul><li>阶符 2 位、阶码 2 位、数符 2 位、尾数 9 位。</li></ul><p><strong>预备步骤 1：格式转换</strong></p><ul><li><strong>对于$ X&#x3D;-\frac{5}{256}$​</strong>：其中分子 $ (101)_{2}$​，而 $ \frac{1}{256}&#x3D;2^{-8} $，因此 $ X&#x3D;-101× 2^{-8}&#x3D;-0.101×2^{-5}&#x3D;-0.101×2^{-101} $</li><li>**对于 $Y&#x3D;+\frac{59}{1024} $**：其中分子 $ 59&#x3D;(111011)_{2} $​，而 $ \frac{1}{1024}&#x3D;2^{-10} $，因此 $ Y&#x3D;+111011×2^{-10}&#x3D;+0.111011×2^{-4}&#x3D;+0.111011×2^{-100} $。</li></ul><p><strong>预备步骤 2：确定浮点数</strong></p><p>题目规定：阶符 2 位、阶码 2 位、数符 2 位、尾数 9 位。</p><p>①：对于 $X$</p><ul><li><strong>阶码</strong>：其阶码部分为 $-5 $，对应原码为 $ 1101 $，对应补码为 $1011 $，因为阶符 2 位、阶码 3 位，因此必须增添 1 位，采用双符号位，<strong>也即补码为 11011 11011 11011;</strong></li><li><strong>尾数</strong>：其尾数部分为$-0.101 $，对应原码为 $ 1.101 $，对应补码为$ 1.011 $, 因为数符 2 位、尾数 9 位，因此必须增添 1 位，采用双符号位，也即补码为$ 11.011 $, 再进行符号扩展，<strong>也即补码为 $11.011000000$。</strong></li></ul><p>因此 $X$ 的浮点数形式为：11011，11.011000000。</p><p>②：对于 $Y$</p><ul><li><strong>阶码</strong>：其阶码部分为 $-4 $，对应原码为 1100，对应补码为 $1100 $，因为阶符 2 位、阶码 3 位，因此必须增添 1 位，采用双符号位，<strong>也即补码为 $11100 $</strong></li><li><strong>尾数</strong>：其尾数部分为$+0.111011$, 对应原码为 $ 0.111011 $，对应补码为$ 0.111011 $，因为数符 2 位、尾数 9 位，因此必须增添 1 位，采用双符号位，也即补码为 $ 00.111011 $，再进行符号扩展，<strong>也即补码为 $00.111011000 $。</strong></li></ul><p>因此 $Y$ 的浮点数形式为：11100，00.111011000。</p><p><strong>第一步：对阶</strong>：<strong>使两个数的阶码相等，小阶向大阶看齐。</strong></p><ul><li><strong>求阶差（减法采用加法实现）</strong>：$ [\Delta E]_{补}&#x3D;11011+00100&#x3D;11111 $，也即 11001 11001 11001，也就是 $− 1 $，这意味着 $X$ 的阶数要比 $Y$ 低一阶。</li><li>**对阶 (小的对齐，尾数每右移一位，阶码就加 1)**：因此 $X$ 尾数部分右移一位，同时注意阶码部分 + 1，也即 11011，11.011000000—–&gt;11100，11.101100000。</li></ul><p><strong>第二步：尾数相减</strong>：</p><ul><li>**先求出 - $Y$**：$ [-Y]_{补}&#x3D;11100,11.000101000$。</li><li><strong>再尾数相减</strong>： 因此尾数部分 $ X-Y&#x3D;11.101100000+11.000101000&#x3D;10.110001000 $（根据之前我们学习的双符号位的运算规则，大家可以发现此时其实已经溢出了），<strong>因此 $ X-Y&#x3D;11100,10.110001000 $。</strong></li></ul><p><strong>第三步：规格化</strong>：</p><p>尾数采用双符号位的好处就是，我们可以通过右规的操作挽救刚才的溢出 <strong>，算数右移时小数点前的 0 会被移动到小数点后面，补多少看双符号位的高位，因为双符号位的高位表示的是正确的本应该得到的符号，因此这里补 1</strong>，同时右移不要忘记啊阶码 + 1。</p><p>因此：11100，10.110001000—–&gt;11101，11.011000100</p><p><strong>第四步：舍入</strong>：</p><p>这个例子中算数右移时, 抛弃了最低位的 0，0 对精度没有任何影响，因此不舍入（后面会有一个需要舍入的例子）。</p><p><strong>第五步：判断溢出</strong>：</p><p>由于阶码采用双符号位，因此我们只需要让其 + 1，如果相同那么没有溢出，在这个例子中很明显没有溢出。</p><p><strong>收尾步骤：翻译真值</strong></p><p>$X-Y&#x3D; 11101,11.011000100$</p><ul><li>阶码：$ 2^{-3} $</li><li>尾数： $ -0.1001111 $</li></ul><p>因此 $ 2 X-Y&#x3D;2^{-3}×(-0.1001111)_{2}$</p><h2 id="17-3-浮点数的加减运算（舍入）"><a href="#17-3-浮点数的加减运算（舍入）" class="headerlink" title="17.3.浮点数的加减运算（舍入）"></a>17.3.浮点数的加减运算（舍入）</h2><p>前面的所有例子中都没有涉及到舍入这个步骤。浮点数加减运算舍入有两种：</p><ul><li><strong>舍 “0” 入“1”</strong>：类似于十进制中的四舍五入，<strong>即在尾数右移时，被移去的最高数位为 0，则舍去；被移去的最高数值位为 1</strong>，则在尾数的末位加 1，这样做可能会使尾数又溢出，此时需要再做一次右规。</li></ul><p>比如某次尾数相减结果：$X-Y&#x3D;11100,10.110001011 $，此时产生溢出，接着进行右规结果为 11101,11.011000101 1(抛弃)，由于这一位抛弃的是 1，因此再继续加 1，正确结果就为 11101,11.011000110 1(抛弃)（如果加上之后还要进位，可能导致又溢出，再进行右规即可）；如果舍弃的是 0 就不用加了。</p><ul><li><strong>恒置 “1” 法</strong>：尾数右移时，<strong>不论丢掉的最高数值位是 “1” 还是“0”，都使右移后的尾数末尾恒置为“1”</strong>。这种方法同样有可能使尾数变大或变小。</li></ul><h2 id="17-4-浮点数强制类型转换"><a href="#17-4-浮点数强制类型转换" class="headerlink" title="17.4.浮点数强制类型转换"></a>17.4.浮点数强制类型转换</h2><p>C 语言中的<code>float</code>和<code>double</code>类型分别对应于 IEEE 754 单精度浮点数和双精度浮点数。<code>long double</code> 类型对应于扩展双精度浮点数，但是<code>long double</code>的长度和格式会随编译器和处理器类型的不同而与所不同。</p><p>在 C 程序中等式的赋值和判断常会强制类型转换，以下两种最为常见，<strong>其最前到后范围和精度都从小到大，转换过程没有损失</strong></p><ul><li><code>char</code>-&gt;<code>int</code>-&gt;<code>long</code>-&gt;<code>double</code></li><li><code>float</code>-&gt;<code>double</code></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920412.png" loading="lazy"></p><ul><li>从<code>int</code>转换为<code>float</code>时，虽然不会发生溢出，但是<code>int</code>可以保留 32 位，<code>float</code>保留 24 位，可能有数据舍入；若<code>int</code>转换为<code>double</code>则不会出现这种情况。</li><li>从<code>int</code>或 float 转化为<code>double</code>时，由于<code>double</code>有效位数更多，因此能够保留精度。</li><li>从<code>double</code>转换<code>float</code>时，由于<code>float</code>表示的范围更小，因此可能发生溢出。此外，由于有效位数变少，因此可能被舍入。</li><li>从<code>float</code>或<code>double</code>转换为 int 时，由于<code>int</code>没有小数部分，所以数据可能会向 0 方向被截断（仅保留整数部分），影响精度，同时由于<code>int</code>的表示范围更小，因此可能发生溢出。</li></ul><p>类型转换是一个让人很恼火的话题，如果处理不正确，极容易出现 bug。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数制与编码&quot;&gt;&lt;a href=&quot;#1-数制与编码&quot; class=&quot;headerlink&quot; title=&quot;1.数制与编码&quot;&gt;&lt;/a&gt;1.数制与编码&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wushua</summary>
      
    
    
    
    <category term="考研408" scheme="http://ccsu.top/categories/%E8%80%83%E7%A0%94408/"/>
    
    
    <category term="计算机组成原理" scheme="http://ccsu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="考研" scheme="http://ccsu.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>机组-第一章 计算机发展历程</title>
    <link href="http://ccsu.top/posts/c441e7e0/"/>
    <id>http://ccsu.top/posts/c441e7e0/</id>
    <published>2023-03-31T16:00:00.000Z</published>
    <updated>2023-03-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-计算机发展历程"><a href="#1-计算机发展历程" class="headerlink" title="1.计算机发展历程"></a>1.计算机发展历程</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121446238.png" alt="image-20230412144653181" loading="lazy"></p><h2 id="1-1-计算机硬件的发展"><a href="#1-1-计算机硬件的发展" class="headerlink" title="1.1.计算机硬件的发展"></a>1.1.计算机硬件的发展</h2><p><strong>①：电子管时代：第一代计算机（1946-1957 年）</strong></p><p>逻辑元件采用电子管；使用机器语言进行编程；主存用延迟线或磁鼓存储信息，容量极小；体积庞大，成本高；运算速度较低，一般只有几千次到几万次每秒。</p><hr><p><strong>②：晶体管时代：第二代计算机（1958-1964 年）</strong></p><p>逻辑元件采用晶体管；运算速度提高到几万次到几十万次每秒；主存使用磁芯存储器；计算机软件也得到了发展，开始出现了高级语言及其编译程序，有了操作系统的雏形。</p><hr><p><strong>③：中小规模集成电路时代：第三代计算机（1965-1971 年）</strong></p><p>逻辑元件采用中小规模集成电路：半导体存储器开始取代磁芯存储器；高级语言发展迅速，操作系统也进一步发展，开始有了分时操作系统。</p><hr><p><strong>④：超大规模集成电路时代：第四代计算机（1927 年 - 现在）</strong></p><p>逻辑元件采用大规模集成电路和超大规模集成电路，产生了微处理器：诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中。</p><hr><p><strong>⑤：智能计算机</strong></p><p>具备人工智能，运算速度极快，软件系统能够处理知识信息，以<strong>神经网络计算机</strong>为代表。</p><hr><p><strong>⑥：生物计算机和量子计算机</strong></p><ul><li><p>生物计算机是指使用生物分子或细胞作为计算元件的计算机。生物计算机的运算方式与传统的计算机不同，它们利用生物分子的结构和运动来进行计算，从而实现高效的计算能力。生物计算机具有较低的功耗和较长的计算时间，但它们需要更为复杂的技术和材料来实现。</p></li><li><p>量子计算机是指使用量子比特 (qubit) 来进行计算的计算机。与传统计算机使用的二进制比特 (bit) 不同，量子比特可以处于多种状态的叠加态，这种叠加态可以在量子计算机中实现高效的并行计算。量子计算机的运算速度非常快，但目前尚处于研究和开发阶段，需要解决许多技术难题才能实现。</p></li></ul><hr><h2 id="1-2-计算机元件的更新换代"><a href="#1-2-计算机元件的更新换代" class="headerlink" title="1.2.计算机元件的更新换代"></a>1.2.计算机元件的更新换代</h2><p><strong>注意以下三点或概念即可</strong>：</p><ul><li><strong>摩尔定律：</strong> 每平方英寸电路板上的晶体管数量<strong>每 18 个月</strong>翻一番。</li><li><strong>微处理器的出现和发展</strong>：自1971年Intel公司开发出第一个微处理器<code>Intel4004</code>至今，微处理器经历了<code>Intel8008（8位）</code>、<code>Intel8086（16位）</code>、<code>Intel80386（32位）</code>、<code>Pentium（32位）</code>、<code> Pentium III（64位）</code>、<code>Pentium4（64位）</code>、<code>Core i7（64位）</code>等。这里的32位、64位指的是机器字长，是指<strong>计算机进行一次整数运算所能处理的二进制数据的位数</strong>。</li><li><strong>半导体存储器的发展：</strong> 1970年，仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代：单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB和现在的1GB。</li></ul><h2 id="1-3-计算机软件的发展"><a href="#1-3-计算机软件的发展" class="headerlink" title="1.3.计算机软件的发展"></a>1.3.计算机软件的发展</h2><p><strong>计算机语言的发展</strong>： 机器语言 - 汇编语言 - 高级语言。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033369.png" alt="image-20230416203359301" loading="lazy"></p><p><strong>操作系统的发展</strong>：例如 DOS，Windows，MAC 等等。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034743.png" alt="image-20230416203429681" loading="lazy"></p><h2 id="1-4-计算机的分类与发展方向"><a href="#1-4-计算机的分类与发展方向" class="headerlink" title="1.4.计算机的分类与发展方向"></a>1.4.计算机的分类与发展方向</h2><h3 id="1-4-1-分类"><a href="#1-4-1-分类" class="headerlink" title="1.4.1.分类"></a>1.4.1.分类</h3><p><strong>电子计算机</strong></p><ul><li>电子模拟计算机</li><li>电子数字计算机</li></ul><p><strong>数字计算机</strong></p><ul><li>专用计算机</li><li>通用计算机</li></ul><p><strong>通用计算机</strong></p><ul><li>巨型机</li><li>大型机</li><li>中型机</li><li>小型机</li><li>微型机</li><li>单片机</li></ul><p><strong>依照指令与数据流划分：</strong></p><ul><li><strong>单指令流与单数据流（SISD）</strong>：冯诺依曼体系结构。</li><li><strong>单指令流与多数据流（SIMD）</strong>：阵列存储器与向量存储器。</li><li><strong>多指令流与单数据流（MISD）</strong>：不存在。</li><li><strong>多指令流与多数据流（MIMD）</strong>：多处理器和计算机系统。</li></ul><h3 id="1-4-2-发展方向"><a href="#1-4-2-发展方向" class="headerlink" title="1.4.2.发展方向"></a>1.4.2.发展方向</h3><p><strong>两极化发展方向</strong></p><ul><li><strong>微型计算机：微型化、网络化、高性能、多用途。</strong></li><li><strong>巨型计算机：巨型化、超高速、并行处理、智能化。</strong></li></ul><h1 id="2-计算机硬件的基本组成"><a href="#2-计算机硬件的基本组成" class="headerlink" title="2.计算机硬件的基本组成"></a>2.计算机硬件的基本组成</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121452420.png" alt="image-20230412145256346" loading="lazy"></p><h2 id="2-1-冯诺依曼机特点"><a href="#2-1-冯诺依曼机特点" class="headerlink" title="2.1.冯诺依曼机特点"></a>2.1.冯诺依曼机特点</h2><ol><li>计算机硬件系统由<strong>运算器、存储器、控制器、输入和输出设备</strong> 5 部分组成。</li><li><strong>指令和数据</strong>以同等地位存储在<strong>存储器</strong>，并可按<strong>地址</strong>寻访。</li><li>指令由<strong>操作码和地址码</strong>组成，操作码用于表示这是一个<strong>什么类型的操作</strong>，地址码用于表示<strong>操作数在存储器中的存放位置。</strong></li><li>指令在存储器内<strong>按顺序存放</strong>（一般情况下是这样的，但在特定条件下也可以进行设定）。</li><li><strong>早期的冯诺依曼机器以运算器为中心</strong>，输入输出设备通过运算器与存储器传送数据。</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450055.png" alt="image-20230412145004989" loading="lazy"></p><ul><li>上图中，<strong>实线是数据线，虚线是控制线</strong>（双向）。</li></ul><p><strong>冯诺依曼机缺陷（早期）</strong></p><p>在控制器的指挥下，输入和输出设备输入一些数据交给运算器进行运算，如果产生中间结果，就会传送给存储器，计算完成后最终结果会给输出设备。<strong>可以发现这种层次结构容易受到输入和输出设备的牵制，因为他们的速度相较于运算器太慢了（短板效应）。</strong></p><h2 id="2-2-现代计算机的组织结构"><a href="#2-2-现代计算机的组织结构" class="headerlink" title="2.2.现代计算机的组织结构"></a>2.2.现代计算机的组织结构</h2><p>为了解决 I&#x2F;O 设备的速度和 CPU 速度差异悬殊的问题，<strong>现如今的计算机则采用以存储器为中心的计算机组织结构</strong>，这种结果使 I&#x2F;O 操作尽可能绕过 CPU，直接<strong>在 I&#x2F;O 设备和存储器之间完成</strong>，以提高系统的整体运行效率。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450737.png" alt="image-20230412145050674" loading="lazy"></p><h1 id="3-各个硬件的工作原理"><a href="#3-各个硬件的工作原理" class="headerlink" title="3.各个硬件的工作原理"></a>3.各个硬件的工作原理</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532810.png" alt="image-20230412153254738" loading="lazy"></p><h2 id="3-1-存储器（第三章重点学习）"><a href="#3-1-存储器（第三章重点学习）" class="headerlink" title="3.1.存储器（第三章重点学习）"></a>3.1.存储器（第三章重点学习）</h2><h3 id="3-3-1-存储器相关基本定义"><a href="#3-3-1-存储器相关基本定义" class="headerlink" title="3.3.1.存储器相关基本定义"></a>3.3.1.存储器相关基本定义</h3><p><strong>存储器相关基本定义：目前我们采用半导体器件来承担存储任务，一个半导体触发器由于有 0 和 1 两个状态，就可以记忆一个二进制代码，关于存储器有如下五个非常重要的概念</strong>：</p><ul><li><p><strong>存储元</strong>：也可称为存储元件和存储基元，用来存放<strong>一位二进制信息</strong>。</p></li><li><p><strong>存储单元</strong>：由若干个存储元组成，能存放<strong>多位二进制信息。</strong></p></li><li><p><strong>存储体</strong>：许多存储单元可组成存储体，也即<strong>存储矩阵。</strong></p></li><li><p><strong>存储字</strong>：每个存储单元中<strong>二进制代码的组合</strong>即为存储字，可代表数值、指令和地址等。</p></li><li><p><strong>存储字长</strong>：每个存储单元中<strong>二进制代码的位数</strong>就是存储字长。</p></li></ul><p><strong>上述概念可以这样记忆</strong>：主存储器由许多存储单元组成，每个存储单元包含多个存储元，每个存储元存储 1 位二进制代码 0 或 1，故存储单元可存储一串二进制代码，称这串代码为存储字，而这串代码的位数称为存储字长，存储字长一般是一个字节（8 位）或字节的偶数倍。</p><h3 id="3-3-2存储器的基本结构"><a href="#3-3-2存储器的基本结构" class="headerlink" title="3.3.2存储器的基本结构"></a>3.3.2存储器的基本结构</h3><p><strong>存储器基本结构：存储器主要分为</strong>：</p><ul><li><strong>主存（内存）</strong>：CPU <strong>可以直接访问</strong>；主要存放<strong>程序和数据</strong>；是计算机实现 “<strong>存储程序</strong>” 控制的基础；外存中信息必须<strong>加载进主存后</strong> CPU 才可以访问。</li><li><strong>辅存（外存）</strong>：CPU <strong>不可以直接访问。</strong></li></ul><p><strong>主存的基本构成如下图所示</strong></p><ul><li><strong>存储体 M</strong>：存放<strong>二进制信息。</strong></li><li><strong>MAR（地址寄存器）</strong>：存放的是<strong>访存地址</strong>（经过地址译码后找到所选存储单元）。</li><li><strong>MDR（数据寄存器）</strong>：存放的是要从存储器中<strong>读入或写入的信息。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171053506.png" alt="image-20230417105309384" loading="lazy"></p><p>内部原理图如下。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121458028.png" loading="lazy"></p><h3 id="3-3-3-存储器相关小考点"><a href="#3-3-3-存储器相关小考点" class="headerlink" title="3.3.3.存储器相关小考点"></a>3.3.3.存储器相关小考点</h3><p><strong>此部分内容将在【第三章：存储系统】学习，所以看不太懂没有关系，其中一些常考考点汇总如下</strong>：</p><ul><li>数据在存储体中是<strong>按照地址存储的，每个地址对应一个存储单元</strong>。</li><li><strong>存储单元数目 &#x3D; $2^{MAR 位数}$<strong>（如果 MAR 为 10 位，则存储单元数目为 $2^{10}&#x3D;1024$）。它用于</strong>寻址</strong>，其长度和 PC（程序计数器）长度一致。</li><li><strong>MDR 的位数表示存储字长</strong>（例如 MDR 为 16，表示存储字长为 16，也表示 1 个字 (word)&#x3D;16bit）。</li><li>注意区分<strong>字（word）和字节（Byte），1 个字节等于 8 个 bit</strong>，而 1 个字的大小取决于机器。</li><li><strong>1B&#x3D;1 个字节，1b &#x3D; 1个bit</strong>。</li></ul><h2 id="3-2-运算器（第五章重点学习）"><a href="#3-2-运算器（第五章重点学习）" class="headerlink" title="3.2.运算器（第五章重点学习）"></a>3.2.运算器（第五章重点学习）</h2><p><strong>运算器：是计算机的执行部件，主要进行</strong>：</p><ul><li><strong>算数运算</strong>：比如加减乘除。</li><li><strong>逻辑运算</strong>：比如与、或、非、异或、比较等等。</li></ul><h3 id="3-2-1-运算器基本结构"><a href="#3-2-1-运算器基本结构" class="headerlink" title="3.2.1.运算器基本结构"></a>3.2.1.运算器基本结构</h3><p><strong>运算器基本结构：由以下四部分构成</strong>：</p><ul><li><strong>ALU（算数逻辑单元）</strong>：运算器中造价最为高昂的部分，本质是一对电路；通过内部复杂的电路实现算数运算、逻辑运算。</li><li><strong>ACC（累加器）</strong>：辅助 ALU，累加器，用于存放操作数，或运算结果。</li><li><strong>MQ（乘商寄存器）</strong>：辅助 ALU，乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。</li><li><strong>X（通用操作数寄存器）</strong>：辅助 ALU，通用的操作数寄存器，用于存放操作数。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121503264.png" alt="image-20230412150310212" loading="lazy"></p><h3 id="3-2-2-运算器过程伪代码描述（了解）"><a href="#3-2-2-运算器过程伪代码描述（了解）" class="headerlink" title="3.2.2.运算器过程伪代码描述（了解）"></a>3.2.2.运算器过程伪代码描述（了解）</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121508014.png" alt="image-20230412150802918" loading="lazy"></p><p>设 M 为主存中的某一个存储单元，<code>(M)</code>表示取 M 中的数据，<code>-&gt;</code>表示将内容送入寄存器。</p><p><strong>加法实现</strong>：假设 ACC 中已经存在一个数，那么首先取 M 的内容送入通用操作数寄存器 X，即<code>(M)-&gt;X</code>；然后两者相加重新送入寄存器 ACC 中，即<code>(ACC)+(M)-&gt;(ACC)。</code></p><p><strong>乘法实现</strong>：假设 ACC 中已经存在一个数，那么首先取 M 的内容送入乘商寄存器 MQ 作为乘数，即<code>(M)-&gt;MQ</code>，再取 ACC 寄存器的内容放入 X 寄存器作为被乘数，即<code>ACC-&gt;X</code>，接着将 ACC 清零，即<code>0-&gt;ACC</code>，然后乘数乘以被乘数，一个送入乘积高位，一个送入乘积低位，即<code>(X)×(MQ)-&gt;ACC//MQ。</code></p><p><strong>除法实现</strong>：假设 ACC 中已经存在一个数，首先取 M 的内容送入 X 作为除数，即<code>(M)-&gt;X</code>，ACC 中的内容作为被除数，结果一个放入 MQ 作为整数部分，即<code>(ACC)/(X)-&gt;MQ</code>，另一个放入 ACC 作为余数，即<code>(ACC)%(X)-&gt;ACC。</code></p><h2 id="3-3-控制器（第四章重点学习）"><a href="#3-3-控制器（第四章重点学习）" class="headerlink" title="3.3.控制器（第四章重点学习）"></a>3.3.控制器（第四章重点学习）</h2><p><strong>运算器：是计算机的指挥中心，由其指挥各部件自动协调地进行工作。</strong></p><h3 id="3-3-1-指令"><a href="#3-3-1-指令" class="headerlink" title="3.3.1.指令"></a>3.3.1.指令</h3><p><strong>指令：是指指挥机器工作的指示和命令。程序本质就是一系列按照一定顺序排列的指令。人们用程序表达自己的意图，控制器则通过指令指挥机器工作。指令 &#x3D; 操作码 + 地址码。</strong></p><ul><li><strong>操作码</strong>：指示计算机要干什么。</li><li><strong>地址码</strong>：干这些事情需要的原材料在哪里。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121510905.png" loading="lazy">  </p><h3 id="3-3-2-控制器基本结构"><a href="#3-3-2-控制器基本结构" class="headerlink" title="3.3.2.控制器基本结构"></a>3.3.2.控制器基本结构</h3><p><strong>控制器基本结构：由以下三部分构成</strong>：</p><ul><li><strong>控制单元（CU）</strong>：分析指令、发出信号、协调操作。</li><li><strong>指令寄存器（IR）</strong>：存放<strong>当前要执行的指令</strong>。注意其内容来源于 MDR，因为指令和数据本质是一样的，都被存放在存储器。</li><li><strong>程序计数器（PC）</strong>：存放<strong>当前要执行的指令地址</strong>。注意其与 MAR 直接连通，并且可以自动 + 1。</li></ul><h3 id="3-3-3-控制器过程伪代码描述（了解）"><a href="#3-3-3-控制器过程伪代码描述（了解）" class="headerlink" title="3.3.3.控制器过程伪代码描述（了解）"></a>3.3.3.控制器过程伪代码描述（了解）</h3><p>完成一条指令的过程为：<strong>取指令（PC）-&gt; 分析指令（IR）-&gt; 执行指令（CU）。</strong></p><p>具体过程：首先取出指令，即<code>(IR)</code>，接着获取指令的操作码，即<code>OP(IR)</code>，然后获取指令的地址码，即<code>AD(IR)</code>，然后将操作码送入控制单元分析，即<code>OP(IR)-&gt;CU</code>，操作码表示需要干什么，但是干活需要原材料，所以再把指令的地址码送入 MAR，<code>AD(IR)-&gt;MAR</code>, 从 MAR 指示的存储体取出原材料即可。</p><p>结合前面的加法，我们可以写出完整的加法运算的过程的： 首要取加法指令，而指令存储在存储体中，想要取出指令必须要知道的指令的地址，而这个地址就存放在 PC 中，PC 又和 MAR 直接相连，即<code>(PC)-&gt;MAR</code>，于是指令此时被放入了 MDR 中，那么接着将指令放入 IR 中，即<code>(MDR)-&gt;IR</code>, 接着取指令的操作码送入控制单元，即<code>OP(IR)-&gt;CU</code>，然后再把原材料（就是一些操作数）的地址码送入 MAR，即<code>AD(IR)-&gt;MAR</code>。接着就可以进行加法操作了，由于上一步已经将操作数的地址码送入了 MDR 中，所以现在送入操作数寄存器，即<code>(MDR)-&gt;X</code>，然后<code>(ACC)+(X)-&gt;ACC</code>，最后 PC 要自增，即<code>(PC)+1-&gt;PC</code>，表示下一条指令。</p><h2 id="3-4-计算机的工作过程"><a href="#3-4-计算机的工作过程" class="headerlink" title="3.4.计算机的工作过程"></a>3.4.计算机的工作过程</h2><p><strong>接下来以一段简单的 C 语言代码为例展示计算机在背后所做的工作。</strong></p><ul><li>以下程序非常简单，声明了 4 个变量并赋值，然后在 main 函数内进行运算。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>y<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token operator">+</span>c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过编译器编译后，这段程序在主存中就是这样的  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121513033.png" alt="image-20230412151300971" loading="lazy"></p><ul><li>下半部分是定义的变量，上半部分则是对应于高级语言对应的机器指令。</li></ul><p>为了方便演示，我们将控制器、运算器和存储体也放在旁。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520952.png" loading="lazy"></p><p>第一组<br>1：程序开始运行，PC 的值为 0，保存的是第一条指令的地址。然后将 PC 的内容，也就是指令的地址送入到 MAR 中，即 (PC)-&gt;MAR,MAR&#x3D;0。也就是说控制器向存储器指明，我接下来要访问主存 0 号地址处的数据，同时告诉存储器进行读操作 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520320.png" loading="lazy"></p><p>2+3：主存储器会根据 MAR 记录的地址信息，到存储体中找出 0 号地址对应的二进制数据，并将其放入到 MDR 中，此时 MDR 中存放了第一条指令。即 M(MAR)-&gt;MDR，此时 <code>MDR=000001 0000000101</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520452.png" loading="lazy"></p><p>4：接着将 MDR 中的指令放入 IR 中，于是控制器就存放了当前要执行的指令。即 (MDR)-&gt;IR，<code>(IR)=000001 0000000101 </code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520495.png" loading="lazy"></p><p>  5：这条指令的前 6 个比特位是操作码，会被送入到控制单元<code> CU</code> 中，<code>CU </code>分析后，得知这是一条取数命令。即 <code>OP(IR)-&gt;CU </code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520536.png" loading="lazy"></p><p> 6：取数指令会将变量 a 的内容放入寄存器 ACC 中。但是现在变量 a 不知道在哪里，所以现在会把指令的地址码送到 MAR 当中，即<code>(MAR)=5</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520751.png" loading="lazy"></p><p>  7+8：接着主存储器根据 MAR 指明的地址，也就是 a 的地址（5），去存储体中找出 5 号地址的数据，并将其放入 MDR 当中。即<code> M(MAR)-&gt;MDR</code>，<code>(MDR)=0000000000000010</code>，也即 <code>(MDR)=2  </code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520409.png" loading="lazy"></p><p>  9：接着在控制单元的指挥下，MDR 中的数据就被放入到了 ACC 中。至此第一条指令完成  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520639.png" loading="lazy"></p><p>  10：最后 PC 自增 1，进行下一条指令，即 (PC)&#x3D;1  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520072.png" alt="image-20230412152035976" loading="lazy"></p><p>接下来进行下一组操作  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162032683.png" loading="lazy"> </p><p>1：程序接着运行，PC 的值为 1，保存的是第二条指令的地址。然后将 PC 的内容，也就是指令的地址送入到 MAR 中，即<code> (PC)-&gt;MAR</code>，<code>MAR=1</code>。也就是说控制器向存储器指明，我接下来要访问主存 1 号地址处的数据，同时告诉存储器进行读操作  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034679.png" loading="lazy"></p><p>  2+3：主存储器会根据 MAR 记录的地址信息，到存储体中找出 1 号地址对应的二进制数据，并将其放入到 MDR 中，此时 MDR 中存放了第二条指令。即<code> M(MAR)-&gt;MDR</code>，此时<code>MDR=000100 0000000110 </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033681.png" loading="lazy"></p><p>4：接着将 MDR 中的指令放入 IR 中，于是控制器就存放了当前要执行的指令。即<code> (MDR)-&gt;IR</code>，<code>(IR)=000100 0000000110  </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033562.png" loading="lazy"></p><p>5：这条指令的前 6 个比特位是操作码，会被送入到控制单元 CU 中，CU 分析后，得知这是一条乘法命令。即<code>OP(IR)-&gt;CU </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033265.png" loading="lazy"></p><p>6：接着把指令的地址码送到 MAR 当中，即<code>(MAR)=6 </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033330.png" loading="lazy"></p><p>7+8：接着主存储器根据 MAR 指明的地址，也就是 b 的地址（6），去存储体中找出 6 号地址的数据，并将其放入 MDR 当中。即<code> M(MAR)-&gt;MDR</code>，<code>(MDR)=0000000000000011</code>，也即<code>(MDR)=3</code> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033644.png" loading="lazy"></p><p>9：由于是乘法，所以控制单元将 MDR 中的内容送入到乘商寄存器 MQ 中，即 <code>(MDR)-&gt;MQ</code>，此时 <code>(MQ)=0000000000000011=3 </code> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033315.png" loading="lazy"></p><p>10：先把 a 的值放入通用寄存器 X 中，即<code> (ACC)-&gt;X</code>，<code>(X)=2  </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034823.png" loading="lazy"></p><p>11：CU 告诉 ALU，让其进行乘法运算。即<code> (MQ)×(X)-&gt;ACC</code>，<code>(ACC)=6</code>。注意如果乘积过大，需要 MQ 辅助存储，也就是最上面讲到过的 <code>(X)×(MQ)-&gt;ACC/MQ</code>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033141.png" loading="lazy"></p><p>接着进行下一组操作，具体过程就不详细演示了，步骤如下：</p><ul><li><strong>1</strong>:PC 存储 2 号指令的地址，<code>(PC)-&gt;MAR</code>，<code>(MAR)=2</code></li><li><strong>2+3</strong>:<code>M(MAR)-&gt;MDR</code>，<code>(MDR)=000011 0000000111</code></li><li><strong>4</strong>:<code>(MDR)-&gt;IR</code>，<code>(IR)=000011 0000000111</code></li><li><strong>5</strong>:<code>OP(IR)-&gt;CU</code>,CU 分析操作码，得知这是加法执行</li><li><strong>6</strong>:<code>Ad(IR)-&gt;MAR</code>，将指令的地址码送入 MAR，<code>(MAR)=7</code></li><li><strong>7+8</strong>:<code>M(MAR)-&gt;MDR</code>，<code>(MDR)=00000000 00000001=1</code></li><li><strong>9</strong>:<code>(MDR)-&gt;x</code>，<code>(X)= 00000000 00000001=1</code></li><li><strong>10</strong>:<code>(ACC)+(X)-&gt;ACC</code>，<code>(ACC)-&gt;7</code>，由 ALU 实现加法运算</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033988.png" loading="lazy"></p><p>接着进行下一组操作：</p><ul><li><strong>1</strong>:<code>(PC)-&gt;MAR</code>，<code>(MAR)=3</code></li><li><strong>2+3</strong>:<code>M(MAR)-&gt;MDR</code>，<code>MDR=000010 0000001000</code></li><li><strong>4:</strong><code>(MDR)-&gt;IR</code>，<code>(IR)000010 0000001000</code></li><li>**5:<code>**OP(IR)-&gt;CU</code>，CU 分析得知，这是存数指令</li><li><strong>6</strong>:<code>AD(IR)-&gt;MAR</code>，<code>(MAR)=8</code></li><li><strong>7+8</strong>:<code>(ACC)-&gt;MDR</code>，<code>MDR=7</code></li><li><strong>9</strong>:<code>(MDR)-&gt; 地址为 8 的存储单元</code>，导致<code> y=7</code></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033504.png" loading="lazy"></p><p>最后再读取到停机指令时，计算机通过中断机制就结束了程序的运行。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532924.png" alt="image-20230412153204838" loading="lazy"></p><h1 id="4-计算机层次结构"><a href="#4-计算机层次结构" class="headerlink" title="4.计算机层次结构"></a>4.计算机层次结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121547792.png" alt="image-20230412154711717" loading="lazy"></p><h2 id="4-1-计算机系统的多级层次结构"><a href="#4-1-计算机系统的多级层次结构" class="headerlink" title="4.1.计算机系统的多级层次结构"></a>4.1.计算机系统的多级层次结构</h2><p><strong>计算机系统的多级层次结构：现代计算机是一个硬件与软件组成的综合体，自下而上依次为：</strong></p><ul><li><p><strong>第一级是微程序机器层</strong>：这是一个实在的<strong>硬件层</strong>，它由机器硬件直接执行<strong>微指令。</strong></p></li><li><p><strong>第二级是传统机器语言层</strong>：它是一个实际的<strong>机器层</strong>，由<strong>微程序</strong>解释机器指令系统。</p></li><li><p><strong>第三级是操作系统层</strong>：它由<strong>操作系统</strong>实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称为<strong>混合层。</strong></p></li><li><p><strong>第四级是汇编语言层</strong>：他为用户提供一种<strong>符号化的语言</strong>，借此可编写汇编语言源程序。</p></li><li><p><strong>第五级是高级语言层</strong>：它是<strong>面向用户的</strong>，是为方便用户编写应用程序而设置的。</p></li><li><p>在高级语言层之上，还可以<strong>有应用层</strong>，它由解决实际问题的程序组成（比如 word，chrome 等等）。</p></li></ul><p><strong>这样的分层结构，使得本层的使用者无需关心下一层的实现细节。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121536129.png" alt="image-20230412153640058" loading="lazy"></p><ul><li>注意：在很多情况下，计算机的某些功能既可以由硬件实现，也可以由软件来实现，<strong>因此硬件和软件没有严格的界限</strong>。</li></ul><h2 id="4-2-计算机软件的分类"><a href="#4-2-计算机软件的分类" class="headerlink" title="4.2.计算机软件的分类"></a>4.2.计算机软件的分类</h2><p><strong>软件：软件是人们事先编制的具有各类特殊功能的程序，他们通常存放在计算机的主存或外存中，按其功能可以分为以下两类:</strong></p><ul><li><strong>系统软件</strong>：是一组<strong>保证计算机系统高效，正确运行的基础软件</strong>，通常作为系统资源提供给用户使用。<strong>系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序，分布式软件系统、网络软件系统、标准库程序、服务型程序等。</strong></li><li><strong>应用软件</strong>：是指<strong>用户为解决某个应用领域中的各类问题而编制的程序</strong>、如各种<strong>科学计算类程序，工程设计类程序，数据统计与处理程序等</strong>。</li></ul><h2 id="4-3-解释程序和编译程序"><a href="#4-3-解释程序和编译程序" class="headerlink" title="4.3.解释程序和编译程序"></a>4.3.解释程序和编译程序</h2><ul><li><strong>解释程序</strong>：它将源语言书写的源程序作为输入，<strong>解释一句就提交给计算机执行一句</strong>，并<strong>不形成目标程序</strong>；例如 Python、JavaScript 等都是解释型语言。</li><li><strong>编译程序</strong>：把高级语言源程序作为输入，进行翻译转换，<strong>产生出的机器语言作为目标程序</strong>，然后让计算机去执行这个目标程序，得到计算结果；例如 C&#x2F;C++、Java 等都是编译型语言。</li></ul><p>对于编译程序来说，<strong>其产生目标代码的执行速度要比解释程序的执行速度快</strong>。</p><h2 id="4-4-机器语言、汇编语言和高级语言"><a href="#4-4-机器语言、汇编语言和高级语言" class="headerlink" title="4.4.机器语言、汇编语言和高级语言"></a>4.4.机器语言、汇编语言和高级语言</h2><ul><li><strong>机器语言</strong>：又称二进制代码语言，用 <strong>二进制 “0” 和“1”</strong> 描述不同指令，编程人员需要记忆每一条指令的二进制编码。其优点就是<strong>计算机可以直接识别并执行</strong>。</li><li><strong>汇编语言</strong>：其实质和机器语言是相同的，都是直接对硬件操作，只不过指令<strong>采用了英文缩写的标识符，更容易识别和记忆</strong>。汇编语言的程序必须经过一个称为<strong>汇编程序</strong>的系统软件的翻译，将其转化为机器语言，才能在计算机的硬件系统上运行。</li><li><strong>高级语言</strong>：高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常需要经过<strong>编译程序</strong>编译成汇编语言程序，然后经过<strong>汇编操作</strong>得到机器语言程序。其优点在于<strong>方便编程人员写出解决问题的方案和解题过程。</strong></li></ul><p>由于计算机无法直接理解和执行高级语言程序，需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：</p><ul><li><strong>汇编程序（汇编器）</strong>。将汇编语言程序翻译成机器语言程序。</li><li><strong>解释程序（解释器）</strong>。将源程序中的语句按执行额序逐条翻译成机器指令并立即执行。</li><li><strong>编译程序（编译器）</strong>。将高级语言程序翻译成汇编语言或机器语言程序。</li></ul><h2 id="4-5-计算机体系结构和计算机组成原理概念区别"><a href="#4-5-计算机体系结构和计算机组成原理概念区别" class="headerlink" title="4.5.计算机体系结构和计算机组成原理概念区别"></a>4.5.计算机体系结构和计算机组成原理概念区别</h2><ul><li><strong>计算机体系结构</strong>：研究的是机器语言程序所见的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O 机理）。<strong>也就是说是如何设计硬件与软件之间的接口</strong>，举例：无乘法指令。</li><li><strong>计算机组成原理</strong>：研究的是计算机体系结构体现出来的属性，对于程序员来说是 “透明的”。<strong>也就是说是如何使用硬件实现所定义的接口</strong>，举例：如何实现乘法指令。</li></ul><h1 id="5-计算机性能指标"><a href="#5-计算机性能指标" class="headerlink" title="5.计算机性能指标"></a>5.计算机性能指标</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121609226.png" alt="image-20230412160927153" loading="lazy"></p><h2 id="5-1-主存容量指标"><a href="#5-1-主存容量指标" class="headerlink" title="5.1.主存容量指标"></a>5.1.主存容量指标</h2><p><strong>主存容量指标：主要有两个</strong></p><ul><li><strong>MAR 位数</strong>：反映<strong>存储单元</strong>的个数。</li><li><strong>MDR 位数</strong>：它等于<strong>存储字长</strong>，等于<strong>每个存储单元的大小</strong>。</li></ul><p>**所以有：存储体总容量 &#x3D; 存储单元个数 × 存储字长 (bit)&#x3D; 存储单元个数 ×(存储字长 &#x2F; 8)(Byte)**。</p><ul><li>例如 MAR 为 32 位，MDR 为 8 位，则总容量为$2^{32}×8bit&#x3D;4GB$。</li></ul><p>为快速计算，请熟记$2^{n}$对应数值：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121550702.png" alt="image-20230412155043652" loading="lazy"></p><blockquote><p>注意：在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如$1Kb&#x3D;2^{10}b$；在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如$1kb&#x2F;s&#x3D;10^{3}b&#x2F;s$。通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。</p></blockquote><h2 id="5-2-运算速度指标"><a href="#5-2-运算速度指标" class="headerlink" title="5.2.运算速度指标"></a>5.2.运算速度指标</h2><h3 id="5-2-1-CPU-主频（时钟频率）"><a href="#5-2-1-CPU-主频（时钟频率）" class="headerlink" title="5.2.1.CPU 主频（时钟频率）"></a>5.2.1.CPU 主频（时钟频率）</h3><ul><li><strong>单位：Hz</strong></li></ul><p><strong>CPU 主频（时钟频率）</strong>：你在买电脑的时候，一定关注过 CPU 的主频。比如我手头的这台电脑就是 Intel Core-i7-7700HQ 2.8GHz，<strong>这里的 2.8GHz 就是电脑的主频（Frequency&#x2F;Clock Rate）</strong>。这个 2.8GHz，<strong>我们可以先粗浅地认为表示：CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条。</strong></p><p>如果想要更准确一点描述，<strong>这个 2.8GHz 就代表，CPU 的一个 “钟表” 能够识别出来的最小的时间间隔</strong>。就像我们挂在墙上的挂钟，都是 “滴答滴答” 一秒一秒地走，所以通过墙上的挂钟能够识别出来的最小时间单位就是秒。</p><p><strong>而在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡（OscillatorCrystal）的东西，简称为晶振</strong>。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次 “滴答”，就是时钟周期时间。</p><h3 id="5-2-2-CPU-时钟周期"><a href="#5-2-2-CPU-时钟周期" class="headerlink" title="5.2.2.CPU 时钟周期"></a>5.2.2.CPU 时钟周期</h3><ul><li><strong>单位：us 或 ns</strong><br><strong>CPU 时钟周期</strong>：接上面，在我这个 2.8GHz 的 CPU 上，<strong>这个时钟周期时间，就是 1&#x2F;2.8G</strong>。我们的 CPU，是按照这个 “时钟” 提示的时间来进行自己的操作。<strong>主频越高，意味着这个表走得越快，我们的 CPU 也就 “被逼” 着走得越快</strong>。</li></ul><p>如果你自己组装过台式机的话，可能听说过 “<strong>超频</strong>” 这个概念，<strong>本质就是把买回来的 CPU 内部的钟给调快了，于是 CPU 的计算跟着这个时钟的节奏</strong>，也就自然变快了。当然这个快不是没有代价的，CPU 跑得越快，散热的压力也就越大。就和人一样，超过生理极限，CPU 就会崩溃了。</p><p><strong>所以：CPU 主频（时钟频率）&#x3D;1&#x2F;CPU 时钟周期</strong>，主频通常以Hz（赫兹）为单位，1Hz表示每秒1次。</p><h3 id="5-2-3-CPI"><a href="#5-2-3-CPI" class="headerlink" title="5.2.3.CPI"></a>5.2.3.CPI</h3><p><strong>CPI</strong>：对于 CPU 时钟周期数，我们可以再做一个分解，<strong>把它变成 “指令数 × 每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）”</strong>。不同的指令需要的指令数是不同的。</p><ul><li>加法和乘法都对应着一条 CPU 指令，但是乘法需要的指令数就比加法要多，自然也就慢。</li></ul><h3 id="5-2-4-CPU-执行时间"><a href="#5-2-4-CPU-执行时间" class="headerlink" title="5.2.4.CPU 执行时间"></a>5.2.4.CPU 执行时间</h3><p><strong>CPU 执行时间</strong>：CPI 会受到很多因素的影响，因此用它衡量 CPU 速度是不合理的，<strong>所以我们把 CPU 执行时间定义为： CPU 执行时间 &#x3D; 指令数 ×CPI× 时钟周期 &#x3D;(指令数 ×CPI)&#x2F; 主频</strong>。</p><ul><li>例如：某 CPU 主频为 1000Hz，某程序包含 100 条指令，平均来看指令的 CPI&#x3D;3，则该程序执行时间为 $100×3×\frac{1}{1000}&#x3D;0.3s $。</li></ul><p>总结一下：</p><ul><li><strong>时钟周期时间，就是计算机主频，这个取决于计算机硬件</strong>：我们所熟知的摩尔定律就一直在不停地提高我们计算机的主频。比如说，我最早使用的 80386 主频只有 33MHz，现在手头的笔记本电脑就有 2.8GHz，在主频层面，就提升了将近 100 倍。</li><li><strong>每条指令的平均时钟周期数 CPI，就是一条指令到底需要多少 CPU Cycle</strong>：现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。因此，对于 CPI 的优化，也是计算机组成和体系结构中的重要一环。</li><li><strong>指令数，代表执行我们的程序到底需要多少条指令、用哪些指令</strong>：这个很多时候就把挑战交给了编译器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。</li></ul><p>我们可以把自己想象成一个 CPU，坐在那里写程序。<strong>计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。CPI 相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少</strong>。如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的 “性能” 从外面来看就是好的。</p><h3 id="5-2-5-IPS-和-FLOPS"><a href="#5-2-5-IPS-和-FLOPS" class="headerlink" title="5.2.5.IPS 和 FLOPS"></a>5.2.5.IPS 和 FLOPS</h3><ul><li><strong>IPS(Instructions Per Second)<strong>：每秒可以执行</strong>多少条指令</strong>，$ IPS&#x3D;\frac{主频}{平均 CPI}$。</li><li><strong>FLOPS(Floating-point Operation Per Second)<strong>：每秒执行</strong>多少次浮点运算。</strong></li></ul><p><strong>IPS 前面可以加入 K 或 M</strong></p><ul><li>KIPS：每秒可以多少千条指令。</li><li>MIPS：每秒可以执行多少百万条指。</li></ul><p><strong>FLOPS 前面加入 M、G 和 T</strong></p><ul><li>MFLOPS：每秒执行多少百万次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $10^{6} $)。</li><li>GFLOPS：每秒执行多少十亿次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $10^{9} $)。</li><li>TFLOPS：每秒执行多少万亿次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $ 10^{12} $)。</li></ul><p><strong>2021考研大纲新增</strong>：PFLOPS，EFLOPS，ZFLOPS，$P&#x3D;10^3T$，$E&#x3D;10^3P$，$Z&#x3D;10^3E$。</p><p><strong>最后需要注意</strong>：</p><ul><li><strong>在描述容量、文件大小时</strong>，K、M、G、T 通常用 <strong>2 的幂次表示</strong>。如 $1Kb&#x3D; 2^{10} b$。</li><li><strong>在描述速率、频率时</strong>，k、M、G、T 通常用 <strong>10 的幂次表示</strong>，如 $1kb&#x2F;s&#x3D;  10^{3} b&#x2F;s$。</li></ul><h2 id="5-3-系统整体性能指标"><a href="#5-3-系统整体性能指标" class="headerlink" title="5.3.系统整体性能指标"></a>5.3.系统整体性能指标</h2><ul><li><strong>数据通路带宽</strong>：是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度有可能不同。</li><li><strong>吞吐量</strong>：指信息流入、处理和流出系统的速率。它取决于 CPU 能够多快的取指令，数据能够多快地从内存取出或存入，以及所得结果能够多块地从内存送到输出设备。这些决定因素中的任何一步都与主存息息相关，<strong>因此吞吐量主要取决于主存的存取周期</strong>。</li><li><strong>响应时间</strong>：指的是用户向计算机发送一个请求，到系统对该请求作出相应并获得所需结果的等待时间。通常包括 CPU 时间（运行程序花费）与等待时间（例如 I&#x2F;O 操作）。</li></ul><h1 id="6-本章总结"><a href="#6-本章总结" class="headerlink" title="6.本章总结"></a>6.本章总结</h1><p>1：冯诺依曼机以<strong>运算器</strong>为核心，最根本的特征是<strong>存储程序原理</strong>，基本方式是<strong>控制流驱动。</strong></p><p>2：<strong>取指阶段</strong>取出的是指令、<strong>执行阶段</strong>取出的是数据。</p><p>3：以下概念易混淆：</p><ul><li>MAR(Memory Adress Regiater)：存放想要访问的存储单元的地址。</li><li>PC：存放下一条指令的地址。</li><li>IR：存放当前执行的指令。</li><li>MDR(Memory Data Regiater)：存放取来的数据。</li></ul><p>4：软件和硬件在逻辑功能上是<strong>等效的而不是等价的</strong>。</p><p>5：计算机的位数指的就是机器字长。</p><p>6：科学计算机主要关注浮点运算性能。</p><p>7：IR、MAR、MDR 是 CPU 内部寄存器，<strong>不可见。</strong></p><p>8：需要注意 CPU 的 <strong>CPI 与主频是没有关系的</strong>，但是主频却会加快指令执行速度。</p><p>9：评价计算机系统的综合参数是<strong>吞吐率</strong>。</p><p>10：当前设计高性能计算机的重要技术途径是<strong>采用并行处理技术</strong>。</p><hr><p><strong>Q:软件和硬件</strong></p><p><strong>A:<strong>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础; 软件是一种信息，看不见、摸不到。</strong>但在逻辑功能上，软件和硬件是等效的</strong>。因此，在计算机系统中，<strong>许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。</strong></p><ul><li>例如，乘法运算既可用专门的乘法器 (主要由加法器和移位器组成) 实现，也可用乘法子程序 (主要由加法指令和移位指令等组成) 来实现。</li></ul><hr><p><strong>Q:计算机由哪儿部分组成？以哪部分为中心？</strong></p><p><strong>A:<strong>计算机由</strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>及<strong>输出设备</strong>五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量I&#x2F;O设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。<strong>现代计算机</strong>已经发展为<strong>以存储器为中心</strong>，使I&#x2F;O操作尽可能地绕过CPU，直接在I&#x2F;O设备和存储器之间完成，以提高系统的整体运行效率。</p><hr><p><strong>Q:主频高的CPU一定比主频低的CPU快吗？为什么？</strong></p><p>**A:**衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频，即CPU内核工作的时钟频率。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、Cache大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的CPU实际运算速度较低的现象。</p><hr><p><strong>Q:翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？</strong></p><p><strong>A:<strong>翻译程序有两种：一种是</strong>编译程序</strong>，它<strong>将高级语言源程序一次全部翻译成目标程序</strong>，只要源程序不变，就无须重新翻译。另一种是<strong>解释程序</strong>，它<strong>将源程序的一条语向翻译成对应的机器目标代码，并立即执行</strong>，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</p><p><strong>汇编程序</strong>也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。</p><p><strong>编译程序与汇编程序的区别</strong>：若源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</p><hr><p><strong>Q:不同级别的语言编写的程序有什么区别？那种语言编写的程序能被硬件直接执行？</strong></p><p>**A:**机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。<br>其中机器语言可以被硬件直接执行。</p><hr><p><strong>Q:什么是透明性？透明是指什么都能看见吗？</strong></p><p><strong>A:<strong>在计算机领域中，</strong>站在某类用户的角度，若感觉不到某个事物或属性的存在</strong>，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。<br>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。<br><strong>在CPU中，IR、MAR和MDR对各类程序员都是透明的。</strong></p><hr><p><strong>Q:字、字长、机器字长、指令字长、存储字长的区别和联系是什么？</strong></p><p><strong>A:<strong>在通常所说的“某16位或32位机器”中，16、32指的是字长，也称</strong>机器字长</strong>。所谓字长通常是指CPU内部用于整数运算的数据通路的宽度，因此<strong>字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度</strong>，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。<br>            <strong>指令字长</strong>：一个指令字中包含的二进制代码的位数。<br>            <strong>存储字长</strong>：一个存储单元存储的二进制代码的长度。<br>            <strong>机器字长</strong>：计算机能直接处理的二进制数据的位数，<strong>机器字长一般等于内部寄存器的大小</strong>，它决定了计算机运算的精度</p><p>​        它们<strong>都必须是字节的整数倍</strong>。<br>​        早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。</p><p>注意：<strong>指令字长一般取存储字长的整数倍，若指令字长等于存储字长 2 倍，则需要 2 次访存才能取出一条指令，这导致取指周期就会是机器周期的 2 倍</strong>；<strong>若指令字长等于存储字长，则取指周期等于机器周期。</strong></p><hr><p><strong>Q:计算机体系结构和计算机组成的区别和联系是什么？</strong></p><p><strong>计算机体系结构</strong>：是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性</p><p><strong>计算机组成</strong>：是指<strong>如何实现计算机体系结构所体现的属性</strong>, 它包含对许多对程序员来说透明的硬件细节。例如，<strong>指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题</strong>。因此，<strong>当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的</strong>。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</p><hr><p><strong>Q:基准程序执行得越快说明机器的性能越好吗？</strong></p><p>**A:**一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-计算机发展历程&quot;&gt;&lt;a href=&quot;#1-计算机发展历程&quot; class=&quot;headerlink&quot; title=&quot;1.计算机发展历程&quot;&gt;&lt;/a&gt;1.计算机发展历程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.co</summary>
      
    
    
    
    <category term="考研408" scheme="http://ccsu.top/categories/%E8%80%83%E7%A0%94408/"/>
    
    
    <category term="计算机组成原理" scheme="http://ccsu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="考研" scheme="http://ccsu.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>MQTT协议</title>
    <link href="http://ccsu.top/posts/bd50b816/"/>
    <id>http://ccsu.top/posts/bd50b816/</id>
    <published>2022-06-01T03:45:00.000Z</published>
    <updated>2022-06-01T03:51:05.291Z</updated>
    
    <content type="html"><![CDATA[<p>一.什么是MQTT协议</p><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的“轻量级”通讯协议，该协议构建于TCP&#x2F;IP协议上，由IBM在1999年发布。</p><p>MQTT最大优点在于，用极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。</p><p>作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><h1 id="二-MQTT协议特点"><a href="#二-MQTT协议特点" class="headerlink" title="二.MQTT协议特点"></a>二.MQTT协议特点</h1><p>MQTT是一个基于客户端-服务器的消息发布&#x2F;订阅传输协议。</p><p>MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。</p><p>其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p><p>MQTT协议当前版本为，2014年发布的MQTT v3.1.1。除标准版外，还有一个简化版MQTT-SN，该协议主要针对嵌入式设备，这些设备一般工作于TCP&#x2F;IP网络，如：ZigBee。</p><p>MQTT 与 HTTP 一样，MQTT 运行在传输控制协议&#x2F;互联网协议 (TCP&#x2F;IP) 堆栈之上。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601001652.png" alt="img" loading="lazy"></p><p>MQTT协议当前版本为，2014年发布的<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">MQTT v3.1.1</a>。除标准版外，还有一个简化版<code>MQTT-SN</code>，该协议主要针对嵌入式设备，这些设备一般工作于TCP&#x2F;IP网络，如：ZigBee。</p><p>MQTT协议运行在<code>TCP/IP</code>或其他网络协议，提供有序、无损、双向连接。其特点包括：</p><ol><li><p>使用的发布&#x2F;订阅消息模式，它提供了一对多消息分发，以实现与应用程序的解耦。</p></li><li><p>对负载内容屏蔽的消息传输机制。</p></li><li><p>对传输消息有三种服务质量（QoS）：</p></li><li><ul><li><p><code>最多一次</code>，这一级别会发生消息丢失或重复，消息发布依赖于底层TCP&#x2F;IP网络。即：&lt;&#x3D;1</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002046.png" alt="img" loading="lazy"></p></li><li><p><code>至多一次</code>，这一级别会确保消息到达，但消息可能会重复。即：&gt;&#x3D;1</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002054.png" alt="img" loading="lazy"></p></li><li><p><code>只有一次</code>，确保消息只有一次到达。即：＝1。在一些要求比较严格的计费系统中，可以使用此级别。为此，带有唯一消息 ID 的消息会存储两次，首先来自发送者，然后是接收者。QoS 级别 2 在网络中具有最高的开销，因为在发送方和接收方之间需要两个流。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002100.png" alt="img" loading="lazy"></p></li></ul></li><li><p>数据传输和协议交换的最小化（协议头部只有2字节），以减少网络流量</p></li><li><p>通知机制，异常中断时通知传输双方</p></li></ol><h1 id="三-MQTT协议原理"><a href="#三-MQTT协议原理" class="headerlink" title="三.MQTT协议原理"></a>三.MQTT协议原理</h1><p>1.<code>MQTT</code>协议实现方式</p><p><code>MQTT</code>使用的发布&#x2F;订阅消息模式，它提供了一对多的消息分发机制，从而实现与应用程序的解耦。</p><p>这是一种消息传递模式，<strong>消息不是直接从发送器发送到接收器</strong>（即点对点），而是由<code>MQTT server</code>（或称为 MQTT Broker）分发的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002952.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601010213.png" alt="image-20220601010212990" loading="lazy"></p><ul><li>实现<code>MQTT</code>协议需要：<code>客户端</code>和<code>服务器端</code></li><li><code>MQTT</code>协议中有三种身份：<code>发布者（Publish）</code>、<code>代理（Broker）</code>（服务器）、<code>订阅者（Subscribe）</code>。其中，消息的<code>发布者</code>和<code>订阅者</code>都是客户端，消息<code>代理</code>是服务器，消息<code>发布者</code>可以同时是<code>订阅者</code>。</li><li>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分<ul><li><code>Topic</code>，可以理解为消息的类型，<code>订阅者</code>订阅（Subscribe）后，就会收到该主题的消息内容（<code>payload</code>）</li><li><code>payload</code>，可以理解为消息的内容，是指<code>订阅者</code>具体要使用的内容</li></ul></li></ul><h1 id="四-MQTT案例"><a href="#四-MQTT案例" class="headerlink" title="四.MQTT案例"></a>四.MQTT案例</h1><p>光伏发电站是发布者（Publisher）。</p><p>主要主题（Topic）级别是”PV”，这个工厂发布两个子级别”sunshine”和”data”；</p><p>“PV&#x2F;sunshine”是一个布尔值（true&#x2F;false，也可以是 1&#x2F;0），充电站需要它来知道是否应该装载电动汽车（仅在阳光普照时 :)）。</p><p>充电站（EVSE）是订阅者，订阅”PV&#x2F;sunshine”从服务器获取信息。</p><p>“PV&#x2F;data” 另一方面，以 kW 为单位传输工厂产生的瞬时功率，并且该主题可以例如通过计算机或平板电脑订阅，以生成一天内传输功率的图表。</p><p>这就是一个简单的MQTT的应用场景，具体如下图所示；</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601010123.png" alt="img" loading="lazy"></p><h1 id="五-MQTT的优点"><a href="#五-MQTT的优点" class="headerlink" title="五.MQTT的优点"></a>五.MQTT的优点</h1><ol><li>MQTT的独特功能是每个消息头都可以缩短为2个字节。对于HTTP，为每个新请求消息重新建立HTTP连接会产生可观的开销。 MQ和MQTT使用的持久连接可以大大减少这种开销。</li><li>包容不稳定的网络，MQTT和MQ可以从诸如断开连接之类的故障中恢复，无需进一步的代码要求。但是，HTTP本身无法实现此目标，并且客户端必须重试编码，这会增加身份问题。</li><li>低功耗MQTT专为低功耗目标而设计。 HTTP设计未考虑此因素，这会增加功耗。</li><li>在连接数百万个客户端的情况下，在HTTP堆栈中维护数百万个并发连接需要大量工作才能提供支持。尽管这种支持是可行的，但大多数商业产品都经过优化以处理此订单上的持久连接。 IBM提供了IBM MessageSight，这是一种单机架安装服务器，已经过测试，可以通过MQTT处理多达一百万个并发设备。相反，MQ不是为许多同时进行的客户设计的。</li><li>推送通知。您需要能够及时向客户发送通知。为此，您应该使用常规的轮询或推送方法。就电池，系统负载和带宽而言，推送是最佳解决方案。</li><li>客户端平台的差异。 HTTP和MQTT客户端都在许多平台上实现。 MQTT的简单性可帮助您以最少的努力在其他客户端上实施MQTT。</li><li>防火墙容错能力。某些公司防火墙将出站连接限制到某些预定义的端口，这些端口通常仅限于HTTP（端口80），HTTPS（端口443）等，HTTP在这种情况下显然可以工作。 MQTT封装在WebSockets连接中，并显示为HTTP升级请求，因此可以在这种情况下运行。</li></ol><p><strong>补充</strong>：</p><ul><li><strong>mqtt</strong>：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范</li><li><strong>MQ</strong>：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式</li><li><strong>json</strong>：一种内容格式，类似人类交谈中的排比句等方式</li><li><strong>消息</strong>：信息的载体</li><li><strong>消息协议</strong>：为了让消息发送者和消息接收者都能够明白消息所承载的信息（消息发送者需要知道如何构造消息；消息接收者需要知道如何解析消息），它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。所以，有效的消息一定具有某一种格式；而没有格式的消息是没有意义的。</li><li><strong>消息队列</strong>：消息从发送者到接收者的方式也有两种。<ul><li>一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是我们已经介绍过的RPC（当然单纯的http通讯也满足这个定义）；</li><li>另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。</li></ul></li></ul><p><strong>参考链接</strong>：</p><p><a href="https://itbilu.com/other/relate/4kHBsx_Pg.html">https://itbilu.com/other/relate/4kHBsx_Pg.html</a></p><p><a href="https://blog.csdn.net/u010632165/article/details/118503059">https://blog.csdn.net/u010632165/article/details/118503059</a></p><p><a href="https://blog.csdn.net/hyz529900/article/details/123917756">https://blog.csdn.net/hyz529900/article/details/123917756</a></p><p><a href="https://www.cnblogs.com/111testing/p/11487689.html">https://www.cnblogs.com/111testing/p/11487689.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一.什么是MQTT协议&lt;/p&gt;
&lt;p&gt;MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布&amp;#x2F;订阅（publish&amp;#x2F;subscribe）模式的“轻量级”通讯协议，该协议构建于TCP&amp;#x2</summary>
      
    
    
    
    <category term="MQTT" scheme="http://ccsu.top/categories/MQTT/"/>
    
    
    <category term="MQTT" scheme="http://ccsu.top/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>树莓派4B UART多串口配置通信</title>
    <link href="http://ccsu.top/posts/54ae1768/"/>
    <id>http://ccsu.top/posts/54ae1768/</id>
    <published>2022-04-23T12:18:00.000Z</published>
    <updated>2022-05-25T12:28:59.257Z</updated>
    
    <content type="html"><![CDATA[<p>相比树莓派零、1、2 以及 3 的双串口 UART0（PL011）和 UART1（mini UART），树莓派 4 中新增了 4 个 PL011 串口共计有 6 个 UART，整理此笔记用作记录和配置参考。</p><p>注意，目前搜到的大多数描述树莓派 4 串口的文章，大多数开头都是禁用下蓝牙，这个做法针对树莓派0-3 是必须的，因为本身串口不够用，但对树莓派 4 来说并不需要，因为有额外 4 个串口可以利用，默认配置好的两串口一个用于蓝牙（UART0）另一个是 miniUART 可以保留设置。此方面的文章大多都是一个流程，原因是参考的最初版本是树莓派 3 的设置；树莓派 4 的额外串口设置在树莓派论坛中可以看到相关的介绍，外面的文章不太多。</p><h1 id="1-展示所有串口命令"><a href="#1-展示所有串口命令" class="headerlink" title="1. 展示所有串口命令"></a>1. 展示所有串口命令</h1><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dtoverlay -a | grep uart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>展示 pi4 中所有串口</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ dtoverlay -a | grep uart  midi-uart0  midi-uart1  miniuart-bt  uart0  uart1  uart2  uart3  uart4  uart5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-查看特定串口信息"><a href="#2-查看特定串口信息" class="headerlink" title="2. 查看特定串口信息"></a>2. 查看特定串口信息</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dtoverlay -h uart2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看 UART2 的配置信息等：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ dtoverlay -h uart2Name:   uart2Info:   Enable uart 2 on GPIOs 0-3Usage:  dtoverlay&#x3D;uart2,&lt;param&gt;Params: ctsrts                  Enable CTS&#x2F;RTS on GPIOs 2-3 (default off)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关信息会展现 GPIOs 与新的 UART 串口的分配：0-3 对应 UART2， 4-7 对应 UART3，8-11 对应 UART 4，以及 12-15 对应 GUIO 5</p><p>关于 4 个针脚中后两位对应的 CTS&#x2F;RTS，可参考： <a href="https://blog.csdn.net/zeroboundary/article/details/8966586">https://blog.csdn.net/zeroboundary/article/details/8966586</a></p><h1 id="3-配置开启串口-UART2-5"><a href="#3-配置开启串口-UART2-5" class="headerlink" title="3. 配置开启串口 UART2-5"></a>3. 配置开启串口 UART2-5</h1><p>执行编辑 config.txt 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /boot/config.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件结尾添加如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dtoverlay&#x3D;uart2dtoverlay&#x3D;uart3dtoverlay&#x3D;uart4dtoverlay&#x3D;uart5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>保存（Write Out）并退出（Exit）</p><p>重启后查看是否生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> /dev/ttyAMA*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果显示如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ ls &#x2F;dev&#x2F;ttyAMA*&#x2F;dev&#x2F;ttyAMA0  &#x2F;dev&#x2F;ttyAMA1  &#x2F;dev&#x2F;ttyAMA2  &#x2F;dev&#x2F;ttyAMA3  &#x2F;dev&#x2F;ttyAMA4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>各 UART 串口与 GPIO 对应关系：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">GPIO14 &#x3D; TXD0 -&gt; ttyAMA0GPIO0  &#x3D; TXD2 -&gt; ttyAMA1GPIO4  &#x3D; TXD3 -&gt; ttyAMA2GPIO8  &#x3D; TXD4 -&gt; ttyAMA3GPIO12 &#x3D; TXD5 -&gt; ttyAMA4GPIO15 &#x3D; RXD0 -&gt; ttyAMA0GPIO1  &#x3D; RXD2 -&gt; ttyAMA1GPIO5  &#x3D; RXD3 -&gt; ttyAMA2GPIO9  &#x3D; RXD4 -&gt; ttyAMA3GPIO13 &#x3D; RXD5 -&gt; ttyAMA4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><h3 id="串口自发自收测试"><a href="#串口自发自收测试" class="headerlink" title="串口自发自收测试"></a>串口自发自收测试</h3><p>现在我们先测试 UART2 是否启用成功，比较简单的测试方式是将其 TXD 和 RXD 相连，自发自收。</p><p>根据上方对应关系，UART2 对应 TXD2 和 RXD2，对应 GPIO0 和 GPIO1，对应 ttyAMA1</p><p>注：UART0 对应的 ttyAMA0，UART1 对应的 ttyS0，UART2 到 UART5 对应的 ttyAMA1 到 ttyAMA4。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220525202856.png" alt="树莓派 gpio 针脚" loading="lazy"></p><p>找到对应的 GPIO0 和 GPIO1 针脚连起来：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409093839.png" alt="image-20220409093839015" loading="lazy"></p><p>在树莓派端命令行进入 Python3 环境，通过如下模块和命令自发自收：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ python3Python 3.7.3 (default, Jul 25 2020, 13:03:44) [GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import serial&gt;&gt;&gt; ted &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA1&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted.write(&quot;Hello World&quot;.encode(&quot;gbk&quot;))11&gt;&gt;&gt; ted.read(11)b&#39;Hello World&#39;&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，我们可以继续用跳线帽将 GPIO4 和 5 相连测试 UART3；GPIO8 和 9 相连测试 UART4； GPIO12 和 13 相连测试 UART5。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ python3Python 3.7.3 (default, Jul 25 2020, 13:03:44) [GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import serial&gt;&gt;&gt; ted &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA1&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted.write(&quot;Hello World&quot;.encode(&quot;gbk&quot;))11&gt;&gt;&gt; ted.read(11)b&#39;Hello World&#39;&gt;&gt;&gt; ted3 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA2&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted3.write(&quot;Hello No.3&quot;.encode(&quot;gbk&quot;))10&gt;&gt;&gt; ted3.read(10)b&#39;Hello No.3&#39;&gt;&gt;&gt; ted4 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA3&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted4.write(&quot;Hello No.4&quot;.encode(&quot;gbk&quot;))10&gt;&gt;&gt; ted4.read(10)b&#39;Hello No.4&#39;&gt;&gt;&gt; ted5 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA4&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted5.write(&quot;Hello No.5&quot;.encode(&quot;gbk&quot;))10&gt;&gt;&gt; ted5.read(10)b&#39;Hello No.5&#39;&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="串口间通信测试"><a href="#串口间通信测试" class="headerlink" title="串口间通信测试"></a>串口间通信测试</h3><p>接下来测试 UART2 和 UART3 间的通信，将 TXD2 连接 RXD3 即 GPIO0 与 GPIO5 相连；将 TXD3 与 RXD2 连接即 GPIO4 与 GPIO1 相连。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">GPIO0  &#x3D; TXD2 -&gt; ttyAMA1GPIO4  &#x3D; TXD3 -&gt; ttyAMA2GPIO1  &#x3D; RXD2 -&gt; ttyAMA1GPIO5  &#x3D; RXD3 -&gt; ttyAMA2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ python3Python 3.7.3 (default, Jul 25 2020, 13:03:44) [GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import serial&gt;&gt;&gt; ted &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA1&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted3 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA2&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted.write(&quot;Msg from UART2...&quot;.encode(&quot;gbk&quot;))17&gt;&gt;&gt; ted3.read(17)b&#39;Msg from UART2...&#39;&gt;&gt;&gt; ted3.write(&quot;Msg from UART3...&quot;.encode(&quot;gbk&quot;))17&gt;&gt;&gt; ted.read(17)b&#39;Msg from UART3...&#39;&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK 挺顺利，UART2 和 UART3 间通信正常。</p><p>参考：</p><p>官方 UART 配置文档：<br><a href="https://www.raspberrypi.org/documentation/configuration/uart.md">https://www.raspberrypi.org/documentation/configuration/uart.md</a></p><p>论坛关于多串口的命令与指引：<br><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=244827#p1493698">https://www.raspberrypi.org/forums/viewtopic.php?t=244827#p1493698</a></p><p>树莓派 4 UART 多串口配置通信<br><a href="https://blog.csdn.net/weixin_40796925/article/details/107907991?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946453016781683948237%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164946453016781683948237&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107907991.142">https://blog.csdn.net/weixin_40796925/article/details/107907991?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946453016781683948237%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164946453016781683948237&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107907991.142</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相比树莓派零、1、2 以及 3 的双串口 UART0（PL011）和 UART1（mini UART），树莓派 4 中新增了 4 个 PL011 串口共计有 6 个 UART，整理此笔记用作记录和配置参考。&lt;/p&gt;
&lt;p&gt;注意，目前搜到的大多数描述树莓派 4 串口的文章，大</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="树莓派" scheme="http://ccsu.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="串口" scheme="http://ccsu.top/tags/%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Arduino Json串口</title>
    <link href="http://ccsu.top/posts/84233d6d/"/>
    <id>http://ccsu.top/posts/84233d6d/</id>
    <published>2022-04-09T15:18:00.000Z</published>
    <updated>2022-05-09T01:59:12.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arduino-串口接受字符串操作"><a href="#Arduino-串口接受字符串操作" class="headerlink" title="Arduino 串口接受字符串操作"></a>Arduino 串口接受字符串操作</h1><h2 id="自定义函数操作方式"><a href="#自定义函数操作方式" class="headerlink" title="自定义函数操作方式"></a>自定义函数操作方式</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*使用自定函数，将字符转化为字符串，再进行操作*&#x2F; String comdata &#x3D; &quot;&quot;;&#x2F;&#x2F;声明字符串变量 void setup() &#123;  Serial.begin(9600);      &#x2F;&#x2F;设定的波特率&#125; void loop() &#123;   while (Serial.available() &gt; 0)      &#123;        comdata +&#x3D; char(Serial.read());        delay(2);    &#125;       if (comdata.length() &gt; 0)    &#123;       Serial.println(comdata);       comdata &#x3D; &quot;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法使用自定函数实现了字符到字符串的转换再进行操作，使用起来还不错，推荐大家使用。</p><h2 id="采用库函数Serial-readString-；"><a href="#采用库函数Serial-readString-；" class="headerlink" title="采用库函数Serial.readString()；"></a>采用库函数Serial.readString()；</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void setup() &#123;  Serial.begin(9600);      &#x2F;&#x2F;设定的波特率&#125; void loop() &#123;  String rx_buffer;  rx_buffer&#x3D;Serial.readString();  Serial.print(rx_buffer);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法使用简单暴力，但是有个缺点，官方库函数默认的参数使得读取串口操作必须要阻塞1s的时间，实时性较差；</p><p>在这里，提供一种修改方法：</p><p>在Arduino IDE 安装路径下找到<code> stream.h</code> 文件修改参数</p><p>①文件路径：<code>C:\Program Files\arduino-1.8.19\hardware\arduino\avr\cores\arduino</code></p><p>②找到文件 <code>stream.h</code>，修改参数：<code>Stream() &#123;_timeout=200;&#125;</code>，红色数值单位为毫秒，根据需要修改然后保存编译即可生效；</p><p>附<code>stream.h</code>文件内容（突出显示 要修改的地方：Stream() {_timeout&#x3D;200;}）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*  Stream.h - base class for character-based streams.  Copyright (c) 2010 David A. Mellis.  All right reserved.  This library is free software; you can redistribute it and&#x2F;or  modify it under the terms of the GNU Lesser General Public  License as published by the Free Software Foundation; either  version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public  License along with this library; if not, write to the Free Software  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  parsing functions based on TextFinder library by Michael Margolis*&#x2F;#ifndef Stream_h#define Stream_h#include &lt;inttypes.h&gt;#include &quot;Print.h&quot;&#x2F;&#x2F; compatability macros for testing&#x2F;*#define   getInt()            parseInt()#define   getInt(ignore)    parseInt(ignore)#define   getFloat()          parseFloat()#define   getFloat(ignore)  parseFloat(ignore)#define   getString( pre_string, post_string, buffer, length)readBytesBetween( pre_string, terminator, buffer, length)*&#x2F;&#x2F;&#x2F; This enumeration provides the lookahead options for parseInt(), parseFloat()&#x2F;&#x2F; The rules set out here are used until either the first valid character is found&#x2F;&#x2F; or a time out occurs due to lack of input.enum LookaheadMode&#123;    SKIP_ALL,       &#x2F;&#x2F; All invalid characters are ignored.    SKIP_NONE,      &#x2F;&#x2F; Nothing is skipped, and the stream is not touched unless the first waiting character is valid.    SKIP_WHITESPACE &#x2F;&#x2F; Only tabs, spaces, line feeds &amp; carriage returns are skipped.&#125;;#define NO_IGNORE_CHAR  &#39;\x01&#39; &#x2F;&#x2F; a char not found in a valid ASCII numeric fieldclass Stream : public Print&#123;  protected:    unsigned long _timeout;      &#x2F;&#x2F; number of milliseconds to wait for the next char before aborting timed read    unsigned long _startMillis;  &#x2F;&#x2F; used for timeout measurement    int timedRead();    &#x2F;&#x2F; read stream with timeout    int timedPeek();    &#x2F;&#x2F; peek stream with timeout    int peekNextDigit(LookaheadMode lookahead, bool detectDecimal); &#x2F;&#x2F; returns the next numeric digit in the stream or -1 if timeout  public:    virtual int available() &#x3D; 0;    virtual int read() &#x3D; 0;    virtual int peek() &#x3D; 0;    Stream() &#123;_timeout&#x3D;100;&#125;&#x2F;&#x2F; parsing methods  void setTimeout(unsigned long timeout);  &#x2F;&#x2F; sets maximum milliseconds to wait for stream data, default is 1 second  unsigned long getTimeout(void) &#123; return _timeout; &#125;    bool find(char *target);   &#x2F;&#x2F; reads data from the stream until the target string is found  bool find(uint8_t *target) &#123; return find ((char *)target); &#125;  &#x2F;&#x2F; returns true if target string is found, false if timed out (see setTimeout)  bool find(char *target, size_t length);   &#x2F;&#x2F; reads data from the stream until the target string of given length is found  bool find(uint8_t *target, size_t length) &#123; return find ((char *)target, length); &#125;  &#x2F;&#x2F; returns true if target string is found, false if timed out  bool find(char target) &#123; return find (&amp;target, 1); &#125;  bool findUntil(char *target, char *terminator);   &#x2F;&#x2F; as find but search ends if the terminator string is found  bool findUntil(uint8_t *target, char *terminator) &#123; return findUntil((char *)target, terminator); &#125;  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   &#x2F;&#x2F; as above but search ends if the terminate string is found  bool findUntil(uint8_t *target, size_t targetLen, char *terminate, size_t termLen) &#123;return findUntil((char *)target, targetLen, terminate, termLen); &#125;  long parseInt(LookaheadMode lookahead &#x3D; SKIP_ALL, char ignore &#x3D; NO_IGNORE_CHAR);  &#x2F;&#x2F; returns the first valid (long) integer value from the current position.  &#x2F;&#x2F; lookahead determines how parseInt looks ahead in the stream.  &#x2F;&#x2F; See LookaheadMode enumeration at the top of the file.  &#x2F;&#x2F; Lookahead is terminated by the first character that is not a valid part of an integer.  &#x2F;&#x2F; Once parsing commences, &#39;ignore&#39; will be skipped in the stream.  float parseFloat(LookaheadMode lookahead &#x3D; SKIP_ALL, char ignore &#x3D; NO_IGNORE_CHAR);  &#x2F;&#x2F; float version of parseInt  size_t readBytes( char *buffer, size_t length); &#x2F;&#x2F; read chars from stream into buffer  size_t readBytes( uint8_t *buffer, size_t length) &#123; return readBytes((char *)buffer, length); &#125;  &#x2F;&#x2F; terminates if length characters have been read or timeout (see setTimeout)  &#x2F;&#x2F; returns the number of characters placed in the buffer (0 means no valid data found)  size_t readBytesUntil( char terminator, char *buffer, size_t length); &#x2F;&#x2F; as readBytes with terminator character  size_t readBytesUntil( char terminator, uint8_t *buffer, size_t length) &#123; return readBytesUntil(terminator, (char *)buffer, length); &#125;  &#x2F;&#x2F; terminates if length characters have been read, timeout, or if the terminator character  detected  &#x2F;&#x2F; returns the number of characters placed in the buffer (0 means no valid data found)  &#x2F;&#x2F; Arduino String functions to be added here  String readString();  String readStringUntil(char terminator);  protected:  long parseInt(char ignore) &#123; return parseInt(SKIP_ALL, ignore); &#125;  float parseFloat(char ignore) &#123; return parseFloat(SKIP_ALL, ignore); &#125;  &#x2F;&#x2F; These overload exists for compatibility with any class that has derived  &#x2F;&#x2F; Stream and used parseFloat&#x2F;Int with a custom ignore character. To keep  &#x2F;&#x2F; the public API simple, these overload remains protected.  struct MultiTarget &#123;    const char *str;  &#x2F;&#x2F; string you&#39;re searching for    size_t len;       &#x2F;&#x2F; length of string you&#39;re searching for    size_t index;     &#x2F;&#x2F; index used by the search routine.  &#125;;  &#x2F;&#x2F; This allows you to search for an arbitrary number of strings.  &#x2F;&#x2F; Returns index of the target that is found first or -1 if timeout occurs.  int findMulti(struct MultiTarget *targets, int tCount);&#125;;#undef NO_IGNORE_CHAR#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用ArdunioJson发送Json数据包"><a href="#使用ArdunioJson发送Json数据包" class="headerlink" title="使用ArdunioJson发送Json数据包"></a>使用ArdunioJson发送Json数据包</h1><p>注意：这里使用的<strong>ArduinoJson的V6版本</strong>，关于V6和V5版本的切换，可以按照报错网站查询并修改。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;ArduinoJson.h&gt;void setup() &#123;  &#x2F;&#x2F; put your setup code here, to run once:  Serial.begin(115200);  Serial.println(&quot;begin now&quot;);&#125;void loop() &#123;  &#x2F;&#x2F; put your main code here, to run repeatedly:   DynamicJsonDocument data(256);   data[&quot;temp&quot;]&#x3D;25;   data[&quot;hum&quot;]&#x3D;110;   char json_string[256];   serializeJson(data,json_string);   Serial.println(json_string);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220430205543.png" alt="在这里插入图片描述" loading="lazy"></p><h2 id="解析Json数据包（int，char型）"><a href="#解析Json数据包（int，char型）" class="headerlink" title="解析Json数据包（int，char型）"></a>解析Json数据包（int，char型）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 电源属性修改的回调函数void powerCallback(JsonVariant p)&#123;    extern int a;    int PowerSwitch &#x3D; p[&quot;PowerSwitch&quot;];    if (PowerSwitch &#x3D;&#x3D; 2)    &#123;       digitalWrite(LED_BUILTIN,HIGH);  &#x2F;&#x2F; 启动设备       a&#x3D;2;    &#125;     if (PowerSwitch &#x3D;&#x3D; 3)    &#123;       digitalWrite(LED_BUILTIN,LOW); &#x2F;&#x2F; 启动设备       a&#x3D;3;    &#125;&#125;&#x2F;&#x2F;字符回调函数void Receive_Zi_Fu_Callback(JsonVariant p)&#123;      const char* Zi_Fu &#x3D; p[&quot;Receive_Zi_Fu&quot;];&#x2F;      String S(Zi_Fu);&#x2F;&#x2F;const char*转String      S &#x3D; S.substring(2,6);&#x2F;&#x2F;截取字符串的一部分，可以去掉,比如123456,就是3456      extern char *c;      const int len&#x3D;S.length();      c &#x3D; new char[len+1];      strcpy(c,S.c_str());&#x2F;&#x2F;Strinf转char* ，是为了OLED_ShowString      OLED_ShowString(0,0,c,16);      Serial.println(S);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于char和String"><a href="#关于char和String" class="headerlink" title="关于char和String"></a>关于char和String</h2><ul><li>char表示的是字符，定义用单引号；</li><li>String表示字符串，定义用双引号。</li><li>string的内存管理是由系统处理，除非系统内存池用完，不然不会出现这种内存问题。</li><li>char *的内存管理由用户自己处理，很容易出现内存不足的问题。</li></ul><p>当我们要存一个串，但是不知道其他需要多少内存时， 用<code>string</code>来处理就最好不过了。当你知道了存储的内存的时候，可以用<code>char *</code>，但是不如用<code>string</code>的好，用指针总会有隐患。</p><h1 id="使用ArdunioJson解析Json数据包"><a href="#使用ArdunioJson解析Json数据包" class="headerlink" title="使用ArdunioJson解析Json数据包"></a>使用ArdunioJson解析Json数据包</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ArduinoJson.h></span></span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   DynamicJsonDocument  <span class="token function">jsonBuffer</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String json <span class="token operator">=</span>      <span class="token string">"&#123;\"sensor\":\"gps\",\"time\":1351824120,\"data\":[48.756080,2.302038]&#125;"</span><span class="token punctuation">;</span>   <span class="token function">deserializeJson</span><span class="token punctuation">(</span>jsonBuffer<span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span>    JsonObject root <span class="token operator">=</span> jsonBuffer<span class="token punctuation">.</span>as<span class="token operator">&lt;</span>JsonObject<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> sensor <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"sensor"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> time <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"time"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> latitude <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> longitude <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sensor<span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>latitude<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>longitude<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解析Arduino串口Json包"><a href="#解析Arduino串口Json包" class="headerlink" title="解析Arduino串口Json包"></a>解析Arduino串口Json包</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&#123;&quot;state&quot;:1,&quot;LeftMotor&quot;:100,&quot;RightMotor&quot;:100,&quot;UpServo&quot;:10,&quot;DownServo&quot;:10,&quot;Light&quot;:0,&quot;Pump&quot;:0&#125;#include &lt;ArduinoJson.h&gt;String rx_buffer &#x3D; &quot;&quot;;&#x2F;&#x2F;声明字符串变量void setup()&#123;  Serial.begin(9600);      &#x2F;&#x2F;设定的波特率&#125;void loop()&#123;  while (Serial.available() &gt; 0)  &#123;    rx_buffer +&#x3D; char(Serial.read());    delay(2);  &#125;  if (rx_buffer.length() &gt; 0)  &#123;    DynamicJsonDocument  jsonBuffer(400);    deserializeJson(jsonBuffer, rx_buffer);    JsonObject root &#x3D; jsonBuffer.as&lt;JsonObject&gt;();    int state &#x3D; root[&quot;state&quot;];    int LeftMotor &#x3D; root[&quot;LeftMotor&quot;];    int RightMotor &#x3D; root[&quot;RightMotor&quot;];    int UpServo &#x3D; root[&quot;UpServo&quot;];    int DownServo &#x3D; root[&quot;DownServo&quot;];    int Light &#x3D; root[&quot;Light&quot;];    int Pump &#x3D; root[&quot;Pump&quot;];    Serial.println(state);    Serial.println(LeftMotor);    Serial.println(RightMotor);    Serial.println(UpServo);    Serial.println(DownServo);    Serial.println(Light);    Serial.println(Pump);    Serial.print(rx_buffer);    rx_buffer &#x3D; &quot;&quot;;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Arduino修改Serial接收缓冲区大小"><a href="#Arduino修改Serial接收缓冲区大小" class="headerlink" title="Arduino修改Serial接收缓冲区大小"></a>Arduino修改Serial接收缓冲区大小</h1><blockquote><p>  向Arduino发送一个90字节的字符串，不管怎么样都只能收到63个字节的数据，感觉应该是串口缓冲区大小的限制，修改完后，串口收发数据正常。</p></blockquote><p>看到网上有资料说，直接添加以下宏定义就可以了：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define SERIAL_RX_BUFFER_SIZE 2048 &#x2F;&#x2F;修改串口发送缓冲区大小为2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是由于Arduino的编译器是先导入其他头文件，再编译用户区代码的，所以会提示已经被重定义。</p><p>那么我们就只能根据提示，去修改<code>C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino\HardwareSerial.h</code>的代码了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220430225817.png" alt="image-20220430225817140" loading="lazy"></p><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/huanzx/article/details/79596855">https://blog.csdn.net/huanzx/article/details/79596855</a></li><li><a href="https://blog.csdn.net/weixin_43475628/article/details/118925979">https://blog.csdn.net/weixin_43475628/article/details/118925979</a></li><li><a href="https://blog.csdn.net/qq_27508477/article/details/105419505">https://blog.csdn.net/qq_27508477/article/details/105419505</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Arduino-串口接受字符串操作&quot;&gt;&lt;a href=&quot;#Arduino-串口接受字符串操作&quot; class=&quot;headerlink&quot; title=&quot;Arduino 串口接受字符串操作&quot;&gt;&lt;/a&gt;Arduino 串口接受字符串操作&lt;/h1&gt;&lt;h2 id=&quot;自定义函数</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="串口" scheme="http://ccsu.top/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="Arduino" scheme="http://ccsu.top/tags/Arduino/"/>
    
    <category term="Json" scheme="http://ccsu.top/tags/Json/"/>
    
  </entry>
  
  <entry>
    <title>Arduino IO口使用方法</title>
    <link href="http://ccsu.top/posts/514fc85a/"/>
    <id>http://ccsu.top/posts/514fc85a/</id>
    <published>2022-04-09T14:18:00.000Z</published>
    <updated>2022-05-09T01:59:12.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字输入输出"><a href="#数字输入输出" class="headerlink" title="数字输入输出"></a>数字输入输出</h1><p>在使用输入或输出功能前，你需要先通过<code>pinMode()</code> 函数配置引脚的模式为输入模式或输出模式。</p><h2 id="端口初始化函数"><a href="#端口初始化函数" class="headerlink" title="端口初始化函数"></a>端口初始化函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//端口初始化</span><span class="token function">pinMode</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p><strong>pin:</strong> 为指定配置的引脚编号</p></li><li><p>mode:</p><p> 为指定的配置模式 通常可用模式有三种:</p><ul><li><strong>INPUT:</strong> 输入模式 (DDRx&#x3D;0xFF)</li><li><strong>OUTPUT:</strong> 输出模式 (DDRx&#x3D;0x00)</li><li><strong>INPUT_PULLUP:</strong> 输入上拉模式 (DDRx&#x3D;0xFF;PORTx&#x3D;0xFF)</li></ul></li></ul><h2 id="输出电平函数"><a href="#输出电平函数" class="headerlink" title="输出电平函数"></a>输出电平函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//输出电平函数</span><span class="token function">digitalWrite</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 为指定输出的引脚编号；</li><li><strong>value:</strong> 为你要指定输出的电平<ul><li><strong>HIGH:</strong> 指定输出高电平(1)</li><li><strong>LOW:</strong> 指定输出低电平(0)(PORTx)</li></ul></li></ul><h2 id="读取电平函数"><a href="#读取电平函数" class="headerlink" title="读取电平函数"></a>读取电平函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//读取输入电平函数</span><span class="token function">digitalRead</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">digitalRead</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 为指定读取状态的引脚编号。(PINx)</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>获取到的信号状态，1为高电平，0为低电平。</li></ul><h1 id="模拟输入输出"><a href="#模拟输入输出" class="headerlink" title="模拟输入输出"></a>模拟输入输出</h1><p>模拟输入引脚是带有ADC（Analog-to-Digital Converter，模数转换器）功能的引脚。<br>它可以将外部输入的模拟信号转换为芯片运算时可以识别的数字信号，从而实现读入模拟值的功能。</p><h2 id="模拟信号输入函数"><a href="#模拟信号输入函数" class="headerlink" title="模拟信号输入函数"></a>模拟信号输入函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//模拟信号输入函数</span><span class="token function">analogRead</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">analogRead</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 是指定要读取模拟值的引脚，被指定的引脚必须是模拟输入引脚。<br>如<code>analogRead(A0)</code>，即是读取<code>A0</code>引脚上的模拟值。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p><code>Arduino Uno</code>模拟输入功能有10位精度，即可以将0～5V的电压信号转换为0～1023的整数形式表示。</p><h2 id="模拟信号输出（PWM）函数"><a href="#模拟信号输出（PWM）函数" class="headerlink" title="模拟信号输出（PWM）函数"></a>模拟信号输出（PWM）函数</h2><p>在<code>Arduino Uno</code>中，提供PWM功能的引脚为3、5、6、9、10、11。<br>在<code>analogWrite()</code> 和<code>analogRead() </code>函数内部，已经完成了引脚的初始化，因此不用在Setup() 函数中进行初始化操作。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//模拟信号输出函数</span><span class="token function">analogWrite</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">analogWrite</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 是指定要输出PWM波的引脚；</li><li><strong>value:</strong> 指定是PWM的脉冲宽度，范围为0～255。</li></ul><h2 id="模拟电压输出函数"><a href="#模拟电压输出函数" class="headerlink" title="模拟电压输出函数"></a>模拟电压输出函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//模拟电压输出函数</span><span class="token function">analogReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">analogReference</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>为模拟电压输入设置参考值；</li></ul><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><ul><li>analogReference(type)</li></ul><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><p>type有以下几个选项：</p><ul><li>DEFAULT: 默认参考值5v (在5V的 板子上 ) 或者 3.3 v (在3.3V 的Arduino板子上)；</li><li>INTERNAL: 内置参考值, 在 ATmega168 或者ATmega328板子上为1.1v；在ATmega8 板子上为2.56v (在Arduino Mega板子上不可获得)。</li><li>INTERNAL1V1: 内置的1.1V 参考值 (只在Arduino Mega板子上有效 )</li><li>INTERNAL2V56: 内置的2.56V 参考值 (只在Arduino Mega板子上有效)</li><li>EXTERNAL: 在AREF引脚加的电压(0 ~ 5V)将作为参考值 。 AREF外接电源后不能使用其他的基准源,使用时会引起片内基准源与外部参考源短路</li></ul><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><ul><li>-none</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>改变参考值的时候，刚开始的读数可能不准确。<br>不要用低于0v或高于5v的电压加在AREF引脚。如果使用加在AREF的外部电压作为参考那一定要在调用<code>analogRead()</code>之前设置<code>analogReference</code>为<code>EXTERNAL</code>，否则可能毁坏芯片。<br>也可以使用一个5千欧的电阻连接外部参考电压到AREF引脚，这样可以方便地在内外参考电压间转换，不过请注意电阻将改变原先你想要的参考值，因为在AREF引脚内部有个32千欧的内置电阻。这样两个电阻就可以分压了，例如：加的是2.5v，那么在AREF引脚的电压就是：2.5 * 32 &#x2F; (32 + 5) &#x3D; ~2.2V 。</p><h1 id="高级输入输出"><a href="#高级输入输出" class="headerlink" title="高级输入输出"></a>高级输入输出</h1><h2 id="输出50-方波函数"><a href="#输出50-方波函数" class="headerlink" title="输出50%方波函数"></a>输出50%方波函数</h2><p><code>tone() </code>主要用于<code>Arduino</code>连接蜂鸣器或扬声器发声。可以让指定引脚产生一个占空比为<code>50%</code>的指定频率的方波。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//输出50%方波函数</span><span class="token function">tone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">tone</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> _pin<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> frequency<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> duration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">tone</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> frequency<span class="token punctuation">)</span> <span class="token function">tone</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> frequency<span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 需要输出方波的引脚</li><li><strong>frequency:</strong> 输出的频率，unsigned int型</li><li><strong>duration:</strong> 方波持续的时间，单位毫秒。如果没有该参数，Arduino将持续发出设定的音调，直到你改变发声频率或者使用<code>noTone()</code> 函数停止发声。</li></ul><h2 id="停止输出50-方波函数"><a href="#停止输出50-方波函数" class="headerlink" title="停止输出50%方波函数"></a>停止输出50%方波函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//停止输出50%方波函数</span><span class="token function">noTone</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">noTone</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> _pin<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><ul><li><strong>noTone(pin)</strong></li></ul><h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 需要停止方波输出的引脚</li></ul><h2 id="检测脉冲宽度函数"><a href="#检测脉冲宽度函数" class="headerlink" title="检测脉冲宽度函数"></a>检测脉冲宽度函数</h2><p>例如当要检测高电平脉冲时，<code>pulseIn()</code> 会等待指定引脚输入的电平变高，当变高后开始记时，直到输入电平变低，停止计时。<br><code>pulseln() </code>函数会返回这个脉冲信号持续的时间，即这个脉冲的宽度。<br>函数还可以设定超时时间。如果超过设定时间，仍未检测到脉冲，则会退出<code>pulseIn()</code>函数并返回0。<br>当没有设定超时时间时，<code>pulseIn() </code>会默认1秒钟的超时时间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//检测脉冲宽度函数</span><span class="token function">pulseIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">pulseIn</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> pin<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> state<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> timeout <span class="token operator">=</span> <span class="token number">1000000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><ul><li>pulseIn(pin, value)</li><li>pulseIn(pin, value, timeout)</li></ul><h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><ul><li>pin：需要读取脉冲的引脚</li><li>value：需要读取的脉冲类型，HIGH或LOW</li><li>timeout：超时时间，单位微秒，数据类型为无符号长整型。</li></ul><h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回脉冲宽度，单位微秒，数据类型为无符号长整型。如果在指定时间内没有检测到脉冲，则返回0。</li></ul><h2 id="外部中断函数"><a href="#外部中断函数" class="headerlink" title="外部中断函数"></a>外部中断函数</h2><p>对中断引脚进行初始化配置，以开启Arduino的外部中断功能</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//中断配置函数</span><span class="token function">attachInterrupt</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> ISR<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><ul><li>pin：中断引脚,部分为中断源标号</li></ul><table><thead><tr><th align="center">型号 编号</th><th align="center">int.0</th><th align="center">int.1</th><th align="center">int.2</th><th align="center">int.3</th><th align="center">int.4</th><th align="center">int.5</th></tr></thead><tbody><tr><td align="center">UNO\Ethernet</td><td align="center">2</td><td align="center">3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Mega2560</td><td align="center">2</td><td align="center">3</td><td align="center">21</td><td align="center">20</td><td align="center">19</td><td align="center">18</td></tr><tr><td align="center">Leonardo</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">1</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Due</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td></tr></tbody></table><ul><li><strong>ISR:</strong> 中断函数名</li><li><strong>mode:</strong> 中断模式<ul><li><strong>LOW:</strong> 低电平触发</li><li><strong>CHANGE:</strong> 变化时触发</li><li><strong>RISING:</strong> 低电平变为高电平时触发</li><li><strong>FALLING:</strong> 高电平变低电平时触发</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">attachInterrupt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> Hello<span class="token punctuation">,</span> LOW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该语句会开启Arduino Uno的 2号引脚（中断编号0）的外部中断功能，并指定下降沿时触发该中断。<br>当2号引脚上电平由高变低后，该中断会被触发，Arduino即会运行Hello() 函数中的语句。</p><h2 id="关闭中断函数"><a href="#关闭中断函数" class="headerlink" title="关闭中断函数"></a>关闭中断函数</h2><p>中断分离函数,关闭中断功能。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">detachInterrupt</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 需要禁用中断的引脚。<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3></li></ul> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">detachInterrupt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="外部中断寄存器模式"><a href="#外部中断寄存器模式" class="headerlink" title="外部中断寄存器模式"></a>外部中断寄存器模式</h1><p>外部中断控制寄存器- <strong>EICRA</strong></p><table><thead><tr><th></th><th></th><th></th><th></th><th>ISC11</th><th>ISC10</th><th>ISC01</th><th>ISC00</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>INT0:(ISC11&amp;ISC10) </p><p>INT1:(ISC01&amp;ISC00)</p><ul><li>00:低电平触发</li><li>01:逻辑变化触发</li><li>10:下降沿触发</li><li>11:上升沿触发</li></ul><p>外部中断屏蔽寄存器- <strong>EIMSK</strong></p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th>INT1</th><th>INT0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>0:中断关闭</li><li>1:中断使能外部中断标志位寄存器- <strong>EIFR</strong></li></ul><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th>INTF1</th><th>INTF0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>当中断触发标志位置高,执行ISR或向标志位写’1’时标志位重置</p><h3 id="中断函数总结"><a href="#中断函数总结" class="headerlink" title="中断函数总结"></a>中断函数总结</h3><p>单片机的中断可以描述为：由于某一随机事件的发生，单片机暂停在原程序的运行，转而执行另一个程序（随机事件），处理完毕之后又自动回到断点处继续执行。</p><p>其中， 中断源、主程序、中断服务程序简述如下：</p><ul><li>中断源：引起中断的原因，或能够发生中断请求的来源。</li><li>主程序：单片机现在运行的程序。</li><li>中断服务程序：处理中断请求的程序。</li><li><code>interrupts()</code>和<code>noInterrupts()</code>在Arduino中，<code>interrupts</code>函数和<code>noInterrupts</code>函数分别负责打开与关闭中断，这两个函数均为无返回值的函数，无参数。</li><li><code>attachInterrrupt(interrupt，function，mode)</code>该函数用于设置外部中断，有三个参数，分别表示中断源、中断处理函数和触发模式，它们的具体含义如下：<ul><li>中断源：可选0、1，对应2或3号数字引脚。</li><li>中断处理函数：指定中断的处理函数，是一段程序，当中断发生时执行该子程序部分，其中参数为函数的指针。</li><li>触发模式：有四种类型-LOW（低电平触发）、CHANGE（跳变时触发）、RISING(上升沿触发）、FALLING（下降沿触发）。</li><li><code>detachInterrupt(interrupt)</code>用于取消中断。</li></ul></li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_LOW</span><span class="token expression"><span class="token number">0</span>b00</span><span class="token comment">//低电平触发</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_CHANGE</span><span class="token expression"><span class="token number">0</span>b01</span><span class="token comment">//逻辑变化触发</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_FALL</span><span class="token expression"><span class="token number">0</span>b10</span><span class="token comment">//下降沿触发</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_RISE</span><span class="token expression"><span class="token number">0</span>b11</span><span class="token comment">//上升沿触发</span></span><span class="token keyword">void</span> <span class="token function">SetInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//外部中断</span><span class="token punctuation">&#123;</span><span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Set EXINT0(pin->PD2), EXINT1(pin->PD3) to Mode INPUT_PULLUP </span>DDRD <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PORTD <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Set EXINT Mode to catch FALLING EDGE 下降沿触发中断</span>EICRA <span class="token operator">|=</span> <span class="token punctuation">(</span>EXINT_FALL <span class="token operator">&lt;&lt;</span> ISC00<span class="token punctuation">)</span><span class="token punctuation">;</span>EICRA <span class="token operator">|=</span> <span class="token punctuation">(</span>EXINT_FALL <span class="token operator">&lt;&lt;</span> ISC10<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Enable EXINT</span>EIMSK <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INT1<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INT0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启用外部中断</span><span class="token function">sei</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// EXINT0(p2)</span><span class="token function">ISR</span><span class="token punctuation">(</span>INT0_vect<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// EXINT1(p3)</span><span class="token function">ISR</span><span class="token punctuation">(</span>INT1_vect<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h1><h2 id="串口设置"><a href="#串口设置" class="headerlink" title="串口设置"></a>串口设置</h2><h3 id="Serial-begin"><a href="#Serial-begin" class="headerlink" title="Serial.begin();"></a>Serial.begin();</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>开启串口，通常置于setup()函数中。</li></ul><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><ul><li><p>Serial.begin(speed);  </p></li><li><p>Serial.begin(speed,config);</p></li></ul><h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4><ul><li><p>speed: 波特率，一般取值300, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600,115200</p></li><li><p>config: 设置数据位、校验位和停止位。例如Serial.begin(speed,Serial_8N1);  Serial_8N1中：8表示8个数据位，N表示没有校验，1表示有1个停止位。</p></li></ul><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// opensserial port, sets data rate to 9600 bps </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Serial-end"><a href="#Serial-end" class="headerlink" title="Serial.end();"></a>Serial.end();</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li>禁止串口传输函数。此时串口传输的pin脚可以作为数字IO脚使用。</li></ul><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.end()</li></ul><h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-1"><a href="#返回-1" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h2 id="清空串口缓存"><a href="#清空串口缓存" class="headerlink" title="清空串口缓存"></a>清空串口缓存</h2><h3 id="Serial-flush"><a href="#Serial-flush" class="headerlink" title="Serial.flush();"></a>Serial.flush();</h3><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul><li>1.0版本之前为清空串口缓存，现在该函数作用为等待输出数据传送完毕。如果要清空串口缓存的话，可以使用：while(Serial.read() &gt;&#x3D; 0)来代替。</li></ul><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.flush ()</li></ul><h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-2"><a href="#返回-2" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h3 id="while-Serial-read-gt-x3D-0"><a href="#while-Serial-read-gt-x3D-0" class="headerlink" title="while(Serial.read()&gt;&#x3D; 0){}"></a>while(Serial.read()&gt;&#x3D; 0){}</h3><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ul><li>因Serial.read()函数读取串口缓存中的一个字符，并删除已读字符。因此可以用这句代码来清空串口缓存。实验代码详见下文代码。</li></ul><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><ul><li>while(Serial.read() &gt;&#x3D;0){}</li></ul><h4 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-3"><a href="#返回-3" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h2 id="输出串口数据"><a href="#输出串口数据" class="headerlink" title="输出串口数据"></a>输出串口数据</h2><h3 id="Serial-print"><a href="#Serial-print" class="headerlink" title="Serial.print();"></a>Serial.print();</h3><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ul><li>串口输出数据函数，写入字符串数据到串口。</li></ul><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><ul><li><p>Serial.print(val)</p></li><li><p>Serial.print(val,format)</p></li></ul><h4 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h4><ul><li><p>val: 打印的值，任意数据类型</p></li><li><p>format: 输出的数据格式，包括整数类型和浮点型数据的小数点位数。</p></li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> BIN<span class="token punctuation">)</span> 得到 <span class="token string">"1001110"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> OCT<span class="token punctuation">)</span> 得到 <span class="token string">"116"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> DEC<span class="token punctuation">)</span> 得到 <span class="token string">"78"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> HEX<span class="token punctuation">)</span> 得到 <span class="token string">"4E"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1.23456</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> 得到 <span class="token string">"1"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1.23456</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> 得到 <span class="token string">"1.23"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1.23456</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> 得到 <span class="token string">"1.2346"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token char">'N'</span><span class="token punctuation">)</span> 得到 <span class="token string">"N"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello world."</span><span class="token punctuation">)</span> 得到 <span class="token string">"Hello world."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Serial-println"><a href="#Serial-println" class="headerlink" title="Serial.println();"></a>Serial.println();</h3><h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p>写入字符串数据，并换行。实验代码详见下文。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.println(val) </li><li>Serial.println(val,format)</li></ul><h4 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h4><ul><li><p>val: 打印的值，任意数据类型 </p></li><li><p>format: 输出的数据格式，包括整数类型和浮点型数据的小数点位数。</p></li></ul><h4 id="返回-4"><a href="#返回-4" class="headerlink" title="返回"></a>返回</h4><ul><li>字节</li></ul><h3 id="Serial-SerialEvent"><a href="#Serial-SerialEvent" class="headerlink" title="Serial.SerialEvent();"></a>Serial.SerialEvent();</h3><h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><ul><li>串口数据准备好时触发的事件函数，即串口数据准备好调用该函数。</li></ul><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.serialEvent{&#x2F;&#x2F;statements}</li></ul><h4 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h4><ul><li>statements: 任何有效的语句。</li></ul><h2 id="读串口缓存区数据"><a href="#读串口缓存区数据" class="headerlink" title="读串口缓存区数据"></a>读串口缓存区数据</h2><h3 id="Serial-available"><a href="#Serial-available" class="headerlink" title="Serial.available();"></a>Serial.available();</h3><h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><ul><li>判断串口缓冲器的状态函数，用以判断数据是否送达串口。注意使用时通常用delay(100)以保证串口字符接收完毕，即保证Serial.available()返回的是缓冲区准确的可读字节数。</li></ul><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.available();</li></ul><h4 id="参数-18"><a href="#参数-18" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-5"><a href="#返回-5" class="headerlink" title="返回"></a>返回</h4><ul><li>返回缓冲区可读字节数目</li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待数据传完</span>    <span class="token keyword">int</span> numdata <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.available = :"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>numdata<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//清空串口缓存</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225354.jpeg" alt="img" loading="lazy"></p><h3 id="Serial-read"><a href="#Serial-read" class="headerlink" title="Serial.read();"></a>Serial.read();</h3><h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><ul><li>读取串口数据，一次读一个字符，读完后删除已读数据。</li></ul><h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.read();</li></ul><h4 id="参数-19"><a href="#参数-19" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-6"><a href="#返回-6" class="headerlink" title="返回"></a>返回</h4><ul><li>返回串口缓存中第一个可读字节，当没有可读数据时返回-1，整数类型。</li></ul><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> comchar<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">/</span> <span class="token operator">/</span>clear serialbuffer<span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    comchar <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读串口第一个字节</span>    Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.read: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comchar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225507.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial.read()每次从串口缓存中读取第一个字符，并将读过的字符删除。</p><h3 id="Serial-peek"><a href="#Serial-peek" class="headerlink" title="Serial.peek();"></a>Serial.peek();</h3><h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h4><ul><li>读串口缓存中下一字节的数据（字符型），但不从内部缓存中删除该数据。也就是说，连续的调用peek()将返回同一个字符。而调用read()则会返回下一个字符。</li></ul><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.peek();</li></ul><h4 id="参数-20"><a href="#参数-20" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-7"><a href="#返回-7" class="headerlink" title="返回"></a>返回</h4><ul><li>返回串口缓存中下一字节（字符）的数据，如果没有返回-1，整数int型</li></ul><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> comchar<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    comchar <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.peek: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comchar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225600.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial.peek()每次从串口缓存中读取一个字符，并不会将读过的字符删除。第二次读取时仍然为同一个字符。</p><h3 id="Serial-readBytes-buffer-length"><a href="#Serial-readBytes-buffer-length" class="headerlink" title="Serial.readBytes(buffer,length);"></a>Serial.readBytes(buffer,length);</h3><h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口读取指定长度length的字符到缓存数组buffer。</li></ul><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readBytes(buffer,length);</li></ul><h4 id="参数-21"><a href="#参数-21" class="headerlink" title="参数"></a>参数</h4><ul><li><p>buffer: 缓存变量</p></li><li><p>length:设定的读取长度</p></li></ul><h4 id="返回-8"><a href="#返回-8" class="headerlink" title="返回"></a>返回</h4><ul><li>返回存入缓存的字符数，0表示没有有效数据。</li></ul><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> numdata<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serial port</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      numdata <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">readBytes</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readBytes:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">18</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225657.jpeg" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225703.jpeg" alt="img" loading="lazy"></p><p>从串口缓存读取指定长度为3的字节。</p><h3 id="Serial-readBytesUntil-character-buffer-length"><a href="#Serial-readBytesUntil-character-buffer-length" class="headerlink" title="Serial.readBytesUntil(character,buffer,length);"></a>Serial.readBytesUntil(character,buffer,length);</h3><h4 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存读取指定长度的字符到数组buffer，遇到终止字符character后停止。</li></ul><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readBytesUntil(character ,buffer,length);</li></ul><h4 id="参数-22"><a href="#参数-22" class="headerlink" title="参数"></a>参数</h4><ul><li><p>character : 查找的字符 (char)</p></li><li><p>buffer: 存储读取数据的缓存(char[] 或byte[])</p></li><li><p>length:设定的读取长度</p></li></ul><h4 id="返回-9"><a href="#返回-9" class="headerlink" title="返回"></a>返回</h4><ul><li>返回存入缓存的字符数，0表示没有有效数据。</li></ul><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> character <span class="token operator">=</span> <span class="token char">','</span><span class="token punctuation">;</span> <span class="token comment">//终止字符</span><span class="token keyword">int</span> numdata<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialport</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      numdata <span class="token operator">=</span>Serial<span class="token punctuation">.</span><span class="token function">readBytesUntil</span><span class="token punctuation">(</span>character<span class="token punctuation">,</span>buffer<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readBytes:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">18</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230024.jpeg" loading="lazy"></p><p>从串口缓存中读取3个字符，当遇到”,”时终止读取。</p><h3 id="Serial-readString-；"><a href="#Serial-readString-；" class="headerlink" title="Serial.readString()；"></a>Serial.readString()；</h3><h4 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取全部数据到一个字符串型变量。</li></ul><h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readString();</li></ul><h4 id="参数-23"><a href="#参数-23" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-10"><a href="#返回-10" class="headerlink" title="返回"></a>返回</h4><ul><li>返回从串口缓存区中读取的一个字符串。</li></ul><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">String comdata <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comdata <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">readString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readString:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    comdata <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230024.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial.readString()从串口缓存中读取字符至字符串。</p><h3 id="Serial-readStringUntil"><a href="#Serial-readStringUntil" class="headerlink" title="Serial.readStringUntil();"></a>Serial.readStringUntil();</h3><h4 id="说明-13"><a href="#说明-13" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取字符到一个字符串型变量，直至读完或遇到某终止字符。</li></ul><h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readStringUntil(terminator)</li></ul><h4 id="参数-24"><a href="#参数-24" class="headerlink" title="参数"></a>参数</h4><ul><li>terminator:终止字符(cha型)</li></ul><h4 id="返回-11"><a href="#返回-11" class="headerlink" title="返回"></a>返回</h4><ul><li>从串口缓存区中读取的整个字符串，直至检测到终止字符。</li></ul><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">String comdata <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">char</span> terminator <span class="token operator">=</span> <span class="token char">','</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comdata <span class="token operator">=</span>Serial<span class="token punctuation">.</span><span class="token function">readStringUntil</span><span class="token punctuation">(</span>terminator<span class="token punctuation">)</span><span class="token punctuation">;</span>     Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readStringUntil: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-3"><a href="#实验结果-3" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225902.jpeg" alt="img" loading="lazy"></p><p>从串口读取所有字符存放于字符串comdata，直至遇到字符”,”时终止读取。</p><h3 id="Serial-parseFloat"><a href="#Serial-parseFloat" class="headerlink" title="Serial.parseFloat();"></a>Serial.parseFloat();</h3><h4 id="说明-14"><a href="#说明-14" class="headerlink" title="说明"></a>说明</h4><ul><li>读串口缓存区第一个有效的浮点型数据，数字将被跳过。当读到第一个非浮点数时函数结束。</li></ul><h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.parseFloat()</li></ul><h4 id="参数-25"><a href="#参数-25" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-12"><a href="#返回-12" class="headerlink" title="返回"></a>返回</h4><ul><li>返回串口缓存区第一个有效的浮点型数据，数字将被跳过。</li></ul><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> comfloat<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comfloat <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.parseFloat:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comfloat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-4"><a href="#实验结果-4" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230045.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial. parseFloat()从串口缓存中读取第一个有效的浮点数，第一个有效数字之前的负号也将被读取，独立的负号将被舍弃。</p><h3 id="Serial-parseInt"><a href="#Serial-parseInt" class="headerlink" title="Serial.parseInt()"></a>Serial.parseInt()</h3><h4 id="说明-15"><a href="#说明-15" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口接收数据流中读取第一个有效整数（包括负数）。</li></ul><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>非数字的首字符或者负号将被跳过</p></li><li><p>当可配置的超时值没有读到有效字符时，或者读不到有效整数时，分析停止</p></li><li><p>如果超时且读不到有效整数时，返回0</p></li></ul><h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><p>Serial.parseInt()</p><p>Serial.parseInt(charskipChar)</p><h4 id="参数-26"><a href="#参数-26" class="headerlink" title="参数"></a>参数</h4><ul><li>skipChar用于在搜索中跳过指定字符（此用法未知）</li></ul><h4 id="返回-13"><a href="#返回-13" class="headerlink" title="返回"></a>返回</h4><ul><li>返回下一个有效整型值。</li></ul><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> comInt<span class="token punctuation">;</span> <span class="token function">voidsetup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comInt <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.parseInt:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-5"><a href="#实验结果-5" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230007.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial. parseInt()从串口缓存中读取第一个有效整数，第一个有效数字之前的负号也将被读取，独立的负号将被舍弃。</p><h2 id="串口查找指定字符串"><a href="#串口查找指定字符串" class="headerlink" title="串口查找指定字符串"></a>串口查找指定字符串</h2><h3 id="Serial-find"><a href="#Serial-find" class="headerlink" title="Serial.find()"></a>Serial.find()</h3><h4 id="说明-16"><a href="#说明-16" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取数据，寻找目标字符串target(char型)</li></ul><h4 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h4><ul><li><p>char target[] &#x3D; ”目标字符串”;</p></li><li><p>Serial.find(target);</p></li></ul><h4 id="参数-27"><a href="#参数-27" class="headerlink" title="参数"></a>参数</h4><ul><li>target: 目标字符串（char型）</li></ul><h4 id="返回-14"><a href="#返回-14" class="headerlink" title="返回"></a>返回</h4><ul><li>找到目标字符串返回真，否则为假</li></ul><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> target<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"test"</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span> Serial<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"find traget:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-6"><a href="#实验结果-6" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://img-blog.csdn.net/20151216230204010" alt="img" loading="lazy"></p><p>串口输入字符中只要有test,函数返回真，打印出目标字符串”test”，否则返回假，不打印任何值。</p><h3 id="Serial-findUntil-target-terminal"><a href="#Serial-findUntil-target-terminal" class="headerlink" title="Serial.findUntil(target,terminal);"></a>Serial.findUntil(target,terminal);</h3><h4 id="说明-17"><a href="#说明-17" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取数据，寻找目标字符串target(char型数组)，直到出现给定字符串terminal(char型)，找到为真，否则为假。</li></ul><h4 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.findUntil(target,terminal);</li></ul><h4 id="参数-28"><a href="#参数-28" class="headerlink" title="参数"></a>参数</h4><ul><li><p>target : 目标字符串（char型）</p></li><li><p>terminal : 结束搜索字符串（char型）</p></li></ul><h4 id="返回-15"><a href="#返回-15" class="headerlink" title="返回"></a>返回</h4><ul><li>如果在找到终止字符terminal之前找到目标字符target，返回真，否则返回假。</li></ul><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> target<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"test"</span><span class="token punctuation">;</span><span class="token keyword">char</span> terminal<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"end"</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span> Serial<span class="token punctuation">.</span><span class="token function">findUntil</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>terminal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"find traget:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-7"><a href="#实验结果-7" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://img-blog.csdn.net/20151216230345691" alt="img" loading="lazy"></p><p>如果串口缓存中有目标字符”test”，返回真，但如果先遇到终止字符串”end”则函数立即终止，不论字符串后面有没有目标字符”test”。</p><h2 id="向串口写数据"><a href="#向串口写数据" class="headerlink" title="向串口写数据"></a>向串口写数据</h2><h3 id="Serial-write"><a href="#Serial-write" class="headerlink" title="Serial.write();"></a>Serial.write();</h3><h4 id="说明-18"><a href="#说明-18" class="headerlink" title="说明"></a>说明</h4><ul><li>串口输出数据函数。写二进制数据到串口。</li></ul><h4 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h4><ul><li><p>Serial.write(val) </p></li><li><p>Serial.write(str) </p></li><li><p>Serial.write(buf, len)</p></li></ul><h4 id="参数-29"><a href="#参数-29" class="headerlink" title="参数"></a>参数</h4><ul><li><p>val: 字节 </p></li><li><p>str: 一串字节 </p></li><li><p>buf: 字节数组 </p></li><li><p>len: buf的长度</p></li></ul><h4 id="返回-16"><a href="#返回-16" class="headerlink" title="返回"></a>返回</h4><ul><li>字节长度</li></ul><h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   Serial<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// send a byte with thevalue 45 </span>  <span class="token keyword">int</span> bytesSent <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>“hello”<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//sendthe string “hello” and return the length of the string. </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_42863355/article/details/102759709">https://blog.csdn.net/qq_42863355/article/details/102759709</a></p><p><a href="https://blog.csdn.net/iracer/article/details/50334041">https://blog.csdn.net/iracer/article/details/50334041</a></p><p><a href="https://blog.csdn.net/GuanFuXinCSDN/article/details/104144362">https://blog.csdn.net/GuanFuXinCSDN/article/details/104144362</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字输入输出&quot;&gt;&lt;a href=&quot;#数字输入输出&quot; class=&quot;headerlink&quot; title=&quot;数字输入输出&quot;&gt;&lt;/a&gt;数字输入输出&lt;/h1&gt;&lt;p&gt;在使用输入或输出功能前，你需要先通过&lt;code&gt;pinMode()&lt;/code&gt; 函数配置引脚的模式为输入模</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="GPIO" scheme="http://ccsu.top/tags/GPIO/"/>
    
    <category term="Arduino" scheme="http://ccsu.top/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>Arduino uno介绍</title>
    <link href="http://ccsu.top/posts/c3972d29/"/>
    <id>http://ccsu.top/posts/c3972d29/</id>
    <published>2022-04-09T13:18:00.000Z</published>
    <updated>2022-05-09T01:59:12.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arduino介绍"><a href="#Arduino介绍" class="headerlink" title="Arduino介绍"></a>Arduino介绍</h1><p>官网链接 <a href="https://www.arduino.cc/">Arduino</a></p><p>Arduino是源自意大利的一个开放源代码的硬件项目平台，该平台包括一块具备简单I&#x2F;O功能的电路板以及一套程序开发环境软件。Arduino可以用来开发交互产品，比如它可以读取大量的开关和传感器信号，并且可以控制电灯、电机和其他各式各样的物理设备；Arduino也可以开发出与PC相连的周边装置，能在运行时与PC上的软件进行通信。Arduino的硬件电路板可以自行焊接组装，也可以购买已经组装好的模块，而程序开发环境的软件则可以从网上免费下载并使用。</p><h1 id="Arduino-Uno引脚分配图"><a href="#Arduino-Uno引脚分配图" class="headerlink" title="Arduino Uno引脚分配图"></a><strong>Arduino Uno引脚分配图</strong></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409212401.png" alt="img" loading="lazy"></p><table><thead><tr><th>引脚</th><th>作用</th></tr></thead><tbody><tr><td>0和1接口</td><td>串口输出输入（入门很少用到，如无必要尽量不用这两个接口）</td></tr><tr><td>2到13接口</td><td>可作为数字输入输出 (输出or输入，可自己定义) 其中带 ~ 符号的可作为模拟输出</td></tr><tr><td>A0到A5</td><td>模拟输入</td></tr><tr><td>GND</td><td>接地线</td></tr><tr><td>5V</td><td>输出5V电压</td></tr><tr><td>3.3V</td><td>输出3.3V电压</td></tr><tr><td>Vin</td><td>外部电源给arduino供电 ，电压要在7~12V之间</td></tr><tr><td>SCL与SDA</td><td>I2c接口，初学者很少用</td></tr></tbody></table><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>数字输入输出：只有0和1两种状态，表示开或关（高电平或低电平）</li><li>模拟输入输出：就是将电信号转化为一系列数值，有一系列的量，如可设置灯泡百分之几的亮度，而不是只有开关。</li><li>模拟输入：0-5V的电压转换为0-1023的整数来表示</li><li>模拟输出：PWM （脉宽调制）输出 （0~255）</li><li>高电平低电平：Arduino一般用的是5V的电压，超过3V就算是高电平，低于1.5V就是低电平啦，一般来说高电平就是5V上下，低电平就是指的0V。</li><li>PWM ：（脉宽调制）输出，带PWM功能的引脚标有波浪线 ‘~’。</li><li>拉高：给Arduino的引脚设定了模式之后，有时并未指定引脚的状态，引脚会悬空，状态忽高忽低，拉高就是说让引脚保持高电平的状态</li><li>拉低：相反</li></ul><h1 id="Arduino-Uno-R3-详细参数"><a href="#Arduino-Uno-R3-详细参数" class="headerlink" title="Arduino Uno R3 - 详细参数"></a><em><strong>Arduino Uno R3 - 详细参数</strong></em></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213026.png" alt="img" loading="lazy"></p><h1 id="Arduino-Uno-R3-存储"><a href="#Arduino-Uno-R3-存储" class="headerlink" title="Arduino Uno R3 - 存储"></a><em><strong>Arduino Uno R3 - 存储</strong></em></h1><p>Arduino的存储空间即是其主控芯片所集成的存储空间。也可以通过使用外设芯片的方式来扩展Arduino的存储空间。</p><p>　　Arduino UNO的存储空间分三种：</p><ul><li>Flash，容量为32 KB。其中0. 5 KB作为BOOT区用于储存引导程序，实现通过串口下载程序的功能；另外的31.5 KB作为用户储存程序的空间。相对于现在动辄几百GB的硬盘，可能觉得32 KB太小了，但是在单片机上，32 KB已经可以存储很大的程序了。</li><li>SRAM，容量为2 KB。SRAM相当于计算机的内存，当CPU进行运算时，需要在其中开辟一定的存储空间。当Arduino 断电或复位后，其中的数据都会丢失。</li><li>EEPROM，容量为1 KB。EEPROM的全称为电可擦写的可编程只读存储器，是一种用户可更改的只读存储器，其特点是在Arduino断电或复位后，其中的数据不会丢失。</li></ul><h1 id="Arduino-Uno引脚分配-电源"><a href="#Arduino-Uno引脚分配-电源" class="headerlink" title="Arduino Uno引脚分配 - 电源"></a><strong>Arduino Uno引脚分配 - 电源</strong></h1><p>　　<strong>Arduino UNO可以通过3种方式供电：</strong></p><h2 id="1、直流电源插孔"><a href="#1、直流电源插孔" class="headerlink" title="1、直流电源插孔"></a>1、直流电源插孔</h2><p>　　可以使用直流电源插孔为Arduino开发板供电。电源插孔通常连接到一个适配器。</p><p>　　开发板的供电范围可以是6-20V，但制造商建议将其保持在7-12V之间。高于12V时，稳压芯片可能会过热，低于7V可能会供电不足。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213108.png" alt="img" loading="lazy"></p><h2 id="2、VIN引脚"><a href="#2、VIN引脚" class="headerlink" title="2、VIN引脚"></a>2、VIN引脚</h2><p>​        该引脚用于使用外部电源为Arduino Uno开发板供电。电压应控制在上述提到的范围内。</p><p><img src="https://img2020.cnblogs.com/blog/2103481/202009/2103481-20200907110948426-1333579329.png" alt="img" loading="lazy"></p><h2 id="3、USB接口"><a href="#3、USB接口" class="headerlink" title="3、USB接口"></a>3、USB接口</h2><p>​            连接到计算机时，提供500mA&#x2F;5V电压。</p><p><strong>所使用的供电方式决定了可用于电路的功率：</strong></p><ul><li>使用USB为电路供电时，电流最大限制在500mA。（考虑到该电源也用于为MCU、外围设备、板载稳压器和与其连接的组件供电。）</li><li>当通过电源插座或VIN为电路供电时，可用的最大电流取决于Arduino开发板上的5V和3.3V稳压器。</li></ul><p>　　<strong>电源引脚说明：</strong></p><p>　　<strong><img src="https://img2020.cnblogs.com/blog/2103481/202009/2103481-20200907111909648-418280813.png" alt="img" loading="lazy"></strong></p><ul><li>VIN — 可以通过此引脚向UNO供电；VIN有电时将忽略从USB或者其他引脚接入的电源</li><li>5V — 提供稳压的3.3V，为外部电子元件供电</li><li>3.3V — 提供稳压的3.3V，为外部电子元件供电</li><li>GND — GND引脚与设备外壳相接（接地），用于闭合电路回路，并在整个电路中提供一个公共逻辑参考电平。</li></ul><p><strong>Arduino Uno引脚分配 - 数字引脚</strong></p><p>Arduino Uno的引脚0-13用作数字输入&#x2F;输出引脚。其中，引脚13连接到板载的LED指示灯；引脚3、5、6、9、10、11具有PWM功能。</p><p>需要注意的是：</p><p>●  每个引脚可提供&#x2F;接收最高40 mA的电流。但推荐的电流是20毫安。</p><p>●  所有引脚提供的绝对最大电流为200mA。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213245.png" alt="img" loading="lazy"></p><h2 id="数字电平意味着什么？"><a href="#数字电平意味着什么？" class="headerlink" title="数字电平意味着什么？"></a><strong>数字电平意味着什么？</strong></h2><p>数字是一种表示1位电压的方式：0或1。Arduino上的数字引脚是根据用户需求设计为输入或输出的引脚。数字引脚可以打开或关闭。开启时，它们处于5V的高电平状态，当关闭时，它们处于0V的低电平状态。</p><p>在Arduino上，当数字引脚配置为输出时，它们设置为0或5V。</p><p>当数字引脚配置为输入时，电压由外部设备提供。该电压可以在0-5V之间变化，并转换成数字表示（0或1）。为了确定这一点，有2个阈值：</p><p>●  低于0.8v - 视为0。</p><p>●  高于2.0v - 视为1。</p><p>将组件连接到数字引脚时，确保逻辑电平匹配。如果电压在阈值之间，则返回值将不确定。</p><h1 id="Arduino-Uno引脚分配-模拟输入"><a href="#Arduino-Uno引脚分配-模拟输入" class="headerlink" title="Arduino Uno引脚分配 - 模拟输入"></a><em><strong>Arduino Uno引脚分配 - 模拟输入</strong></em></h1><p><img src="https://img2020.cnblogs.com/blog/2103481/202009/2103481-20200907112952054-1679928809.png" alt="img" loading="lazy"></p><p>Arduino uno r3 有6个模拟输入引脚（Analog In），可以用于接收模拟输入、用来测定0~5v的电压，但也可用作数字输入或数字输出。</p><p>　　我们看到上图中每一个模拟输入引脚前面都标注了一个ADC，这是什么含义呢？这里就涉及到了模拟输入的原理。</p><h2 id="ADC是什么？"><a href="#ADC是什么？" class="headerlink" title="ADC是什么？"></a><strong>ADC是什么？</strong></h2><p>ADC表示模拟到数字转换器。 ADC是用于将模拟信号转换为数字信号的电路。将输入的模拟信号通过ADC转换为数字信号，处理器才能对其进行处理。</p><p>　　这里讲的模拟输入是指0 ~ 5v的电压值。在Arduino上，ADC具有10位分辨率，这意味着它可以通过1,024个数字电平表示模拟电压。相当于将连续的电压值0 ~ 5v映射到离散的数值0<del>1023。将0 ~ 5 V的电压分成1024份（2^10^），算出来即为4.882mV的测量精度。即：0 ~ 4.882mV之间的电压值映射到数字0，4.883mV</del>9.764mV之间的电压值映射到数字1……</p><h1 id="Arduino-Uno引脚分配-关于模拟输出"><a href="#Arduino-Uno引脚分配-关于模拟输出" class="headerlink" title="Arduino Uno引脚分配 - 关于模拟输出"></a><em><strong>Arduino Uno引脚分配 - 关于模拟输出</strong></em></h1><p>Arduino控制板没有模拟输出引脚，但是数字引脚3、5、6、9、10、11具有PWM功能。</p><h2 id="PWM是什么？"><a href="#PWM是什么？" class="headerlink" title="PWM是什么？"></a><strong>PWM是什么？</strong></h2><p>　　脉冲宽带调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。</p><p>　　PWM是一种对模拟信号电平进行数字编码的方法。</p><p>　　PWM有两个关键组成部分：频率和占空比。频率决定了单个周期所用的时间。占空比 &#x3D; 一个周期中高电平所占的时间&#x2F;整个周期的时间。</p><p>　　<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213801.png" alt="img" loading="lazy"></p><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a><em><strong>LED</strong></em></h2><ul><li>ON：电源指示灯，灯亮时表示Arduino已经通电</li><li>TX：串口发送指示灯。当使用USB连接到计算机且Arduino向计算机传输数据时，TX灯会点亮。</li><li>RX：串口接收指示灯。当使用USB连接到计算机且Arduino接收到计算机传来的数据时，RX灯会点亮。</li><li>L：可编程控制指示灯。该LED通过特殊电路连接到Arduino的13 号引脚，当13号引脚为高电平或高阻态时，该LED 会点亮；当为低电平时，不会点亮。因此可以通过程序或者外部输入信号来控制该LED的亮灭。可以用来测试板子是否正常：如果运行Blink程序时，L灯一闪一闪说明板子是好的。</li></ul><h1 id="RESET"><a href="#RESET" class="headerlink" title="RESET"></a><em><strong>RESET</strong></em></h1><p>　　按下该按键可以使Arduino重新启动，从头开始运行程序。</p><p>　　复位引脚接低电平会使Arduino复位。当复位键被按下时，会使该端口接到低电平，从而使Arduino复位。</p><h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a><strong>通信协议</strong></h1><p>串行（TTL） - 数字引脚0和1是Arduino Uno的串行引脚。</p><p>它们由板载USB模块使用。</p><h2 id="什么是串行通信？"><a href="#什么是串行通信？" class="headerlink" title="什么是串行通信？"></a><strong>什么是串行通信？</strong></h2><p>串行通信用于在Arduino板和其他串行设备（如计算机，显示器，传感器等）之间交换数据。每块Arduino板至少有一个串口。串行通信发生在数字引脚0（RX）和1（TX）以及USB上。 Arduino也支持通过数字引脚与<code>SoftwareSerial Library</code>进行串行通信。这允许用户连接多个支持串行的设备，并保留主串行端口可用于USB。</p><p>软件串行和硬件串行 - 大多数微控制器都具有用于与其他串行设备进行通信的硬件。软件串行端口使用引脚更改中断系统进行通信。有一个用于软件串行通信的内置库。处理器使用软件串行来模拟额外的串行端口。软件串行唯一的缺点是它需要更多的处理，并且不能支持与硬件串行相同的高速。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a><strong>SPI</strong></h2><p> SS &#x2F; SCK &#x2F; MISO &#x2F; MOSI引脚是SPI通信的专用引脚。它们可以在Arduino Uno的数字引脚10-13和ICSP插头上找到。</p><p>串行外设接口（Serial Peripheral Interface，SPI）是一种串行数据协议，由微控制器用来与总线中的一个或多个外部设备进行通信，如连接。 SPI也可以用来连接2个微控制器。在SPI总线上，总是有一个设备表示为主设备，其余所有设备都表示为从设备。在大多数情况下，微控制器是主设备。 SS（从选择）引脚确定主器件当前正在与哪个器件通信。</p><p>启用SPI的器件始终具有以下引脚：</p><p>●  MISO（主从输出） - 用于向主设备发送数据的线路</p><p>●  MOSI（主机输出从机输入） - 发送数据到外围设备的主机线</p><p>●  SCK（串行时钟） - 由主设备生成的用于同步数据传输的时钟信号。</p><h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a><strong>I2C</strong></h2><p>SCL &#x2F; SDA引脚是I2C通信的专用引脚。在Arduino Uno上，它们可以在模拟引脚A4和A5上找到。</p><p>I2C通信协议通常称为“I2C总线”。 I2C协议旨在实现单个电路板上组件之间的通信。使用I2C时，有2条通信线，称为SCL和SDA。</p><p>●  SCL是用于同步数据传输的时钟线。</p><p>●  SDA是用于传输数据的通讯线。</p><p>I2C总线上的每个器件都有一个唯一的地址，最多可以在同一条总线上连接255个器件。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.yiboard.com/thread-831-1-1.html">https://www.yiboard.com/thread-831-1-1.html</a></p><p><a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/113663176">https://blog.csdn.net/chenhuanqiangnihao/article/details/113663176</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Arduino介绍&quot;&gt;&lt;a href=&quot;#Arduino介绍&quot; class=&quot;headerlink&quot; title=&quot;Arduino介绍&quot;&gt;&lt;/a&gt;Arduino介绍&lt;/h1&gt;&lt;p&gt;官网链接 &lt;a href=&quot;https://www.arduino.cc/&quot;&gt;Ard</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Arduino" scheme="http://ccsu.top/tags/Arduino/"/>
    
  </entry>
  
  <entry>
    <title>乐迪AT9SPro连接双电机双电调车船调参</title>
    <link href="http://ccsu.top/posts/eeeaf652/"/>
    <id>http://ccsu.top/posts/eeeaf652/</id>
    <published>2022-04-08T12:18:00.000Z</published>
    <updated>2022-05-09T01:59:12.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="连接双电机双电调车船调参教程"><a href="#连接双电机双电调车船调参教程" class="headerlink" title="连接双电机双电调车船调参教程"></a>连接双电机双电调车船调参教程</h1><p>左边电机和右边电机分别接<code>二通道</code>和<code>四通道</code>，在可编程混控里面设置混控，对应摇杆如下图所示</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408020931.png" alt="image-20220408020931476" loading="lazy"></p><p>设置两个普通模式的混控</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021230.png" alt="image-20220408021229825" loading="lazy"></p><p>四通控制右边电机，用来控制方向，主控设置为<code>四通</code>，被控设置为<code>二通</code>，正反比例都是-100%</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021450.png" alt="image-20220408021450340" loading="lazy"></p><p>二通控制右边电机，用来控制前进后退，主控设置为<code>二通</code>，被控设置为<code>四通</code>，正反比例都是+100%</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021531.png" alt="image-20220408021531628" loading="lazy"></p><p>同时设置<code>SWE</code>为控制混控的打开和关闭</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408020509.png" alt="按键定义" loading="lazy"></p><p>这时候就可以自由控制船的前进后退与转向了</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021956.png" alt="image-20220408021955698" loading="lazy"></p><blockquote><p>  Tip：在接线的时候确保摇杆向左或者向上拨动螺旋桨的推力是向后的，这样就不用再在遥控器上面改变电机方向了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;连接双电机双电调车船调参教程&quot;&gt;&lt;a href=&quot;#连接双电机双电调车船调参教程&quot; class=&quot;headerlink&quot; title=&quot;连接双电机双电调车船调参教程&quot;&gt;&lt;/a&gt;连接双电机双电调车船调参教程&lt;/h1&gt;&lt;p&gt;左边电机和右边电机分别接&lt;code&gt;二通道&lt;</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="AT9SPro" scheme="http://ccsu.top/tags/AT9SPro/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://ccsu.top/posts/2f57a694/"/>
    <id>http://ccsu.top/posts/2f57a694/</id>
    <published>2022-03-22T03:17:00.000Z</published>
    <updated>2022-03-22T03:18:22.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式概述"><a href="#正则表达式概述" class="headerlink" title="正则表达式概述"></a>正则表达式概述</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h4 id="场景1：在一个文件中，查找出itcast开头的语句"><a href="#场景1：在一个文件中，查找出itcast开头的语句" class="headerlink" title="场景1：在一个文件中，查找出itcast开头的语句"></a>场景1：在一个文件中，查找出itcast开头的语句</h4><p>测试文件</p><pre class="line-numbers language-none"><code class="language-none">itcast hello pythonitcast c++itheima iositheima php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="场景：在一个文件中，找到含有itcast的语句"><a href="#场景：在一个文件中，找到含有itcast的语句" class="headerlink" title="场景：在一个文件中，找到含有itcast的语句"></a>场景：在一个文件中，找到含有itcast的语句</h4><p>测试文件</p><pre class="line-numbers language-none"><code class="language-none">hello itcast pythonwww.itcast.cn c++itheima iositheima php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="场景：在一个文件中，找到邮箱为163或者126的所有邮件地址"><a href="#场景：在一个文件中，找到邮箱为163或者126的所有邮件地址" class="headerlink" title="场景：在一个文件中，找到邮箱为163或者126的所有邮件地址"></a>场景：在一个文件中，找到邮箱为163或者126的所有邮件地址</h4><h1 id="re模块操作"><a href="#re模块操作" class="headerlink" title="re模块操作"></a>re模块操作</h1><p>在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个模块，名字为re</p><h2 id="1-re模块的使用过程"><a href="#1-re模块的使用过程" class="headerlink" title="1. re模块的使用过程"></a>1. re模块的使用过程</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token comment"># 导入re模块</span><span class="token keyword">import</span> re<span class="token comment"># 使用match方法进行匹配操作</span>result <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span>正则表达式<span class="token punctuation">,</span>要匹配的字符串<span class="token punctuation">)</span><span class="token comment"># 如果上一步匹配到数据的话，可以使用group方法来提取数据</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-re模块示例-匹配以itcast开头的语句"><a href="#2-re模块示例-匹配以itcast开头的语句" class="headerlink" title="2. re模块示例(匹配以itcast开头的语句)"></a>2. re模块示例(匹配以itcast开头的语句)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reresult <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">,</span><span class="token string">"itcast.cn"</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre class="line-numbers language-none"><code class="language-none">itcast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-说明"><a href="#3-说明" class="headerlink" title="3. 说明"></a>3. 说明</h2><ul><li>re.match() 能够匹配出以xxx开头的字符串</li></ul><h1 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h1><p>在上一小节中，了解到通过re模块能够完成使用正则表达式来匹配字符串</p><p>本小节，将要讲解正则表达式的单字符匹配</p><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">.</td><td align="left">匹配任意1个字符（除了\n）</td></tr><tr><td align="center">[ ]</td><td align="left">匹配[ ]中列举的字符</td></tr><tr><td align="center">\d</td><td align="left">匹配数字，即0-9</td></tr><tr><td align="center">\D</td><td align="left">匹配非数字，即不是数字</td></tr><tr><td align="center">\s</td><td align="left">匹配空白，即 空格，tab键</td></tr><tr><td align="center">\S</td><td align="left">匹配非空白</td></tr><tr><td align="center">\w</td><td align="left">匹配单词字符，即a-z、A-Z、0-9、_</td></tr><tr><td align="center">\W</td><td align="left">匹配非单词字符</td></tr></tbody></table><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1： ."></a>示例1： .</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"t.o"</span><span class="token punctuation">,</span><span class="token string">"too"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"t.o"</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Mtootwo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2：[ ]"></a>示例2：[ ]</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token comment"># 如果hello的首字符小写，那么正则表达式需要小写的h</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">,</span><span class="token string">"hello Python"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 如果hello的首字符大写，那么正则表达式需要大写的H</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"H"</span><span class="token punctuation">,</span><span class="token string">"Hello Python"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 大小写h都可以的情况</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[hH]"</span><span class="token punctuation">,</span><span class="token string">"hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[hH]"</span><span class="token punctuation">,</span><span class="token string">"Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[hH]ello Python"</span><span class="token punctuation">,</span><span class="token string">"Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 匹配0到9第一种写法</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0123456789]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"7Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 匹配0到9第二种写法</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0-9]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"7Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 匹配0到3 5到9</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0-35-9]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"7Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 下面这个正则不能够匹配到数字4，因此ret为None</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0-35-9]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"4Hello Python"</span><span class="token punctuation">)</span><span class="token comment"># print(ret.group())</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">hHhHHello Python7Hello Python7Hello Python7Hello Python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例3：-d"><a href="#示例3：-d" class="headerlink" title="示例3：\d"></a>示例3：\d</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token comment"># 普通的匹配方式</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥1号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥1号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥2号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥2号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥3号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥3号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 使用\d进行匹配</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥\d号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥1号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥\d号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥2号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥\d号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥3号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">嫦娥<span class="token number">1</span>号嫦娥<span class="token number">2</span>号嫦娥<span class="token number">3</span>号嫦娥<span class="token number">1</span>号嫦娥<span class="token number">2</span>号嫦娥<span class="token number">3</span>号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>其他的匹配符参见后面章节的讲解</li></ul><h1 id="匹配多个字符"><a href="#匹配多个字符" class="headerlink" title="匹配多个字符"></a>匹配多个字符</h1><p>匹配多个字符的相关格式</p><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">匹配前一个字符出现0次或者无限次，即可有可无</td></tr><tr><td align="center">+</td><td align="left">匹配前一个字符出现1次或者无限次，即至少有1次</td></tr><tr><td align="center">?</td><td align="left">匹配前一个字符出现1次或者0次，即要么有1次，要么没有</td></tr><tr><td align="center">{m}</td><td align="left">匹配前一个字符出现m次</td></tr><tr><td align="center">{m,n}</td><td align="left">匹配前一个字符出现从m到n次</td></tr></tbody></table><h2 id="示例1：-1"><a href="#示例1：-1" class="headerlink" title="示例1：*"></a>示例1：*</h2><p>需求：匹配出，一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可有可无</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[A-Z][a-z]*"</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[A-Z][a-z]*"</span><span class="token punctuation">,</span><span class="token string">"MnnM"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[A-Z][a-z]*"</span><span class="token punctuation">,</span><span class="token string">"Aabcdef"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">MMnnAabcdef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="示例2：-1"><a href="#示例2：-1" class="headerlink" title="示例2：+"></a>示例2：+</h2><p>需求：匹配出，变量名是否有效</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> renames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"name1"</span><span class="token punctuation">,</span> <span class="token string">"_name"</span><span class="token punctuation">,</span> <span class="token string">"2_name"</span><span class="token punctuation">,</span> <span class="token string">"__name__"</span><span class="token punctuation">]</span><span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z_]+[\w]*"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"变量名 %s 符合要求"</span> <span class="token operator">%</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"变量名 %s 非法"</span> <span class="token operator">%</span> name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">变量名 name1 符合要求变量名 _name 符合要求变量名 2_name 非法变量名 __name__ 符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3：?"></a>示例3：?</h2><p>需求：匹配出，0到99之间的数字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?[0-9]"</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"33"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"09"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">7</span><span class="token number">33</span><span class="token number">0</span> <span class="token comment"># 这个结果并不是想要的，利用$才能解决</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="示例4：-m"><a href="#示例4：-m" class="headerlink" title="示例4：{m}"></a>示例4：{m}</h2><p>需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z0-9_]&#123;6&#125;"</span><span class="token punctuation">,</span><span class="token string">"12a3g45678"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z0-9_]&#123;8,20&#125;"</span><span class="token punctuation">,</span><span class="token string">"1ad12f23s34455ff66"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">12a3g41ad12f23s34455ff66<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="练一练"><a href="#练一练" class="headerlink" title="练一练"></a>练一练</h2><h3 id="题目1：匹配出163的邮箱地址，且-符号之前有4到20位，例如-104-101-108-108-x6f-x40-x31-54-51-46-x63-x6f-x6d"><a href="#题目1：匹配出163的邮箱地址，且-符号之前有4到20位，例如-104-101-108-108-x6f-x40-x31-54-51-46-x63-x6f-x6d" class="headerlink" title="题目1：匹配出163的邮箱地址，且@符号之前有4到20位，例如&#104;&#101;&#108;&#108;&#x6f;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;"></a>题目1：匹配出163的邮箱地址，且@符号之前有4到20位，例如<a href="mailto:&#104;&#101;&#108;&#108;&#x6f;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;">&#104;&#101;&#108;&#108;&#x6f;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a></h3><h1 id="匹配开头结尾"><a href="#匹配开头结尾" class="headerlink" title="匹配开头结尾"></a>匹配开头结尾</h1><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">^</td><td align="left">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="left">匹配字符串结尾</td></tr></tbody></table><h2 id="示例1：-2"><a href="#示例1：-2" class="headerlink" title="示例1：$"></a>示例1：$</h2><p>需求：匹配163.com的邮箱地址</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reemail_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"xiaoWang@163.com"</span><span class="token punctuation">,</span> <span class="token string">"xiaoWang@163.comheihei"</span><span class="token punctuation">,</span> <span class="token string">".com.xiaowang@qq.com"</span><span class="token punctuation">]</span><span class="token keyword">for</span> email <span class="token keyword">in</span> email_list<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[\w]&#123;4,20&#125;@163\.com"</span><span class="token punctuation">,</span> email<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是符合规定的邮件地址,匹配后的结果是:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>email<span class="token punctuation">,</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不符合要求"</span> <span class="token operator">%</span> email<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>com 是符合规定的邮件地址<span class="token punctuation">,</span>匹配后的结果是<span class="token punctuation">:</span>xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comxiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comheihei 是符合规定的邮件地址<span class="token punctuation">,</span>匹配后的结果是<span class="token punctuation">:</span>xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>com<span class="token punctuation">.</span>com<span class="token punctuation">.</span>xiaowang@qq<span class="token punctuation">.</span>com 不符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="完善后"><a href="#完善后" class="headerlink" title="完善后"></a>完善后</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">email_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"xiaoWang@163.com"</span><span class="token punctuation">,</span> <span class="token string">"xiaoWang@163.comheihei"</span><span class="token punctuation">,</span> <span class="token string">".com.xiaowang@qq.com"</span><span class="token punctuation">]</span><span class="token keyword">for</span> email <span class="token keyword">in</span> email_list<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[\w]&#123;4,20&#125;@163\.com$"</span><span class="token punctuation">,</span> email<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是符合规定的邮件地址,匹配后的结果是:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>email<span class="token punctuation">,</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不符合要求"</span> <span class="token operator">%</span> email<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>com 是符合规定的邮件地址<span class="token punctuation">,</span>匹配后的结果是<span class="token punctuation">:</span>xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comxiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comheihei 不符合要求<span class="token punctuation">.</span>com<span class="token punctuation">.</span>xiaowang@qq<span class="token punctuation">.</span>com 不符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h1><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="left">匹配左右任意一个表达式</td></tr><tr><td align="center">(ab)</td><td align="left">将括号中字符作为一个分组</td></tr><tr><td align="center"><code>\num</code></td><td align="left">引用分组num匹配到的字符串</td></tr><tr><td align="center"><code>(?P&lt;name&gt;)</code></td><td align="left">分组起别名</td></tr><tr><td align="center">(?P&#x3D;name)</td><td align="left">引用别名为name分组匹配到的字符串</td></tr></tbody></table><h2 id="示例1：-3"><a href="#示例1：-3" class="headerlink" title="示例1：|"></a>示例1：|</h2><p>需求：匹配出0-100之间的数字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 8</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"78"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 78</span><span class="token comment"># 不正确的情况</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"08"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 0</span><span class="token comment"># 修正之后的</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$"</span><span class="token punctuation">,</span><span class="token string">"08"</span><span class="token punctuation">)</span><span class="token keyword">if</span> ret<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不在0-100之间"</span><span class="token punctuation">)</span><span class="token comment"># 添加|</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 8</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"78"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 78</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"08"</span><span class="token punctuation">)</span><span class="token comment"># print(ret.group())  # 不是0-100之间</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"100"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例2：-2"><a href="#示例2：-2" class="headerlink" title="示例2：( )"></a>示例2：( )</h2><p>需求：匹配出163、126、qq邮箱</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@163\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@163.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># test@163.com</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@(163|126|qq)\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@126.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># test@126.com</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@(163|126|qq)\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@qq.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># test@qq.com</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@(163|126|qq)\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@gmail.com"</span><span class="token punctuation">)</span><span class="token keyword">if</span> ret<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不是163、126、qq邮箱"</span><span class="token punctuation">)</span>  <span class="token comment"># 不是163、126、qq邮箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不是以4、7结尾的手机号码-11位"><a href="#不是以4、7结尾的手机号码-11位" class="headerlink" title="不是以4、7结尾的手机号码(11位)"></a>不是以4、7结尾的手机号码(11位)</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> retels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"13100001234"</span><span class="token punctuation">,</span> <span class="token string">"18912344321"</span><span class="token punctuation">,</span> <span class="token string">"10086"</span><span class="token punctuation">,</span> <span class="token string">"18800007777"</span><span class="token punctuation">]</span><span class="token keyword">for</span> tel <span class="token keyword">in</span> tels<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"1\d&#123;9&#125;[0-35-68-9]"</span><span class="token punctuation">,</span> tel<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不是想要的手机号"</span> <span class="token operator">%</span> tel<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="提取区号和电话号码"><a href="#提取区号和电话号码" class="headerlink" title="提取区号和电话号码"></a>提取区号和电话号码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"([^-]*)-(\d+)"</span><span class="token punctuation">,</span><span class="token string">"010-12345678"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'010-12345678'</span><span class="token operator">>></span><span class="token operator">></span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'010'</span><span class="token operator">>></span><span class="token operator">></span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token string">'12345678'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例3：-1"><a href="#示例3：-1" class="headerlink" title="示例3：\"></a>示例3：\</h2><p>需求：匹配出<code>&lt;html&gt;hh&lt;/html&gt;</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token comment"># 能够完成对正确的字符串的匹配</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"&lt;[a-zA-Z]*>\w*&lt;/[a-zA-Z]*>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>hh&lt;/html>"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 如果遇到非正常的html格式字符串，匹配出错</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"&lt;[a-zA-Z]*>\w*&lt;/[a-zA-Z]*>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>hh&lt;/htmlbalabala>"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 正确的理解思路：如果在第一对&lt;>中是什么，按理说在后面的那对&lt;>中就应该是什么</span><span class="token comment"># 通过引用分组中匹配到的数据即可，但是要注意是元字符串，即类似 r""这种格式</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;([a-zA-Z]*)>\w*&lt;/\1>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>hh&lt;/html>"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 因为2对&lt;>中的数据不一致，所以没有匹配出来</span>test_label <span class="token operator">=</span> <span class="token string">"&lt;html>hh&lt;/htmlbalabala>"</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;([a-zA-Z]*)>\w*&lt;/\1>"</span><span class="token punctuation">,</span> test_label<span class="token punctuation">)</span><span class="token keyword">if</span> ret<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 这是一对不正确的标签"</span> <span class="token operator">%</span> test_label<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>htmlbalabala</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>htmlbalabala</span><span class="token punctuation">></span></span> 这是一对不正确的标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例4：-number"><a href="#示例4：-number" class="headerlink" title="示例4：\number"></a>示例4：\number</h2><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> relabels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h1>&lt;/html>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h2>&lt;/html>"</span><span class="token punctuation">]</span><span class="token keyword">for</span> label <span class="token keyword">in</span> labels<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;(\w*)>&lt;(\w*)>.*&lt;/\2>&lt;/\1>"</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是符合要求的标签"</span> <span class="token operator">%</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不符合要求"</span> <span class="token operator">%</span> label<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>www.itcast.cn<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> 是符合要求的标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>www.itcast.cn<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> 不符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="示例5：-P-lt-name-gt-P-name"><a href="#示例5：-P-lt-name-gt-P-name" class="headerlink" title="示例5：(?P&lt;name&gt;) (?P=name)"></a>示例5：<code>(?P&lt;name&gt;)</code> <code>(?P=name)</code></h2><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;(?P&lt;name1>\w*)>&lt;(?P&lt;name2>\w*)>.*&lt;/(?P=name2)>&lt;/(?P=name1)>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h1>&lt;/html>"</span><span class="token punctuation">)</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;(?P&lt;name1>\w*)>&lt;(?P&lt;name2>\w*)>.*&lt;/(?P=name2)>&lt;/(?P=name1)>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h2>&lt;/html>"</span><span class="token punctuation">)</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意：-P-lt-name-gt-和-P-name-中的字母p大写"><a href="#注意：-P-lt-name-gt-和-P-name-中的字母p大写" class="headerlink" title="注意：(?P&lt;name&gt;)和(?P=name)中的字母p大写"></a>注意：<code>(?P&lt;name&gt;)</code>和<code>(?P=name)</code>中的字母p大写</h3><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321230906.png" alt="img" loading="lazy"></p><h1 id="re模块的高级用法"><a href="#re模块的高级用法" class="headerlink" title="re模块的高级用法"></a>re模块的高级用法</h1><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>需求：匹配出文章阅读的次数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> <span class="token string">"阅读次数为 9999"</span><span class="token punctuation">)</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token string">'9999'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h2><p>需求：统计出python、c、c++相应文章阅读的次数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> <span class="token string">"python = 9999, c = 7890, c++ = 12345"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span><span class="token string">'9999'</span><span class="token punctuation">,</span> <span class="token string">'7890'</span><span class="token punctuation">,</span> <span class="token string">'12345'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="sub-将匹配到的数据进行替换"><a href="#sub-将匹配到的数据进行替换" class="headerlink" title="sub 将匹配到的数据进行替换"></a>sub 将匹配到的数据进行替换</h2><p>需求：将匹配到的阅读次数加1</p><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> <span class="token string">'998'</span><span class="token punctuation">,</span> <span class="token string">"python = 997"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python <span class="token operator">=</span> <span class="token number">998</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>    strNum <span class="token operator">=</span> temp<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>    num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>strNum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> add<span class="token punctuation">,</span> <span class="token string">"python = 997"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> add<span class="token punctuation">,</span> <span class="token string">"python = 99"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python <span class="token operator">=</span> <span class="token number">998</span>python <span class="token operator">=</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321230920.png" alt="img" loading="lazy"></p><p>从下面的字符串中取出文本</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>岗位职责：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>完成推荐算法、数据统计、接口、后台等服务器端相关工作<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>必备要求：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>良好的自我驱动力和职业素养，工作积极主动、结果导向<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>技术要求：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>1、一年以上 Python 开发经验，掌握面向对象分析和设计，了解设计模式<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>2、掌握HTTP协议，熟悉MVC、MVVM等概念以及相关WEB开发框架<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>3、掌握关系数据库开发设计，掌握 SQL，熟练使用 MySQL/PostgreSQL 中的一种<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>4、掌握NoSQL、MQ，熟练使用对应技术解决方案<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>5、熟悉 Javascript/CSS/HTML5，JQuery、React、Vue.js<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>加分项：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>大数据，数理统计，机器学习，sklearn，高性能，大并发。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考答案:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"&lt;[^>]*>|&amp;nbsp;|\n"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> test_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="split-根据匹配进行切割字符串，并返回一个列表"><a href="#split-根据匹配进行切割字符串，并返回一个列表" class="headerlink" title="split 根据匹配进行切割字符串，并返回一个列表"></a>split 根据匹配进行切割字符串，并返回一个列表</h2><p>需求：切割字符串“info:xiaoZhang 33 shandong”</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">r":| "</span><span class="token punctuation">,</span><span class="token string">"info:xiaoZhang 33 shandong"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span><span class="token string">'info'</span><span class="token punctuation">,</span> <span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span> <span class="token string">'33'</span><span class="token punctuation">,</span> <span class="token string">'shandong'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="python贪婪和非贪婪"><a href="#python贪婪和非贪婪" class="headerlink" title="python贪婪和非贪婪"></a>python贪婪和非贪婪</h1><p>Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；</p><p>非贪婪则相反，总是尝试匹配尽可能少的字符。</p><p>在”*”,”?”,”+”,”{m,n}”后面加上？，使贪婪变成非贪婪。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s<span class="token operator">=</span><span class="token string">"This is a number 234-235-22-423"</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token operator">=</span>re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">".+(\d+-\d+-\d+-\d+)"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'4-235-22-423'</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token operator">=</span>re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">".+?(\d+-\d+-\d+-\d+)"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'234-235-22-423'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。</p><p>解决方式：非贪婪操作符“？”，这个操作符可以用在”*”,”+”,”?”的后面，要求正则匹配的越少越好。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+)"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'2343'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+?)"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'2'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+)ddd"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">'2343'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+?)ddd"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'2343'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练一练-1"><a href="#练一练-1" class="headerlink" title="练一练"></a>练一练</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321230940.png" alt="img" loading="lazy"></p><p>字符串为:</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">data-original</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">display</span><span class="token punctuation">:</span> inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请提取url地址</p><p>参考答案</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">r"https://.*?\.jpg"</span><span class="token punctuation">,</span> test_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="r的作用"><a href="#r的作用" class="headerlink" title="r的作用"></a>r的作用</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> mm <span class="token operator">=</span> <span class="token string">"c:\\a\\b\\c"</span><span class="token operator">>></span><span class="token operator">></span> mm<span class="token string">'c:\\a\\b\\c'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a\b\c<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"c:\\\\"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'c:\\'</span><span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"c:\\\\"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\<span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"c:\\\\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a<span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"c:\\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a<span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"c:\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>AttributeError<span class="token punctuation">:</span> <span class="token string">'NoneType'</span> <span class="token builtin">object</span> has no attribute <span class="token string">'group'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明</p><p><code>Python中字符串前面加上 r 表示原生字符串</code>，</p><p>与大多数编程语言相同，<code>正则表达式里使用&quot;\&quot;作为转义字符</code>，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。</p><p>Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"c:\\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式概述&quot;&gt;&lt;a href=&quot;#正则表达式概述&quot; class=&quot;headerlink&quot; title=&quot;正则表达式概述&quot;&gt;&lt;/a&gt;正则表达式概述&lt;/h1&gt;&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思</summary>
      
    
    
    
    <category term="Python" scheme="http://ccsu.top/categories/Python/"/>
    
    
    <category term="Python" scheme="http://ccsu.top/tags/Python/"/>
    
    <category term="正则表达式" scheme="http://ccsu.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网穿透</title>
    <link href="http://ccsu.top/posts/bd50b816/"/>
    <id>http://ccsu.top/posts/bd50b816/</id>
    <published>2022-03-20T17:08:00.000Z</published>
    <updated>2022-04-02T07:03:22.084Z</updated>
    
    <content type="html"><![CDATA[<p>通过<code>frp</code>开源代码进行内网穿透，需要准备一台带宽高有官网IP的服务器</p><p>下载地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321003851.png" alt="image-20220321003850923" loading="lazy"></p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>下载<code>frp_0.40.0_linux_amd64.tar.gz</code>，可以通过命令行，也可以直接在github下载</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 下载frpwget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.40.0&#x2F;frp_0.40.0_linux_amd64.tar.gz# 解压tar -zvxf frp_0.40.0_linux_amd64.tar.gz# 重命名mv frp_0.40.0_linux_amd64.tar.gz frp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321004249.png" alt="image-20220321004249532" loading="lazy"></p><p>修改<code>frps.ini</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[common]bind_port &#x3D; 7000# frp使用的端口dashboard_user &#x3D; admin# 流量监控的账户dashboard_pwd &#x3D; admin  # 流量监控的密码dashboard_port &#x3D; 6443# 流量监控程序的端口，搭建完成之后用服务器IP:6443就可以打开流量监控网页程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给文件夹<code>frp</code>赋权</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo chmod 755 frp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动<code>frp</code></p><pre class="line-numbers language-SH" data-language="SH"><code class="language-SH">.&#x2F;frps -c .&#x2F;frps.ini <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005150.png" alt="image-20220321005150643" loading="lazy"></p><p>打开流量监控网页，<code>服务器IP地址:7000</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321004800.png" alt="image-20220321004800570" loading="lazy"></p><h1 id="树莓派端"><a href="#树莓派端" class="headerlink" title="树莓派端"></a>树莓派端</h1><p>下载<code>frp_0.40.0_linux_amd64.tar.gz</code>，可以通过命令行，也可以直接在github下载</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 下载frpwget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.40.0&#x2F;frp_0.40.0_linux_amd64.tar.gz# 解压tar -zvxf frp_0.40.0_linux_amd64.tar.gz# 重命名mv frp_0.40.0_linux_amd64.tar.gz frp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321004249.png" alt="image-20220321004249532" loading="lazy"></p><p>修改<code>frpc.ini</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[common]server_addr &#x3D; 服务器IPserver_port &#x3D; 7000[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000[cream]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8880remote_port &#x3D; 8880[vnc]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 5900# vnc端口是5900remote_port &#x3D; 5900<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给文件夹<code>frp</code>赋权</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo chmod 755 frp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动<code>frp</code></p><pre class="line-numbers language-SH" data-language="SH"><code class="language-SH">.&#x2F;frpc -c .&#x2F;frpc.ini <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005206.png" alt="image-20220321005206495" loading="lazy"></p><p>查看<code>frp</code>后台，可以看见服务</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005256.png" alt="image-20220321005256292" loading="lazy"></p><blockquote><p>  <code>frps.ini</code>是服务端的配置文件，<code>frpc.ini</code>是客户端的配置文件，注意不要混淆</p></blockquote><h1 id="配置frp自启动"><a href="#配置frp自启动" class="headerlink" title="配置frp自启动"></a>配置frp自启动</h1><p>使用systemctl来控制启动，将<code>/frp/systemd/frps.service</code>拷贝到<code>/lib/systemd/system/</code>目录下，在<code>frps.service</code>里写入以下内容</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[Unit]Description&#x3D;fraps serviceAfter&#x3D;network.target syslog.targetWants&#x3D;network.target[Service]Type&#x3D;simple#启动服务的命令（此处写你的frps的实际安装目录）ExecStart&#x3D;&#x2F;your&#x2F;path&#x2F;frps -c &#x2F;your&#x2F;path&#x2F;frps.ini[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就启动<code>frps</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo systemctl start frps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再打开自启动</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo systemctl enable frps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要重启应用，可以这样，<code>sudo systemctl restart frps</code><br>如果要停止应用，可以输入，<code>sudo systemctl stop frps</code><br>如果要查看应用的日志，可以输入，<code>sudo systemctl status frps</code></p><p>实测树莓派远程监控延时为0.5s左右，这个时候可以通过公网地址和端口访问树莓派，通过<code>ssh</code>或者<code>vnc</code>都可以</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005459.png" alt="image-20220321005459457" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过&lt;code&gt;frp&lt;/code&gt;开源代码进行内网穿透，需要准备一台带宽高有官网IP的服务器&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/fatedier/frp/releases&quot;&gt;https://github.com/fatedie</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="内网穿透" scheme="http://ccsu.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>树莓派实现远程监控</title>
    <link href="http://ccsu.top/posts/108619c9/"/>
    <id>http://ccsu.top/posts/108619c9/</id>
    <published>2022-03-20T16:23:00.000Z</published>
    <updated>2022-03-20T17:15:33.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  python实现opencv+scoket网络实时图传</p></blockquote><h1 id="服务器分析"><a href="#服务器分析" class="headerlink" title="服务器分析"></a><strong>服务器分析</strong></h1><p>1.　先通过在服务器端利用OpenCV捕获到视频的每一帧图片</p><p>2.　将这些图片进行压缩成JPEG格式，这样能减小图片大小，便于传输</p><p>3.　按照提前协商好的分辨率和帧数进行打包编码传输</p><p>4.　利用服务器端打开端口8880，此时客户端连接后，便可以在客户端中捕获到服务器端的视频。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#服务端</span><span class="token keyword">import</span> socket<span class="token keyword">import</span> threading<span class="token keyword">import</span> struct<span class="token keyword">import</span> time<span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy<span class="token keyword">import</span> warningswarnings<span class="token punctuation">.</span>filterwarnings<span class="token punctuation">(</span><span class="token string">"ignore"</span><span class="token punctuation">,</span>category<span class="token operator">=</span>DeprecationWarning<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Carame_Accept_Object</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>S_addr_port<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">8880</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>resolution<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">)</span>    <span class="token comment">#分辨率</span>    self<span class="token punctuation">.</span>img_fps<span class="token operator">=</span><span class="token number">30</span>         <span class="token comment">#每秒传输多少帧数</span>    self<span class="token punctuation">.</span>addr_port<span class="token operator">=</span>S_addr_port    self<span class="token punctuation">.</span>Set_Socket<span class="token punctuation">(</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">)</span>  <span class="token comment">#设置套接字</span>  <span class="token keyword">def</span> <span class="token function">Set_Socket</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>S_addr_port<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>server<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>server<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#端口可复用</span>    self<span class="token punctuation">.</span>server<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>S_addr_port<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>server<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment">#print("the process work in the port:%d" % S_addr_port[1])</span><span class="token keyword">def</span> <span class="token function">check_option</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">,</span>client<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#按格式解码，确定帧数和分辨率</span>  info<span class="token operator">=</span>struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'lhh'</span><span class="token punctuation">,</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> info<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">888</span><span class="token punctuation">:</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>img_fps<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>info<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">888</span>     <span class="token comment">#获取帧数</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">)</span>    <span class="token comment"># 获取分辨率</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>info<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>info<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">RT_Image</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">,</span>client<span class="token punctuation">,</span>D_addr<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>check_option<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">,</span>client<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span>  camera<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment">#从摄像头中获取视频</span>  img_param<span class="token operator">=</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>IMWRITE_JPEG_QUALITY<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>img_fps<span class="token punctuation">]</span> <span class="token comment">#设置传送图像格式、帧数</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>       <span class="token comment">#推迟线程运行0.1s</span>    ret<span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token operator">=</span>camera<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#读取视频每一帧</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">)</span>   <span class="token comment">#按要求调整图像大小(resolution必须为元组)</span>    _<span class="token punctuation">,</span>img_encode<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imencode<span class="token punctuation">(</span><span class="token string">'.jpg'</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token punctuation">,</span>img_param<span class="token punctuation">)</span> <span class="token comment">#按格式生成图片</span>    img_code<span class="token operator">=</span>numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span>img_encode<span class="token punctuation">)</span>            <span class="token comment">#转换成矩阵</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>img_data<span class="token operator">=</span>img_code<span class="token punctuation">.</span>tostring<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">#生成相应的字符串</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>      <span class="token comment">#按照相应的格式进行打包发送图片</span>      client<span class="token punctuation">.</span>send<span class="token punctuation">(</span>struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"lhh"</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>img_data<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">object</span><span class="token punctuation">.</span>img_data<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>      camera<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#释放资源</span>      <span class="token keyword">return</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  camera<span class="token operator">=</span>Carame_Accept_Object<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    client<span class="token punctuation">,</span>D_addr<span class="token operator">=</span>camera<span class="token punctuation">.</span>server<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    clientThread<span class="token operator">=</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>target<span class="token operator">=</span>RT_Image<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>camera<span class="token punctuation">,</span>client<span class="token punctuation">,</span>D_addr<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    clientThread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="客户端分析"><a href="#客户端分析" class="headerlink" title="客户端分析"></a><strong>客户端分析</strong></h1><p>1.　客户端连接端口后，首先发送需要协商的分辨率和帧数，以致能够使传输“协议”一致</p><p>2.　客户端使用线程，对图片进行收集</p><ol start="3"><li>对收到的每一张图片进行解码，并利用OpenCV播放出来，即可实现C&#x2F;S两端实时视频传输。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding: utf-8 -*-</span><span class="token comment"># @Time : 2022/3/20 22:57</span><span class="token comment"># @Author : WuShuai</span><span class="token comment"># @Email : wu_shuai_2000@163.com</span><span class="token comment"># @File : test.py</span><span class="token comment"># @blog : https://blog.csdn.net/Dumbking</span><span class="token comment">#客户端</span><span class="token keyword">import</span> socket<span class="token keyword">import</span> cv2<span class="token keyword">import</span> threading<span class="token keyword">import</span> struct<span class="token keyword">import</span> numpy<span class="token keyword">class</span> <span class="token class-name">Camera_Connect_Object</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>D_addr_port<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">8880</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>resolution<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">640</span><span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>addr_port<span class="token operator">=</span>D_addr_port    self<span class="token punctuation">.</span>src<span class="token operator">=</span><span class="token number">888</span><span class="token operator">+</span><span class="token number">15</span>         <span class="token comment">#双方确定传输帧数，（888）为校验值</span>    self<span class="token punctuation">.</span>interval<span class="token operator">=</span><span class="token number">0</span>         <span class="token comment">#图片播放时间间隔</span>    self<span class="token punctuation">.</span>img_fps<span class="token operator">=</span><span class="token number">30</span>         <span class="token comment">#每秒传输多少帧数</span>  <span class="token keyword">def</span> <span class="token function">Set_socket</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>client<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">Socket_Connect</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>Set_socket<span class="token punctuation">(</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"IP is %s:%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">RT_Image</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#按照格式打包发送帧数和分辨率</span>    self<span class="token punctuation">.</span>name<span class="token operator">=</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">" Camera"</span>    self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>send<span class="token punctuation">(</span>struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"lhh"</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>src<span class="token punctuation">,</span> self<span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      info<span class="token operator">=</span>struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">"lhh"</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      buf_size<span class="token operator">=</span>info<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>          <span class="token comment">#获取读的图片总长度</span>      <span class="token keyword">if</span> buf_size<span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>          self<span class="token punctuation">.</span>buf<span class="token operator">=</span><span class="token string">b""</span>        <span class="token comment">#代表bytes类型</span>          temp_buf<span class="token operator">=</span>self<span class="token punctuation">.</span>buf          <span class="token keyword">while</span><span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment">#读取每一张图片的长度</span>            temp_buf<span class="token operator">=</span>self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span>            buf_size<span class="token operator">-=</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp_buf<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>buf<span class="token operator">+=</span>temp_buf   <span class="token comment">#获取图片</span>            data <span class="token operator">=</span> numpy<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>self<span class="token punctuation">.</span>buf<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'uint8'</span><span class="token punctuation">)</span>  <span class="token comment">#按uint8转换为图像矩阵</span>            self<span class="token punctuation">.</span>image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imdecode<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>         <span class="token comment">#图像解码</span>            cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>image<span class="token punctuation">)</span>          <span class="token comment">#展示图片</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>          <span class="token keyword">pass</span><span class="token punctuation">;</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#每10ms刷新一次图片，按‘ESC'（27）退出</span>            self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>  <span class="token keyword">def</span> <span class="token function">Get_Data</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>interval<span class="token punctuation">)</span><span class="token punctuation">:</span>    showThread<span class="token operator">=</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>self<span class="token punctuation">.</span>RT_Image<span class="token punctuation">)</span>    showThread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  camera<span class="token operator">=</span>Camera_Connect_Object<span class="token punctuation">(</span><span class="token punctuation">)</span>  camera<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"服务端的ip"</span>  camera<span class="token punctuation">.</span>addr_port<span class="token operator">=</span><span class="token builtin">tuple</span><span class="token punctuation">(</span>camera<span class="token punctuation">.</span>addr_port<span class="token punctuation">)</span>  camera<span class="token punctuation">.</span>Socket_Connect<span class="token punctuation">(</span><span class="token punctuation">)</span>  camera<span class="token punctuation">.</span>Get_Data<span class="token punctuation">(</span>camera<span class="token punctuation">.</span>interval<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  服务端放在树莓派上面运行，在局域网内可以直接访问，想要远程访问还需要让树莓派进行内网穿透。</p><p>  原本的思路是树莓派通过<code>opencv</code>获取视频帧，传给有公网IP的服务器，服务器再进行转发到客户端，这样的话需要多写服务器上面的代码，利用内网穿透可以很好地避免这个过程，减少开发的工作量。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;  python实现opencv+scoket网络实时图传&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;服务器分析&quot;&gt;&lt;a href=&quot;#服务器分析&quot; class=&quot;headerlink&quot; title=&quot;服务器分析&quot;&gt;&lt;/a&gt;&lt;strong</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="树莓派" scheme="http://ccsu.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="OpenCV" scheme="http://ccsu.top/tags/OpenCV/"/>
    
    <category term="Socket" scheme="http://ccsu.top/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Python多任务-进程</title>
    <link href="http://ccsu.top/posts/b23c6bbe/"/>
    <id>http://ccsu.top/posts/b23c6bbe/</id>
    <published>2022-03-19T16:53:00.000Z</published>
    <updated>2022-03-19T16:53:47.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程以及状态"><a href="#进程以及状态" class="headerlink" title="进程以及状态"></a>进程以及状态</h1><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>程序：例如xxx.py这是程序，是一个静态的</p><p>进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。</p><p>不仅可以通过线程完成多任务，进程也是可以的</p><h3 id="2-进程的状态"><a href="#2-进程的状态" class="headerlink" title="2. 进程的状态"></a>2. 进程的状态</h3><p>工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319220239.png" alt="img" loading="lazy"></p><ul><li>就绪态：运行的条件都已经慢去，正在等在cpu执行</li><li>执行态：cpu正在执行其功能</li><li>等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态</li></ul><h1 id="进程的创建-multiprocessing"><a href="#进程的创建-multiprocessing" class="headerlink" title="进程的创建-multiprocessing"></a>进程的创建-multiprocessing</h1><p>multiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情</p><h3 id="1-2个while循环一起执行"><a href="#1-2个while循环一起执行" class="headerlink" title="1. 2个while循环一起执行"></a>1. 2个while循环一起执行</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">run_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----2----"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>run_proc<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----1----"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动</li></ul><h3 id="2-进程pid"><a href="#2-进程pid" class="headerlink" title="2. 进程pid"></a>2. 进程pid</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">run_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程运行中，pid=%d...'</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># os.getpid获取当前进程的进程号</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程将要结束...'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父进程pid: %d'</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># os.getpid获取当前进程的进程号</span>    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>run_proc<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Process语法结构如下："><a href="#3-Process语法结构如下：" class="headerlink" title="3. Process语法结构如下："></a>3. Process语法结构如下：</h3><p>Process([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码</li><li>args：给target指定的函数传递的参数，以元组的方式传递</li><li>kwargs：给target指定的函数传递命名参数</li><li>name：给进程设定一个名字，可以不设定</li><li>group：指定进程组，大多数情况下用不到</li></ul><p>Process创建的实例对象的常用方法：</p><ul><li>start()：启动子进程实例（创建子进程）</li><li>is_alive()：判断进程子进程是否还在活着</li><li>join([timeout])：是否等待子进程执行结束，或等待多少秒</li><li>terminate()：不管任务是否完成，立即终止子进程</li></ul><p>Process创建的实例对象的常用属性：</p><ul><li>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数</li><li>pid：当前进程的pid（进程号）</li></ul><h3 id="4-给子进程指定的函数传递参数"><a href="#4-给子进程指定的函数传递参数" class="headerlink" title="4. 给子进程指定的函数传递参数"></a>4. 给子进程指定的函数传递参数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token keyword">def</span> <span class="token function">run_proc</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程运行中，name= %s,age=%d ,pid=%d...'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>run_proc<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> kwargs<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"m"</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 1秒中之后，立即结束子进程</span>    p<span class="token punctuation">.</span>terminate<span class="token punctuation">(</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-进程间不同享全局变量"><a href="#5-进程间不同享全局变量" class="headerlink" title="5. 进程间不同享全局变量"></a>5. 进程间不同享全局变量</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">import</span> timenums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"in process1 pid=%d ,nums=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"in process1 pid=%d ,nums=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"in process2 pid=%d ,nums=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    p1 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">)</span>    p1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    p1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    p2 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">)</span>    p2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">in</span> process2 pid<span class="token operator">=</span><span class="token number">11350</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="进程、线程对比"><a href="#进程、线程对比" class="headerlink" title="进程、线程对比"></a>进程、线程对比</h1><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ</li><li>线程，能够完成多任务，比如 一个QQ中的多个聊天窗口</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319221932.jpg" alt="img" loading="lazy"></p><h3 id="定义的不同"><a href="#定义的不同" class="headerlink" title="定义的不同"></a>定义的不同</h3><ul><li>进程是系统进行资源分配和调度的一个独立单位.</li><li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319221950.png" alt="img" loading="lazy"></p><ul><li>线线程不能够独立执行，必须依存在进程中</li><li>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319222001.gif" alt="img" loading="lazy"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h1 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信-Queue"></a>进程间通信-Queue</h1><p>Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。</p><h3 id="1-Queue的使用"><a href="#1-Queue的使用" class="headerlink" title="1. Queue的使用"></a>1. Queue的使用</h3><p>可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Queueq<span class="token operator">=</span>Queue<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">#初始化一个Queue对象，最多可接收三条put消息</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息1"</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息2"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">#False</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息3"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#True</span><span class="token comment">#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常</span><span class="token keyword">try</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息4"</span><span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"消息列队已满，现有消息数量:%s"</span><span class="token operator">%</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put_nowait<span class="token punctuation">(</span><span class="token string">"消息4"</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"消息列队已满，现有消息数量:%s"</span><span class="token operator">%</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#推荐的方式，先判断消息列队是否已满，再写入</span><span class="token keyword">if</span> <span class="token keyword">not</span> q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put_nowait<span class="token punctuation">(</span><span class="token string">"消息4"</span><span class="token punctuation">)</span><span class="token comment">#读取消息时，先判断消息列队是否为空，再读取</span><span class="token keyword">if</span> <span class="token keyword">not</span> q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>get_nowait<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token boolean">False</span><span class="token boolean">True</span>消息列队已满，现有消息数量<span class="token punctuation">:</span><span class="token number">3</span>消息列队已满，现有消息数量<span class="token punctuation">:</span><span class="token number">3</span>消息<span class="token number">1</span>消息<span class="token number">2</span>消息<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>初始化Queue()对象时（例如：q&#x3D;Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；</p><ul><li>Queue.qsize()：返回当前队列包含的消息数量；</li><li>Queue.empty()：如果队列为空，返回True，反之False ；</li><li>Queue.full()：如果队列满了，返回True,反之False；</li><li>Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；</li></ul><p>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常；</p><p>2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常；</p><ul><li>Queue.get_nowait()：相当Queue.get(False)；</li><li>Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；</li></ul><p>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；</p><p>2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常；</p><ul><li>Queue.put_nowait(item)：相当Queue.put(item, False)；</li></ul><h3 id="2-Queue实例"><a href="#2-Queue实例" class="headerlink" title="2. Queue实例"></a>2. Queue实例</h3><p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue<span class="token keyword">import</span> os<span class="token punctuation">,</span> time<span class="token punctuation">,</span> random<span class="token comment"># 写数据进程执行的代码:</span><span class="token keyword">def</span> <span class="token function">write</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> value <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Put %s to queue...'</span> <span class="token operator">%</span> value<span class="token punctuation">)</span>        q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 读数据进程执行的代码:</span><span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            value <span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get %s from queue.'</span> <span class="token operator">%</span> value<span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># 父进程创建Queue，并传给各个子进程：</span>    q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    pw <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>write<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    pr <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>read<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 启动子进程pw，写入:</span>    pw<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 等待pw结束:</span>    pw<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 启动子进程pr，读取:</span>    pr<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    pr<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有数据都写入并且读完'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319222345.gif" alt="img" loading="lazy"></p><h1 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h1><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。</p><p>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool<span class="token keyword">import</span> os<span class="token punctuation">,</span> time<span class="token punctuation">,</span> random<span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    t_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s开始执行,进程号为%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>msg<span class="token punctuation">,</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># random.random()随机生成0~1之间的浮点数</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>     t_stop <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span><span class="token string">"执行完毕，耗时%0.2f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>t_stop<span class="token operator">-</span>t_start<span class="token punctuation">)</span><span class="token punctuation">)</span>po <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 定义一个进程池，最大进程数3</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))</span>    <span class="token comment"># 每次循环将会用空闲出来的子进程去调用目标</span>    po<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>worker<span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----start----"</span><span class="token punctuation">)</span>po<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭进程池，关闭后po不再接收新的请求</span>po<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 等待po中所有子进程执行完成，必须放在close语句之后</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----end-----"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>start<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">0</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">1</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21468</span><span class="token number">2</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21467</span><span class="token number">0</span> 执行完毕，耗时<span class="token number">1.01</span><span class="token number">3</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">2</span> 执行完毕，耗时<span class="token number">1.24</span><span class="token number">4</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21467</span><span class="token number">3</span> 执行完毕，耗时<span class="token number">0.56</span><span class="token number">5</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">1</span> 执行完毕，耗时<span class="token number">1.68</span><span class="token number">6</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21468</span><span class="token number">4</span> 执行完毕，耗时<span class="token number">0.67</span><span class="token number">7</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21467</span><span class="token number">5</span> 执行完毕，耗时<span class="token number">0.83</span><span class="token number">8</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">6</span> 执行完毕，耗时<span class="token number">0.75</span><span class="token number">9</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21468</span><span class="token number">7</span> 执行完毕，耗时<span class="token number">1.03</span><span class="token number">8</span> 执行完毕，耗时<span class="token number">1.05</span><span class="token number">9</span> 执行完毕，耗时<span class="token number">1.69</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>end<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>multiprocessing.Pool常用函数解析：</p><ul><li>apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；</li><li>close()：关闭Pool，使其不再接受新的任务；</li><li>terminate()：不管任务是否完成，立即终止；</li><li>join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</li></ul><h2 id="进程池中的Queue"><a href="#进程池中的Queue" class="headerlink" title="进程池中的Queue"></a>进程池中的Queue</h2><p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：</p><p>RuntimeError: Queue objects should only be shared between processes through inheritance.</p><p>下面的实例演示了进程池中的进程如何通信：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token comment"># 修改import中的Queue为Manager</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Manager<span class="token punctuation">,</span>Pool<span class="token keyword">import</span> os<span class="token punctuation">,</span>time<span class="token punctuation">,</span>random<span class="token keyword">def</span> <span class="token function">reader</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"reader启动(%s),父进程为(%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"reader从Queue获取到消息：%s"</span> <span class="token operator">%</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">writer</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"writer启动(%s),父进程为(%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token string">"itcast"</span><span class="token punctuation">:</span>        q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"(%s) start"</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    q <span class="token operator">=</span> Manager<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 使用Manager中的Queue</span>    po <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token punctuation">)</span>    po<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>writer<span class="token punctuation">,</span> <span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据</span>    po<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>reader<span class="token punctuation">,</span> <span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    po<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    po<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"(%s) End"</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span> startwriter启动<span class="token punctuation">(</span><span class="token number">11097</span><span class="token punctuation">)</span><span class="token punctuation">,</span>父进程为<span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span>reader启动<span class="token punctuation">(</span><span class="token number">11098</span><span class="token punctuation">)</span><span class="token punctuation">,</span>父进程为<span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span>reader从Queue获取到消息：ireader从Queue获取到消息：treader从Queue获取到消息：creader从Queue获取到消息：areader从Queue获取到消息：sreader从Queue获取到消息：t<span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span> End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用：文件夹copy器（多进程版）"><a href="#应用：文件夹copy器（多进程版）" class="headerlink" title="应用：文件夹copy器（多进程版）"></a>应用：文件夹copy器（多进程版）</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> multiprocessing<span class="token keyword">import</span> os<span class="token keyword">import</span> time<span class="token keyword">import</span> random<span class="token keyword">def</span> <span class="token function">copy_file</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> file_name<span class="token punctuation">,</span>source_folder_name<span class="token punctuation">,</span>  dest_folder_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""copy文件到指定的路径"""</span>    f_read <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>source_folder_name <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> file_name<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span>    f_write <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>dest_folder_name <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> file_name<span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        content <span class="token operator">=</span> f_read<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> content<span class="token punctuation">:</span>            f_write<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    f_read<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_write<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 发送已经拷贝完毕的文件名字</span>    queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 获取要复制的文件夹</span>    source_folder_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入要复制文件夹名字:"</span><span class="token punctuation">)</span>    <span class="token comment"># 整理目标文件夹</span>    dest_folder_name <span class="token operator">=</span> source_folder_name <span class="token operator">+</span> <span class="token string">"[副本]"</span>    <span class="token comment"># 创建目标文件夹</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>dest_folder_name<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>  <span class="token comment"># 如果文件夹已经存在，那么创建会失败</span>    <span class="token comment"># 获取这个文件夹中所有的普通文件名</span>    file_names <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>source_folder_name<span class="token punctuation">)</span>    <span class="token comment"># 创建Queue</span>    queue <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Manager<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 创建进程池</span>    pool <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> file_name <span class="token keyword">in</span> file_names<span class="token punctuation">:</span>        <span class="token comment"># 向进程池中添加任务</span>        pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>copy_file<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> file_name<span class="token punctuation">,</span> source_folder_name<span class="token punctuation">,</span> dest_folder_name<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 主进程显示进度</span>    pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    all_file_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>file_names<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        file_name <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> file_name <span class="token keyword">in</span> file_names<span class="token punctuation">:</span>            file_names<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span>        copy_rate <span class="token operator">=</span> <span class="token punctuation">(</span>all_file_num<span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>file_names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">/</span>all_file_num        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\r%.2f...(%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>copy_rate<span class="token punctuation">,</span> file_name<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token operator">*</span><span class="token number">50</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> copy_rate <span class="token operator">>=</span> <span class="token number">100</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程以及状态&quot;&gt;&lt;a href=&quot;#进程以及状态&quot; class=&quot;headerlink&quot; title=&quot;进程以及状态&quot;&gt;&lt;/a&gt;进程以及状态&lt;/h1&gt;&lt;h3 id=&quot;1-进程&quot;&gt;&lt;a href=&quot;#1-进程&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="Python" scheme="http://ccsu.top/categories/Python/"/>
    
    
    <category term="进程" scheme="http://ccsu.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python多任务-线程</title>
    <link href="http://ccsu.top/posts/a4da6e72/"/>
    <id>http://ccsu.top/posts/a4da6e72/</id>
    <published>2022-03-19T15:00:00.000Z</published>
    <updated>2022-03-19T16:53:47.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多任务介绍"><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h1><h2 id="现实生活中"><a href="#现实生活中" class="headerlink" title="现实生活中"></a>现实生活中</h2><p>有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的；</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205200.jpg" alt="img" loading="lazy"></p><p>试想，如果把唱歌和跳舞这2件事情分开依次完成的话，估计就没有那么好的效果了（想一下场景：先唱歌，然后在跳舞，O(∩_∩)O哈哈~）</p><h2 id="程序中"><a href="#程序中" class="headerlink" title="程序中"></a>程序中</h2><p>如下程序，来模拟“唱歌跳舞”这件事情</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在唱歌...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在跳舞...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sing<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#唱歌</span>    dance<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#跳舞</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205249.png" alt="image-20220319205249393" loading="lazy"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>很显然刚刚的程序并没有完成唱歌和跳舞同时进行的要求</li><li>如果想要实现“唱歌跳舞”同时进行，那么就需要一个新的方法，叫做：<strong>多任务</strong></li></ul><h1 id="多任务的概念"><a href="#多任务的概念" class="headerlink" title="多任务的概念"></a>多任务的概念</h1><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205356.png" alt="img" loading="lazy"></p><p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p><p>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p><p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205411.jpg" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205417.gif" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205426.gif" alt="img" loading="lazy"></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>**&#x3D;&#x3D;并发&#x3D;&#x3D;**：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</li><li>**&#x3D;&#x3D;并行&#x3D;&#x3D;**：指的是任务数小于等于cpu核数，即任务真的是一起执行的</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用</p><h3 id="1-使用threading模块"><a href="#1-使用threading模块" class="headerlink" title="1. 使用threading模块"></a>1. 使用threading模块</h3><h4 id="单线程执行"><a href="#单线程执行" class="headerlink" title="单线程执行"></a>单线程执行</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">saySorry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"亲爱的，我错了，我能吃饭了吗？"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        saySorry<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205623.gif" alt="img" loading="lazy"></p><h4 id="多线程执行"><a href="#多线程执行" class="headerlink" title="多线程执行"></a>多线程执行</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">saySorry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"亲爱的，我错了，我能吃饭了吗？"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>saySorry<span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#启动线程，即让线程开始执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205706.gif" alt="img" loading="lazy"></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>可以明显看出使用了多线程并发的操作，花费时间要短很多</li><li>当调用<code>start()</code>时，才会真正的创建线程，并且开始执行</li></ol><h3 id="2-主线程会等待所有的子线程结束后才结束"><a href="#2-主线程会等待所有的子线程结束后才结束" class="headerlink" title="2. 主线程会等待所有的子线程结束后才结束"></a>2. 主线程会等待所有的子线程结束后才结束</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token punctuation">,</span>ctime<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在唱歌...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在跳舞...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---开始---:%s'</span><span class="token operator">%</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>sing<span class="token punctuation">)</span>    t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>dance<span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#sleep(5) # 屏蔽此行代码，试试看，程序是否会立马结束？</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---结束---:%s'</span><span class="token operator">%</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205759.gif" alt="img" loading="lazy"></p><h3 id="3-查看线程数量"><a href="#3-查看线程数量" class="headerlink" title="3. 查看线程数量"></a>3. 查看线程数量</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token punctuation">,</span>ctime<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在唱歌...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在跳舞...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---开始---:%s'</span><span class="token operator">%</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>sing<span class="token punctuation">)</span>    t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>dance<span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前运行的线程数为：%d'</span><span class="token operator">%</span>length<span class="token punctuation">)</span>        <span class="token keyword">if</span> length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319210210.gif" alt="img" loading="lazy"></p><h1 id="线程-注意点"><a href="#线程-注意点" class="headerlink" title="线程-注意点"></a>线程-注意点</h1><h4 id="1-线程执行代码的封装"><a href="#1-线程执行代码的封装" class="headerlink" title="1. 线程执行代码的封装"></a>1. 线程执行代码的封装</h4><p>通过上一小节，能够看出，通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承<code>threading.Thread</code>就可以了，然后重写<code>run</code>方法</p><p>示例如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            msg <span class="token operator">=</span> <span class="token string">"I'm "</span><span class="token operator">+</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">' @ '</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">#name属性中保存的是当前线程的名字</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> MyThread<span class="token punctuation">(</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319210233.gif" alt="img" loading="lazy"></p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li>python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。</li></ul><h4 id="2-线程的执行顺序"><a href="#2-线程的执行顺序" class="headerlink" title="2. 线程的执行顺序"></a>2. 线程的执行顺序</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            msg <span class="token operator">=</span> <span class="token string">"I'm "</span><span class="token operator">+</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">' @ '</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> MyThread<span class="token punctuation">(</span><span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：(运行的结果可能不一样，但是大体是一致的)</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">I&#39;m Thread-1 @ 0I&#39;m Thread-2 @ 0I&#39;m Thread-5 @ 0I&#39;m Thread-3 @ 0I&#39;m Thread-4 @ 0I&#39;m Thread-3 @ 1I&#39;m Thread-4 @ 1I&#39;m Thread-5 @ 1I&#39;m Thread-1 @ 1I&#39;m Thread-2 @ 1I&#39;m Thread-4 @ 2I&#39;m Thread-5 @ 2I&#39;m Thread-2 @ 2I&#39;m Thread-1 @ 2I&#39;m Thread-3 @ 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ol><li>每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。</li><li>当线程的run()方法结束时该线程完成。</li><li>无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</li></ol><h1 id="多线程-共享全局变量"><a href="#多线程-共享全局变量" class="headerlink" title="多线程-共享全局变量"></a>多线程-共享全局变量</h1><p>在一个函数中对全局变屋进行修改的时候，到底是香需要使用<code>global</code>进行说明要看是否对全局变量的执行指向进行了修改如果修改了执行，即上全局变量指向了一个新的地方，那么必须使用<code>global</code>如果，仅仅是修改了指向的空间中的数据，此时不用必须使用<code>global</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---线程创建之前g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span>t1 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#延时一会，保证t1线程中的事情做完</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>线程创建之前g_num <span class="token keyword">is</span> <span class="token number">100</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">103</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">103</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="列表当做实参传递到线程中"><a href="#列表当做实参传递到线程中" class="headerlink" title="列表当做实参传递到线程中"></a>列表当做实参传递到线程中</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1---"</span><span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#延时一会，保证t1线程中的事情做完</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2---"</span><span class="token punctuation">,</span>nums<span class="token punctuation">)</span>g_nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">]</span>t1 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>g_nums<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>g_nums<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据</li><li>缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）</li></ul><h1 id="多线程-共享全局变量问题"><a href="#多线程-共享全局变量问题" class="headerlink" title="多线程-共享全局变量问题"></a>多线程-共享全局变量问题</h1><h3 id="多线程开发可能遇到的问题"><a href="#多线程开发可能遇到的问题" class="headerlink" title="多线程开发可能遇到的问题"></a>多线程开发可能遇到的问题</h3><p>假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。</p><p>但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li>在g_num&#x3D;0时，t1取得g_num&#x3D;0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num&#x3D;0</li><li>然后t2对得到的值进行加1并赋给g_num，使得g_num&#x3D;1</li><li>然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</li><li>这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num&#x3D;1</li></ol><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---线程创建之前g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span>t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2个线程对同一个全局变量操作之后的最终结果是:%s"</span> <span class="token operator">%</span> g_num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>线程创建之前g_num <span class="token keyword">is</span> <span class="token number">0</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">100</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">200</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">2</span>个线程对同一个全局变量操作之后的最终结果是<span class="token punctuation">:</span><span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---线程创建之前g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span>t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2个线程对同一个全局变量操作之后的最终结果是:%s"</span> <span class="token operator">%</span> g_num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>线程创建之前g_num <span class="token keyword">is</span> <span class="token number">0</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">1088005</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">1286202</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">2</span>个线程对同一个全局变量操作之后的最终结果是<span class="token punctuation">:</span><span class="token number">1286202</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>&#x3D;&#x3D;如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确&#x3D;&#x3D;</li></ul><h1 id="同步的概念"><a href="#同步的概念" class="headerlink" title="同步的概念"></a>同步的概念</h1><p>同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。</p><p>“同”字从字面上容易理解为一起动作</p><p>其实不是，”同”字应是指协同、协助、互相配合。</p><p>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。</p><h4 id="解决线程同时修改全局变量的方式"><a href="#解决线程同时修改全局变量的方式" class="headerlink" title="解决线程同时修改全局变量的方式"></a>解决线程同时修改全局变量的方式</h4><p>对于上一小节提出的那个计算错误的问题，可以通过线程同步来进行解决</p><p>思路，如下:</p><ol><li>系统调用t1，然后获取到g_num的值为0，此时上一把锁，即不允许其他线程操作g_num</li><li>t1对g_num的值进行+1</li><li>t1解锁，此时g_num的值为1，其他的线程就可以使用g_num了，而且是g_num的值不是0而是1</li><li>同理其他线程在对g_num进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性</li></ol><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</p><p>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。</p><p>互斥锁为资源引入一个状态：锁定&#x2F;非锁定</p><p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319213103.png" alt="img" loading="lazy"></p><p>threading模块中定义了Lock类，可以方便的处理锁定：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建锁</span>mutex <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 锁定</span>mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 释放</span>mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><ul><li>如果这个锁之前是没有上锁的，那么acquire不会堵塞</li><li>如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止</li></ul><h4 id="使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"><a href="#使用互斥锁完成2个线程对同一个全局变量各加100万次的操作" class="headerlink" title="使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"></a>使用互斥锁完成2个线程对同一个全局变量各加100万次的操作</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 上锁</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>        mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 解锁</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---test1---g_num=%d"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 上锁</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>        mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 解锁</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---test2---g_num=%d"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token comment"># 创建一个互斥锁</span><span class="token comment"># 默认是未上锁的状态</span>mutex <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 创建2个线程，让他们各自对g_num加1000000次</span>p1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>test1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>p2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>test2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 等待计算完成</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2个线程对同一个全局变量操作之后的最终结果是:%s"</span> <span class="token operator">%</span> g_num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>test1<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>g_num<span class="token operator">=</span><span class="token number">1909909</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>test2<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>g_num<span class="token operator">=</span><span class="token number">2000000</span><span class="token number">2</span>个线程对同一个全局变量操作之后的最终结果是<span class="token punctuation">:</span><span class="token number">2000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到最后的结果，加入互斥锁后，其结果与预期相符。</p><h2 id="上锁解锁过程"><a href="#上锁解锁过程" class="headerlink" title="上锁解锁过程"></a>上锁解锁过程</h2><p>当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。</p><p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</p><p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>锁的好处：</p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li></ul><p>锁的坏处：</p><ul><li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li><li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>现实社会中，男女双方都在等待对方先道歉</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215542.png" alt="img" loading="lazy"></p><p>如果双方都这样固执的等待对方先开口，弄不好，就分搜了</p><h3 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p><p>尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对mutexA上锁</span>        mutexA<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># mutexA上锁后，延时1秒，等待另外那个线程 把mutexB上锁</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do1---up----'</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了</span>        mutexB<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do1---down----'</span><span class="token punctuation">)</span>        mutexB<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 对mutexA解锁</span>        mutexA<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对mutexB上锁</span>        mutexB<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># mutexB上锁后，延时1秒，等待另外那个线程 把mutexA上锁</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do2---up----'</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了</span>        mutexA<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do2---down----'</span><span class="token punctuation">)</span>        mutexA<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 对mutexB解锁</span>        mutexB<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>mutexA <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>mutexB <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    t1 <span class="token operator">=</span> MyThread1<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2 <span class="token operator">=</span> MyThread2<span class="token punctuation">(</span><span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果： </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215630.gif" alt="img" loading="lazy"></p><p>此时已经进入到了死锁状态，可以使用ctrl-c退出</p><h3 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2. 避免死锁"></a>2. 避免死锁</h3><ul><li>程序设计时要尽量避免（银行家算法）</li><li>添加超时时间等</li></ul><h3 id="附录-银行家算法"><a href="#附录-银行家算法" class="headerlink" title="附录-银行家算法"></a>附录-银行家算法</h3><p>[背景知识]</p><p>一个银行家如何将一定数目的资金安全地借给若干个客户，使这些客户既能借到钱完成要干的事，同时银行家又能收回全部资金而不至于破产，这就是银行家问题。这个问题同操作系统中资源分配问题十分相似：银行家就像一个操作系统，客户就像运行的进程，银行家的资金就是系统的资源。</p><p>[问题的描述]</p><p>一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。客户贷款是以每次一个资金单位（如1万RMB等）的方式进行的，客户在借满所需的全部单位款额之前可能会等待，但银行家须保证这种等待是有限的，可完成的。</p><p>例如：有三个客户C1，C2，C3，向银行家借款，该银行家的资金总额为10个资金单位，其中C1客户要借9各资金单位，C2客户要借3个资金单位，C3客户要借8个资金单位，总计20个资金单位。某一时刻的状态如图所示。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215638.png" alt="img" loading="lazy"></p><p>对于a图的状态，按照安全序列的要求，我们选的第一个客户应满足该客户所需的贷款小于等于银行家当前所剩余的钱款，可以看出只有C2客户能被满足：C2客户需1个资金单位，小银行家手中的2个资金单位，于是银行家把1个资金单位借给C2客户，使之完成工作并归还所借的3个资金单位的钱，进入b图。同理，银行家把4个资金单位借给C3客户，使其完成工作，在c图中，只剩一个客户C1，它需7个资金单位，这时银行家有8个资金单位，所以C1也能顺利借到钱并完成工作。最后（见图d）银行家收回全部10个资金单位，保证不赔本。那麽客户序列{C1，C2，C3}就是个安全序列，按照这个序列贷款，银行家才是安全的。否则的话，若在图b状态时，银行家把手中的4个资金单位借给了C1，则出现不安全状态：这时C1，C3均不能完成工作，而银行家手中又没有钱了，系统陷入僵持局面，银行家也不能收回投资。</p><p>综上所述，银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，……。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。</p><h1 id="案例：多任务版udp聊天器"><a href="#案例：多任务版udp聊天器" class="headerlink" title="案例：多任务版udp聊天器"></a>案例：多任务版udp聊天器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215802.png" alt="img" loading="lazy"></p><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><blockquote><ul><li>编写一个有2个线程的程序</li><li>线程1用来接收数据然后显示</li><li>线程2用来检测键盘数据然后通过udp发送数据</li></ul></blockquote><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><blockquote><ol><li>实现上述要求</li><li>总结多任务程序的特点</li></ol></blockquote><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码:"></a>参考代码:</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">send_msg</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""获取键盘数据，并将其发送给对方"""</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 1. 从键盘输入数据</span>        msg <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"\n请输入要发送的数据:"</span><span class="token punctuation">)</span>        <span class="token comment"># 2. 输入对方的ip地址</span>        dest_ip <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"\n请输入对方的ip地址:"</span><span class="token punctuation">)</span>        <span class="token comment"># 3. 输入对方的port</span>        dest_port <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"\n请输入对方的port:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 4. 发送数据</span>        udp_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>dest_ip<span class="token punctuation">,</span> dest_port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">recv_msg</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""接收数据并显示"""</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 1. 接收数据</span>        recv_msg <span class="token operator">=</span> udp_socket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token comment"># 2. 解码</span>        recv_ip <span class="token operator">=</span> recv_msg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        recv_msg <span class="token operator">=</span> recv_msg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>        <span class="token comment"># 3. 显示接收到的数据</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>%s:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>recv_ip<span class="token punctuation">)</span><span class="token punctuation">,</span> recv_msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 1. 创建套接字</span>    udp_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span>    <span class="token comment"># 2. 绑定本地信息</span>    udp_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">7890</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 3. 创建一个子线程用来接收数据</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>recv_msg<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 4. 让主线程用来检测键盘数据并且发送</span>    send_msg<span class="token punctuation">(</span>udp_socket<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多任务介绍&quot;&gt;&lt;a href=&quot;#多任务介绍&quot; class=&quot;headerlink&quot; title=&quot;多任务介绍&quot;&gt;&lt;/a&gt;多任务介绍&lt;/h1&gt;&lt;h2 id=&quot;现实生活中&quot;&gt;&lt;a href=&quot;#现实生活中&quot; class=&quot;headerlink&quot; title=&quot;现实生</summary>
      
    
    
    
    <category term="Python" scheme="http://ccsu.top/categories/Python/"/>
    
    
    <category term="线程" scheme="http://ccsu.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://ccsu.top/posts/65cd929b/"/>
    <id>http://ccsu.top/posts/65cd929b/</id>
    <published>2022-03-18T16:07:00.000Z</published>
    <updated>2022-03-18T16:14:53.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PyCharm-的初始设置（知道）"><a href="#PyCharm-的初始设置（知道）" class="headerlink" title="PyCharm 的初始设置（知道）"></a>PyCharm 的初始设置（知道）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>恢复 PyCharm 的初始设置</li><li>第一次启动 PyCharm</li><li>新建一个 Python 项目</li><li>设置 PyCharm 的字体显示</li><li>PyCharm 的升级以及其他</li></ul><p>PyCharm 的官方网站地址是：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p><h2 id="01-恢复-PyCharm-的初始设置"><a href="#01-恢复-PyCharm-的初始设置" class="headerlink" title="01. 恢复 PyCharm 的初始设置"></a>01. 恢复 PyCharm 的初始设置</h2><p><code>PyCharm</code> 的 <strong>配置信息</strong> 是保存在 <strong>用户家目录下</strong> 的 <code>.PyCharmxxxx.x</code> 目录下的，<code>xxxx.x</code> 表示当前使用的 <code>PyCharm</code> 的版本号</p><p>如果要恢复 <code>PyCharm</code> 的初始设置，可以按照以下步骤进行：</p><ul><li><ol><li>关闭正在运行的 <code>PyCharm</code></li></ol></li><li><ol start="2"><li>在终端中执行以下终端命令，删除 <code>PyCharm</code> 的配置信息目录：</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>重新启动 <code>PyCharm</code></li></ol></li></ul><h2 id="02-第一次启动-PyCharm"><a href="#02-第一次启动-PyCharm" class="headerlink" title="02. 第一次启动 PyCharm"></a>02. 第一次启动 PyCharm</h2><ol><li>导入配置信息</li><li>选择许可协议</li><li>配置初始界面</li></ol><h3 id="2-1-导入配置信息"><a href="#2-1-导入配置信息" class="headerlink" title="2.1 导入配置信息"></a>2.1 导入配置信息</h3><ul><li>在第一次启动 <code>PyCharm</code> 时，会首先提示用户是否导入 <strong>之前的配置信息</strong></li><li>如果是第一次使用，直接点击 <strong>OK</strong> 按钮</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025501.png" alt="001_PyCharm导入配置信息-w603" loading="lazy"></p><h3 id="2-2-选择许可协议"><a href="#2-2-选择许可协议" class="headerlink" title="2.2 选择许可协议"></a>2.2 选择许可协议</h3><ul><li>PyCharm 是一个付费软件，购买费用为 <strong>199$ &#x2F; 年</strong> 或者 <strong>19.90$ ／ 月</strong></li><li>不过 PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong><ul><li>下载地址是：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li></ul></li><li>商业版本会提示输入注册信息，或者选择免费评估</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025502.png" alt="002_激活许可证-w495" loading="lazy"></p><h3 id="2-3-PyCharm-的配置初始界面"><a href="#2-3-PyCharm-的配置初始界面" class="headerlink" title="2.3 PyCharm 的配置初始界面"></a>2.3 PyCharm 的配置初始界面</h3><ul><li>在初始配置界面，可以通过 <code>Editor colors and fonts</code> 选择 <strong>编辑器的配色方案</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025503.png" alt="003_PyCharm初始配置界面-w491" loading="lazy"></p><h3 id="2-4-欢迎界面"><a href="#2-4-欢迎界面" class="headerlink" title="2.4 欢迎界面"></a>2.4 欢迎界面</h3><ul><li>所有基础配置工作结束之后，就可以看到 <code>PyCharm</code> 的 <strong>欢迎界面</strong>了，通过 <strong>欢迎界面</strong> 就可以开始开发 Python 项目了</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025504.png" alt="004_PyCharm欢迎页面-w664" loading="lazy"></p><h2 id="03-新建-x2F-打开一个-Python-项目"><a href="#03-新建-x2F-打开一个-Python-项目" class="headerlink" title="03. 新建&#x2F;打开一个 Python 项目"></a>03. 新建&#x2F;打开一个 Python 项目</h2><h3 id="3-1-项目简介"><a href="#3-1-项目简介" class="headerlink" title="3.1 项目简介"></a>3.1 项目简介</h3><ul><li>开发 <strong>项目</strong> 就是开发一个 <strong>专门解决一个复杂业务功能的软件</strong></li><li>通常每 <strong>一个项目</strong> 就具有一个 <strong>独立专属的目录</strong>，用于保存 <strong>所有和项目相关的文件</strong><ul><li>一个项目通常会包含 <strong>很多源文件</strong></li></ul></li></ul><h3 id="3-2-打开-Python-项目"><a href="#3-2-打开-Python-项目" class="headerlink" title="3.2 打开 Python 项目"></a>3.2 打开 Python 项目</h3><ul><li>直接点击 <strong>Open</strong> 按钮，然后浏览到之前保存 <strong>Python 文件的目录</strong>，既可以打开项目</li><li>打开之后，会在目录下新建一个 <code>.idea</code> 的目录，用于保存 <strong>项目相关的信息</strong>，例如：<strong>解释器版本</strong>、<strong>项目包含的文件</strong>等等</li><li>第一次打开项目，需要耐心等待 <code>PyCharm</code> 对项目<strong>进行初始设置</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025505.png" alt="005_打开已有Python项目-w423" loading="lazy"></p><h4 id="设置项目使用的解释器版本"><a href="#设置项目使用的解释器版本" class="headerlink" title="设置项目使用的解释器版本"></a>设置项目使用的解释器版本</h4><ul><li>打开的目录如果不是由 <code>PyCharm</code> 建立的项目目录，<strong>有的时候</strong> 使用的解释器版本是 <code>Python 2.x</code> 的，需要<strong>单独设置解释器的版本</strong></li><li>通过 <strong>File</strong> &#x2F; <strong>Settings…</strong> 可以打开设置窗口，如下图所示：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025506.png" alt="006_选择项目的解释器版本-w975" loading="lazy"></p><h3 id="3-3-新建项目"><a href="#3-3-新建项目" class="headerlink" title="3.3 新建项目"></a>3.3 新建项目</h3><h4 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1) 命名规则"></a>1) 命名规则</h4><ul><li><p>以后 <strong>项目名</strong> 前面都以 <strong>数字编号</strong>，<strong>随着知识点递增，编号递增</strong></p><ul><li>例如：<strong>01_Python 基础</strong>、<strong>02_分支</strong>、<strong>03_循环</strong>…</li></ul></li><li><p>每个项目下的 <strong>文件名</strong> 都以 <code>hm_xx_知识点</code> 方式来命名</p><ul><li>其中 <strong>xx</strong> 是演练文件的序号</li></ul></li><li><p>注意</p><ul><li><ol><li>命名文件名时建议只使用 <strong>小写字母</strong>、<strong>数字</strong> 和 <strong>下划线</strong></li></ol></li><li><ol start="2"><li><strong>文件名不能以数字开始</strong></li></ol></li></ul></li><li><p>通过 <strong>欢迎界面</strong> 或者菜单 <strong>File</strong> &#x2F; <strong>New Project</strong> 可以新建项目</p></li></ul><h4 id="2-演练步骤"><a href="#2-演练步骤" class="headerlink" title="2) 演练步骤"></a>2) 演练步骤</h4><ul><li>新建 <code>01_Python基础</code> 项目，使用 <strong>Python 3.x 解释器</strong></li><li>在项目下新建 <code>hm_01_hello.py</code> Python 文件</li><li>编写 <code>print(&quot;Hello Python&quot;)</code> 代码</li></ul><h2 id="04-设置-PyCharm-的字体显示"><a href="#04-设置-PyCharm-的字体显示" class="headerlink" title="04. 设置 PyCharm 的字体显示"></a>04. 设置 PyCharm 的字体显示</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025507.png" alt="007_PyCharm设置编辑器字体-w500" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025508.png" alt="008_PyCharm设置控制台字体-w500" loading="lazy"></p><h2 id="05-PyCharm-的升级以及其他"><a href="#05-PyCharm-的升级以及其他" class="headerlink" title="05. PyCharm 的升级以及其他"></a>05. PyCharm 的升级以及其他</h2><blockquote><p>PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong></p></blockquote><ul><li>教育版下载地址：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li><li>专业版下载地址：<a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></li></ul><h3 id="5-1-安装和启动步骤"><a href="#5-1-安装和启动步骤" class="headerlink" title="5.1 安装和启动步骤"></a>5.1 安装和启动步骤</h3><ul><li><ol><li>执行以下终端命令，解压缩下载后的安装包</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">tar</span> -zxvf pycharm-professional-2017.1.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>将解压缩后的目录移动到 <code>/opt</code> 目录下，可以方便其他用户使用</li></ol></li></ul><blockquote><p><code>/opt</code> 目录用户存放给主机额外安装的软件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-2017.1.3/ /opt/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>切换工作目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /opt/pycharm-2017.1.3/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="4"><li>启动 <code>PyCharm</code></li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-设置专业版启动图标"><a href="#5-2-设置专业版启动图标" class="headerlink" title="5.2 设置专业版启动图标"></a>5.2 设置专业版启动图标</h3><ul><li>在<strong>专业版</strong>中，选择菜单 <strong>Tools</strong> &#x2F; <strong>Create Desktop Entry…</strong> 可以设置任务栏启动图标<ul><li>注意：设置图标时，需要勾选 <code>Create the entry for all users</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025509.png" alt="009_创建桌面图标-w657" loading="lazy"></p><h3 id="5-3-卸载之前版本的-PyCharm"><a href="#5-3-卸载之前版本的-PyCharm" class="headerlink" title="5.3 卸载之前版本的 PyCharm"></a>5.3 卸载之前版本的 PyCharm</h3><h4 id="1-程序安装"><a href="#1-程序安装" class="headerlink" title="1) 程序安装"></a>1) 程序安装</h4><ul><li><ol><li><p><strong>程序文件目录</strong> </p><ul><li>将安装包解压缩，并且移动到 <code>/opt</code> 目录下</li><li><strong>所有的相关文件都保存在解压缩的目录中</strong></li></ul></li></ol></li><li><ol start="2"><li><p><strong>配置文件目录</strong></p><ul><li>启动 <code>PyCharm</code> 后，会在用户家目录下建立一个 <code>.PyCharmxxx</code> 的隐藏目录</li><li><strong>保存 <code>PyCharm</code> 相关的配置信息</strong></li></ul></li></ol></li><li><ol start="3"><li><p><strong>快捷方式文件</strong></p><ul><li><code>/usr/share/applications/jetbrains-pycharm.desktop</code></li></ul></li></ol></li></ul><blockquote><p>在 <code>ubuntu</code> 中，应用程序启动的快捷方式通常都保存在 <code>/usr/share/applications</code> 目录下</p></blockquote><h4 id="2-程序卸载"><a href="#2-程序卸载" class="headerlink" title="2) 程序卸载"></a>2) 程序卸载</h4><ul><li><p>要卸载 <code>PyCharm</code> 只需要做以下两步工作：</p></li><li><ol><li>删除解压缩目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">rm</span> -r /opt/pycharm-2016.3.1/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>删除家目录下用于保存配置信息的隐藏目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果不再使用 PyCharm 还需要将 <code>/usr/share/applications/</code> 下的 <code>jetbrains-pycharm.desktop</code> 删掉</p></blockquote><h3 id="5-4-教育版安装演练"><a href="#5-4-教育版安装演练" class="headerlink" title="5.4 教育版安装演练"></a>5.4 教育版安装演练</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 解压缩下载后的安装包</span>$ <span class="token function">tar</span> -zxvf pycharm-edu-3.5.1.tar.gz<span class="token comment"># 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用</span>$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-edu-3.5.1/ /opt/<span class="token comment"># 3. 启动 `PyCharm`</span>/opt/pycharm-edu-3.5.1/bin/pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>后续课程<strong>都使用专业版本演练</strong></p></blockquote><h4 id="设置启动图标"><a href="#设置启动图标" class="headerlink" title="设置启动图标"></a>设置启动图标</h4><ul><li><ol><li>编辑快捷方式文件</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> gedit /usr/share/applications/jetbrains-pycharm.desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>按照以下内容修改文件内容，需要注意<strong>指定正确的 <code>pycharm</code> 目录</strong></li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">[Desktop Entry]Version&#x3D;1.0Type&#x3D;ApplicationName&#x3D;PyCharmIcon&#x3D;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.pngExec&#x3D;&quot;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.sh&quot; %fComment&#x3D;The Drive to DevelopCategories&#x3D;Development;IDE;Terminal&#x3D;falseStartupWMClass&#x3D;jetbrains-pycharm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="认识-Python"><a href="#认识-Python" class="headerlink" title="认识 Python"></a>认识 Python</h1><blockquote><p>人生苦短，我用 Python —— Life is short, you need Python</p></blockquote><p><img src="J:/02-%25E6%25AF%2595%25E8%25AE%25BE/2018%25E5%25B9%25B4%25E4%25BC%25A0%25E6%2599%25BA%25E6%2592%25AD%25E5%25AE%25A2%25E9%25BB%2591%25E9%25A9%25ACpython+%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD%252015%25E6%259C%259F/%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD-%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD%25E8%25AF%25BE%25E4%25BB%25B6%25E8%25B5%2584%25E6%2596%2599%2520-1-4%25E4%25BD%258D%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD%2520%25205-14%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD/02python%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BC%2596%25E7%25A8%258B%25E9%2598%25B6%25E6%25AE%25B5-python%25E5%259F%25BA%25E7%25A1%2580/%25E8%25AF%25BE%25E4%25BB%25B6/day02_markdown/media/14950329208518/001_%25E4%25BA%25BA%25E7%2594%259F%25E8%258B%25A6%25E7%259F%25AD%25E6%2588%2591%25E7%2594%25A8python.jpg" alt="001_人生苦短我用python" loading="lazy"></p><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li>Python 的起源</li><li>为什么要用 Python？</li><li>Python 的特点</li><li>Python 的优缺点</li></ul><h2 id="01-Python-的起源"><a href="#01-Python-的起源" class="headerlink" title="01. Python 的起源"></a>01. Python 的起源</h2><blockquote><p>Python 的创始人为吉多·范罗苏姆（Guido van Rossum）</p></blockquote><p><img src="J:/02-%25E6%25AF%2595%25E8%25AE%25BE/2018%25E5%25B9%25B4%25E4%25BC%25A0%25E6%2599%25BA%25E6%2592%25AD%25E5%25AE%25A2%25E9%25BB%2591%25E9%25A9%25ACpython+%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD%252015%25E6%259C%259F/%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD-%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD%25E8%25AF%25BE%25E4%25BB%25B6%25E8%25B5%2584%25E6%2596%2599%2520-1-4%25E4%25BD%258D%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD%2520%25205-14%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD/02python%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BC%2596%25E7%25A8%258B%25E9%2598%25B6%25E6%25AE%25B5-python%25E5%259F%25BA%25E7%25A1%2580/%25E8%25AF%25BE%25E4%25BB%25B6/day02_markdown/media/14950329208518/002_%25E5%2590%2589%25E5%25A4%259A.jpg" alt="002_吉多-w256" loading="lazy"></p><ol><li>1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的<strong>解释程序</strong>，作为 ABC 语言的一种继承（<strong>感觉下什么叫牛人</strong>）</li><li>ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是<strong>专门为非专业程序员设计的</strong>。但是 ABC 语言并没有成功，究其原因，吉多认为是<strong>非开放</strong>造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果</li><li>之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）的爱好者</li><li>1991 年，第一个 Python <strong>解释器</strong> 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件</li></ol><h3 id="1-1-解释器（科普）"><a href="#1-1-解释器（科普）" class="headerlink" title="1.1 解释器（科普）"></a>1.1 解释器（科普）</h3><p><strong>计算机不能直接理解任何除机器语言以外的语言</strong>，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。<strong>将其他语言翻译成机器语言的工具，被称为编译器</strong></p><p>编译器翻译的方式有两种：一个是<strong>编译</strong>，另外一个是<strong>解释</strong>。两种方式之间的区别在于<strong>翻译时间点的不同</strong>。当编译器<strong>以解释方式运行的时候</strong>，也称之为<strong>解释器</strong></p><p><img src="J:/02-%25E6%25AF%2595%25E8%25AE%25BE/2018%25E5%25B9%25B4%25E4%25BC%25A0%25E6%2599%25BA%25E6%2592%25AD%25E5%25AE%25A2%25E9%25BB%2591%25E9%25A9%25ACpython+%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD%252015%25E6%259C%259F/%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD-%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD%25E8%25AF%25BE%25E4%25BB%25B6%25E8%25B5%2584%25E6%2596%2599%2520-1-4%25E4%25BD%258D%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD%2520%25205-14%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD/02python%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BC%2596%25E7%25A8%258B%25E9%2598%25B6%25E6%25AE%25B5-python%25E5%259F%25BA%25E7%25A1%2580/%25E8%25AF%25BE%25E4%25BB%25B6/day02_markdown/media/14950329208518/001_%25E7%25BC%2596%25E8%25AF%2591%25E5%259E%258B%25E5%2592%258C%25E8%25A7%25A3%25E9%2587%258A%25E5%259E%258B%25E8%25AF%25AD%25E8%25A8%2580%25E5%25B7%25A5%25E4%25BD%259C%25E5%25AF%25B9%25E6%25AF%2594.png" alt="001_编译型和解释型语言工作对比-w360" loading="lazy"></p><ul><li><strong>编译型语言</strong>：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++</li><li><strong>解释型语言</strong>：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行</li></ul><h4 id="编译型语言和解释型语言对比"><a href="#编译型语言和解释型语言对比" class="headerlink" title="编译型语言和解释型语言对比"></a>编译型语言和解释型语言对比</h4><ul><li><strong>速度</strong> —— 编译型语言比解释型语言执行速度快</li><li><strong>跨平台性</strong> —— 解释型语言比编译型语言跨平台性好</li></ul><h3 id="1-2-Python-的设计目标"><a href="#1-2-Python-的设计目标" class="headerlink" title="1.2 Python 的设计目标"></a>1.2 Python 的设计目标</h3><p>1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标：</p><ul><li>一门<strong>简单直观的语言</strong>并与主要竞争者一样强大</li><li><strong>开源</strong>，以便任何人都可以为它做贡献</li><li>代码<strong>像纯英语那样容易理解</strong></li><li>适用于<strong>短期</strong>开发的日常任务</li></ul><p>这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言</p><h3 id="1-3-Python-的设计哲学"><a href="#1-3-Python-的设计哲学" class="headerlink" title="1.3 Python 的设计哲学"></a>1.3 Python 的设计哲学</h3><ol><li>优雅</li><li>明确</li><li>简单</li></ol><p>在 Python 解释器内运行 <code>import this</code> 可以获得完整的列表 </p><ul><li>Python 开发者的哲学是：<strong>用一种方法，最好是只有一种方法来做一件事</strong></li><li>如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择<strong>明确没有或者很少有歧义的语法</strong></li></ul><blockquote><p>在 Python 社区，吉多被称为“仁慈的独裁者”</p></blockquote><h2 id="02-为什么选择-Python？"><a href="#02-为什么选择-Python？" class="headerlink" title="02. 为什么选择 Python？"></a>02. 为什么选择 Python？</h2><ul><li>代码量少</li><li>……</li></ul><blockquote><p>同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 <code>Python</code> 是 <code>Java</code> 的 <strong>1&#x2F;5</strong>，所以说 <strong>人生苦短，我用 Python</strong></p></blockquote><h2 id="03-Python-特点"><a href="#03-Python-特点" class="headerlink" title="03. Python 特点"></a>03. Python 特点</h2><ul><li>Python 是<strong>完全面向对象的语言</strong><ul><li><strong>函数</strong>、<strong>模块</strong>、<strong>数字</strong>、<strong>字符串</strong>都是对象，<strong>在 Python 中一切皆对象</strong></li><li>完全支持继承、重载、多重继承</li><li>支持重载运算符，也支持泛型设计</li></ul></li><li>Python <strong>拥有一个强大的标准库</strong>，Python 语言的核心只包含 <strong>数字</strong>、<strong>字符串</strong>、<strong>列表</strong>、<strong>字典</strong>、<strong>文件</strong> 等常见类型和函数，而由 Python 标准库提供了 <strong>系统管理</strong>、<strong>网络通信</strong>、<strong>文本处理</strong>、<strong>数据库接口</strong>、<strong>图形系统</strong>、<strong>XML 处理</strong> 等额外的功能</li><li>Python 社区提供了<strong>大量的第三方模块</strong>，使用方式与标准库类似。它们的功能覆盖 <strong>科学计算</strong>、<strong>人工智能</strong>、<strong>机器学习</strong>、<strong>Web 开发</strong>、<strong>数据库接口</strong>、<strong>图形系统</strong> 多个领域</li></ul><h3 id="面向对象的思维方式"><a href="#面向对象的思维方式" class="headerlink" title="面向对象的思维方式"></a>面向对象的思维方式</h3><ul><li><strong>面向对象</strong> 是一种 <strong>思维方式</strong>，也是一门 <strong>程序设计技术</strong></li><li>要解决一个问题前，首先考虑 <strong>由谁</strong> 来做，怎么做事情是 <strong>谁</strong> 的职责，最后把事情做好就行！<ul><li><strong>对象</strong> 就是 <strong>谁</strong></li></ul></li><li>要解决复杂的问题，就可以找<strong>多个不同的对象</strong>，<strong>各司其职</strong>，共同实现，最终完成需求</li></ul><h2 id="04-Python-的优缺点"><a href="#04-Python-的优缺点" class="headerlink" title="04. Python 的优缺点"></a>04. Python 的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><ul><li>简单、易学</li><li>免费、开源</li><li><strong>面向对象</strong></li><li>丰富的库</li><li>可扩展性<ul><li>如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 <code>C</code> 或 <code>C++</code> 编写，然后在 <code>Python</code> 程序中使用它们</li></ul></li><li>……</li></ul><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><ul><li>运行速度</li><li>国内市场较小</li><li>中文资料匮乏</li></ul><h1 id="第一个-Python-程序"><a href="#第一个-Python-程序" class="headerlink" title="第一个 Python 程序"></a>第一个 Python 程序</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ul><li>第一个 <code>HelloPython</code> 程序</li><li><code>Python 2.x</code> 与 <code>3​​.x</code> 版本简介</li><li>执行 <code>Python</code> 程序的三种方式<ul><li>解释器 —— <code>python</code> &#x2F; <code>python3</code></li><li>交互式 —— <code>ipython</code></li><li>集成开发环境 —— <code>PyCharm</code></li></ul></li></ul><h2 id="01-第一个-HelloPython-程序"><a href="#01-第一个-HelloPython-程序" class="headerlink" title="01. 第一个 HelloPython 程序"></a>01. 第一个 <code>HelloPython</code> 程序</h2><h3 id="1-1-Python-源程序的基本概念"><a href="#1-1-Python-源程序的基本概念" class="headerlink" title="1.1 Python 源程序的基本概念"></a>1.1 Python 源程序的基本概念</h3><ol><li>Python 源程序就是<strong>一个特殊格式的文本文件</strong>，可以<strong>使用任意文本编辑软件</strong>做 <code>Python</code> 的开发</li><li>Python 程序的 <strong>文件扩展名</strong> 通常都是 <code>.py</code></li></ol><h3 id="1-2-演练步骤"><a href="#1-2-演练步骤" class="headerlink" title="1.2 演练步骤"></a>1.2 演练步骤</h3><ul><li>在桌面下，新建 <code>认识Python</code> 目录</li><li>在 <code>认识Python</code> 目录下新建 <code>01-HelloPython.py</code> 文件</li><li>使用 <strong>gedit</strong> 编辑 <code>01-HelloPython.py</code> 并且输入以下内容：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在终端中输入以下命令执行 <code>01-HelloPython.py</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python 01-HelloPython.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>print</code> 是 <code>python</code> 中我们学习的第一个 <strong>函数</strong></p><p><code>print</code> 函数的作用，可以把 <strong>“”</strong> 内部的内容，输出到屏幕上</p></blockquote><h3 id="1-3-演练扩展-——-认识错误（BUG）"><a href="#1-3-演练扩展-——-认识错误（BUG）" class="headerlink" title="1.3 演练扩展 —— 认识错误（BUG）"></a>1.3 演练扩展 —— 认识错误（BUG）</h3><h4 id="关于错误"><a href="#关于错误" class="headerlink" title="关于错误"></a>关于错误</h4><ul><li>编写的程序<strong>不能正常执行</strong>，或者<strong>执行的结果不是我们期望的</strong></li><li>俗称 <code>BUG</code>，是程序员在开发时非常常见的，初学者常见错误的原因包括：<ol><li>手误</li><li>对已经学习过的知识理解还存在不足</li><li>对语言还有需要学习和提升的内容</li></ol></li><li>在学习语言时，不仅要<strong>学会语言的语法</strong>，而且还要<strong>学会如何认识错误和解决错误的方法</strong></li></ul><blockquote><p>每一个程序员都是在不断地修改错误中成长的</p></blockquote><h4 id="第一个演练中的常见错误"><a href="#第一个演练中的常见错误" class="headerlink" title="第一个演练中的常见错误"></a>第一个演练中的常见错误</h4><ul><li>1&gt; <strong>手误</strong>，例如使用 <code>pirnt(&quot;Hello world&quot;)</code></li></ul><pre class="line-numbers language-none"><code class="language-none">NameError: name &#39;pirnt&#39; is not defined名称错误：&#39;pirnt&#39; 名字没有定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>2&gt; 将多条 <code>print</code> 写在一行</li></ul><pre class="line-numbers language-none"><code class="language-none">SyntaxError: invalid syntax语法错误：语法无效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>每行代码负责完成一个动作</p></blockquote><ul><li>3&gt; 缩进错误</li></ul><pre class="line-numbers language-none"><code class="language-none">IndentationError: unexpected indent缩进错误：不期望出现的缩进<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>Python 是一个格式非常严格的程序设计语言</li><li>目前而言，大家记住每行代码前面都不要增加空格</li></ul></blockquote><ul><li>4&gt; <strong>python 2.x 默认不支持中文</strong></li></ul><p>目前市场上有两个 Python 的版本并存着，分别是 <code>Python 2.x</code> 和 <code>Python 3.x</code></p><ul><li><strong>Python 2.x 默认不支持中文</strong>，具体原因，等到介绍 <strong>字符编码</strong> 时给大家讲解</li><li>Python 2.x 的解释器名称是 <strong>python</strong></li><li>Python 3.x 的解释器名称是 <strong>python3</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">SyntaxError: Non-ASCII character &#39;\xe4&#39; in file 01-HelloPython.py on line 3, but no encoding declared; see http:&#x2F;&#x2F;python.org&#x2F;dev&#x2F;peps&#x2F;pep-0263&#x2F; for details语法错误： 在 01-HelloPython.py 中第 3 行出现了非 ASCII 字符 &#39;\xe4&#39;，但是没有声明文件编码请访问 http:&#x2F;&#x2F;python.org&#x2F;dev&#x2F;peps&#x2F;pep-0263&#x2F; 了解详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><code>ASCII</code> 字符只包含 <code>256</code> 个字符，不支持中文</li><li>有关字符编码的问题，后续会讲</li></ul></blockquote><h4 id="单词列表"><a href="#单词列表" class="headerlink" title="单词列表"></a>单词列表</h4><pre class="line-numbers language-none"><code class="language-none">* error 错误* name 名字* defined 已经定义* syntax 语法* invalid 无效* Indentation 索引* unexpected 意外的，不期望的* character 字符* line 行* encoding 编码* declared 声明* details 细节，详细信息* ASCII 一种字符编码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-Python-2-x-与-3​​-x-版本简介"><a href="#02-Python-2-x-与-3​​-x-版本简介" class="headerlink" title="02. Python 2.x 与 3​​.x 版本简介"></a>02. <code>Python 2.x</code> 与 <code>3​​.x</code> 版本简介</h2><p>目前市场上有两个 Python 的版本并存着，分别是 <code>Python 2.x</code> 和 <code>Python 3.x</code></p><blockquote><p>新的 Python 程序建议使用 <code>Python 3.0</code> 版本的语法</p></blockquote><ul><li>Python 2.x 是 <strong>过去的版本</strong><ul><li>解释器名称是 <strong>python</strong></li></ul></li><li>Python 3.x 是 <strong>现在和未来 主流的版本</strong><ul><li>解释器名称是 <strong>python3</strong></li><li>相对于 <code>Python</code> 的早期版本，这是一个 <strong>较大的升级</strong></li><li>为了不带入过多的累赘，<code>Python 3.0</code> 在设计的时候 <strong>没有考虑向下兼容</strong><ul><li>许多早期 <code>Python</code> 版本设计的程序都无法在 <code>Python 3.0</code> 上正常执行</li></ul></li><li>Python 3.0 发布于 <strong>2008 年</strong></li><li>到目前为止，Python 3.0 的稳定版本已经有很多年了<ul><li>Python 3.3 发布于 2012</li><li>Python 3.4 发布于 2014</li><li>Python 3.5 发布于 2015</li><li>Python 3.6 发布于 2016</li></ul></li></ul></li><li>为了照顾现有的程序，官方提供了一个过渡版本 —— <strong>Python 2.6</strong><ul><li>基本使用了 <code>Python 2.x</code> 的语法和库</li><li>同时考虑了向 <code>Python 3.0</code> 的迁移，<strong>允许使用部分</strong> <code>Python 3.0</code> 的语法与函数</li><li>2010 年中推出的 <code>Python 2.7</code> 被确定为 <strong>最后一个Python 2.x 版本</strong></li></ul></li></ul><blockquote><p>提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议</p><ul><li>先使用 <code>Python 3.0</code> 版本进行开发</li><li>然后使用 <code>Python 2.6</code>、<code>Python 2.7</code> 来执行，并且做一些兼容性的处理</li></ul></blockquote><h2 id="03-执行-Python-程序的三种方式"><a href="#03-执行-Python-程序的三种方式" class="headerlink" title="03. 执行 Python 程序的三种方式"></a>03. 执行 Python 程序的三种方式</h2><h3 id="3-1-解释器-python-x2F-python3"><a href="#3-1-解释器-python-x2F-python3" class="headerlink" title="3.1. 解释器 python &#x2F; python3"></a>3.1. 解释器 <code>python</code> &#x2F; <code>python3</code></h3><h4 id="Python-的解释器"><a href="#Python-的解释器" class="headerlink" title="Python 的解释器"></a>Python 的解释器</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 python 2.x 解释器</span>$ python xxx.py<span class="token comment"># 使用 python 3.x 解释器</span>$ python3 xxx.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="其他解释器（知道）"><a href="#其他解释器（知道）" class="headerlink" title="其他解释器（知道）"></a>其他解释器（知道）</h5><p><strong>Python 的解释器</strong> 如今有多个语言的实现，包括：</p><ul><li><code>CPython</code> —— 官方版本的 C 语言实现</li><li><code>Jython</code> —— 可以运行在 Java 平台</li><li><code>IronPython</code> —— 可以运行在 .NET 和 Mono 平台</li><li><code>PyPy</code> —— Python 实现的，支持 JIT 即时编译</li></ul><h3 id="3-2-交互式运行-Python-程序"><a href="#3-2-交互式运行-Python-程序" class="headerlink" title="3.2. 交互式运行 Python 程序"></a>3.2. 交互式运行 Python 程序</h3><ul><li>直接在终端中运行解释器，而不输入要执行的文件名</li><li>在 Python 的 <code>Shell</code> 中直接输入 <strong>Python 的代码</strong>，会立即看到程序执行结果</li></ul><h4 id="1-交互式运行-Python-的优缺点"><a href="#1-交互式运行-Python-的优缺点" class="headerlink" title="1) 交互式运行 Python 的优缺点"></a>1) 交互式运行 Python 的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>适合于学习&#x2F;验证 Python 语法或者局部代码</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>代码不能保存</li><li>不适合运行太大的程序</li></ul><h4 id="2-退出-官方的解释器"><a href="#2-退出-官方的解释器" class="headerlink" title="2) 退出 官方的解释器"></a>2) 退出 官方的解释器</h4><h5 id="1-gt-直接输入-exit"><a href="#1-gt-直接输入-exit" class="headerlink" title="1&gt; 直接输入 exit()"></a>1&gt; 直接输入 <code>exit()</code></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-gt-使用热键退出"><a href="#2-gt-使用热键退出" class="headerlink" title="2&gt; 使用热键退出"></a>2&gt; 使用热键退出</h5><p>在 python 解释器中，按热键 <code>ctrl + d</code> 可以退出解释器</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000129.jpg" alt="001_积跬步以至千里" loading="lazy"></p><h4 id="3-IPython"><a href="#3-IPython" class="headerlink" title="3) IPython"></a>3) IPython</h4><ul><li>IPython 中 的 “I” 代表 <strong>交互 interactive</strong></li></ul><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>IPython 是一个 python 的 <strong>交互式 shell</strong>，比默认的 <code>python shell</code> 好用得多<ul><li>支持自动补全</li><li>自动缩进</li><li>支持 <code>bash shell</code> 命令</li><li>内置了许多很有用的功能和函数</li></ul></li><li>IPython 是基于 BSD 开源的</li></ul><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><ul><li><p>Python 2.x 使用的解释器是 <strong>ipython</strong></p></li><li><p>Python 3.x 使用的解释器是 <strong>ipython3</strong></p></li><li><p>要退出解释器可以有以下两种方式：</p></li></ul><h5 id="1-gt-直接输入-exit-1"><a href="#1-gt-直接输入-exit-1" class="headerlink" title="1&gt; 直接输入 exit"></a>1&gt; 直接输入 <code>exit</code></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-gt-使用热键退出-1"><a href="#2-gt-使用热键退出-1" class="headerlink" title="2&gt; 使用热键退出"></a>2&gt; 使用热键退出</h5><p>在 IPython 解释器中，按热键 <code>ctrl + d</code>，<code>IPython</code> 会询问是否退出解释器</p><h4 id="IPython-的安装"><a href="#IPython-的安装" class="headerlink" title="IPython 的安装"></a>IPython 的安装</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ipython<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-3-Python-的-IDE-——-PyCharm"><a href="#3-3-Python-的-IDE-——-PyCharm" class="headerlink" title="3.3. Python 的 IDE —— PyCharm"></a>3.3. Python 的 IDE —— <code>PyCharm</code></h2><h3 id="1）-集成开发环境（IDE）"><a href="#1）-集成开发环境（IDE）" class="headerlink" title="1） 集成开发环境（IDE）"></a>1） 集成开发环境（IDE）</h3><p>集成开发环境（<code>IDE</code>，Integrated Development Environment）—— <strong>集成了开发软件需要的所有工具</strong>，一般包括以下工具：</p><ul><li>图形用户界面</li><li>代码编辑器（支持 <strong>代码补全</strong>／<strong>自动缩进</strong>）</li><li>编译器／解释器</li><li>调试器（<strong>断点</strong>／<strong>单步执行</strong>）</li><li>……</li></ul><h3 id="2）PyCharm-介绍"><a href="#2）PyCharm-介绍" class="headerlink" title="2）PyCharm 介绍"></a>2）PyCharm 介绍</h3><ul><li><code>PyCharm</code> 是 Python 的一款非常优秀的集成开发环境</li><li><code>PyCharm</code> 除了具有一般 IDE 所必备功能外，还可以在 <code>Windows</code>、<code>Linux</code>、<code>macOS</code> 下使用</li><li><code>PyCharm</code> 适合开发大型项目<ul><li>一个项目通常会包含 <strong>很多源文件</strong></li><li>每个 <strong>源文件</strong> 的代码行数是有限的，通常在几百行之内</li><li>每个 <strong>源文件</strong> 各司其职，共同完成复杂的业务功能</li></ul></li></ul><h3 id="3）PyCharm-快速体验"><a href="#3）PyCharm-快速体验" class="headerlink" title="3）PyCharm 快速体验"></a>3）PyCharm 快速体验</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000130.png" alt="001_PyCharm的界面结构" loading="lazy"></p><ul><li><strong>文件导航区域</strong> 能够 <strong>浏览</strong>／<strong>定位</strong>／<strong>打开</strong> 项目文件</li><li><strong>文件编辑区域</strong> 能够 <strong>编辑</strong> 当前打开的文件</li><li><strong>控制台区域</strong> 能够：<ul><li>输出程序执行内容</li><li>跟踪调试代码的执行</li></ul></li><li>右上角的 <strong>工具栏</strong> 能够 <strong>执行(SHIFT + F10)</strong> &#x2F; <strong>调试(SHIFT + F9)</strong> 代码</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000131.png" alt="002_PyCharm运行工具栏" loading="lazy"></p><ul><li>通过控制台上方的**单步执行按钮(F8)**，可以单步执行代码</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000132.png" alt="003_PyCharm调试器" loading="lazy"></p><h1 id="PyCharm-的初始设置（知道）-1"><a href="#PyCharm-的初始设置（知道）-1" class="headerlink" title="PyCharm 的初始设置（知道）"></a>PyCharm 的初始设置（知道）</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><ul><li>恢复 PyCharm 的初始设置</li><li>第一次启动 PyCharm</li><li>新建一个 Python 项目</li><li>设置 PyCharm 的字体显示</li><li>PyCharm 的升级以及其他</li></ul><p>PyCharm 的官方网站地址是：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p><h2 id="01-恢复-PyCharm-的初始设置-1"><a href="#01-恢复-PyCharm-的初始设置-1" class="headerlink" title="01. 恢复 PyCharm 的初始设置"></a>01. 恢复 PyCharm 的初始设置</h2><p><code>PyCharm</code> 的 <strong>配置信息</strong> 是保存在 <strong>用户家目录下</strong> 的 <code>.PyCharmxxxx.x</code> 目录下的，<code>xxxx.x</code> 表示当前使用的 <code>PyCharm</code> 的版本号</p><p>如果要恢复 <code>PyCharm</code> 的初始设置，可以按照以下步骤进行：</p><ul><li><ol><li>关闭正在运行的 <code>PyCharm</code></li></ol></li><li><ol start="2"><li>在终端中执行以下终端命令，删除 <code>PyCharm</code> 的配置信息目录：</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>重新启动 <code>PyCharm</code></li></ol></li></ul><h2 id="02-第一次启动-PyCharm-1"><a href="#02-第一次启动-PyCharm-1" class="headerlink" title="02. 第一次启动 PyCharm"></a>02. 第一次启动 PyCharm</h2><ol><li>导入配置信息</li><li>选择许可协议</li><li>配置初始界面</li></ol><h3 id="2-1-导入配置信息-1"><a href="#2-1-导入配置信息-1" class="headerlink" title="2.1 导入配置信息"></a>2.1 导入配置信息</h3><ul><li>在第一次启动 <code>PyCharm</code> 时，会首先提示用户是否导入 <strong>之前的配置信息</strong></li><li>如果是第一次使用，直接点击 <strong>OK</strong> 按钮</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235746.png" alt="001_PyCharm导入配置信息-w603" loading="lazy"></p><h3 id="2-2-选择许可协议-1"><a href="#2-2-选择许可协议-1" class="headerlink" title="2.2 选择许可协议"></a>2.2 选择许可协议</h3><ul><li>PyCharm 是一个付费软件，购买费用为 <strong>199$ &#x2F; 年</strong> 或者 <strong>19.90$ ／ 月</strong></li><li>不过 PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong><ul><li>下载地址是：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li></ul></li><li>商业版本会提示输入注册信息，或者选择免费评估</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235747.png" alt="002_激活许可证-w495" loading="lazy"></p><h3 id="2-3-PyCharm-的配置初始界面-1"><a href="#2-3-PyCharm-的配置初始界面-1" class="headerlink" title="2.3 PyCharm 的配置初始界面"></a>2.3 PyCharm 的配置初始界面</h3><ul><li>在初始配置界面，可以通过 <code>Editor colors and fonts</code> 选择 <strong>编辑器的配色方案</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235748.png" alt="003_PyCharm初始配置界面-w491" loading="lazy"></p><h3 id="2-4-欢迎界面-1"><a href="#2-4-欢迎界面-1" class="headerlink" title="2.4 欢迎界面"></a>2.4 欢迎界面</h3><ul><li>所有基础配置工作结束之后，就可以看到 <code>PyCharm</code> 的 <strong>欢迎界面</strong>了，通过 <strong>欢迎界面</strong> 就可以开始开发 Python 项目了</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235749.png" alt="004_PyCharm欢迎页面-w664" loading="lazy"></p><h2 id="03-新建-x2F-打开一个-Python-项目-1"><a href="#03-新建-x2F-打开一个-Python-项目-1" class="headerlink" title="03. 新建&#x2F;打开一个 Python 项目"></a>03. 新建&#x2F;打开一个 Python 项目</h2><h3 id="3-1-项目简介-1"><a href="#3-1-项目简介-1" class="headerlink" title="3.1 项目简介"></a>3.1 项目简介</h3><ul><li>开发 <strong>项目</strong> 就是开发一个 <strong>专门解决一个复杂业务功能的软件</strong></li><li>通常每 <strong>一个项目</strong> 就具有一个 <strong>独立专属的目录</strong>，用于保存 <strong>所有和项目相关的文件</strong><ul><li>一个项目通常会包含 <strong>很多源文件</strong></li></ul></li></ul><h3 id="3-2-打开-Python-项目-1"><a href="#3-2-打开-Python-项目-1" class="headerlink" title="3.2 打开 Python 项目"></a>3.2 打开 Python 项目</h3><ul><li>直接点击 <strong>Open</strong> 按钮，然后浏览到之前保存 <strong>Python 文件的目录</strong>，既可以打开项目</li><li>打开之后，会在目录下新建一个 <code>.idea</code> 的目录，用于保存 <strong>项目相关的信息</strong>，例如：<strong>解释器版本</strong>、<strong>项目包含的文件</strong>等等</li><li>第一次打开项目，需要耐心等待 <code>PyCharm</code> 对项目<strong>进行初始设置</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235750.png" alt="005_打开已有Python项目-w423" loading="lazy"></p><h4 id="设置项目使用的解释器版本-1"><a href="#设置项目使用的解释器版本-1" class="headerlink" title="设置项目使用的解释器版本"></a>设置项目使用的解释器版本</h4><ul><li>打开的目录如果不是由 <code>PyCharm</code> 建立的项目目录，<strong>有的时候</strong> 使用的解释器版本是 <code>Python 2.x</code> 的，需要<strong>单独设置解释器的版本</strong></li><li>通过 <strong>File</strong> &#x2F; <strong>Settings…</strong> 可以打开设置窗口，如下图所示：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235751.png" alt="006_选择项目的解释器版本-w975" loading="lazy"></p><h3 id="3-3-新建项目-1"><a href="#3-3-新建项目-1" class="headerlink" title="3.3 新建项目"></a>3.3 新建项目</h3><h4 id="1-命名规则-1"><a href="#1-命名规则-1" class="headerlink" title="1) 命名规则"></a>1) 命名规则</h4><ul><li><p>以后 <strong>项目名</strong> 前面都以 <strong>数字编号</strong>，<strong>随着知识点递增，编号递增</strong></p><ul><li>例如：<strong>01_Python 基础</strong>、<strong>02_分支</strong>、<strong>03_循环</strong>…</li></ul></li><li><p>每个项目下的 <strong>文件名</strong> 都以 <code>hm_xx_知识点</code> 方式来命名</p><ul><li>其中 <strong>xx</strong> 是演练文件的序号</li></ul></li><li><p>注意</p><ul><li><ol><li>命名文件名时建议只使用 <strong>小写字母</strong>、<strong>数字</strong> 和 <strong>下划线</strong></li></ol></li><li><ol start="2"><li><strong>文件名不能以数字开始</strong></li></ol></li></ul></li><li><p>通过 <strong>欢迎界面</strong> 或者菜单 <strong>File</strong> &#x2F; <strong>New Project</strong> 可以新建项目</p></li></ul><h4 id="2-演练步骤-1"><a href="#2-演练步骤-1" class="headerlink" title="2) 演练步骤"></a>2) 演练步骤</h4><ul><li>新建 <code>01_Python基础</code> 项目，使用 <strong>Python 3.x 解释器</strong></li><li>在项目下新建 <code>hm_01_hello.py</code> Python 文件</li><li>编写 <code>print(&quot;Hello Python&quot;)</code> 代码</li></ul><h2 id="04-设置-PyCharm-的字体显示-1"><a href="#04-设置-PyCharm-的字体显示-1" class="headerlink" title="04. 设置 PyCharm 的字体显示"></a>04. 设置 PyCharm 的字体显示</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235752.png" alt="007_PyCharm设置编辑器字体-w500" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235753.png" alt="008_PyCharm设置控制台字体-w500" loading="lazy"></p><h2 id="05-PyCharm-的升级以及其他-1"><a href="#05-PyCharm-的升级以及其他-1" class="headerlink" title="05. PyCharm 的升级以及其他"></a>05. PyCharm 的升级以及其他</h2><blockquote><p>PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong></p></blockquote><ul><li>教育版下载地址：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li><li>专业版下载地址：<a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></li></ul><h3 id="5-1-安装和启动步骤-1"><a href="#5-1-安装和启动步骤-1" class="headerlink" title="5.1 安装和启动步骤"></a>5.1 安装和启动步骤</h3><ul><li><ol><li>执行以下终端命令，解压缩下载后的安装包</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">tar</span> -zxvf pycharm-professional-2017.1.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>将解压缩后的目录移动到 <code>/opt</code> 目录下，可以方便其他用户使用</li></ol></li></ul><blockquote><p><code>/opt</code> 目录用户存放给主机额外安装的软件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-2017.1.3/ /opt/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>切换工作目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /opt/pycharm-2017.1.3/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="4"><li>启动 <code>PyCharm</code></li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-设置专业版启动图标-1"><a href="#5-2-设置专业版启动图标-1" class="headerlink" title="5.2 设置专业版启动图标"></a>5.2 设置专业版启动图标</h3><ul><li>在<strong>专业版</strong>中，选择菜单 <strong>Tools</strong> &#x2F; <strong>Create Desktop Entry…</strong> 可以设置任务栏启动图标<ul><li>注意：设置图标时，需要勾选 <code>Create the entry for all users</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235754.png" alt="009_创建桌面图标-w657" loading="lazy"></p><h3 id="5-3-卸载之前版本的-PyCharm-1"><a href="#5-3-卸载之前版本的-PyCharm-1" class="headerlink" title="5.3 卸载之前版本的 PyCharm"></a>5.3 卸载之前版本的 PyCharm</h3><h4 id="1-程序安装-1"><a href="#1-程序安装-1" class="headerlink" title="1) 程序安装"></a>1) 程序安装</h4><ul><li><ol><li><p><strong>程序文件目录</strong> </p><ul><li>将安装包解压缩，并且移动到 <code>/opt</code> 目录下</li><li><strong>所有的相关文件都保存在解压缩的目录中</strong></li></ul></li></ol></li><li><ol start="2"><li><p><strong>配置文件目录</strong></p><ul><li>启动 <code>PyCharm</code> 后，会在用户家目录下建立一个 <code>.PyCharmxxx</code> 的隐藏目录</li><li><strong>保存 <code>PyCharm</code> 相关的配置信息</strong></li></ul></li></ol></li><li><ol start="3"><li><p><strong>快捷方式文件</strong></p><ul><li><code>/usr/share/applications/jetbrains-pycharm.desktop</code></li></ul></li></ol></li></ul><blockquote><p>在 <code>ubuntu</code> 中，应用程序启动的快捷方式通常都保存在 <code>/usr/share/applications</code> 目录下</p></blockquote><h4 id="2-程序卸载-1"><a href="#2-程序卸载-1" class="headerlink" title="2) 程序卸载"></a>2) 程序卸载</h4><ul><li><p>要卸载 <code>PyCharm</code> 只需要做以下两步工作：</p></li><li><ol><li>删除解压缩目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">rm</span> -r /opt/pycharm-2016.3.1/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>删除家目录下用于保存配置信息的隐藏目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果不再使用 PyCharm 还需要将 <code>/usr/share/applications/</code> 下的 <code>jetbrains-pycharm.desktop</code> 删掉</p></blockquote><h3 id="5-4-教育版安装演练-1"><a href="#5-4-教育版安装演练-1" class="headerlink" title="5.4 教育版安装演练"></a>5.4 教育版安装演练</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 解压缩下载后的安装包</span>$ <span class="token function">tar</span> -zxvf pycharm-edu-3.5.1.tar.gz<span class="token comment"># 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用</span>$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-edu-3.5.1/ /opt/<span class="token comment"># 3. 启动 `PyCharm`</span>/opt/pycharm-edu-3.5.1/bin/pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>后续课程<strong>都使用专业版本演练</strong></p></blockquote><h4 id="设置启动图标-1"><a href="#设置启动图标-1" class="headerlink" title="设置启动图标"></a>设置启动图标</h4><ul><li><ol><li>编辑快捷方式文件</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> gedit /usr/share/applications/jetbrains-pycharm.desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>按照以下内容修改文件内容，需要注意<strong>指定正确的 <code>pycharm</code> 目录</strong></li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">[Desktop Entry]Version&#x3D;1.0Type&#x3D;ApplicationName&#x3D;PyCharmIcon&#x3D;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.pngExec&#x3D;&quot;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.sh&quot; %fComment&#x3D;The Drive to DevelopCategories&#x3D;Development;IDE;Terminal&#x3D;falseStartupWMClass&#x3D;jetbrains-pycharm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="多文件项目的演练"><a href="#多文件项目的演练" class="headerlink" title="多文件项目的演练"></a>多文件项目的演练</h1><ul><li>开发 <strong>项目</strong> 就是开发一个 <strong>专门解决一个复杂业务功能的软件</strong></li><li>通常每 <strong>一个项目</strong> 就具有一个 <strong>独立专属的目录</strong>，用于保存 <strong>所有和项目相关的文件</strong><ul><li>一个项目通常会包含 <strong>很多源文件</strong></li></ul></li></ul><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h2><ul><li>在项目中添加多个文件，并且设置文件的执行</li></ul><h2 id="多文件项目演练"><a href="#多文件项目演练" class="headerlink" title="多文件项目演练"></a>多文件项目演练</h2><ol><li>在 <code>01_Python基础</code> 项目中新建一个 <code>hm_02_第2个Python程序.py</code> </li><li>在 <code>hm_02_第2个Python程序.py</code> 文件中添加一句 <code>print(&quot;hello&quot;)</code></li><li><strong>点击右键执行</strong> <code>hm_02_第2个Python程序.py</code></li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025811.png" alt="001_让选中的程序可以执行-w662" loading="lazy"></p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li>在 <code>PyCharm</code> 中，要想让哪一个 <code>Python</code> 程序能够执行，必须首先通过 <strong>鼠标右键的方式执行</strong> 一下</li><li>对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试</li><li>对于商业项目而言，通常在一个项目中，只有一个 <strong>可以直接执行的 Python 源程序</strong></li></ul><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h2><ul><li>注释的作用</li><li>单行注释（行注释）</li><li>多行注释（块注释）</li></ul><h2 id="01-注释的作用"><a href="#01-注释的作用" class="headerlink" title="01. 注释的作用"></a>01. 注释的作用</h2><blockquote><p>使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025819.gif" alt="001_未使用注释的python程序" loading="lazy"></p><h2 id="02-单行注释-行注释"><a href="#02-单行注释-行注释" class="headerlink" title="02. 单行注释(行注释)"></a>02. 单行注释(行注释)</h2><ul><li><p>以 <code>#</code> 开头，<code>#</code> 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用</p></li><li><p>示例代码如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这是第一个单行注释</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>为了保证代码的可读性，<code>#</code> 后面建议先添加一个空格，然后再编写相应的说明文字</p></blockquote><h3 id="在代码后面增加的单行注释"><a href="#在代码后面增加的单行注释" class="headerlink" title="在代码后面增加的单行注释"></a>在代码后面增加的单行注释</h3><ul><li><p>在程序开发时，同样可以使用 <code>#</code> 在代码的后面（旁边）增加说明性的文字</p></li><li><p>但是，需要注意的是，<strong>为了保证代码的可读性</strong>，<strong>注释和代码之间</strong> 至少要有 <strong>两个空格</strong></p></li><li><p>示例代码如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 `hello python`</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="03-多行注释（块注释）"><a href="#03-多行注释（块注释）" class="headerlink" title="03. 多行注释（块注释）"></a>03. 多行注释（块注释）</h2><ul><li><p>如果希望编写的 <strong>注释信息很多，一行无法显示</strong>，就可以使用多行注释</p></li><li><p>要在 Python 程序中使用多行注释，可以用 <strong>一对 连续的 三个 引号</strong>(单引号和双引号都可以)</p></li><li><p>示例代码如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""这是一个多行注释在多行注释之间，可以写很多很多的内容……"""</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="什么时候需要使用注释？"><a href="#什么时候需要使用注释？" class="headerlink" title="什么时候需要使用注释？"></a>什么时候需要使用注释？</h3><ol><li><strong>注释不是越多越好</strong>，对于一目了然的代码，不需要添加注释</li><li>对于 <strong>复杂的操作</strong>，应该在操作开始前写上若干行注释</li><li>对于 <strong>不是一目了然的代码</strong>，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格）</li><li>绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么</li></ol><blockquote><p>在一些正规的开发团队，通常会有 <strong>代码审核</strong> 的惯例，就是一个团队中彼此阅读对方的代码</p></blockquote><h3 id="关于代码规范"><a href="#关于代码规范" class="headerlink" title="关于代码规范"></a>关于代码规范</h3><ul><li><code>Python</code> 官方提供有一系列 PEP（Python Enhancement Proposals） 文档</li><li>其中第 8 篇文档专门针对 <strong>Python 的代码格式</strong> 给出了建议，也就是俗称的 <strong>PEP 8</strong></li><li>文档地址：<a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></li><li>谷歌有对应的中文文档：<a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/">http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/</a></li></ul><blockquote><p>任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步</p></blockquote><h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><p><strong>计算机</strong>，顾名思义就是负责进行 <strong>数学计算</strong> 并且 <strong>存储计算结果</strong> 的电子设备</p><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h2><ul><li>算术运算符的基本使用</li></ul><h2 id="01-算数运算符"><a href="#01-算数运算符" class="headerlink" title="01. 算数运算符"></a>01. 算数运算符</h2><ul><li>算数运算符是 <strong>运算符的一种</strong></li><li>是完成基本的算术运算使用的符号，用来处理四则运算</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td>10 + 20 &#x3D; 30</td></tr><tr><td align="center">-</td><td align="center">减</td><td>10 - 20 &#x3D; -10</td></tr><tr><td align="center">*</td><td align="center">乘</td><td>10 * 20 &#x3D; 200</td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td><td>10 &#x2F; 20 &#x3D; 0.5</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td align="center">取整除</td><td>返回除法的整数部分（商） 9 &#x2F;&#x2F; 2 输出结果 4</td></tr><tr><td align="center">%</td><td align="center">取余数</td><td>返回除法的余数 9 % 2 &#x3D; 1</td></tr><tr><td align="center">**</td><td align="center">幂</td><td>又称次方、乘方，2 ** 3 &#x3D; 8</td></tr></tbody></table><ul><li>在 Python 中 <code>*</code> 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'----------------------------------------'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="02-算数运算符的优先级"><a href="#02-算数运算符的优先级" class="headerlink" title="02. 算数运算符的优先级"></a>02. 算数运算符的优先级</h2><ul><li><p>和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是：</p><ul><li><strong>先乘除后加减</strong></li><li>同级运算符是 <strong>从左至右</strong> 计算</li><li>可以使用 <code>()</code> 调整计算的优先级</li></ul></li><li><p>以下表格的算数优先级由高到最低顺序排列</p></li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>幂 (最高优先级)</td></tr><tr><td>* &#x2F; % &#x2F;&#x2F;</td><td>乘、除、取余数、取整除</td></tr><tr><td>+ -</td><td>加法、减法</td></tr></tbody></table><ul><li>例如：<ul><li><code>2 + 3 * 5 = 17</code></li><li><code>(2 + 3) * 5 = 25</code></li><li><code>2 * 3 + 5 = 11</code></li><li><code>2 * (3 + 5) = 16</code></li></ul></li></ul><h1 id="程序执行原理（科普）"><a href="#程序执行原理（科普）" class="headerlink" title="程序执行原理（科普）"></a>程序执行原理（科普）</h1><h2 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h2><ul><li>计算机中的 <strong>三大件</strong></li><li>程序执行的原理</li><li>程序的作用</li></ul><h2 id="01-计算机中的三大件"><a href="#01-计算机中的三大件" class="headerlink" title="01. 计算机中的三大件"></a>01. 计算机中的三大件</h2><p>计算机中包含有较多的硬件，但是一个程序要运行，有 <strong>三个</strong> 核心的硬件，分别是：</p><ol><li><strong>CPU</strong> <ul><li>中央处理器，是一块超大规模的集成电路</li><li>负责 <strong>处理数据</strong>／<strong>计算</strong></li></ul></li><li><strong>内存</strong><ul><li><strong>临时</strong> 存储数据（断电之后，数据会消失）</li><li>速度快</li><li>空间小（单位价格高）</li></ul></li><li><strong>硬盘</strong> <ul><li><strong>永久</strong> 存储数据</li><li>速度慢</li><li>空间大（单位价格低）</li></ul></li></ol><table><thead><tr><th align="center">CPU</th><th align="center">内存</th><th align="center">硬盘</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025841.jpg" alt="CPU-w200" loading="lazy"></td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025842.png" alt="内存条-w200" loading="lazy"></td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025843.jpg" alt="硬盘-w200" loading="lazy"></td></tr></tbody></table><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol><li>计算机中哪一个硬件设备负责执行程序？<ul><li><strong>CPU</strong></li></ul></li><li><strong>内存</strong> 的速度快还是 <strong>硬盘</strong> 的速度快？<ul><li><strong>内存</strong></li></ul></li><li>我们的程序是安装在内存中的，还是安装在硬盘中的？<ul><li>硬盘</li></ul></li><li><strong>我买了一个内存条，有 500G 的空间！！！</strong>，这句话对吗？<ul><li>不对，内存条通常只有 <code>4G</code> &#x2F; <code>8G</code> &#x2F; <code>16G</code> &#x2F; <code>32G</code></li></ul></li><li><strong>计算机关机之后，内存中的数据都会消失</strong>，这句话对吗？<ul><li>正确</li></ul></li></ol><h2 id="02-程序执行的原理"><a href="#02-程序执行的原理" class="headerlink" title="02. 程序执行的原理"></a>02. 程序执行的原理</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025844.png" alt="001_程序执行示意图-w" loading="lazy"></p><ol><li>程序 <strong>运行之前</strong>，程序是 <strong>保存在硬盘</strong> 中的</li><li>当要运行一个程序时<ul><li>操作系统会首先让 <strong>CPU</strong> 把程序复制到 <strong>内存</strong> 中</li><li><strong>CPU</strong> 执行 <strong>内存</strong> 中的 <strong>程序代码</strong></li></ul></li></ol><blockquote><p><strong>程序要执行，首先要被加载到内存</strong></p></blockquote><h3 id="2-1-Python-程序执行原理"><a href="#2-1-Python-程序执行原理" class="headerlink" title="2.1 Python 程序执行原理"></a>2.1 Python 程序执行原理</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025845.png" alt="003_Python程序执行示意图" loading="lazy"></p><ol><li>操作系统会首先让 <strong>CPU</strong> 把 <strong>Python 解释器</strong> 的程序复制到 <strong>内存</strong> 中</li><li><strong>Python 解释器</strong> 根据语法规则，<strong>从上向下</strong> 让 <strong>CPU</strong> 翻译 <strong>Python 程序中的代码</strong></li><li><strong>CPU</strong> 负责执行翻译完成的代码</li></ol><h4 id="Python-的解释器有多大？"><a href="#Python-的解释器有多大？" class="headerlink" title="Python 的解释器有多大？"></a>Python 的解释器有多大？</h4><ul><li>执行以下终端命令可以查看 Python 解释器的大小</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 确认解释器所在位置</span>$ <span class="token function">which</span> python<span class="token comment"># 2. 查看 python 文件大小(只是一个软链接)</span>$ <span class="token function">ls</span> -lh /usr/bin/python<span class="token comment"># 3. 查看具体文件大小</span>$ <span class="token function">ls</span> -lh /usr/bin/python2.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：建立 <strong>软链接</strong> 的目的，是为了方便使用者不用记住使用的解释器是 <strong>哪一个具体版本</strong></p></blockquote><h2 id="03-程序的作用"><a href="#03-程序的作用" class="headerlink" title="03. 程序的作用"></a>03. 程序的作用</h2><blockquote><p>程序就是 <strong>用来处理数据</strong> 的！</p></blockquote><ul><li><strong>新闻软件</strong> 提供的 <strong>新闻内容、评论……</strong> 是数据</li><li><strong>电商软件</strong> 提供的 <strong>商品信息、配送信息……</strong> 是数据</li><li><strong>运动类软件</strong> 提供的 <strong>运动数据……</strong> 是数据</li><li><strong>地图类软件</strong> 提供的 <strong>地图信息、定位信息、车辆信息……</strong> 是数据</li><li><strong>即时通讯软件</strong> 提供的 <strong>聊天信息、好友信息……</strong> 是数据</li><li>……</li></ul><h3 id="3-1-思考-QQ-程序的启动过程"><a href="#3-1-思考-QQ-程序的启动过程" class="headerlink" title="3.1 思考 QQ 程序的启动过程"></a>3.1 思考 QQ 程序的启动过程</h3><ol><li>QQ 在<strong>运行之前</strong>，是保存在 <strong>硬盘</strong> 中的</li><li><strong>运行之后</strong>，QQ 程序就会被加载到 <strong>内存</strong> 中了</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025846.png" alt="003_QQ登陆界面-w248" loading="lazy"></p><h3 id="3-2-思考-QQ-程序的-登录-过程"><a href="#3-2-思考-QQ-程序的-登录-过程" class="headerlink" title="3.2 思考 QQ 程序的 登录 过程"></a>3.2 思考 QQ 程序的 <strong>登录</strong> 过程</h3><ol><li>读取用户输入的 <strong>QQ 号码</strong></li><li>读取用户输入的 <strong>QQ 密码</strong></li><li>将 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 发送给腾讯的服务器，等待服务器确认用户信息</li></ol><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考 1"></a>思考 1</h4><blockquote><p>在 QQ 这个程序将 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 发送给服务器之前，<strong>是否需要先存储一下 QQ 号码 和 密码?</strong></p></blockquote><p><strong>答案</strong></p><p>肯定需要！—— 否则 QQ 这个程序就不知道把什么内容发送给服务器了！</p><h4 id="思考-2"><a href="#思考-2" class="headerlink" title="思考 2"></a>思考 2</h4><blockquote><p>QQ 这个程序把 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 保存在哪里？</p></blockquote><p><strong>答案</strong></p><p>保存在 <strong>内存</strong> 中，因为 QQ 程序自己就在内存中</p><h4 id="思考-3"><a href="#思考-3" class="headerlink" title="思考 3"></a>思考 3</h4><blockquote><p>QQ 这个程序是怎么保存用户的 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 的？</p></blockquote><p><strong>答案</strong></p><ol><li>在内存中为 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 各自分配一块空间<ul><li>在 QQ 程序结束之前，这两块空间是由 QQ 程序负责管理的，其他任何程序都不允许使用</li><li>在 QQ 自己使用完成之前，这两块空间始终都只负责保存 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong></li></ul></li><li>使用一个 <strong>别名</strong> 标记 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 在内存中的位置</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025847.png" alt="004_QQ号码和密码内存示意图" loading="lazy"></p><blockquote><ul><li>在程序内部，为 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 在内存中分配的空间就叫做 <strong>变量</strong></li><li><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></li></ul></blockquote><h1 id="变量的基本使用"><a href="#变量的基本使用" class="headerlink" title="变量的基本使用"></a>变量的基本使用</h1><blockquote><p><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></p></blockquote><h2 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h2><ul><li>变量定义</li><li>变量的类型</li><li>变量的命名</li></ul><h2 id="01-变量定义"><a href="#01-变量定义" class="headerlink" title="01. 变量定义"></a>01. 变量定义</h2><ul><li>在 Python 中，每个变量 <strong>在使用前都必须赋值</strong>，变量 <strong>赋值以后</strong> 该变量 <strong>才会被创建</strong></li><li>等号（&#x3D;）用来给变量赋值<ul><li><code>=</code> 左边是一个变量名</li><li><code>=</code> 右边是存储在变量中的值</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">变量名 <span class="token operator">=</span> 值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>变量定义之后，后续就可以直接使用了</p></blockquote><h3 id="1-变量演练1-——-iPython"><a href="#1-变量演练1-——-iPython" class="headerlink" title="1) 变量演练1 —— iPython"></a>1) 变量演练1 —— iPython</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义 qq_number 的变量用来保存 qq 号码</span>In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_number <span class="token operator">=</span> <span class="token string">"1234567"</span><span class="token comment"># 输出 qq_number 中保存的内容</span>In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_numberOut<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'1234567'</span><span class="token comment"># 定义 qq_password 的变量用来保存 qq 密码</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_password <span class="token operator">=</span> <span class="token string">"123"</span><span class="token comment"># 输出 qq_password 中保存的内容</span>In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_passwordOut<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'123'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 <code>print</code> 函数</p></blockquote><h3 id="2-变量演练-2-——-PyCharm"><a href="#2-变量演练-2-——-PyCharm" class="headerlink" title="2) 变量演练 2 —— PyCharm"></a>2) 变量演练 2 —— PyCharm</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义 qq 号码变量</span>qq_number <span class="token operator">=</span> <span class="token string">"1234567"</span><span class="token comment"># 定义 qq 密码变量</span>qq_password <span class="token operator">=</span> <span class="token string">"123"</span><span class="token comment"># 在程序中，如果要输出变量的内容，需要使用 print 函数</span><span class="token keyword">print</span><span class="token punctuation">(</span>qq_number<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>qq_password<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用解释器执行，如果要输出变量的内容，必须要要使用 <code>print</code> 函数</p></blockquote><h3 id="3-变量演练-3-——-超市买苹果"><a href="#3-变量演练-3-——-超市买苹果" class="headerlink" title="3) 变量演练 3 —— 超市买苹果"></a>3) 变量演练 3 —— 超市买苹果</h3><blockquote><ul><li>可以用 <strong>其他变量的计算结果</strong> 来定义变量</li><li>变量定义之后，后续就可以直接使用了</li></ul></blockquote><p><strong>需求</strong></p><ul><li>苹果的价格是 <strong>8.5 元&#x2F;斤</strong></li><li>买了 <strong>7.5 斤</strong> 苹果</li><li>计算付款金额</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义苹果价格变量</span>price <span class="token operator">=</span> <span class="token number">8.5</span><span class="token comment"># 定义购买重量</span>weight <span class="token operator">=</span> <span class="token number">7.5</span><span class="token comment"># 计算金额</span>money <span class="token operator">=</span> price <span class="token operator">*</span> weight<span class="token keyword">print</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h4><ul><li>如果 <strong>只要买苹果，就返 5 块钱</strong></li><li>请重新计算购买金额</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义苹果价格变量</span>price <span class="token operator">=</span> <span class="token number">8.5</span><span class="token comment"># 定义购买重量</span>weight <span class="token operator">=</span> <span class="token number">7.5</span><span class="token comment"># 计算金额</span>money <span class="token operator">=</span> price <span class="token operator">*</span> weight<span class="token comment"># 只要买苹果就返 5 元</span>money <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">5</span><span class="token keyword">print</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提问</strong></p><ul><li>上述代码中，一共定义有几个变量？<ul><li>三个：<code>price</code>／<code>weight</code>／<code>money</code></li></ul></li><li><code>money = money - 5</code> 是在定义新的变量还是在使用变量？<ul><li>直接使用之前已经定义的变量</li><li>变量名 只有在 <strong>第一次出现</strong> 才是 <strong>定义变量</strong></li><li>变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量</li></ul></li><li>在程序开发中，可以修改之前定义变量中保存的值吗？<ul><li>可以</li><li>变量中存储的值，就是可以 <strong>变</strong> 的</li></ul></li></ul><h2 id="02-变量的类型"><a href="#02-变量的类型" class="headerlink" title="02. 变量的类型"></a>02. 变量的类型</h2><ul><li>在内存中创建一个变量，会包括：<ol><li>变量的名称</li><li>变量保存的数据</li><li>变量存储数据的类型</li><li>变量的地址（标示）</li></ol></li></ul><h3 id="2-1-变量类型的演练-——-个人信息"><a href="#2-1-变量类型的演练-——-个人信息" class="headerlink" title="2.1 变量类型的演练 —— 个人信息"></a>2.1 变量类型的演练 —— 个人信息</h3><p><strong>需求</strong></p><ul><li>定义变量保存小明的个人信息</li><li>姓名：<strong>小明</strong></li><li>年龄：<strong>18</strong> 岁</li><li>性别：<strong>是</strong>男生</li><li>身高：<strong>1.75</strong> 米</li><li>体重：<strong>75.0</strong> 公斤</li></ul><blockquote><p>利用 <strong>单步调试</strong> 确认变量中保存数据的类型</p></blockquote><p><strong>提问</strong></p><ol><li>在演练中，一共有几种数据类型？<ul><li>4 种</li><li><code>str</code> —— 字符串</li><li><code>bool</code> —— 布尔（真假）</li><li><code>int</code> —— 整数</li><li><code>float</code> —— 浮点数（小数）</li></ul></li><li>在 <code>Python</code> 中定义变量时需要指定类型吗？<ul><li>不需要</li><li><code>Python</code> 可以根据 <code>=</code> 等号右侧的值，自动推导出变量中存储数据的类型</li></ul></li></ol><h3 id="2-2-变量的类型"><a href="#2-2-变量的类型" class="headerlink" title="2.2 变量的类型"></a>2.2 变量的类型</h3><ul><li>在 <code>Python</code> 中定义变量是 <strong>不需要指定类型</strong>（在其他很多高级语言中都需要）</li><li>数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></li><li>数字型<ul><li>整型 (<code>int</code>)</li><li>浮点型（<code>float</code>）</li><li>布尔型（<code>bool</code>） <ul><li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 (<code>complex</code>)<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li>非数字型<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li></ul><blockquote><p>提示：在 Python 2.x 中，<strong>整数</strong> 根据保存数值的长度还分为：</p><ul><li><code>int</code>（整数）</li><li><code>long</code>（长整数）</li></ul></blockquote><ul><li>使用 <code>type</code> 函数可以查看一个变量的类型</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">type</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-不同类型变量之间的计算"><a href="#2-3-不同类型变量之间的计算" class="headerlink" title="2.3 不同类型变量之间的计算"></a>2.3 不同类型变量之间的计算</h3><h4 id="1-数字型变量-之间可以直接计算"><a href="#1-数字型变量-之间可以直接计算" class="headerlink" title="1) 数字型变量 之间可以直接计算"></a>1) <strong>数字型变量</strong> 之间可以直接计算</h4><ul><li>在 Python 中，两个数字型变量是可以直接进行 算数运算的</li><li>如果变量是 <code>bool</code> 型，在计算时<ul><li><code>True</code> 对应的数字是 <code>1</code></li><li><code>False</code> 对应的数字是 <code>0</code></li></ul></li></ul><p><strong>演练步骤</strong></p><ol><li>定义整数 <code>i = 10</code></li><li>定义浮点数 <code>f = 10.5</code></li><li>定义布尔型 <code>b = True</code></li></ol><ul><li>在 iPython 中，使用上述三个变量相互进行算术运算</li></ul><h4 id="2-字符串变量-之间使用-拼接字符串"><a href="#2-字符串变量-之间使用-拼接字符串" class="headerlink" title="2) 字符串变量 之间使用 + 拼接字符串"></a>2) <strong>字符串变量</strong> 之间使用 <code>+</code> 拼接字符串</h4><ul><li>在 Python 中，字符串之间可以使用 <code>+</code> 拼接生成新的字符串</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> first_name <span class="token operator">=</span> <span class="token string">"三"</span>In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> last_name <span class="token operator">=</span> <span class="token string">"张"</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> first_name <span class="token operator">+</span> last_nameOut<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'三张'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-字符串变量-可以和-整数-使用-重复拼接相同的字符串"><a href="#3-字符串变量-可以和-整数-使用-重复拼接相同的字符串" class="headerlink" title="3) 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串"></a>3) <strong>字符串变量</strong> 可以和 <strong>整数</strong> 使用 <code>*</code> 重复拼接相同的字符串</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'--------------------------------------------------'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-数字型变量-和-字符串-之间-不能进行其他计算"><a href="#4-数字型变量-和-字符串-之间-不能进行其他计算" class="headerlink" title="4) 数字型变量 和 字符串 之间 不能进行其他计算"></a>4) <strong>数字型变量</strong> 和 <strong>字符串</strong> 之间 <strong>不能进行其他计算</strong></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> first_name <span class="token operator">=</span> <span class="token string">"zhang"</span>In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">10</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">+</span> first_name<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>TypeError<span class="token punctuation">:</span> unsupported operand <span class="token builtin">type</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token string">'int'</span> <span class="token keyword">and</span> <span class="token string">'str'</span>类型错误：`<span class="token operator">+</span>` 不支持的操作类型：`<span class="token builtin">int</span>` 和 `<span class="token builtin">str</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-变量的输入"><a href="#2-4-变量的输入" class="headerlink" title="2.4 变量的输入"></a>2.4 变量的输入</h3><ul><li>所谓 <strong>输入</strong>，就是 <strong>用代码</strong> <strong>获取</strong> 用户通过 <strong>键盘</strong> 输入的信息</li><li>例如：去银行取钱，在 ATM 上输入密码</li><li>在 Python 中，如果要获取用户在 <strong>键盘</strong> 上的输入信息，需要使用到 <code>input</code> 函数</li></ul><h4 id="1-关于函数"><a href="#1-关于函数" class="headerlink" title="1) 关于函数"></a>1) 关于函数</h4><ul><li>一个 <strong>提前准备好的功能</strong>(别人或者自己写的代码)，<strong>可以直接使用</strong>，而 <strong>不用关心内部的细节</strong></li><li>目前已经学习过的函数</li></ul><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>print(x)</td><td>将 x 输出到控制台</td></tr><tr><td>type(x)</td><td>查看 x 的变量类型</td></tr></tbody></table><h4 id="2-input-函数实现键盘输入"><a href="#2-input-函数实现键盘输入" class="headerlink" title="2) input 函数实现键盘输入"></a>2) input 函数实现键盘输入</h4><ul><li>在 Python 中可以使用 <code>input</code> 函数从键盘等待用户的输入</li><li>用户输入的 <strong>任何内容</strong> Python 都认为是一个 <strong>字符串</strong></li><li>语法如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">字符串变量 <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"提示信息："</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-类型转换函数"><a href="#3-类型转换函数" class="headerlink" title="3) 类型转换函数"></a>3) 类型转换函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>int(x)</td><td>将 x 转换为一个整数</td></tr><tr><td>float(x)</td><td>将 x 转换到一个浮点数</td></tr></tbody></table><h4 id="4-变量输入演练-——-超市买苹果增强版"><a href="#4-变量输入演练-——-超市买苹果增强版" class="headerlink" title="4) 变量输入演练 —— 超市买苹果增强版"></a>4) 变量输入演练 —— 超市买苹果增强版</h4><p><strong>需求</strong></p><ul><li><strong>收银员输入</strong> 苹果的价格，单位：<strong>元／斤</strong></li><li><strong>收银员输入</strong> 用户购买苹果的重量，单位：<strong>斤</strong></li><li>计算并且 <strong>输出</strong> 付款金额</li></ul><h5 id="演练方式-1"><a href="#演练方式-1" class="headerlink" title="演练方式 1"></a>演练方式 1</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 输入苹果单价</span>price_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入苹果价格："</span><span class="token punctuation">)</span><span class="token comment"># 2. 要求苹果重量</span>weight_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入苹果重量："</span><span class="token punctuation">)</span><span class="token comment"># 3. 计算金额</span><span class="token comment"># 1> 将苹果单价转换成小数</span>price <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>price_str<span class="token punctuation">)</span><span class="token comment"># 2> 将苹果重量转换成小数</span>weight <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>weight_str<span class="token punctuation">)</span><span class="token comment"># 3> 计算付款金额</span>money <span class="token operator">=</span> price <span class="token operator">*</span> weight<span class="token keyword">print</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提问</strong></p><ol><li>演练中，针对 <strong>价格</strong> 定义了几个变量？<ul><li><strong>两个</strong></li><li><code>price_str</code> 记录用户输入的价格字符串</li><li><code>price</code> 记录转换后的价格数值</li></ul></li><li><strong>思考</strong> —— 如果开发中，需要用户通过控制台 输入 <strong>很多个 数字</strong>，针对每一个数字都要定义两个变量，<strong>方便吗</strong>？</li></ol><h5 id="演练方式-2-——-买苹果改进版"><a href="#演练方式-2-——-买苹果改进版" class="headerlink" title="演练方式 2 —— 买苹果改进版"></a>演练方式 2 —— 买苹果改进版</h5><ol><li><strong>定义</strong> 一个 <strong>浮点变量</strong> 接收用户输入的同时，就使用 <code>float</code> 函数进行转换</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">price <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入价格:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>改进后的好处：</li></ul><ol><li>节约空间，只需要为一个变量分配空间</li><li>起名字方便，不需要为中间变量起名字</li></ol><ul><li>改进后的“缺点”：</li></ul><ol><li>初学者需要知道，两个函数能够嵌套使用，稍微有一些难度</li></ol><p><strong>提示</strong></p><ul><li>如果输入的不是一个数字，程序执行时会出错，有关数据转换的高级话题，后续会讲！</li></ul><h3 id="2-5-变量的格式化输出"><a href="#2-5-变量的格式化输出" class="headerlink" title="2.5 变量的格式化输出"></a>2.5 变量的格式化输出</h3><blockquote><p>苹果单价 <code>9.00</code> 元／斤，购买了 <code>5.00</code> 斤，需要支付 <code>45.00</code> 元</p></blockquote><ul><li>在 Python 中可以使用 <code>print</code> 函数将信息输出到控制台</li><li>如果希望输出文字信息的同时，<strong>一起输出</strong> <strong>数据</strong>，就需要使用到 <strong>格式化操作符</strong></li><li><code>%</code> 被称为 <strong>格式化操作符</strong>，专门用于处理字符串中的格式<ul><li>包含 <code>%</code> 的字符串，被称为 <strong>格式化字符串</strong></li><li><code>%</code> 和不同的 <strong>字符</strong> 连用，<strong>不同类型的数据</strong> 需要使用 <strong>不同的格式化字符</strong></li></ul></li></ul><table><thead><tr><th>格式化字符</th><th>含义</th></tr></thead><tbody><tr><td>%s</td><td>字符串</td></tr><tr><td>%d</td><td>有符号十进制整数，<code>%06d</code> 表示输出的整数显示位数，不足的地方使用 <code>0</code> 补全</td></tr><tr><td>%f</td><td>浮点数，<code>%.2f</code> 表示小数点后只显示两位</td></tr><tr><td>%%</td><td>输出 <code>%</code></td></tr></tbody></table><ul><li>语法格式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span> <span class="token operator">%</span> 变量<span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>变量<span class="token number">1</span><span class="token punctuation">,</span> 变量<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="格式化输出演练-——-基本练习"><a href="#格式化输出演练-——-基本练习" class="headerlink" title="格式化输出演练 —— 基本练习"></a>格式化输出演练 —— 基本练习</h4><p><strong>需求</strong></p><ol><li>定义字符串变量 <code>name</code>，输出 <strong>我的名字叫 小明，请多多关照！</strong></li><li>定义整数变量 <code>student_no</code>，输出 <strong>我的学号是 000001</strong></li><li>定义小数 <code>price</code>、<code>weight</code>、<code>money</code>，输出 <strong>苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元</strong></li><li>定义一个小数 <code>scale</code>，输出 <strong>数据比例是 10.00%</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我的名字叫 %s，请多多关照！"</span> <span class="token operator">%</span> name<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我的学号是 %06d"</span> <span class="token operator">%</span> student_no<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>price<span class="token punctuation">,</span> weight<span class="token punctuation">,</span> money<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据比例是 %.02f%%"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>scale <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="课后练习-——-个人名片"><a href="#课后练习-——-个人名片" class="headerlink" title="课后练习 —— 个人名片"></a>课后练习 —— 个人名片</h4><p><strong>需求</strong></p><ul><li>在控制台依次提示用户输入：<strong>姓名</strong>、<strong>公司</strong>、<strong>职位</strong>、<strong>电话</strong>、<strong>邮箱</strong></li><li>按照以下格式输出：</li></ul><pre class="line-numbers language-none"><code class="language-none">**************************************************公司名称姓名 (职位)电话：电话邮箱：邮箱**************************************************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""在控制台依次提示用户输入：姓名、公司、职位、电话、电子邮箱"""</span>name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入姓名："</span><span class="token punctuation">)</span>company <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入公司："</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入职位："</span><span class="token punctuation">)</span>phone <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入电话："</span><span class="token punctuation">)</span>email <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入邮箱："</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>company<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s (%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"电话：%s"</span> <span class="token operator">%</span> phone<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"邮箱：%s"</span> <span class="token operator">%</span> email<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h1><h2 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h2><ul><li>标识符和关键字</li><li>变量的命名规则</li></ul><h2 id="0-1-标识符和关键字"><a href="#0-1-标识符和关键字" class="headerlink" title="0.1 标识符和关键字"></a>0.1 标识符和关键字</h2><h3 id="1-1-标识符"><a href="#1-1-标识符" class="headerlink" title="1.1 标识符"></a>1.1 标识符</h3><blockquote><p>标示符就是程序员定义的 <strong>变量名</strong>、<strong>函数名</strong></p><p><strong>名字</strong> 需要有 <strong>见名知义</strong> 的效果，见下图：</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030129.jpg" alt="001_中国山东找蓝翔" loading="lazy"></p><ul><li>标示符可以由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li></ul><p>思考：下面的标示符哪些是正确的，哪些不正确为什么？</p><pre class="line-numbers language-none"><code class="language-none">fromNo12from#12my_Booleanmy-BooleanObj22ndObjmyIntMy_tExt_testtest!32haha(da)ttjack_rosejack&amp;roseGUIG.U.I<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h3><ul><li><strong>关键字</strong> 就是在 <code>Python</code> 内部已经使用的标识符</li><li><strong>关键字</strong> 具有特殊的功能和含义</li><li>开发者 <strong>不允许定义和关键字相同的名字的标示符</strong></li></ul><p>通过以下命令可以查看 <code>Python</code> 中的关键字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">import</span> keywordIn <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>提示：<strong>关键字的学习及使用</strong>，会在后面的课程中不断介绍</p><ul><li><p><code>import</code> <strong>关键字</strong> 可以导入一个 <strong>“工具包”</strong></p></li><li><p>在 <code>Python</code> 中不同的工具包，提供有不同的工具</p></li></ul></blockquote><h2 id="02-变量的命名规则"><a href="#02-变量的命名规则" class="headerlink" title="02. 变量的命名规则"></a>02. 变量的命名规则</h2><blockquote><p><strong>命名规则</strong> 可以被视为一种 <strong>惯例</strong>，并无绝对与强制<br>目的是为了 <strong>增加代码的识别和可读性</strong></p></blockquote><p><strong>注意</strong> <code>Python</code> 中的 <strong>标识符</strong> 是 <strong>区分大小写的</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030130.jpg" alt="002_标识符区分大小写" loading="lazy"></p><ol><li><p>在定义变量时，为了保证代码格式，<code>=</code> 的左右应该各保留一个空格</p></li><li><p>在 <code>Python</code> 中，如果 <strong>变量名</strong> 需要由 <strong>二个</strong> 或 <strong>多个单词</strong> 组成时，可以按照以下方式命名</p><ol><li>每个单词都使用小写字母</li><li>单词与单词之间使用 <strong><code>_</code>下划线</strong> 连接</li></ol><ul><li>例如：<code>first_name</code>、<code>last_name</code>、<code>qq_number</code>、<code>qq_password</code></li></ul></li></ol><h3 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h3><ul><li>当 <strong>变量名</strong> 是由二个或多个单词组成时，还可以利用驼峰命名法来命名</li><li><strong>小驼峰式命名法</strong><ul><li>第一个单词以小写字母开始，后续单词的首字母大写</li><li>例如：<code>firstName</code>、<code>lastName</code></li></ul></li><li><strong>大驼峰式命名法</strong><ul><li>每一个单词的首字母都采用大写字母</li><li>例如：<code>FirstName</code>、<code>LastName</code>、<code>CamelCase</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030131.jpg" alt="003_驼峰命名法" loading="lazy"></p><h1 id="判断（if）语句"><a href="#判断（if）语句" class="headerlink" title="判断（if）语句"></a>判断（if）语句</h1><h2 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h2><ul><li>开发中的应用场景</li><li>if 语句体验</li><li>if 语句进阶</li><li>综合应用</li></ul><h2 id="01-开发中的应用场景"><a href="#01-开发中的应用场景" class="headerlink" title="01. 开发中的应用场景"></a>01. 开发中的应用场景</h2><p>生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？……</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030138.jpg" alt="001_未成年人禁止入内-w400" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030139.png" alt="002_火车站安检-w400" loading="lazy"></p><h3 id="程序中的判断"><a href="#程序中的判断" class="headerlink" title="程序中的判断"></a>程序中的判断</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030140.png" alt="003_判断示意图-w600" loading="lazy"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 今天发工资<span class="token punctuation">:</span>    先还信用卡的钱    <span class="token keyword">if</span> 有剩余<span class="token punctuation">:</span>        又可以happy了，O<span class="token punctuation">(</span>∩_∩<span class="token punctuation">)</span>O哈哈<span class="token operator">~</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        噢，no。。。还的等<span class="token number">30</span>天<span class="token keyword">else</span><span class="token punctuation">:</span>    盼着发工资<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断的定义"><a href="#判断的定义" class="headerlink" title="判断的定义"></a>判断的定义</h3><ul><li>如果 <strong>条件满足</strong>，才能做某件事情，</li><li>如果 <strong>条件不满足</strong>，就做另外一件事情，或者什么也不做</li></ul><blockquote><p>正是因为有了判断，才使得程序世界丰富多彩，充满变化！</p><p><strong>判断语句</strong> 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支</p></blockquote><h2 id="02-if-语句体验"><a href="#02-if-语句体验" class="headerlink" title="02. if 语句体验"></a>02. if 语句体验</h2><h3 id="2-1-if-判断语句基本语法"><a href="#2-1-if-判断语句基本语法" class="headerlink" title="2.1 if 判断语句基本语法"></a>2.1 if 判断语句基本语法</h3><p>在 <code>Python</code> 中，<strong>if 语句</strong> 就是用来进行判断的，格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 要判断的条件<span class="token punctuation">:</span>    条件成立时，要做的事情    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：代码的缩进为一个 <code>tab</code> 键，或者 <strong>4</strong> 个空格 —— <strong>建议使用空格</strong></p><ul><li>在 Python 开发中，Tab 和空格不要混用！</li></ul></blockquote><p><strong>我们可以把整个 if 语句看成一个完整的代码块</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030141.png" alt="004_if语句是一个完整的代码块1-w400" loading="lazy"></p><h3 id="2-2-判断语句演练-——-判断年龄"><a href="#2-2-判断语句演练-——-判断年龄" class="headerlink" title="2.2 判断语句演练 —— 判断年龄"></a>2.2 判断语句演练 —— 判断年龄</h3><p><strong>需求</strong></p><ol><li>定义一个整数变量记录年龄</li><li>判断是否满 18 岁 （**&gt;&#x3D;**）</li><li>如果满 18 岁，允许进网吧嗨皮</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 定义年龄变量</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token comment"># 2. 判断是否满 18 岁</span><span class="token comment"># if 语句以及缩进部分的代码是一个完整的代码块</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">18</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"可以进网吧嗨皮……"</span><span class="token punctuation">)</span><span class="token comment"># 3. 思考！- 无论条件是否满足都会执行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这句代码什么时候执行?"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li><code>if</code> 语句以及缩进部分是一个 <strong>完整的代码块</strong></li></ul><h3 id="2-3-else-处理条件不满足的情况"><a href="#2-3-else-处理条件不满足的情况" class="headerlink" title="2.3 else 处理条件不满足的情况"></a>2.3 else 处理条件不满足的情况</h3><p><strong>思考</strong></p><p>在使用 <code>if</code> 判断时，只能做到满足条件时要做的事情。那如果需要在 <strong>不满足条件的时候</strong>，做某些事情，该如何做呢？</p><p><strong>答案</strong></p><p><code>else</code>，格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 要判断的条件<span class="token punctuation">:</span>    条件成立时，要做的事情    ……<span class="token keyword">else</span><span class="token punctuation">:</span>    条件不成立时，要做的事情    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li><code>if</code> 和 <code>else</code> 语句以及各自的缩进部分共同是一个 <strong>完整的代码块</strong></li></ul><h3 id="2-4-判断语句演练-——-判断年龄改进"><a href="#2-4-判断语句演练-——-判断年龄改进" class="headerlink" title="2.4 判断语句演练 —— 判断年龄改进"></a>2.4 判断语句演练 —— 判断年龄改进</h3><p><strong>需求</strong></p><ol><li>输入用户年龄</li><li>判断是否满 18 岁 （**&gt;&#x3D;**）</li><li>如果满 18 岁，允许进网吧嗨皮</li><li>如果未满 18 岁，提示回家写作业</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 输入用户年龄</span>age <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"今年多大了？"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 2. 判断是否满 18 岁</span><span class="token comment"># if 语句以及缩进部分的代码是一个完整的语法块</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">18</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"可以进网吧嗨皮……"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"你还没长大，应该回家写作业！"</span><span class="token punctuation">)</span><span class="token comment"># 3. 思考！- 无论条件是否满足都会执行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这句代码什么时候执行?"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030142.png" alt="005_ifelse语句是一个完整的代码块1-w400" loading="lazy"></p><h2 id="03-逻辑运算"><a href="#03-逻辑运算" class="headerlink" title="03. 逻辑运算"></a>03. 逻辑运算</h2><ul><li>在程序开发中，通常 <strong>在判断条件时</strong>，会需要同时判断多个条件</li><li>只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 <strong>逻辑运算符</strong></li><li><strong>逻辑运算符</strong> 可以把 <strong>多个条件</strong> 按照 <strong>逻辑</strong> 进行 <strong>连接</strong>，变成 <strong>更复杂的条件</strong></li><li>Python 中的 <strong>逻辑运算符</strong> 包括：<strong>与 and</strong>／<strong>或 or</strong>／<strong>非 not</strong> 三种</li></ul><h3 id="3-1-and"><a href="#3-1-and" class="headerlink" title="3.1 and"></a>3.1 <code>and</code></h3><pre class="line-numbers language-none"><code class="language-none">条件1 and 条件2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>与</strong>／<strong>并且</strong></li><li>两个条件同时满足，返回 <code>True</code></li><li>只要有一个不满足，就返回 <code>False</code></li></ul><table><thead><tr><th align="center">条件 1</th><th align="center">条件 2</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">成立</td><td align="center">成立</td><td align="center">成立</td></tr><tr><td align="center">成立</td><td align="center">不成立</td><td align="center">不成立</td></tr><tr><td align="center">不成立</td><td align="center">成立</td><td align="center">不成立</td></tr><tr><td align="center">不成立</td><td align="center">不成立</td><td align="center">不成立</td></tr></tbody></table><h3 id="3-2-or"><a href="#3-2-or" class="headerlink" title="3.2 or"></a>3.2 <code>or</code></h3><pre class="line-numbers language-none"><code class="language-none">条件1 or 条件2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>或</strong>／<strong>或者</strong></li><li>两个条件只要有一个满足，返回 <code>True</code></li><li>两个条件都不满足，返回 <code>False</code></li></ul><table><thead><tr><th align="center">条件 1</th><th align="center">条件 2</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">成立</td><td align="center">成立</td><td align="center">成立</td></tr><tr><td align="center">成立</td><td align="center">不成立</td><td align="center">成立</td></tr><tr><td align="center">不成立</td><td align="center">成立</td><td align="center">成立</td></tr><tr><td align="center">不成立</td><td align="center">不成立</td><td align="center">不成立</td></tr></tbody></table><h3 id="3-3-not"><a href="#3-3-not" class="headerlink" title="3.3 not"></a>3.3 <code>not</code></h3><pre class="line-numbers language-none"><code class="language-none">not 条件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>非</strong>／<strong>不是</strong></li></ul><table><thead><tr><th align="center">条件</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">成立</td><td align="center">不成立</td></tr><tr><td align="center">不成立</td><td align="center">成立</td></tr></tbody></table><h4 id="逻辑运算演练"><a href="#逻辑运算演练" class="headerlink" title="逻辑运算演练"></a>逻辑运算演练</h4><ol><li>练习1: 定义一个整数变量 <code>age</code>，编写代码判断年龄是否正确<ul><li>要求人的年龄在 0-120 之间</li></ul></li><li>练习2: 定义两个整数变量 <code>python_score</code>、<code>c_score</code>，编写代码判断成绩<ul><li>要求只要有一门成绩 &gt; 60 分就算合格</li></ul></li><li>练习3: 定义一个布尔型变量 <code>is_employee</code>，编写代码判断是否是本公司员工<ul><li>如果不是提示不允许入内</li></ul></li></ol><p>答案 1：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确</span>age <span class="token operator">=</span> <span class="token number">100</span><span class="token comment"># 要求人的年龄在 0-120 之间</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">0</span> <span class="token keyword">and</span> age <span class="token operator">&lt;=</span> <span class="token number">120</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"年龄正确"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"年龄不正确"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案 2：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩</span>python_score <span class="token operator">=</span> <span class="token number">50</span>c_score <span class="token operator">=</span> <span class="token number">50</span><span class="token comment"># 要求只要有一门成绩 > 60 分就算合格</span><span class="token keyword">if</span> python_score <span class="token operator">></span> <span class="token number">60</span> <span class="token keyword">or</span> c_score <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"考试通过"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"再接再厉！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案 3：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工</span>is_employee <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment"># 如果不是提示不允许入内</span><span class="token keyword">if</span> <span class="token keyword">not</span> is_employee<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"非公勿内"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="04-if-语句进阶"><a href="#04-if-语句进阶" class="headerlink" title="04. if 语句进阶"></a>04. if 语句进阶</h2><h3 id="4-1-elif"><a href="#4-1-elif" class="headerlink" title="4.1 elif"></a>4.1 <code>elif</code></h3><ul><li>在开发中，使用 <code>if</code> 可以 <strong>判断条件</strong></li><li>使用 <code>else</code> 可以处理 <strong>条件不成立</strong> 的情况</li><li>但是，如果希望 <strong>再增加一些条件</strong>，<strong>条件不同，需要执行的代码也不同</strong> 时，就可以使用 <code>elif</code> </li><li>语法格式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 条件<span class="token number">1</span><span class="token punctuation">:</span>    条件<span class="token number">1</span>满足执行的代码    ……<span class="token keyword">elif</span> 条件<span class="token number">2</span><span class="token punctuation">:</span>    条件<span class="token number">2</span>满足时，执行的代码    ……<span class="token keyword">elif</span> 条件<span class="token number">3</span><span class="token punctuation">:</span>    条件<span class="token number">3</span>满足时，执行的代码    ……<span class="token keyword">else</span><span class="token punctuation">:</span>    以上条件都不满足时，执行的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对比逻辑运算符的代码</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 条件<span class="token number">1</span> <span class="token keyword">and</span> 条件<span class="token number">2</span><span class="token punctuation">:</span>    条件<span class="token number">1</span>满足 并且 条件<span class="token number">2</span>满足 执行的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li><code>elif</code> 和 <code>else</code> 都必须和 <code>if</code> 联合使用，而不能单独使用</li><li>可以将 <code>if</code>、<code>elif</code> 和 <code>else</code> 以及各自缩进的代码，看成一个 <strong>完整的代码块</strong></li></ol><h4 id="elif-演练-——-女友的节日"><a href="#elif-演练-——-女友的节日" class="headerlink" title="elif 演练 —— 女友的节日"></a>elif 演练 —— 女友的节日</h4><p><strong>需求</strong></p><ol><li>定义 <code>holiday_name</code> 字符串变量记录节日名称</li><li>如果是 <strong>情人节</strong> 应该 <strong>买玫瑰</strong>／<strong>看电影</strong></li><li>如果是 <strong>平安夜</strong> 应该 <strong>买苹果</strong>／<strong>吃大餐</strong></li><li>如果是 <strong>生日</strong> 应该 <strong>买蛋糕</strong></li><li>其他的日子每天都是节日啊……</li></ol><pre class="line-numbers language-none"><code class="language-none">holiday_name &#x3D; &quot;平安夜&quot;if holiday_name &#x3D;&#x3D; &quot;情人节&quot;:    print(&quot;买玫瑰&quot;)    print(&quot;看电影&quot;)elif holiday_name &#x3D;&#x3D; &quot;平安夜&quot;:    print(&quot;买苹果&quot;)    print(&quot;吃大餐&quot;)elif holiday_name &#x3D;&#x3D; &quot;生日&quot;:    print(&quot;买蛋糕&quot;)else:    print(&quot;每天都是节日啊……&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-if-的嵌套"><a href="#4-2-if-的嵌套" class="headerlink" title="4.2 if 的嵌套"></a>4.2 <code>if</code> 的嵌套</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030139.png" alt="002_火车站安检-w400" loading="lazy"></p><blockquote><p><strong>elif</strong> 的应用场景是：<strong>同时</strong> 判断 <strong>多个条件</strong>，所有的条件是 <strong>平级</strong> 的</p></blockquote><ul><li>在开发中，使用 <code>if</code> 进行条件判断，如果希望 <strong>在条件成立的执行语句中</strong> 再 <strong>增加条件判断</strong>，就可以使用 <strong>if 的嵌套</strong></li><li><strong>if 的嵌套</strong> 的应用场景就是：<strong>在之前条件满足的前提下，再增加额外的判断</strong></li><li><strong>if 的嵌套</strong> 的语法格式，<strong>除了缩进之外</strong> 和之前的没有区别</li><li>语法格式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 条件 <span class="token number">1</span><span class="token punctuation">:</span>    条件 <span class="token number">1</span> 满足执行的代码    ……        <span class="token keyword">if</span> 条件 <span class="token number">1</span> 基础上的条件 <span class="token number">2</span><span class="token punctuation">:</span>        条件 <span class="token number">2</span> 满足时，执行的代码        ……                <span class="token comment"># 条件 2 不满足的处理</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        条件 <span class="token number">2</span> 不满足时，执行的代码        <span class="token comment"># 条件 1 不满足的处理</span><span class="token keyword">else</span><span class="token punctuation">:</span>    条件<span class="token number">1</span> 不满足时，执行的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="if-的嵌套-演练-——-火车站安检"><a href="#if-的嵌套-演练-——-火车站安检" class="headerlink" title="if 的嵌套 演练 —— 火车站安检"></a>if 的嵌套 演练 —— 火车站安检</h4><p><strong>需求</strong></p><ol><li>定义布尔型变量 <code>has_ticket</code> 表示是否有车票</li><li>定义整型变量 <code>knife_length</code> 表示刀的长度，单位：厘米</li><li>首先检查是否有车票，如果有，才允许进行 <strong>安检</strong></li><li>安检时，需要检查刀的长度，判断是否超过 20 厘米<ul><li>如果超过 20 厘米，提示刀的长度，不允许上车</li><li>如果不超过 20 厘米，安检通过</li></ul></li><li>如果没有车票，不允许进门</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义布尔型变量 has_ticket 表示是否有车票</span>has_ticket <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment"># 定义整数型变量 knife_length 表示刀的长度，单位：厘米</span>knife_length <span class="token operator">=</span> <span class="token number">20</span><span class="token comment"># 首先检查是否有车票，如果有，才允许进行 安检</span><span class="token keyword">if</span> has_ticket<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"有车票，可以开始安检..."</span><span class="token punctuation">)</span>    <span class="token comment"># 安检时，需要检查刀的长度，判断是否超过 20 厘米</span>    <span class="token comment"># 如果超过 20 厘米，提示刀的长度，不允许上车</span>    <span class="token keyword">if</span> knife_length <span class="token operator">>=</span> <span class="token number">20</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不允许携带 %d 厘米长的刀上车"</span> <span class="token operator">%</span> knife_length<span class="token punctuation">)</span>    <span class="token comment"># 如果不超过 20 厘米，安检通过</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"安检通过，祝您旅途愉快……"</span><span class="token punctuation">)</span><span class="token comment"># 如果没有车票，不允许进门</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"大哥，您要先买票啊"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="05-综合应用-——-石头剪刀布"><a href="#05-综合应用-——-石头剪刀布" class="headerlink" title="05. 综合应用 —— 石头剪刀布"></a>05. 综合应用 —— 石头剪刀布</h2><p><strong>目标</strong></p><ol><li>强化 <strong>多个条件</strong> 的 <strong>逻辑运算</strong></li><li>体会 <code>import</code> 导入模块（“工具包”）的使用</li></ol><p><strong>需求</strong></p><ol><li>从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）</li><li>电脑 <strong>随机</strong> 出拳 —— 先假定电脑只会出石头，完成整体代码功能</li><li>比较胜负</li></ol><table><thead><tr><th align="center">序号</th><th align="center">规则</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">石头 胜 剪刀</td></tr><tr><td align="center">2</td><td align="center">剪刀 胜 布</td></tr><tr><td align="center">3</td><td align="center">布 胜 石头</td></tr></tbody></table><h3 id="5-1-基础代码实现"><a href="#5-1-基础代码实现" class="headerlink" title="5.1 基础代码实现"></a>5.1 基础代码实现</h3><ul><li>先 <strong>假定电脑就只会出石头</strong>，完成整体代码功能</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）</span>player <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请出拳 石头（1）／剪刀（2）／布（3）："</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 电脑 随机 出拳 - 假定电脑永远出石头</span>computer <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># 比较胜负</span><span class="token comment"># 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号</span><span class="token comment"># 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>player <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> computer <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">or</span>        <span class="token punctuation">(</span>player <span class="token operator">==</span> <span class="token number">2</span> <span class="token keyword">and</span> computer <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">or</span>        <span class="token punctuation">(</span>player <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">and</span> computer <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"噢耶！！！电脑弱爆了！！！"</span><span class="token punctuation">)</span><span class="token keyword">elif</span> player <span class="token operator">==</span> computer<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"心有灵犀，再来一盘！"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不行，我要和你决战到天亮！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-随机数的处理"><a href="#5-2-随机数的处理" class="headerlink" title="5.2 随机数的处理"></a>5.2 随机数的处理</h3><ul><li>在 <code>Python</code> 中，要使用随机数，首先需要导入 <strong>随机数</strong> 的 <strong>模块</strong> —— “工具包”</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>导入模块后，可以直接在 <strong>模块名称</strong> 后面敲一个 <code>.</code> 然后按 <code>Tab</code> 键，会提示该模块中包含的所有函数</p></li><li><p><code>random.randint(a, b)</code> ，返回 <code>[a, b]</code> 之间的整数，包含 <code>a</code> 和 <code>b</code></p></li><li><p>例如：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment"># 生成的随机数n: 12 &lt;= n &lt;= 20   </span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment"># 结果永远是 20   </span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 该语句是错误的，下限必须小于上限</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h2><ul><li>算数运算符</li><li>比较（关系）运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>运算符的优先级</li></ul><p>数学符号表链接：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8">https://zh.wikipedia.org/wiki/数学符号表</a></p><h2 id="01-算数运算符-1"><a href="#01-算数运算符-1" class="headerlink" title="01. 算数运算符"></a>01. 算数运算符</h2><ul><li>是完成基本的算术运算使用的符号，用来处理四则运算</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td>10 + 20 &#x3D; 30</td></tr><tr><td align="center">-</td><td align="center">减</td><td>10 - 20 &#x3D; -10</td></tr><tr><td align="center">*</td><td align="center">乘</td><td>10 * 20 &#x3D; 200</td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td><td>10 &#x2F; 20 &#x3D; 0.5</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td align="center">取整除</td><td>返回除法的整数部分（商） 9 &#x2F;&#x2F; 2 输出结果 4</td></tr><tr><td align="center">%</td><td align="center">取余数</td><td>返回除法的余数 9 % 2 &#x3D; 1</td></tr><tr><td align="center">**</td><td align="center">幂</td><td>又称次方、乘方，2 ** 3 &#x3D; 8</td></tr></tbody></table><ul><li>在 Python 中 <code>*</code> 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'----------------------------------------'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="02-比较（关系）运算符"><a href="#02-比较（关系）运算符" class="headerlink" title="02. 比较（关系）运算符"></a>02. 比较（关系）运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个操作数的值是否 <strong>相等</strong>，如果是，则条件成立，返回 True</td></tr><tr><td>!&#x3D;</td><td>检查两个操作数的值是否 <strong>不相等</strong>，如果是，则条件成立，返回 True</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否 <strong>大于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否 <strong>小于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr><tr><td>&gt;&#x3D;</td><td>检查左操作数的值是否 <strong>大于或等于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr><tr><td>&lt;&#x3D;</td><td>检查左操作数的值是否 <strong>小于或等于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr></tbody></table><blockquote><p>Python 2.x 中判断 <strong>不等于</strong> 还可以使用 <code>&lt;&gt;</code> 运算符</p><p><code>!=</code> 在 Python 2.x 中同样可以用来判断 <strong>不等于</strong></p></blockquote><h2 id="03-逻辑运算符"><a href="#03-逻辑运算符" class="headerlink" title="03. 逻辑运算符"></a>03. 逻辑运算符</h2><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>只有 x 和 y 的值都为 True，才会返回 True<br />否则只要 x 或者 y 有一个值为 False，就返回 False</td></tr><tr><td>or</td><td>x or y</td><td>只要 x 或者 y 有一个值为 True，就返回 True<br />只有 x 和 y 的值都为 False，才会返回 False</td></tr><tr><td>not</td><td>not x</td><td>如果 x 为 True，返回 False<br />如果 x 为 False，返回 True</td></tr></tbody></table><h2 id="04-赋值运算符"><a href="#04-赋值运算符" class="headerlink" title="04. 赋值运算符"></a>04. 赋值运算符</h2><ul><li>在 Python 中，使用 <code>=</code> 可以给变量赋值</li><li>在算术运算时，为了简化代码的编写，<code>Python</code> 还提供了一系列的 与 <strong>算术运算符</strong> 对应的 <strong>赋值运算符</strong></li><li>注意：<strong>赋值运算符中间不能使用空格</strong></li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取 <strong>模</strong> (余数)赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr></tbody></table><h2 id="05-运算符的优先级"><a href="#05-运算符的优先级" class="headerlink" title="05. 运算符的优先级"></a>05. 运算符的优先级</h2><ul><li>以下表格的算数优先级由高到最低顺序排列</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>幂 (最高优先级)</td></tr><tr><td>* &#x2F; % &#x2F;&#x2F;</td><td>乘、除、取余数、取整除</td></tr><tr><td>+ -</td><td>加法、减法</td></tr><tr><td>&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td>比较运算符</td></tr><tr><td>&#x3D;&#x3D; !&#x3D;</td><td>等于运算符</td></tr><tr><td>&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td>赋值运算符</td></tr><tr><td>not or and</td><td>逻辑运算符</td></tr></tbody></table><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h2><ul><li>程序的三大流程</li><li>while 循环基本使用</li><li>break 和 continue</li><li>while 循环嵌套</li></ul><h2 id="01-程序的三大流程"><a href="#01-程序的三大流程" class="headerlink" title="01. 程序的三大流程"></a>01. 程序的三大流程</h2><ul><li><p>在程序开发中，一共有三种流程方式：</p><ul><li><strong>顺序</strong> —— <strong>从上向下</strong>，顺序执行代码</li><li><strong>分支</strong> —— 根据条件判断，决定执行代码的 <strong>分支</strong></li><li><strong>循环</strong> —— 让 <strong>特定代码 重复</strong> 执行</li></ul><p>  <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030157.png" alt="001_程序三大流程" loading="lazy"></p></li></ul><h2 id="02-while-循环基本使用"><a href="#02-while-循环基本使用" class="headerlink" title="02. while 循环基本使用"></a>02. <code>while</code> 循环基本使用</h2><ul><li><p>循环的作用就是让 <strong>指定的代码</strong> 重复的执行</p></li><li><p><code>while</code> 循环最常用的应用场景就是 <strong>让执行的代码</strong> 按照 <strong>指定的次数</strong> <strong>重复</strong> 执行</p></li><li><p>需求 —— 打印 5 遍 <code>Hello Python</code></p></li><li><p>思考 —— 如果要求打印 100 遍怎么办？</p></li></ul><h3 id="2-1-while-语句基本语法"><a href="#2-1-while-语句基本语法" class="headerlink" title="2.1 while 语句基本语法"></a>2.1 <code>while</code> 语句基本语法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">初始条件设置 —— 通常是重复执行的 计数器<span class="token keyword">while</span> 条件<span class="token punctuation">(</span>判断 计数器 是否达到 目标次数<span class="token punctuation">)</span><span class="token punctuation">:</span>    条件满足时，做的事情<span class="token number">1</span>    条件满足时，做的事情<span class="token number">2</span>    条件满足时，做的事情<span class="token number">3</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>省略<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        处理条件<span class="token punctuation">(</span>计数器 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li><code>while</code> 语句以及缩进部分是一个 <strong>完整的代码块</strong></li></ul><h4 id="第一个-while-循环"><a href="#第一个-while-循环" class="headerlink" title="第一个 while 循环"></a>第一个 while 循环</h4><p><strong>需求</strong></p><ul><li>打印 5 遍 Hello Python</li></ul><pre class="line-numbers language-while" data-language="while"><code class="language-while"># 1. 定义重复次数计数器i &#x3D; 1# 2. 使用 while 判断条件while i &lt;&#x3D; 5:    # 要重复执行的代码    print(&quot;Hello Python&quot;)    # 处理计数器 i    i &#x3D; i + 1print(&quot;循环结束后的 i &#x3D; %d&quot; % i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：循环结束后，之前定义的计数器条件的数值是依旧存在的</p></blockquote><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><blockquote><p>由于程序员的原因，<strong>忘记</strong> 在循环内部 <strong>修改循环的判断条件</strong>，导致循环持续执行，程序无法终止！</p></blockquote><h3 id="2-2-赋值运算符"><a href="#2-2-赋值运算符" class="headerlink" title="2.2 赋值运算符"></a>2.2 赋值运算符</h3><ul><li>在 Python 中，使用 <code>=</code> 可以给变量赋值</li><li>在算术运算时，为了简化代码的编写，<code>Python</code> 还提供了一系列的 与 <strong>算术运算符</strong> 对应的 <strong>赋值运算符</strong></li><li>注意：<strong>赋值运算符中间不能使用空格</strong></li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取 <strong>模</strong> (余数)赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr></tbody></table><h3 id="2-3-Python-中的计数方法"><a href="#2-3-Python-中的计数方法" class="headerlink" title="2.3 Python 中的计数方法"></a>2.3 Python 中的计数方法</h3><p>常见的计数方法有两种，可以分别称为：</p><ul><li><strong>自然计数法</strong>（从 <code>1</code> 开始）—— 更符合人类的习惯</li><li><strong>程序计数法</strong>（从 <code>0</code> 开始）—— 几乎所有的程序语言都选择从 0 开始计数</li></ul><p>因此，大家在编写程序时，应该尽量养成习惯：<strong>除非需求的特殊要求，否则 循环 的计数都从 0 开始</strong></p><h3 id="2-4-循环计算"><a href="#2-4-循环计算" class="headerlink" title="2.4 循环计算"></a>2.4 循环计算</h3><blockquote><p>在程序开发中，通常会遇到 <strong>利用循环</strong> <strong>重复计算</strong> 的需求</p></blockquote><p>遇到这种需求，可以：</p><ol><li>在 <code>while</code> 上方定义一个变量，用于 <strong>存放最终计算结果</strong></li><li>在循环体内部，每次循环都用 <strong>最新的计算结果</strong>，<strong>更新</strong> 之前定义的变量</li></ol><p><strong>需求</strong></p><ul><li>计算 0 ~ 100 之间所有数字的累计求和结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 计算 0 ~ 100 之间所有数字的累计求和结果</span><span class="token comment"># 0. 定义最终结果的变量</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 1. 定义一个整数的变量记录循环的次数</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 2. 开始循环</span><span class="token keyword">while</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token comment"># 每一次循环，都让 result 这个变量和 i 这个计数器相加</span>    result <span class="token operator">+=</span> i    <span class="token comment"># 处理计数器</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"0~100之间的数字求和结果 = %d"</span> <span class="token operator">%</span> result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="需求进阶"><a href="#需求进阶" class="headerlink" title="需求进阶"></a>需求进阶</h4><ul><li>计算 0 ~ 100 之间 所有 <strong>偶数</strong> 的累计求和结果</li></ul><p>开发步骤</p><ol><li>编写循环 <strong>确认</strong> <strong>要计算的数字</strong></li><li>添加 <strong>结果</strong> 变量，在循环内部 <strong>处理计算结果</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 0. 最终结果</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 1. 计数器</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 2. 开始循环</span><span class="token keyword">while</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">:</span>    <span class="token comment"># 判断偶数</span>    <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        result <span class="token operator">+=</span> i    <span class="token comment"># 处理计数器</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"0~100之间偶数求和结果 = %d"</span> <span class="token operator">%</span> result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="03-break-和-continue"><a href="#03-break-和-continue" class="headerlink" title="03. break 和 continue"></a>03. break 和 continue</h2><blockquote><p><code>break</code> 和 <code>continue</code> 是专门在循环中使用的关键字</p></blockquote><ul><li><code>break</code> <strong>某一条件满足时</strong>，退出循环，不再执行后续重复的代码</li><li><code>continue</code> <strong>某一条件满足时</strong>，不执行后续重复的代码</li></ul><blockquote><p><code>break</code> 和 <code>continue</code> 只针对 <strong>当前所在循环</strong> 有效</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030158.png" alt="002_循环流程图-w400" loading="lazy"></p><h3 id="3-1-break"><a href="#3-1-break" class="headerlink" title="3.1 break"></a>3.1 break</h3><ul><li><strong>在循环过程中</strong>，如果 <strong>某一个条件满足后</strong>，<strong>不</strong> 再希望 <strong>循环继续执行</strong>，可以使用 <code>break</code> 退出循环</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>    <span class="token comment"># break 某一条件满足时，退出循环，不再执行后续重复的代码</span>    <span class="token comment"># i == 3</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>break</code> 只针对当前所在循环有效</p></blockquote><h3 id="3-2-continue"><a href="#3-2-continue" class="headerlink" title="3.2 continue"></a>3.2 continue</h3><ul><li><strong>在循环过程中</strong>，如果 <strong>某一个条件满足后</strong>，<strong>不</strong> 希望 <strong>执行循环代码，但是又不希望退出循环</strong>，可以使用 <code>continue</code></li><li>也就是：在整个循环中，<strong>只有某些条件</strong>，不需要执行循环代码，而其他条件都需要执行</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>    <span class="token comment"># 当 i == 7 时，不希望执行需要重复执行的代码</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">:</span>        <span class="token comment"># 在使用 continue 之前，同样应该修改计数器</span>        <span class="token comment"># 否则会出现死循环</span>        i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">continue</span>    <span class="token comment"># 重复执行的代码</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>需要注意：使用 <code>continue</code> 时，<strong>条件处理部分的代码，需要特别注意</strong>，不小心会出现 <strong>死循环</strong></li></ul><blockquote><p><code>continue</code> 只针对当前所在循环有效</p></blockquote><h2 id="04-while-循环嵌套"><a href="#04-while-循环嵌套" class="headerlink" title="04. while 循环嵌套"></a>04. <code>while</code> 循环嵌套</h2><h3 id="4-1-循环嵌套"><a href="#4-1-循环嵌套" class="headerlink" title="4.1 循环嵌套"></a>4.1 循环嵌套</h3><ul><li><code>while</code> 嵌套就是：<code>while</code> 里面还有 <code>while</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> 条件 <span class="token number">1</span><span class="token punctuation">:</span>    条件满足时，做的事情<span class="token number">1</span>    条件满足时，做的事情<span class="token number">2</span>    条件满足时，做的事情<span class="token number">3</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>省略<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">while</span> 条件 <span class="token number">2</span><span class="token punctuation">:</span>        条件满足时，做的事情<span class="token number">1</span>        条件满足时，做的事情<span class="token number">2</span>        条件满足时，做的事情<span class="token number">3</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>省略<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            处理条件 <span class="token number">2</span>        处理条件 <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-循环嵌套演练-——-九九乘法表"><a href="#4-2-循环嵌套演练-——-九九乘法表" class="headerlink" title="4.2 循环嵌套演练 —— 九九乘法表"></a>4.2 循环嵌套演练 —— 九九乘法表</h3><h4 id="第-1-步：用嵌套打印小星星"><a href="#第-1-步：用嵌套打印小星星" class="headerlink" title="第 1 步：用嵌套打印小星星"></a>第 1 步：用嵌套打印小星星</h4><p><strong>需求</strong></p><ul><li>在控制台连续输出五行 <code>*</code>，每一行星号的数量依次递增</li></ul><pre class="line-numbers language-none"><code class="language-none">***************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用字符串 * 打印</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 定义一个计数器变量，从数字1开始，循环会比较方便</span>row <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">while</span> row <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> row<span class="token punctuation">)</span>    row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第-2-步：使用循环嵌套打印小星星"><a href="#第-2-步：使用循环嵌套打印小星星" class="headerlink" title="第 2 步：使用循环嵌套打印小星星"></a>第 2 步：使用循环嵌套打印小星星</h4><p><strong>知识点</strong> 对 <code>print</code> 函数的使用做一个增强</p><ul><li><p>在默认情况下，<code>print</code> 函数输出内容之后，会自动在内容末尾增加换行</p></li><li><p>如果不希望末尾增加换行，可以在 <code>print</code> 函数输出内容的后面增加 <code>, end=&quot;&quot;</code></p></li><li><p>其中 <code>&quot;&quot;</code> 中间可以指定 <code>print</code> 函数输出内容之后，继续希望显示的内容</p></li><li><p>语法格式如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 向控制台输出内容结束之后，不会换行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token comment"># 单纯的换行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>end=&quot;&quot;</code> 表示向控制台输出内容结束之后，不会换行</p></blockquote><p><strong>假设</strong> <code>Python</code> <strong>没有提供</strong> 字符串的 <code>*</code> 操作 <strong>拼接字符串</strong></p><p><strong>需求</strong></p><ul><li>在控制台连续输出五行 <code>*</code>，每一行星号的数量依次递增</li></ul><pre class="line-numbers language-none"><code class="language-none">***************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>开发步骤</strong></p><ul><li>1&gt; 完成 5 行内容的简单输出</li><li>2&gt; 分析每行内部的 <code>*</code> 应该如何处理？<ul><li>每行显示的星星和当前所在的行数是一致的</li><li>嵌套一个小的循环，专门处理每一行中 <code>列</code> 的星星显示</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">row <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">while</span> row <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token comment"># 假设 python 没有提供字符串 * 操作</span>    <span class="token comment"># 在循环内部，再增加一个循环，实现每一行的 星星 打印</span>    col <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> col <span class="token operator">&lt;=</span> row<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        col <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 每一行星号输出完成后，再增加一个换行</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第-3-步：-九九乘法表"><a href="#第-3-步：-九九乘法表" class="headerlink" title="第 3 步： 九九乘法表"></a>第 3 步： 九九乘法表</h4><p><strong>需求</strong> 输出 九九乘法表，格式如下：</p><pre class="line-numbers language-none"><code class="language-none">1 * 1 &#x3D; 11 * 2 &#x3D; 22 * 2 &#x3D; 41 * 3 &#x3D; 32 * 3 &#x3D; 63 * 3 &#x3D; 91 * 4 &#x3D; 42 * 4 &#x3D; 83 * 4 &#x3D; 124 * 4 &#x3D; 161 * 5 &#x3D; 52 * 5 &#x3D; 103 * 5 &#x3D; 154 * 5 &#x3D; 205 * 5 &#x3D; 251 * 6 &#x3D; 62 * 6 &#x3D; 123 * 6 &#x3D; 184 * 6 &#x3D; 245 * 6 &#x3D; 306 * 6 &#x3D; 361 * 7 &#x3D; 72 * 7 &#x3D; 143 * 7 &#x3D; 214 * 7 &#x3D; 285 * 7 &#x3D; 356 * 7 &#x3D; 427 * 7 &#x3D; 491 * 8 &#x3D; 82 * 8 &#x3D; 163 * 8 &#x3D; 244 * 8 &#x3D; 325 * 8 &#x3D; 406 * 8 &#x3D; 487 * 8 &#x3D; 568 * 8 &#x3D; 641 * 9 &#x3D; 92 * 9 &#x3D; 183 * 9 &#x3D; 274 * 9 &#x3D; 365 * 9 &#x3D; 456 * 9 &#x3D; 547 * 9 &#x3D; 638 * 9 &#x3D; 729 * 9 &#x3D; 81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>开发步骤</strong></p><ul><li><ol><li>打印 9 行小星星</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">*********************************************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><ol start="2"><li>将每一个 <code>*</code> 替换成对应的行与列相乘</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义起始行</span>row <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># 最大打印 9 行</span><span class="token keyword">while</span> row <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">:</span>    <span class="token comment"># 定义起始列</span>    col <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment"># 最大打印 row 列</span>    <span class="token keyword">while</span> col <span class="token operator">&lt;=</span> row<span class="token punctuation">:</span>        <span class="token comment"># end = ""，表示输出结束后，不换行</span>        <span class="token comment"># "\t" 可以在控制台输出一个制表符，协助在输出文本时对齐</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d * %d = %d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>col<span class="token punctuation">,</span> row<span class="token punctuation">,</span> row <span class="token operator">*</span> col<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"\t"</span><span class="token punctuation">)</span>        <span class="token comment"># 列数 + 1</span>        col <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 一行打印完成的换行</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token comment"># 行数 + 1</span>    row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>字符串中的转义字符</strong></p><ul><li><code>\t</code> 在控制台输出一个 <strong>制表符</strong>，协助在输出文本时 <strong>垂直方向</strong> 保持对齐</li><li><code>\n</code> 在控制台输出一个 <strong>换行符</strong></li></ul><blockquote><p><strong>制表符</strong> 的功能是在不使用表格的情况下在 <strong>垂直方向</strong> 按列对齐文本</p></blockquote><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\\</td><td>反斜杠符号</td></tr><tr><td>\‘</td><td>单引号</td></tr><tr><td>\“</td><td>双引号</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\r</td><td>回车</td></tr></tbody></table><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h2><ul><li>函数的快速体验</li><li>函数的基本使用</li><li>函数的参数</li><li>函数的返回值</li><li>函数的嵌套调用</li><li>在模块中定义函数</li></ul><h2 id="01-函数的快速体验"><a href="#01-函数的快速体验" class="headerlink" title="01. 函数的快速体验"></a>01. 函数的快速体验</h2><h3 id="1-1-快速体验"><a href="#1-1-快速体验" class="headerlink" title="1.1 快速体验"></a>1.1 快速体验</h3><ul><li>所谓<strong>函数</strong>，就是把 <strong>具有独立功能的代码块</strong> 组织为一个小模块，在需要的时候 <strong>调用</strong></li><li>函数的使用包含两个步骤：<ol><li>定义函数 —— <strong>封装</strong> 独立的功能</li><li>调用函数 —— 享受 <strong>封装</strong> 的成果</li></ol></li><li><strong>函数的作用</strong>，在开发程序时，使用函数可以提高编写的效率以及代码的 <strong>重用</strong></li></ul><p><strong>演练步骤</strong></p><ol><li>新建 <code>04_函数</code> 项目</li><li>复制之前完成的 <strong>乘法表</strong> 文件</li><li>修改文件，增加函数定义 <code>multiple_table():</code></li><li>新建另外一个文件，使用 <code>import</code> 导入并且调用函数</li></ol><h2 id="02-函数基本使用"><a href="#02-函数基本使用" class="headerlink" title="02. 函数基本使用"></a>02. 函数基本使用</h2><h3 id="2-1-函数的定义"><a href="#2-1-函数的定义" class="headerlink" title="2.1 函数的定义"></a>2.1 函数的定义</h3><p>定义函数的格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> 函数名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    函数封装的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>def</code> 是英文 <code>define</code> 的缩写</li><li><strong>函数名称</strong> 应该能够表达 <strong>函数封装代码</strong> 的功能，方便后续的调用</li><li><strong>函数名称</strong> 的命名应该 <strong>符合</strong> <strong>标识符的命名规则</strong><ul><li>可以由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li></ul></li></ol><h3 id="2-2-函数调用"><a href="#2-2-函数调用" class="headerlink" title="2.2 函数调用"></a>2.2 函数调用</h3><p>调用函数很简单的，通过 <code>函数名()</code> 即可完成对函数的调用</p><h3 id="2-3-第一个函数演练"><a href="#2-3-第一个函数演练" class="headerlink" title="2.3 第一个函数演练"></a>2.3 第一个函数演练</h3><p><strong>需求</strong></p><ul><li><ol><li>编写一个打招呼 <code>say_hello</code> 的函数，封装三行打招呼的代码</li></ol></li><li><ol start="2"><li>在函数下方调用打招呼的代码</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">"小明"</span><span class="token comment"># 解释器知道这里定义了一个函数</span><span class="token keyword">def</span> <span class="token function">say_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello 1"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello 2"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello 3"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token comment"># 只有在调用函数时，之前定义的函数才会被执行</span><span class="token comment"># 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码</span>say_hello<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>用 <strong>单步执行 F8 和 F7</strong> 观察以下代码的执行过程</p></blockquote><ul><li>定义好函数之后，只表示这个函数封装了一段代码而已</li><li>如果不主动调用函数，函数是不会主动执行的</li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul><li><p>能否将 <strong>函数调用</strong> 放在 <strong>函数定义</strong> 的上方？</p><ul><li>不能！</li><li>因为在 <strong>使用函数名</strong> 调用函数之前，必须要保证 <code>Python</code> 已经知道函数的存在</li><li>否则控制台会提示 <code>NameError: name &#39;say_hello&#39; is not defined</code> (<strong>名称错误：say_hello 这个名字没有被定义</strong>)</li></ul></li></ul><h3 id="2-4-PyCharm-的调试工具"><a href="#2-4-PyCharm-的调试工具" class="headerlink" title="2.4 PyCharm 的调试工具"></a>2.4 PyCharm 的调试工具</h3><ul><li><strong>F8 Step Over</strong> 可以单步执行代码，会把函数调用看作是一行代码直接执行</li><li><strong>F7 Step Into</strong> 可以单步执行代码，如果是函数，会进入函数内部</li></ul><h3 id="2-5-函数的文档注释"><a href="#2-5-函数的文档注释" class="headerlink" title="2.5 函数的文档注释"></a>2.5 函数的文档注释</h3><ul><li>在开发中，如果希望给函数添加注释，应该在 <strong>定义函数</strong> 的下方，使用 <strong>连续的三对引号</strong></li><li>在 <strong>连续的三对引号</strong> 之间编写对函数的说明文字</li><li>在 <strong>函数调用</strong> 位置，使用快捷键 <code>CTRL + Q</code> 可以查看函数的说明信息</li></ul><blockquote><p>注意：因为 <strong>函数体相对比较独立</strong>，<strong>函数定义的上方</strong>，应该和其他代码（包括注释）保留 <strong>两个空行</strong></p></blockquote><h2 id="03-函数的参数"><a href="#03-函数的参数" class="headerlink" title="03. 函数的参数"></a>03. 函数的参数</h2><p><strong>演练需求</strong></p><ol><li>开发一个 <code>sum_2_num</code> 的函数</li><li>函数能够实现 <strong>两个数字的求和</strong> 功能</li></ol><p>演练代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_2_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    num1 <span class="token operator">=</span> <span class="token number">10</span>    num2 <span class="token operator">=</span> <span class="token number">20</span>    result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span>sum_2_num<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>思考一下存在什么问题</strong></p><blockquote><p>函数只能处理 <strong>固定数值</strong> 的相加</p></blockquote><p><strong>如何解决？</strong></p><ul><li>如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！</li></ul><h3 id="3-1-函数参数的使用"><a href="#3-1-函数参数的使用" class="headerlink" title="3.1 函数参数的使用"></a>3.1 函数参数的使用</h3><ul><li>在函数名的后面的小括号内部填写 <strong>参数</strong></li><li>多个参数之间使用 <code>,</code> 分隔</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_2_num</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span>sum_2_num<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-参数的作用"><a href="#3-2-参数的作用" class="headerlink" title="3.2 参数的作用"></a>3.2 参数的作用</h3><ul><li><strong>函数</strong>，把 <strong>具有独立功能的代码块</strong> 组织为一个小模块，在需要的时候 <strong>调用</strong></li><li><strong>函数的参数</strong>，增加函数的 <strong>通用性</strong>，针对 <strong>相同的数据处理逻辑</strong>，能够 <strong>适应更多的数据</strong><ol><li>在函数 <strong>内部</strong>，把参数当做 <strong>变量</strong> 使用，进行需要的数据处理</li><li>函数调用时，按照函数定义的<strong>参数顺序</strong>，把 <strong>希望在函数内部处理的数据</strong>，<strong>通过参数</strong> 传递</li></ol></li></ul><h3 id="3-3-形参和实参"><a href="#3-3-形参和实参" class="headerlink" title="3.3 形参和实参"></a>3.3 形参和实参</h3><ul><li><strong>形参</strong>：<strong>定义</strong> 函数时，小括号中的参数，是用来接收参数用的，在函数内部 <strong>作为变量使用</strong></li><li><strong>实参</strong>：<strong>调用</strong> 函数时，小括号中的参数，是用来把数据传递到 <strong>函数内部</strong> 用的</li></ul><h2 id="04-函数的返回值"><a href="#04-函数的返回值" class="headerlink" title="04. 函数的返回值"></a>04. 函数的返回值</h2><ul><li>在程序开发中，有时候，会希望 <strong>一个函数执行结束后，告诉调用者一个结果</strong>，以便调用者针对具体的结果做后续的处理</li><li><strong>返回值</strong> 是函数 <strong>完成工作</strong>后，<strong>最后</strong> 给调用者的 <strong>一个结果</strong></li><li>在函数中使用 <code>return</code> 关键字可以返回结果</li><li>调用函数一方，可以 <strong>使用变量</strong> 来 <strong>接收</strong> 函数的返回结果</li></ul><blockquote><p>注意：<code>return</code> 表示返回，后续的代码都不会被执行</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_2_num</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""对两个数字的求和"""</span>    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token comment"># 调用函数，并使用 result 变量接收计算结果</span>result <span class="token operator">=</span> sum_2_num<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"计算结果是 %d"</span> <span class="token operator">%</span> result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="05-函数的嵌套调用"><a href="#05-函数的嵌套调用" class="headerlink" title="05. 函数的嵌套调用"></a>05. 函数的嵌套调用</h2><ul><li>一个函数里面 <strong>又调用</strong> 了 <strong>另外一个函数</strong>，这就是 <strong>函数嵌套调用</strong></li><li>如果函数 <code>test2</code> 中，调用了另外一个函数 <code>test1</code><ul><li>那么执行到调用 <code>test1</code> 函数时，会先把函数 <code>test1</code> 中的任务都执行完</li><li>才会回到 <code>test2</code> 中调用函数 <code>test1</code> 的位置，继续执行后续的代码</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test 1"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test 2"</span><span class="token punctuation">)</span>        test1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>test2<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数嵌套的演练-——-打印分隔线"><a href="#函数嵌套的演练-——-打印分隔线" class="headerlink" title="函数嵌套的演练 —— 打印分隔线"></a>函数嵌套的演练 —— 打印分隔线</h3><blockquote><p>体会一下工作中 <strong>需求是多变</strong> 的</p></blockquote><p><strong>需求 1</strong></p><ul><li>定义一个 <code>print_line</code> 函数能够打印 <code>*</code> 组成的 <strong>一条分隔线</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>需求 2</strong></p><ul><li>定义一个函数能够打印 <strong>由任意字符组成</strong> 的分隔线</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>char <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需求 3</strong></p><ul><li>定义一个函数能够打印 <strong>任意重复次数</strong> 的分隔线</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>char <span class="token operator">*</span> times<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>需求 4</strong></p><ul><li>定义一个函数能够打印 <strong>5 行</strong> 的分隔线，分隔线要求符合<strong>需求 3</strong></li></ul><blockquote><p>提示：工作中针对需求的变化，应该冷静思考，<strong>不要轻易修改之前已经完成的，能够正常执行的函数</strong>！</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>char <span class="token operator">*</span> times<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">print_lines</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">:</span>    row <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> row <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>        print_line<span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span>        row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="06-使用模块中的函数"><a href="#06-使用模块中的函数" class="headerlink" title="06. 使用模块中的函数"></a>06. 使用模块中的函数</h2><blockquote><p><strong>模块是 Python 程序架构的一个核心概念</strong></p></blockquote><ul><li><strong>模块</strong> 就好比是 <strong>工具包</strong>，要想使用这个工具包中的工具，就需要 <strong>导入 import</strong> 这个模块</li><li>每一个以扩展名 <code>py</code> 结尾的 <code>Python</code> 源代码文件都是一个 <strong>模块</strong></li><li>在模块中定义的 <strong>全局变量</strong> 、 <strong>函数</strong> 都是模块能够提供给外界直接使用的工具</li></ul><h3 id="6-1-第一个模块体验"><a href="#6-1-第一个模块体验" class="headerlink" title="6.1 第一个模块体验"></a>6.1 第一个模块体验</h3><p><strong>步骤</strong></p><ul><li>新建 <code>hm_10_分隔线模块.py</code><ul><li>复制 <code>hm_09_打印多条分隔线.py</code> 中的内容，<strong>最后一行 <code>print</code> 代码除外</strong></li><li>增加一个字符串变量</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">"黑马程序员"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>新建 <code>hm_10_体验模块.py</code> 文件，并且编写以下代码：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> hm_10_分隔线模块hm_10_分隔线模块<span class="token punctuation">.</span>print_line<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hm_10_分隔线模块<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="体验小结"><a href="#体验小结" class="headerlink" title="体验小结"></a>体验小结</h4><ul><li>可以 <strong>在一个 Python 文件</strong> 中 <strong>定义 变量 或者 函数</strong></li><li>然后在 <strong>另外一个文件中</strong> 使用 <code>import</code> 导入这个模块</li><li>导入之后，就可以使用 <code>模块名.变量</code> &#x2F; <code>模块名.函数</code> 的方式，使用这个模块中定义的变量或者函数</li></ul><blockquote><p><strong>模块</strong>可以让 <strong>曾经编写过的代码</strong> 方便的被 <strong>复用</strong>！</p></blockquote><h3 id="6-2-模块名也是一个标识符"><a href="#6-2-模块名也是一个标识符" class="headerlink" title="6.2 模块名也是一个标识符"></a>6.2 模块名也是一个标识符</h3><ul><li>标示符可以由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li></ul><blockquote><p>注意：如果在给 Python 文件起名时，<strong>以数字开头</strong> 是无法在 <code>PyCharm</code> 中通过导入这个模块的</p></blockquote><h3 id="6-3-Pyc-文件（了解）"><a href="#6-3-Pyc-文件（了解）" class="headerlink" title="6.3 Pyc 文件（了解）"></a>6.3 Pyc 文件（了解）</h3><blockquote><p><code>C</code> 是 <code>compiled</code> <strong>编译过</strong> 的意思</p></blockquote><p><strong>操作步骤</strong></p><ol><li>浏览程序目录会发现一个 <code>__pycache__</code> 的目录</li><li>目录下会有一个 <code>hm_10_分隔线模块.cpython-35.pyc</code> 文件，<code>cpython-35</code> 表示 <code>Python</code> 解释器的版本</li><li>这个 <code>pyc</code> 文件是由 Python 解释器将 <strong>模块的源码</strong> 转换为 <strong>字节码</strong><ul><li><code>Python</code> 这样保存 <strong>字节码</strong> 是作为一种启动 <strong>速度的优化</strong></li></ul></li></ol><p><strong>字节码</strong></p><ul><li><p><code>Python</code> 在解释源程序时是分成两个步骤的</p><ol><li>首先处理源代码，<strong>编译</strong> 生成一个二进制 <strong>字节码</strong></li><li>再对 <strong>字节码</strong> 进行处理，才会生成 CPU 能够识别的 <strong>机器码</strong></li></ol></li><li><p>有了模块的字节码文件之后，下一次运行程序时，如果在 <strong>上次保存字节码之后</strong> 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤</p></li><li><p>当 <code>Python</code> 重编译时，它会自动检查源文件和字节码文件的时间戳</p></li><li><p>如果你又修改了源代码，下次程序运行时，字节码将自动重新创建</p></li></ul><blockquote><p>提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！</p><p><strong>模块是 Python 程序架构的一个核心概念</strong></p></blockquote><h1 id="高级变量类型"><a href="#高级变量类型" class="headerlink" title="高级变量类型"></a>高级变量类型</h1><h2 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h2><ul><li>列表</li><li>元组</li><li>字典</li><li>字符串</li><li>公共方法</li><li>变量高级</li></ul><h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><ul><li><p>Python 中数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></p></li><li><p>数字型</p><ul><li>整型 (<code>int</code>)</li><li>浮点型（<code>float</code>）</li><li>布尔型（<code>bool</code>） <ul><li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 (<code>complex</code>)<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li><p>非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li><li><p>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong> 都支持以下特点：</p><ol><li>都是一个 <strong>序列</strong> <code>sequence</code>，也可以理解为 <strong>容器</strong></li><li><strong>取值</strong> <code>[]</code></li><li><strong>遍历</strong> <code>for in</code></li><li><strong>计算长度</strong>、<strong>最大&#x2F;最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li><li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong> <code>*</code></li><li><strong>切片</strong></li></ol></li></ul><h2 id="01-列表"><a href="#01-列表" class="headerlink" title="01. 列表"></a>01. 列表</h2><h3 id="1-1-列表的定义"><a href="#1-1-列表的定义" class="headerlink" title="1.1 列表的定义"></a>1.1 列表的定义</h3><ul><li><code>List</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型，在其他语言中通常叫做 <strong>数组</strong></li><li>专门用于存储 <strong>一串 信息</strong></li><li>列表用 <code>[]</code> 定义，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>列表的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>列表</strong> 中的位置编号，<strong>索引</strong> 又可以被称为 <strong>下标</strong></li></ul></li></ul><blockquote><p>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">name_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token string">"wangwu"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030308.png" alt="001_列表示意图" loading="lazy"></p><h3 id="1-2-列表常用操作"><a href="#1-2-列表常用操作" class="headerlink" title="1.2 列表常用操作"></a>1.2 列表常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li><li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">In [1]: name_list.name_list.append   name_list.count    name_list.insert   name_list.reversename_list.clear    name_list.extend   name_list.pop      name_list.sortname_list.copy     name_list.index    name_list.remove <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>序号</th><th>分类</th><th>关键字 &#x2F; 函数 &#x2F; 方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>增加</td><td>列表.insert(索引, 数据)</td><td>在指定位置插入数据</td></tr><tr><td></td><td></td><td>列表.append(数据)</td><td>在末尾追加数据</td></tr><tr><td></td><td></td><td>列表.extend(列表2)</td><td>将列表2 的数据追加到列表</td></tr><tr><td>2</td><td>修改</td><td>列表[索引] &#x3D; 数据</td><td>修改指定索引的数据</td></tr><tr><td>3</td><td>删除</td><td>del 列表[索引]</td><td>删除指定索引的数据</td></tr><tr><td></td><td></td><td>列表.remove[数据]</td><td>删除第一个出现的指定数据</td></tr><tr><td></td><td></td><td>列表.pop</td><td>删除末尾数据</td></tr><tr><td></td><td></td><td>列表.pop(索引)</td><td>删除指定索引数据</td></tr><tr><td></td><td></td><td>列表.clear</td><td>清空列表</td></tr><tr><td>4</td><td>统计</td><td>len(列表)</td><td>列表长度</td></tr><tr><td></td><td></td><td>列表.count(数据)</td><td>数据在列表中出现的次数</td></tr><tr><td>5</td><td>排序</td><td>列表.sort()</td><td>升序排序</td></tr><tr><td></td><td></td><td>列表.sort(reverse&#x3D;True)</td><td>降序排序</td></tr><tr><td></td><td></td><td>列表.reverse()</td><td>逆序、反转</td></tr></tbody></table><h4 id="del-关键字（科普）"><a href="#del-关键字（科普）" class="headerlink" title="del 关键字（科普）"></a>del 关键字（科普）</h4><ul><li>使用 <code>del</code> 关键字(<code>delete</code>) 同样可以删除列表中元素</li><li><code>del</code> 关键字本质上是用来 <strong>将一个变量从内存中删除的</strong></li><li>如果使用 <code>del</code> 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">del</span> name_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在日常开发中，要从列表删除数据，建议 <strong>使用列表提供的方法</strong></p></blockquote><h4 id="关键字、函数和方法（科普）"><a href="#关键字、函数和方法（科普）" class="headerlink" title="关键字、函数和方法（科普）"></a>关键字、函数和方法（科普）</h4><ul><li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">import</span> keywordIn <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>关键字后面不需要使用括号</p></blockquote><ul><li><strong>函数</strong> 封装了独立功能，可以直接调用</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">函数名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>函数需要死记硬背</p></blockquote><ul><li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li><li><strong>方法</strong> 需要通过 <strong>对象</strong> 来调用，表示针对这个 <strong>对象</strong> 要做的操作</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">对象<span class="token punctuation">.</span>方法名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p></blockquote><h3 id="1-3-循环遍历"><a href="#1-3-循环遍历" class="headerlink" title="1.3 循环遍历"></a>1.3 循环遍历</h3><ul><li><p><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中获取数据</p><ul><li>在 <strong>循环体内部</strong> 针对 <strong>每一个元素</strong>，执行相同的操作</li></ul></li><li><p>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的 <strong>迭代 iteration 遍历</strong></p></li><li><p>使用 <code>for</code> 就能够实现迭代遍历</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># for 循环内部使用的变量 in 列表</span><span class="token keyword">for</span> name <span class="token keyword">in</span> name_list<span class="token punctuation">:</span>    循环内部针对列表元素进行操作    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030309.png" alt="002_forin循环流程图-w420" loading="lazy"></p><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 <strong>应用场景</strong></h3><ul><li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以 <strong>存储不同类型的数据</strong></li><li>但是在开发中，更多的应用场景是<ol><li><strong>列表</strong> 存储相同类型的数据</li><li>通过 <strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ol></li></ul><h2 id="02-元组"><a href="#02-元组" class="headerlink" title="02. 元组"></a>02. 元组</h2><h3 id="2-1-元组的定义"><a href="#2-1-元组的定义" class="headerlink" title="2.1 元组的定义"></a>2.1 元组的定义</h3><ul><li><code>Tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong><ul><li><strong>元组</strong> 表示多个元素组成的序列</li><li><strong>元组</strong> 在 <code>Python</code> 开发中，有特定的应用场景</li></ul></li><li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>元组用 <code>()</code> 定义</li><li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>元组</strong> 中的位置编号</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">info_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1.75</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">info_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="元组中-只包含一个元素-时，需要-在元素后面添加逗号"><a href="#元组中-只包含一个元素-时，需要-在元素后面添加逗号" class="headerlink" title="元组中 只包含一个元素 时，需要 在元素后面添加逗号"></a>元组中 <strong>只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">info_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030310.png" alt="003_元组示意图-w500" loading="lazy"></p><h3 id="2-2-元组常用操作"><a href="#2-2-元组常用操作" class="headerlink" title="2.2 元组常用操作"></a>2.2 元组常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>元组</strong>，例如：<code>info = ()</code></li><li>输入 <code>info.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>元组</strong> 能够使用的函数如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">info<span class="token punctuation">.</span>count  info<span class="token punctuation">.</span>index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>有关 <strong>元组</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="2-3-循环遍历"><a href="#2-3-循环遍历" class="headerlink" title="2.3 循环遍历"></a>2.3 循环遍历</h3><ul><li><strong>取值</strong> 就是从 <strong>元组</strong> 中获取存储在指定位置的数据</li><li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>元组</strong> 中获取数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># for 循环内部使用的变量 in 元组</span><span class="token keyword">for</span> item <span class="token keyword">in</span> info<span class="token punctuation">:</span>    循环内部针对元组元素进行操作    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>在 <code>Python</code> 中，可以使用 <code>for</code> 循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 以及 <strong>字符串</strong></li><li>提示：在实际开发中，除非 <strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li></ul></blockquote><h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li><li>但是在开发中，更多的应用场景是：<ul><li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收 <strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul><li>有关 <strong>函数的参数 和 返回值</strong>，在后续 <strong>函数高级</strong> 给大家介绍</li></ul></li><li><strong>格式字符串</strong>，格式化字符串后面的 <code>()</code> 本质上就是一个元组</li><li><strong>让列表不可以被修改</strong>，以保护数据安全</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">info <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 的年龄是 %d"</span> <span class="token operator">%</span> info<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="元组和列表之间的转换"><a href="#元组和列表之间的转换" class="headerlink" title="元组和列表之间的转换"></a>元组和列表之间的转换</h4><ul><li>使用 <code>list</code> 函数可以把元组转换成列表</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span><span class="token punctuation">(</span>元组<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 <code>tuple</code> 函数可以把列表转换成元组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">tuple</span><span class="token punctuation">(</span>列表<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="03-字典"><a href="#03-字典" class="headerlink" title="03. 字典"></a>03. 字典</h2><h3 id="3-1-字典的定义"><a href="#3-1-字典的定义" class="headerlink" title="3.1 字典的定义"></a>3.1 字典的定义</h3><ul><li><code>dictionary</code>（字典） 是 <strong>除列表以外</strong> <code>Python</code> 之中 <strong>最灵活</strong> 的数据类型</li><li>字典同样可以用来 <strong>存储多个数据</strong><ul><li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong></li></ul></li><li>和列表的区别<ul><li><strong>列表</strong> 是 <strong>有序</strong> 的对象集合</li><li><strong>字典</strong> 是 <strong>无序</strong> 的对象集合</li></ul></li><li>字典用 <code>&#123;&#125;</code> 定义</li><li>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用 <code>,</code> 分隔<ul><li><strong>键</strong> <code>key</code> 是索引</li><li><strong>值</strong> <code>value</code> 是数据</li><li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li><li><strong>键必须是唯一的</strong></li><li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">xiaoming <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小明"</span><span class="token punctuation">,</span>            <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>            <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>            <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">1.75</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030311.png" alt="002_字典示意图" loading="lazy"></p><h3 id="3-2-字典常用操作"><a href="#3-2-字典常用操作" class="headerlink" title="3.2 字典常用操作"></a>3.2 字典常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = &#123;&#125;</code></li><li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong> 能够使用的函数如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">In [1]: xiaoming.xiaoming.clear       xiaoming.items       xiaoming.setdefaultxiaoming.copy        xiaoming.keys        xiaoming.updatexiaoming.fromkeys    xiaoming.pop         xiaoming.valuesxiaoming.get         xiaoming.popitem    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>有关 <strong>字典</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="3-3-循环遍历"><a href="#3-3-循环遍历" class="headerlink" title="3.3 循环遍历"></a>3.3 循环遍历</h3><ul><li><strong>遍历</strong> 就是 <strong>依次</strong> 从 <strong>字典</strong> 中获取所有键值对</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># for 循环内部使用的 `key 的变量` in 字典</span><span class="token keyword">for</span> k <span class="token keyword">in</span> xiaoming<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s: %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span> xiaoming<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p></blockquote><h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 <strong>应用场景</strong></h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li><li>但是在开发中，更多的应用场景是：<ul><li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li><li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">card_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>              <span class="token string">"qq"</span><span class="token punctuation">:</span> <span class="token string">"12345"</span><span class="token punctuation">,</span>              <span class="token string">"phone"</span><span class="token punctuation">:</span> <span class="token string">"110"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>             <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"李四"</span><span class="token punctuation">,</span>              <span class="token string">"qq"</span><span class="token punctuation">:</span> <span class="token string">"54321"</span><span class="token punctuation">,</span>              <span class="token string">"phone"</span><span class="token punctuation">:</span> <span class="token string">"10086"</span><span class="token punctuation">&#125;</span>             <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04. 字符串"></a>04. 字符串</h2><h3 id="4-1-字符串的定义"><a href="#4-1-字符串的定义" class="headerlink" title="4.1 字符串的定义"></a>4.1 字符串的定义</h3><ul><li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li><li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串<ul><li>虽然可以使用 <code>\&quot;</code> 或者 <code>\&#39;</code> 做字符串的转义，但是在实际开发中：<ul><li>如果字符串内部需要使用 <code>&quot;</code>，可以使用 <code>&#39;</code> 定义字符串</li><li>如果字符串内部需要使用 <code>&#39;</code>，可以使用 <code>&quot;</code> 定义字符串</li></ul></li></ul></li><li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li><li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li></ul><blockquote><p>大多数编程语言都是用 <code>&quot;</code> 来定义字符串</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">string <span class="token operator">=</span> <span class="token string">"Hello Python"</span><span class="token keyword">for</span> c <span class="token keyword">in</span> string<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030312.png" alt="005_字符串示意图-w500" loading="lazy"></p><h3 id="4-2-字符串的常用操作"><a href="#4-2-字符串的常用操作" class="headerlink" title="4.2 字符串的常用操作"></a>4.2 字符串的常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = &quot;&quot;</code></li><li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">In [1]: hello_str.hello_str.capitalize    hello_str.isidentifier  hello_str.rindexhello_str.casefold      hello_str.islower       hello_str.rjusthello_str.center        hello_str.isnumeric     hello_str.rpartitionhello_str.count         hello_str.isprintable   hello_str.rsplithello_str.encode        hello_str.isspace       hello_str.rstriphello_str.endswith      hello_str.istitle       hello_str.splithello_str.expandtabs    hello_str.isupper       hello_str.splitlineshello_str.find          hello_str.join          hello_str.startswithhello_str.format        hello_str.ljust         hello_str.striphello_str.format_map    hello_str.lower         hello_str.swapcasehello_str.index         hello_str.lstrip        hello_str.titlehello_str.isalnum       hello_str.maketrans     hello_str.translatehello_str.isalpha       hello_str.partition     hello_str.upperhello_str.isdecimal     hello_str.replace       hello_str.zfillhello_str.isdigit       hello_str.rfind<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p></blockquote><h4 id="1-判断类型-9"><a href="#1-判断类型-9" class="headerlink" title="1) 判断类型 - 9"></a>1) 判断类型 - 9</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True</td></tr><tr><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td></tr><tr><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr><td>string.isdecimal()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code></td></tr><tr><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td></tr><tr><td>string.isnumeric()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td>string.istitle()</td><td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td></tr><tr><td>string.islower()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td></tr><tr><td>string.isupper()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td></tr></tbody></table><h4 id="2-查找和替换-7"><a href="#2-查找和替换-7" class="headerlink" title="2) 查找和替换 - 7"></a>2) 查找和替换 - 7</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.startswith(str)</td><td>检查字符串是否是以 str 开头，是则返回 True</td></tr><tr><td>string.endswith(str)</td><td>检查字符串是否是以 str 结束，是则返回 True</td></tr><tr><td>string.find(str, start&#x3D;0, end&#x3D;len(string))</td><td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td></tr><tr><td>string.rfind(str, start&#x3D;0, end&#x3D;len(string))</td><td>类似于 find()，不过是从右边开始查找</td></tr><tr><td>string.index(str, start&#x3D;0, end&#x3D;len(string))</td><td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td></tr><tr><td>string.rindex(str, start&#x3D;0, end&#x3D;len(string))</td><td>类似于 index()，不过是从右边开始</td></tr><tr><td>string.replace(old_str, new_str, num&#x3D;string.count(old))</td><td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td></tr></tbody></table><h4 id="3-大小写转换-5"><a href="#3-大小写转换-5" class="headerlink" title="3) 大小写转换 - 5"></a>3) 大小写转换 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.title()</td><td>把字符串的每个单词首字母大写</td></tr><tr><td>string.lower()</td><td>转换 string 中所有大写字符为小写</td></tr><tr><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr></tbody></table><h4 id="4-文本对齐-3"><a href="#4-文本对齐-3" class="headerlink" title="4) 文本对齐 - 3"></a>4) 文本对齐 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td></tr></tbody></table><h4 id="5-去除空白字符-3"><a href="#5-去除空白字符-3" class="headerlink" title="5) 去除空白字符 - 3"></a>5) 去除空白字符 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.lstrip()</td><td>截掉 string 左边（开始）的空白字符</td></tr><tr><td>string.rstrip()</td><td>截掉 string 右边（末尾）的空白字符</td></tr><tr><td>string.strip()</td><td>截掉 string 左右两边的空白字符</td></tr></tbody></table><h4 id="6-拆分和连接-5"><a href="#6-拆分和连接-5" class="headerlink" title="6) 拆分和连接 - 5"></a>6) 拆分和连接 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.partition(str)</td><td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td></tr><tr><td>string.rpartition(str)</td><td>类似于 partition() 方法，不过是从右边开始查找</td></tr><tr><td>string.split(str&#x3D;””, num)</td><td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td></tr><tr><td>string.splitlines()</td><td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table><h3 id="4-3-字符串的切片"><a href="#4-3-字符串的切片" class="headerlink" title="4.3 字符串的切片"></a>4.3 字符串的切片</h3><ul><li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030313.png" alt="006_字符串索引示意图" loading="lazy"></p><pre class="line-numbers language-none"><code class="language-none">字符串[开始索引:结束索引:步长]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：</p><ol><li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> &#x3D;&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul><li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li></ul></li><li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li></ol><h4 id="索引的顺序和倒序"><a href="#索引的顺序和倒序" class="headerlink" title="索引的顺序和倒序"></a>索引的顺序和倒序</h4><ul><li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong></li><li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul><li>最右边的索引值是 <strong>-1</strong>，依次递减</li></ul></li></ul><p><strong>演练需求</strong></p><ul><li><ol><li>截取从 2 ~ 5 位置 的字符串</li></ol></li><li><ol start="2"><li>截取从 2 ~ <code>末尾</code> 的字符串</li></ol></li><li><ol start="3"><li>截取从 <code>开始</code> ~ 5 位置 的字符串</li></ol></li><li><ol start="4"><li>截取完整的字符串</li></ol></li><li><ol start="5"><li>从开始位置，每隔一个字符截取字符串</li></ol></li><li><ol start="6"><li>从索引 1 开始，每隔一个取一个</li></ol></li><li><ol start="7"><li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li></ol></li><li><ol start="8"><li>截取字符串末尾两个字符</li></ol></li><li><ol start="9"><li>字符串的逆序（面试题）</li></ol></li></ul><p><strong>答案</strong></p><pre class="line-numbers language-none"><code class="language-none">num_str &#x3D; &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])# 2. 截取从 2 ~ &#96;末尾&#96; 的字符串print(num_str[2:])# 3. 截取从 &#96;开始&#96; ~ 5 位置 的字符串print(num_str[:6])# 4. 截取完整的字符串print(num_str[:])# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])# 7. 截取从 2 ~ &#96;末尾 - 1&#96; 的字符串print(num_str[2:-1])# 8. 截取字符串末尾两个字符print(num_str[-2:])# 9. 字符串的逆序（面试题）print(num_str[::-1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="05-公共方法"><a href="#05-公共方法" class="headerlink" title="05. 公共方法"></a>05. 公共方法</h2><h3 id="5-1-Python-内置函数"><a href="#5-1-Python-内置函数" class="headerlink" title="5.1 Python 内置函数"></a>5.1 Python 内置函数</h3><p>Python 包含了以下内置函数：</p><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del 有两种方式</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>cmp(item1, item2)</td><td>比较两个值，-1 小于&#x2F;0 相等&#x2F;1 大于</td><td>Python 3.x 取消了 cmp 函数</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li></ul><h3 id="5-2-切片"><a href="#5-2-切片" class="headerlink" title="5.2 切片"></a>5.2 切片</h3><p>| 描述 | Python 表达式 | 结果 | 支持的数据类型 |<br>| :—: | — | — | — | — |<br>| 切片 | “0123456789”[::-2] | “97531” | 字符串、列表、元组 |</p><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul><h3 id="5-3-运算符"><a href="#5-3-运算符" class="headerlink" title="5.3 运算符"></a>5.3 运算符</h3><table><thead><tr><th align="center">运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr><td align="center">+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td align="center">*</td><td>[“Hi!”] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td align="center">in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">&gt; &gt;&#x3D; &#x3D;&#x3D; &lt; &lt;&#x3D;</td><td>(1, 2, 3) &lt; (2, 2, 3)</td><td>True</td><td>元素比较</td><td>字符串、列表、元组</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li><li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False</td><td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False</td><td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td></tr></tbody></table><p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p><h3 id="5-4-完整的-for-循环语法"><a href="#5-4-完整的-for-循环语法" class="headerlink" title="5.4 完整的 for 循环语法"></a>5.4 完整的 for 循环语法</h3><ul><li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> 变量 <span class="token keyword">in</span> 集合<span class="token punctuation">:</span>        循环体代码<span class="token keyword">else</span><span class="token punctuation">:</span>    没有通过 <span class="token keyword">break</span> 退出循环，循环结束后，会执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></li><li>需求：要判断 某一个字典中 是否存在 指定的 值 <ul><li>如果 <strong>存在</strong>，提示并且退出循环</li><li>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">students <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"阿土"</span><span class="token punctuation">,</span>     <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>     <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>     <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">1.7</span><span class="token punctuation">,</span>     <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">75.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小美"</span><span class="token punctuation">,</span>     <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">19</span><span class="token punctuation">,</span>     <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token boolean">False</span><span class="token punctuation">,</span>     <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">1.6</span><span class="token punctuation">,</span>     <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">45.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span>find_name <span class="token operator">=</span> <span class="token string">"阿土"</span><span class="token keyword">for</span> stu_dict <span class="token keyword">in</span> students<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>stu_dict<span class="token punctuation">)</span>    <span class="token comment"># 判断当前遍历的字典中姓名是否为find_name</span>    <span class="token keyword">if</span> stu_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">==</span> find_name<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"找到了"</span><span class="token punctuation">)</span>        <span class="token comment"># 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较</span>        <span class="token keyword">break</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有找到"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"循环结束"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="综合应用-——-名片管理系统"><a href="#综合应用-——-名片管理系统" class="headerlink" title="综合应用 —— 名片管理系统"></a>综合应用 —— 名片管理系统</h1><h2 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h2><p>综合应用已经学习过的知识点：</p><ul><li><strong>变量</strong></li><li><strong>流程控制</strong></li><li><strong>函数</strong></li><li><strong>模块</strong></li></ul><p>开发 <strong>名片管理系统</strong></p><h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><ul><li><ol><li>程序启动，显示名片管理系统欢迎界面，并显示功能菜单</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">**************************************************欢迎使用【名片管理系统】V1.01. 新建名片2. 显示全部3. 查询名片0. 退出系统**************************************************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><ol start="2"><li>用户用数字选择不同的功能</li></ol></li><li><ol start="3"><li>根据功能选择，执行不同的功能</li></ol></li><li><ol start="4"><li>用户名片需要记录用户的 <strong>姓名</strong>、<strong>电话</strong>、<strong>QQ</strong>、<strong>邮件</strong></li></ol></li><li><ol start="5"><li>如果查询到指定的名片，用户可以选择 <strong>修改</strong> 或者 <strong>删除</strong> 名片</li></ol></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>框架搭建</li><li>新增名片</li><li>显示所有名片</li><li>查询名片</li><li>查询成功后修改、删除名片</li><li>让 Python 程序能够直接运行</li></ol><h2 id="01-框架搭建"><a href="#01-框架搭建" class="headerlink" title="01. 框架搭建"></a>01. 框架搭建</h2><p><strong>目标</strong></p><ul><li>搭建名片管理系统 <strong>框架结构</strong><ol><li><strong>准备文件</strong>，确定文件名，保证能够 <strong>在需要的位置</strong> 编写代码</li><li>编写 <strong>主运行循环</strong>，实现基本的 <strong>用户输入和判断</strong></li></ol></li></ul><h3 id="1-1-文件准备"><a href="#1-1-文件准备" class="headerlink" title="1.1 文件准备"></a>1.1 文件准备</h3><ol><li>新建 <code>cards_main.py</code> 保存 <strong>主程序功能代码</strong><ul><li>程序的入口</li><li>每一次启动名片管理系统都通过 <code>main</code> 这个文件启动</li></ul></li><li>新建 <code>cards_tools.py</code> 保存 <strong>所有名片功能函数</strong><ul><li>将对名片的 <strong>新增</strong>、<strong>查询</strong>、<strong>修改</strong>、<strong>删除</strong> 等功能封装在不同的函数中</li></ul></li></ol><h3 id="1-2-编写主运行循环"><a href="#1-2-编写主运行循环" class="headerlink" title="1.2 编写主运行循环"></a>1.2 编写主运行循环</h3><ul><li>在 <code>cards_main</code> 中添加一个 <strong>无限循环</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment"># TODO(小明) 显示系统菜单</span>    action <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请选择操作功能："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"您选择的操作是：%s"</span> <span class="token operator">%</span> action<span class="token punctuation">)</span>    <span class="token comment"># 根据用户输入决定后续的操作</span>    <span class="token keyword">if</span> action <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"0"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欢迎再次使用【名片管理系统】"</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输入错误，请重新输入"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> action <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span> <span class="token keyword">or</span> action <span class="token operator">==</span> <span class="token string">"2"</span> <span class="token keyword">or</span> action <span class="token operator">==</span> <span class="token string">"3"</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>使用 <code>in</code> 针对 <strong>列表</strong> 判断，避免使用 <code>or</code> 拼接复杂的逻辑条件</li><li>没有使用 <code>int</code> 转换用户输入，可以避免 <strong>一旦用户输入的不是数字</strong>，导致程序运行出错</li></ol><h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><ul><li><code>pass</code> 就是一个空语句，不做任何事情，一般用做占位语句</li><li>是为了保持程序结构的完整性</li></ul><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><ul><li>在开发软件时，如果 <strong>不希望程序执行后</strong> 立即退出</li><li>可以在程序中增加一个 <strong>无限循环</strong></li><li><strong>由用户来决定</strong> 退出程序的时机</li></ul><h4 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h4><ul><li>在 <code>#</code> 后跟上 <code>TODO</code>，用于标记需要去做的工作</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># TODO(作者/邮件) 显示系统菜单</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-在-cards-tools-中增加四个新函数"><a href="#1-3-在-cards-tools-中增加四个新函数" class="headerlink" title="1.3 在 cards_tools 中增加四个新函数"></a>1.3 在 <code>cards_tools</code> 中增加四个新函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示菜单    """</span>    <span class="token keyword">pass</span><span class="token keyword">def</span> <span class="token function">new_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""新建名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：新建名片"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">search_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""搜索名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：搜索名片"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-导入模块"><a href="#1-4-导入模块" class="headerlink" title="1.4 导入模块"></a>1.4 导入模块</h3><ul><li>在 <code>cards_main.py</code> 中使用 <code>import</code> 导入 <code>cards_tools</code> 模块</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cards_tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改 <code>while</code> 循环的代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cards_tools<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    cards_tools<span class="token punctuation">.</span>show_menu<span class="token punctuation">(</span><span class="token punctuation">)</span>    action <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请选择操作功能："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"您选择的操作是：%s"</span> <span class="token operator">%</span> action<span class="token punctuation">)</span>    <span class="token comment"># 根据用户输入决定后续的操作</span>    <span class="token keyword">if</span> action <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>            cards_tools<span class="token punctuation">.</span>new_card<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>            cards_tools<span class="token punctuation">.</span>show_all<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"3"</span><span class="token punctuation">:</span>            cards_tools<span class="token punctuation">.</span>search_card<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"0"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欢迎再次使用【名片管理系统】"</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输入错误，请重新输入："</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>至此：<code>cards_main</code> 中的所有代码全部开发完毕！</p></blockquote><h3 id="1-5-完成-show-menu-函数"><a href="#1-5-完成-show-menu-函数" class="headerlink" title="1.5 完成 show_menu 函数"></a>1.5 完成 <code>show_menu</code> 函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示菜单    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欢迎使用【菜单管理系统】V1.0"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"1. 新建名片"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2. 显示全部"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"3. 查询名片"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"0. 退出系统"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-保存名片数据的结构"><a href="#02-保存名片数据的结构" class="headerlink" title="02. 保存名片数据的结构"></a>02. 保存名片数据的结构</h2><p><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></p><ul><li>使用 <strong>字典</strong> 记录 <strong>每一张名片</strong> 的详细信息</li><li>使用 <strong>列表</strong> 统一记录所有的 <strong>名片字典</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030350.png" alt="001_名片管理系统全局列表-w500" loading="lazy"></p><h3 id="定义名片列表变量"><a href="#定义名片列表变量" class="headerlink" title="定义名片列表变量"></a>定义名片列表变量</h3><ul><li>在 <code>cards_tools</code> 文件的顶部增加一个 <strong>列表变量</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 所有名片记录的列表</span>card_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li><strong>所有名片相关操作</strong>，都需要使用这个列表，所以应该 <strong>定义在程序的顶部</strong></li><li><strong>程序刚运行时，没有数据</strong>，所以是 <strong>空列表</strong></li></ol><h2 id="03-新增名片"><a href="#03-新增名片" class="headerlink" title="03. 新增名片"></a>03. 新增名片</h2><h3 id="3-1-功能分析"><a href="#3-1-功能分析" class="headerlink" title="3.1 功能分析"></a>3.1 功能分析</h3><ol><li>提示用户依次输入名片信息</li><li>将名片信息保存到一个字典</li><li>将字典添加到名片列表</li><li>提示名片添加完成</li></ol><h3 id="3-2-实现-new-card-方法"><a href="#3-2-实现-new-card-方法" class="headerlink" title="3.2 实现 new_card 方法"></a>3.2 实现 new_card 方法</h3><ul><li>根据步骤实现代码</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">new_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""新建名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：新建名片"</span><span class="token punctuation">)</span>    <span class="token comment"># 1. 提示用户输入名片信息</span>    name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入姓名："</span><span class="token punctuation">)</span>    phone <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入电话："</span><span class="token punctuation">)</span>    qq <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入 QQ 号码："</span><span class="token punctuation">)</span>    email <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入邮箱："</span><span class="token punctuation">)</span>    <span class="token comment"># 2. 将用户信息保存到一个字典</span>    card_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> name<span class="token punctuation">,</span>                 <span class="token string">"phone"</span><span class="token punctuation">:</span> phone<span class="token punctuation">,</span>                 <span class="token string">"qq"</span><span class="token punctuation">:</span> qq<span class="token punctuation">,</span>                 <span class="token string">"email"</span><span class="token punctuation">:</span> email<span class="token punctuation">&#125;</span>    <span class="token comment"># 3. 将用户字典添加到名片列表</span>    card_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card_dict<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>card_list<span class="token punctuation">)</span>        <span class="token comment"># 4. 提示添加成功信息</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"成功添加 %s 的名片"</span> <span class="token operator">%</span> card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>技巧：在 <code>PyCharm</code> 中，可以使用 <code>SHIFT + F6</code> 统一修改变量名</p></blockquote><h2 id="04-显示所有名片"><a href="#04-显示所有名片" class="headerlink" title="04. 显示所有名片"></a>04. 显示所有名片</h2><h3 id="4-1-功能分析"><a href="#4-1-功能分析" class="headerlink" title="4.1 功能分析"></a>4.1 功能分析</h3><ul><li>循环遍历名片列表，顺序显示每一个字典的信息</li></ul><h3 id="4-2-基础代码实现"><a href="#4-2-基础代码实现" class="headerlink" title="4.2 基础代码实现"></a>4.2 基础代码实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> card_dict <span class="token keyword">in</span> card_list<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>card_dict<span class="token punctuation">)</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>显示效果不好！</li></ul><h3 id="4-3-增加标题和使用-t-显示"><a href="#4-3-增加标题和使用-t-显示" class="headerlink" title="4.3 增加标题和使用 \t 显示"></a>4.3 增加标题和使用 <code>\t</code> 显示</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span>    <span class="token comment"># 打印表头</span>    <span class="token keyword">for</span> name <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"姓名"</span><span class="token punctuation">,</span> <span class="token string">"电话"</span><span class="token punctuation">,</span> <span class="token string">"QQ"</span><span class="token punctuation">,</span> <span class="token string">"邮箱"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"\t\t"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token comment"># 打印分隔线</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"="</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> card_dict <span class="token keyword">in</span> card_list<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s\t\t%s\t\t%s\t\t%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                        card_dict<span class="token punctuation">[</span><span class="token string">"phone"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                        card_dict<span class="token punctuation">[</span><span class="token string">"qq"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                        card_dict<span class="token punctuation">[</span><span class="token string">"email"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-增加没有名片记录判断"><a href="#4-4-增加没有名片记录判断" class="headerlink" title="4.4 增加没有名片记录判断"></a>4.4 增加没有名片记录判断</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span>    <span class="token comment"># 1. 判断是否有名片记录</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>card_list<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"提示：没有任何名片记录"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>在函数中使用 <code>return</code> 表示返回</li><li>如果在 <code>return</code> 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码</li></ul><h2 id="05-查询名片"><a href="#05-查询名片" class="headerlink" title="05. 查询名片"></a>05. 查询名片</h2><h3 id="5-1-功能分析"><a href="#5-1-功能分析" class="headerlink" title="5.1 功能分析"></a>5.1 功能分析</h3><ol><li>提示用户要搜索的姓名</li><li>根据用户输入的姓名遍历列表</li><li>搜索到指定的名片后，再执行后续的操作</li></ol><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><ul><li>查询功能实现</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">search_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""搜索名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：搜索名片"</span><span class="token punctuation">)</span>    <span class="token comment"># 1. 提示要搜索的姓名</span>    find_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入要搜索的姓名："</span><span class="token punctuation">)</span>    <span class="token comment"># 2. 遍历字典</span>    <span class="token keyword">for</span> card_dict <span class="token keyword">in</span> card_list<span class="token punctuation">:</span>        <span class="token keyword">if</span> card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">==</span> find_name<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"姓名\t\t\t电话\t\t\tQQ\t\t\t邮箱"</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">40</span><span class="token punctuation">)</span>                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s\t\t\t%s\t\t\t%s\t\t\t%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>                card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                card_dict<span class="token punctuation">[</span><span class="token string">"phone"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                card_dict<span class="token punctuation">[</span><span class="token string">"qq"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                card_dict<span class="token punctuation">[</span><span class="token string">"email"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">40</span><span class="token punctuation">)</span>                        <span class="token comment"># TODO(小明) 针对找到的字典进行后续操作：修改/删除</span>            <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有找到 %s"</span> <span class="token operator">%</span> find_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>增加名片操作函数：<strong>修改</strong>&#x2F;<strong>删除</strong>&#x2F;<strong>返回主菜单</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deal_card</span><span class="token punctuation">(</span>find_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""操作搜索到的名片字典    :param find_dict:找到的名片字典    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>find_dict<span class="token punctuation">)</span>    action_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请选择要执行的操作 "</span>                       <span class="token string">"[1] 修改 [2] 删除 [0] 返回上级菜单"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改"</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"删除"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="06-修改和删除"><a href="#06-修改和删除" class="headerlink" title="06. 修改和删除"></a>06. 修改和删除</h2><h3 id="6-1-查询成功后删除名片"><a href="#6-1-查询成功后删除名片" class="headerlink" title="6.1 查询成功后删除名片"></a>6.1 查询成功后删除名片</h3><ul><li>由于找到的字典记录已经在列表中保存</li><li>要删除名片记录，只需要把列表中对应的字典删除即可</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>    card_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>find_dict<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"删除成功"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-修改名片"><a href="#6-2-修改名片" class="headerlink" title="6.2 修改名片"></a>6.2 修改名片</h3><ul><li>由于找到的字典记录已经在列表中保存</li><li>要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>    find_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入姓名："</span><span class="token punctuation">)</span>    find_dict<span class="token punctuation">[</span><span class="token string">"phone"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入电话："</span><span class="token punctuation">)</span>    find_dict<span class="token punctuation">[</span><span class="token string">"qq"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入QQ："</span><span class="token punctuation">)</span>    find_dict<span class="token punctuation">[</span><span class="token string">"email"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入邮件："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 的名片修改成功"</span> <span class="token operator">%</span> find_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改名片细化"><a href="#修改名片细化" class="headerlink" title="修改名片细化"></a>修改名片细化</h4><ul><li><strong>如果用户在使用时，某些名片内容并不想修改</strong>，应该如何做呢？—— 既然系统提供的 <code>input</code> 函数不能满足需求，那么就新定义一个函数 <code>input_card_info</code> 对系统的 <code>input</code> 函数进行扩展</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">input_card_info</span><span class="token punctuation">(</span>dict_value<span class="token punctuation">,</span> tip_message<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""输入名片信息    :param dict_value: 字典原有值    :param tip_message: 输入提示信息    :return: 如果输入，返回输入内容，否则返回字典原有值    """</span>    <span class="token comment"># 1. 提示用户输入内容</span>    result_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span>tip_message<span class="token punctuation">)</span>    <span class="token comment"># 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>result_str<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> result_str    <span class="token comment"># 3. 如果用户没有输入内容，返回 `字典中原有的值`</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dict_value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="07-LINUX-上的-Shebang-符号"><a href="#07-LINUX-上的-Shebang-符号" class="headerlink" title="07. LINUX 上的 Shebang 符号(#!)"></a>07. LINUX 上的 <code>Shebang</code> 符号(<code>#!</code>)</h2><ul><li><code>#!</code>这个符号叫做 <code>Shebang</code> 或者 <code>Sha-bang</code></li><li><code>Shebang</code> 通常在 <code>Unix</code> 系统脚本的中 <strong>第一行开头</strong> 使用</li><li>指明 <strong>执行这个脚本文件</strong> 的 <strong>解释程序</strong></li></ul><h3 id="使用-Shebang-的步骤"><a href="#使用-Shebang-的步骤" class="headerlink" title="使用 Shebang 的步骤"></a>使用 Shebang 的步骤</h3><ul><li><ol><li>使用 <code>which</code> 查询 <code>python3</code> 解释器所在路径</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">which</span> python3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>修改要运行的 <strong>主 python 文件</strong>，在第一行增加以下内容</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#! /usr/bin/python3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>修改 <strong>主 python 文件</strong> 的文件权限，增加执行权限</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">chmod</span> +x cards_main.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="4"><li>在需要时执行程序即可</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./cards_main.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="变量进阶（理解）"><a href="#变量进阶（理解）" class="headerlink" title="变量进阶（理解）"></a>变量进阶（理解）</h1><h2 id="目标-16"><a href="#目标-16" class="headerlink" title="目标"></a>目标</h2><ul><li>变量的引用</li><li>可变和不可变类型</li><li>局部变量和全局变量</li></ul><h2 id="01-变量的引用"><a href="#01-变量的引用" class="headerlink" title="01. 变量的引用"></a>01. 变量的引用</h2><blockquote><ul><li>变量 和 数据 都是保存在 <strong>内存</strong> 中的</li><li>在 <code>Python</code> 中 <strong>函数 的 参数传递</strong> 以及 <strong>返回值</strong> 都是靠 <strong>引用</strong> 传递的</li></ul></blockquote><h3 id="1-1-引用的概念"><a href="#1-1-引用的概念" class="headerlink" title="1.1 引用的概念"></a>1.1 引用的概念</h3><p>在 <code>Python</code> 中</p><ul><li><strong>变量</strong> 和 <strong>数据</strong> 是分开存储的</li><li><strong>数据</strong> 保存在内存中的一个位置</li><li><strong>变量</strong> 中保存着数据在内存中的地址</li><li><strong>变量</strong> 中 <strong>记录数据的地址</strong>，就叫做 <strong>引用</strong></li><li>使用 <code>id()</code> 函数可以查看变量中保存数据所在的 <strong>内存地址</strong></li></ul><blockquote><p>注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 <strong>修改了数据的引用</strong></p><ul><li>变量 <strong>不再</strong> 对之前的数据引用</li><li>变量 <strong>改为</strong> 对新赋值的数据引用</li></ul></blockquote><h3 id="1-2-变量引用-的示例"><a href="#1-2-变量引用-的示例" class="headerlink" title="1.2 变量引用 的示例"></a>1.2 <code>变量引用</code> 的示例</h3><p>在 <code>Python</code> 中，变量的名字类似于 <strong>便签纸</strong> 贴在 <strong>数据</strong> 上</p><ul><li>定义一个整数变量 <code>a</code>，并且赋值为 <code>1</code></li></ul><table><thead><tr><th align="center">代码</th><th align="center">图示</th></tr></thead><tbody><tr><td align="center">a &#x3D; 1</td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021307.png" alt="004_a1tag" loading="lazy"></td></tr></tbody></table><ul><li>将变量 <code>a</code> 赋值为 <code>2</code></li></ul><table><thead><tr><th align="center">代码</th><th align="center">图示</th></tr></thead><tbody><tr><td align="center">a &#x3D; 2</td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021308.png" alt="005_a2tag" loading="lazy"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021309.png" alt="005_1" loading="lazy"></td></tr></tbody></table><ul><li>定义一个整数变量 <code>b</code>，并且将变量 <code>a</code> 的值赋值给 <code>b</code></li></ul><table><thead><tr><th align="center">代码</th><th align="center">图示</th></tr></thead><tbody><tr><td align="center">b &#x3D; a</td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021310.png" alt="006_ab2tag" loading="lazy"></td></tr></tbody></table><blockquote><p>变量 <code>b</code> 是第 2 个贴在数字 <code>2</code> 上的标签</p></blockquote><h3 id="1-3-函数的参数和返回值的传递"><a href="#1-3-函数的参数和返回值的传递" class="headerlink" title="1.3 函数的参数和返回值的传递"></a>1.3 函数的参数和返回值的传递</h3><p>在 <code>Python</code> 中，函数的 <strong>实参</strong>&#x2F;<strong>返回值</strong> 都是是靠 <strong>引用</strong> 来传递来的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d 在函数内的内存地址是 %x"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"返回值 %d 在内存中的地址是 %x"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">return</span>  resulta <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用函数前 内存地址是 %x"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>r <span class="token operator">=</span> test<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用函数后 实参内存地址是 %x"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用函数后 返回值内存地址是 %x"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-可变和不可变类型"><a href="#02-可变和不可变类型" class="headerlink" title="02. 可变和不可变类型"></a>02. 可变和不可变类型</h2><ul><li><p><strong>不可变类型</strong>，内存中的数据不允许被修改：</p><ul><li>数字类型 <code>int</code>, <code>bool</code>, <code>float</code>, <code>complex</code>, <code>long(2.x)</code></li><li>字符串 <code>str</code></li><li>元组 <code>tuple</code></li></ul></li><li><p><strong>可变类型</strong>，内存中的数据可以被修改：</p><ul><li>列表 <code>list</code></li><li>字典 <code>dict</code></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>a <span class="token operator">=</span> <span class="token string">"hello"</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">demo_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"定义列表后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_list<span class="token punctuation">)</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改数据后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_list<span class="token punctuation">)</span><span class="token punctuation">)</span>demo_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小明"</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"定义字典后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_dict<span class="token punctuation">)</span><span class="token punctuation">)</span>demo_dict<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">18</span>demo_dict<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>demo_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"老王"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改数据后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_dict<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：字典的 <code>key</code> <strong>只能使用不可变类型的数据</strong></p></blockquote><p><strong>注意</strong></p><ol><li><strong>可变类型</strong>的数据变化，是通过 <strong>方法</strong> 来实现的</li><li>如果给一个可变类型的变量，赋值了一个新的数据，<strong>引用会修改</strong><ul><li>变量 <strong>不再</strong> 对之前的数据引用</li><li>变量 <strong>改为</strong> 对新赋值的数据引用</li></ul></li></ol><h3 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 (hash)"></a>哈希 <code>(hash)</code></h3><ul><li><code>Python</code> 中内置有一个名字叫做 <code>hash(o)</code> 的函数<ul><li>接收一个 <strong>不可变类型</strong> 的数据作为 <strong>参数</strong></li><li><strong>返回</strong> 结果是一个 <strong>整数</strong></li></ul></li><li><code>哈希</code> 是一种 <strong>算法</strong>，其作用就是提取数据的 <strong>特征码（指纹）</strong><ul><li><strong>相同的内容</strong> 得到 <strong>相同的结果</strong></li><li><strong>不同的内容</strong> 得到 <strong>不同的结果</strong></li></ul></li><li>在 <code>Python</code> 中，设置字典的 <strong>键值对</strong> 时，会首先对 <code>key</code> 进行 <code>hash</code> 已决定如何在内存中保存字典的数据，以方便 <strong>后续</strong> 对字典的操作：<strong>增、删、改、查</strong><ul><li>键值对的 <code>key</code> 必须是不可变类型数据</li><li>键值对的 <code>value</code> 可以是任意类型的数据</li></ul></li></ul><h2 id="03-局部变量和全局变量"><a href="#03-局部变量和全局变量" class="headerlink" title="03. 局部变量和全局变量"></a>03. 局部变量和全局变量</h2><ul><li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li></ul><blockquote><p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p></blockquote><h3 id="3-1-局部变量"><a href="#3-1-局部变量" class="headerlink" title="3.1 局部变量"></a>3.1 局部变量</h3><ul><li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li><li>函数执行结束后，<strong>函数内部的局部变量，会被系统回收</strong></li><li>不同的函数，可以定义相同的名字的局部变量，但是 <strong>彼此之间</strong> 不会产生影响</li></ul><h4 id="局部变量的作用"><a href="#局部变量的作用" class="headerlink" title="局部变量的作用"></a>局部变量的作用</h4><ul><li>在函数内部使用，<strong>临时</strong> 保存 <strong>函数内部需要使用的数据</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    num <span class="token operator">=</span> <span class="token number">20</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改后 %d"</span> <span class="token operator">%</span> num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="局部变量的生命周期"><a href="#局部变量的生命周期" class="headerlink" title="局部变量的生命周期"></a>局部变量的生命周期</h4><ul><li>所谓 <strong>生命周期</strong> 就是变量从 <strong>被创建</strong> 到 <strong>被系统回收</strong> 的过程</li><li><strong>局部变量</strong> 在 <strong>函数执行时</strong> 才会被创建</li><li><strong>函数执行结束后</strong> 局部变量 <strong>被系统回收</strong></li><li><strong>局部变量在生命周期</strong> 内，可以用来存储 <strong>函数内部临时使用到的数据</strong></li></ul><h3 id="3-2-全局变量"><a href="#3-2-全局变量" class="headerlink" title="3.2 全局变量"></a>3.2 全局变量</h3><ul><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量，所有函数内部都可以使用这个变量</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义一个全局变量</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：函数执行时，<strong>需要处理变量时</strong> 会：</p><ol><li><strong>首先</strong> 查找 <strong>函数内部</strong> 是否存在 <strong>指定名称 的局部变量</strong>，<strong>如果有，直接使用</strong></li><li>如果没有，查找 <strong>函数外部</strong> 是否存在 <strong>指定名称 的全局变量</strong>，<strong>如果有，直接使用</strong></li><li>如果还没有，程序报错！</li></ol><h4 id="1-函数不能直接修改-全局变量的引用"><a href="#1-函数不能直接修改-全局变量的引用" class="headerlink" title="1) 函数不能直接修改 全局变量的引用"></a>1) 函数不能直接修改 <code>全局变量的引用</code></h4><ul><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li></ul><blockquote><p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p></blockquote><ul><li>在函数内部，可以 <strong>通过全局变量的引用获取对应的数据</strong></li><li>但是，<strong>不允许直接修改全局变量的引用</strong> —— 使用赋值语句修改全局变量的值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">num <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo1"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span>    num <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo2"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值</p></blockquote><h4 id="2-在函数内部修改全局变量的值"><a href="#2-在函数内部修改全局变量的值" class="headerlink" title="2) 在函数内部修改全局变量的值"></a>2) 在函数内部修改全局变量的值</h4><ul><li>如果在函数中需要修改全局变量，需要使用 <code>global</code> 进行声明</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">num <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo1"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token comment"># global 关键字，告诉 Python 解释器 num 是一个全局变量</span>    <span class="token keyword">global</span> num    <span class="token comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span>    num <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo2"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-全局变量定义的位置"><a href="#3-全局变量定义的位置" class="headerlink" title="3) 全局变量定义的位置"></a>3) 全局变量定义的位置</h4><ul><li>为了保证所有的函数都能够正确使用到全局变量，应该 <strong>将全局变量定义在其他函数的上方</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token operator">%</span> a<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token operator">%</span> b<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token operator">%</span> c<span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token number">20</span>demo<span class="token punctuation">(</span><span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！</li></ul><p><strong>代码结构示意图如下</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021311.png" alt="001_代码结构示意图-w240" loading="lazy"></p><h4 id="4-全局变量命名的建议"><a href="#4-全局变量命名的建议" class="headerlink" title="4) 全局变量命名的建议"></a>4) 全局变量命名的建议</h4><ul><li>为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：</li><li>全局变量名前应该增加 <code>g_</code> 或者 <code>gl_</code> 的前缀</li></ul><blockquote><p>提示：具体的要求格式，各公司要求可能会有些差异</p></blockquote><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="目标-17"><a href="#目标-17" class="headerlink" title="目标"></a>目标</h2><ul><li>函数参数和返回值的作用</li><li>函数的返回值 进阶</li><li>函数的参数 进阶</li><li>递归函数</li></ul><h2 id="01-函数参数和返回值的作用"><a href="#01-函数参数和返回值的作用" class="headerlink" title="01. 函数参数和返回值的作用"></a>01. 函数参数和返回值的作用</h2><p>函数根据 <strong>有没有参数</strong> 以及 <strong>有没有返回值</strong>，可以 <strong>相互组合</strong>，一共有 <strong>4 种</strong> 组合形式</p><ol><li>无参数，无返回值</li><li>无参数，有返回值</li><li>有参数，无返回值</li><li>有参数，有返回值</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127023303.png" alt="001_函数参数和返回值" loading="lazy"></p><blockquote><p>定义函数时，<strong>是否接收参数，或者是否返回结果</strong>，是根据 <strong>实际的功能需求</strong> 来决定的！</p></blockquote><ol><li>如果函数 <strong>内部处理的数据不确定</strong>，就可以将外界的数据以参数传递到函数内部</li><li>如果希望一个函数 <strong>执行完成后，向外界汇报执行结果</strong>，就可以增加函数的返回值</li></ol><h3 id="1-1-无参数，无返回值"><a href="#1-1-无参数，无返回值" class="headerlink" title="1.1 无参数，无返回值"></a>1.1 无参数，无返回值</h3><p>此类函数，不接收参数，也没有返回值，应用场景如下：</p><ol><li><strong>只是单纯地做一件事情</strong>，例如 <strong>显示菜单</strong></li><li>在函数内部 <strong>针对全局变量进行操作</strong>，例如：<strong>新建名片</strong>，最终结果 <strong>记录在全局变量</strong> 中</li></ol><blockquote><p>注意：</p></blockquote><ul><li>如果全局变量的数据类型是一个 <strong>可变类型</strong>，在函数内部可以使用 <strong>方法</strong> 修改全局变量的内容 —— <strong>变量的引用不会改变</strong></li><li>在函数内部，<strong>使用赋值语句</strong> 才会 <strong>修改变量的引用</strong></li></ul><h3 id="1-2-无参数，有返回值"><a href="#1-2-无参数，有返回值" class="headerlink" title="1.2 无参数，有返回值"></a>1.2 无参数，有返回值</h3><p>此类函数，不接收参数，但是有返回值，应用场景如下：</p><ul><li>采集数据，例如 <strong>温度计</strong>，返回结果就是当前的温度，而不需要传递任何的参数</li></ul><h3 id="1-3-有参数，无返回值"><a href="#1-3-有参数，无返回值" class="headerlink" title="1.3 有参数，无返回值"></a>1.3 有参数，无返回值</h3><p>此类函数，接收参数，没有返回值，应用场景如下：</p><ul><li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong></li><li>例如 <strong>名片管理系统</strong> 针对 <strong>找到的名片</strong> 做 <strong>修改</strong>、<strong>删除</strong> 操作</li></ul><h3 id="1-4-有参数，有返回值"><a href="#1-4-有参数，有返回值" class="headerlink" title="1.4 有参数，有返回值"></a>1.4 有参数，有返回值</h3><p>此类函数，接收参数，同时有返回值，应用场景如下：</p><ul><li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong>，并且 <strong>返回期望的处理结果</strong></li><li>例如 <strong>名片管理系统</strong> 使用 <strong>字典默认值</strong> 和 <strong>提示信息</strong> 提示用户输入内容<ul><li>如果输入，返回输入内容</li><li>如果没有输入，返回字典默认值</li></ul></li></ul><h2 id="02-函数的返回值-进阶"><a href="#02-函数的返回值-进阶" class="headerlink" title="02. 函数的返回值 进阶"></a>02. 函数的返回值 进阶</h2><ul><li>在程序开发中，有时候，会希望 <strong>一个函数执行结束后，告诉调用者一个结果</strong>，以便调用者针对具体的结果做后续的处理</li><li><strong>返回值</strong> 是函数 <strong>完成工作</strong>后，<strong>最后</strong> 给调用者的 <strong>一个结果</strong></li><li>在函数中使用 <code>return</code> 关键字可以返回结果</li><li>调用函数一方，可以 <strong>使用变量</strong> 来 <strong>接收</strong> 函数的返回结果</li></ul><blockquote><p>问题：一个函数执行后能否返回多个结果？</p></blockquote><h3 id="示例-——-温度和湿度测量"><a href="#示例-——-温度和湿度测量" class="headerlink" title="示例 —— 温度和湿度测量"></a>示例 —— 温度和湿度测量</h3><ul><li>假设要开发一个函数能够同时返回当前的温度和湿度</li><li><strong>先完成返回温度</strong>的功能如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">measure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""返回当前的温度"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始测量..."</span><span class="token punctuation">)</span>    temp <span class="token operator">=</span> <span class="token number">39</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测量结束..."</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> tempresult <span class="token operator">=</span> measure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在利用 <strong>元组</strong> 在返回温度的同时，也能够返回 <strong>湿度</strong></li><li>改造如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">measure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""返回当前的温度"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始测量..."</span><span class="token punctuation">)</span>    temp <span class="token operator">=</span> <span class="token number">39</span>    wetness <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测量结束..."</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>temp<span class="token punctuation">,</span> wetness<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：如果一个函数返回的是元组，括号可以省略</p></blockquote><p><strong>技巧</strong> </p><ul><li>在 <code>Python</code> 中，可以 <strong>将一个元组</strong> 使用 <strong>赋值语句</strong> 同时赋值给 <strong>多个变量</strong></li><li>注意：变量的数量需要和元组中的元素数量保持一致</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">result <span class="token operator">=</span> temp<span class="token punctuation">,</span> wetness <span class="token operator">=</span> measure<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="面试题-——-交换两个数字"><a href="#面试题-——-交换两个数字" class="headerlink" title="面试题 —— 交换两个数字"></a>面试题 —— 交换两个数字</h3><p><strong>题目要求</strong></p><ol><li>有两个整数变量 <code>a = 6</code>, <code>b = 100</code></li><li>不使用其他变量，<strong>交换两个变量的值</strong></li></ol><h4 id="解法-1-——-使用其他变量"><a href="#解法-1-——-使用其他变量" class="headerlink" title="解法 1 —— 使用其他变量"></a>解法 1 —— 使用其他变量</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 解法 1 - 使用临时变量</span>c <span class="token operator">=</span> bb <span class="token operator">=</span> aa <span class="token operator">=</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法-2-——-不使用临时变量"><a href="#解法-2-——-不使用临时变量" class="headerlink" title="解法 2 —— 不使用临时变量"></a>解法 2 —— 不使用临时变量</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 解法 2 - 不使用临时变量</span>a <span class="token operator">=</span> a <span class="token operator">+</span> bb <span class="token operator">=</span> a <span class="token operator">-</span> ba <span class="token operator">=</span> a <span class="token operator">-</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法-3-——-Python-专有，利用元组"><a href="#解法-3-——-Python-专有，利用元组" class="headerlink" title="解法 3 —— Python 专有，利用元组"></a>解法 3 —— Python 专有，利用元组</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="03-函数的参数-进阶"><a href="#03-函数的参数-进阶" class="headerlink" title="03. 函数的参数 进阶"></a>03. 函数的参数 进阶</h2><h3 id="3-1-不可变和可变的参数"><a href="#3-1-不可变和可变的参数" class="headerlink" title="3.1. 不可变和可变的参数"></a>3.1. 不可变和可变的参数</h3><blockquote><p>问题 1：在函数内部，针对参数使用 <strong>赋值语句</strong>，会不会影响调用函数时传递的 <strong>实参变量</strong>？ —— 不会！</p></blockquote><ul><li>无论传递的参数是 <strong>可变</strong> 还是 <strong>不可变</strong> <ul><li>只要 <strong>针对参数</strong> 使用 <strong>赋值语句</strong>，会在 <strong>函数内部</strong> 修改 <strong>局部变量的引用</strong>，<strong>不会影响到 外部变量的引用</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数内部"</span><span class="token punctuation">)</span>    <span class="token comment"># 赋值语句</span>    num <span class="token operator">=</span> <span class="token number">200</span>    num_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数代码完成"</span><span class="token punctuation">)</span>gl_num <span class="token operator">=</span> <span class="token number">99</span>gl_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>demo<span class="token punctuation">(</span>gl_num<span class="token punctuation">,</span> gl_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题 2：如果传递的参数是 <strong>可变类型</strong>，在函数内部，使用 <strong>方法</strong> 修改了数据的内容，<strong>同样会影响到外部的数据</strong></p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mutable</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># num_list = [1, 2, 3]</span>    num_list<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>gl_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>mutable<span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面试题-——"><a href="#面试题-——" class="headerlink" title="面试题 —— +="></a>面试题 —— <code>+=</code></h4><ul><li>在 <code>python</code> 中，列表变量调用 <code>+=</code> 本质上是在执行列表变量的 <code>extend</code> 方法，不会修改变量的引用</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数内部代码"</span><span class="token punctuation">)</span>    <span class="token comment"># num = num + num</span>    num <span class="token operator">+=</span> num    <span class="token comment"># num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用</span>    <span class="token comment"># 函数执行结束后，外部数据同样会发生变化</span>    num_list <span class="token operator">+=</span> num_list    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数代码完成"</span><span class="token punctuation">)</span>gl_num <span class="token operator">=</span> <span class="token number">9</span>gl_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>demo<span class="token punctuation">(</span>gl_num<span class="token punctuation">,</span> gl_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-缺省参数"><a href="#3-2-缺省参数" class="headerlink" title="3.2 缺省参数"></a>3.2 缺省参数</h3><ul><li>定义函数时，可以给 <strong>某个参数</strong> 指定一个<strong>默认值</strong>，具有默认值的参数就叫做 <strong>缺省参数</strong></li><li>调用函数时，如果没有传入 <strong>缺省参数</strong> 的值，则在函数内部使用定义函数时指定的 <strong>参数默认值</strong></li><li>函数的缺省参数，<strong>将常见的值设置为参数的缺省值</strong>，从而 <strong>简化函数的调用</strong></li><li>例如：对列表排序的方法</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">gl_num_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token comment"># 默认就是升序排序，因为这种应用需求更多</span>gl_num_list<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num_list<span class="token punctuation">)</span><span class="token comment"># 只有当需要降序排序时，才需要传递 `reverse` 参数</span>gl_num_list<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指定函数的缺省参数"><a href="#指定函数的缺省参数" class="headerlink" title="指定函数的缺省参数"></a>指定函数的缺省参数</h4><ul><li>在参数后使用赋值语句，可以指定参数的缺省值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_info</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    gender_text <span class="token operator">=</span> <span class="token string">"男生"</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> gender<span class="token punctuation">:</span>        gender_text <span class="token operator">=</span> <span class="token string">"女生"</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是 %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ol><li>缺省参数，需要使用 <strong>最常见的值</strong> 作为默认值！</li><li>如果一个参数的值 <strong>不能确定</strong>，则不应该设置默认值，具体的数值在调用函数时，由外界传递！</li></ol><h4 id="缺省参数的注意事项"><a href="#缺省参数的注意事项" class="headerlink" title="缺省参数的注意事项"></a>缺省参数的注意事项</h4><h5 id="1-缺省参数的定义位置"><a href="#1-缺省参数的定义位置" class="headerlink" title="1) 缺省参数的定义位置"></a>1) 缺省参数的定义位置</h5><ul><li><strong>必须保证</strong> <strong>带有默认值的缺省参数</strong> <strong>在参数列表末尾</strong></li><li>所以，以下定义是错误的！</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_info</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-调用带有多个缺省参数的函数"><a href="#2-调用带有多个缺省参数的函数" class="headerlink" title="2) 调用带有多个缺省参数的函数"></a>2) 调用带有多个缺省参数的函数</h5><ul><li>在 <strong>调用函数时</strong>，如果有 <strong>多个缺省参数</strong>，<strong>需要指定参数名</strong>，这样解释器才能够知道参数的对应关系！</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_info</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param title: 职位    :param name: 班上同学的姓名    :param gender: True 男生 False 女生    """</span>    gender_text <span class="token operator">=</span> <span class="token string">"男生"</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> gender<span class="token punctuation">:</span>        gender_text <span class="token operator">=</span> <span class="token string">"女生"</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s%s 是 %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>title<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gender_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！</span>print_info<span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span>print_info<span class="token punctuation">(</span><span class="token string">"老王"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"班长"</span><span class="token punctuation">)</span>print_info<span class="token punctuation">(</span><span class="token string">"小美"</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-多值参数（知道）"><a href="#3-3-多值参数（知道）" class="headerlink" title="3.3 多值参数（知道）"></a>3.3 多值参数（知道）</h3><h4 id="定义支持多值参数的函数"><a href="#定义支持多值参数的函数" class="headerlink" title="定义支持多值参数的函数"></a>定义支持多值参数的函数</h4><ul><li><p>有时可能需要 <strong>一个函数</strong> 能够处理的参数 <strong>个数</strong> 是不确定的，这个时候，就可以使用 <strong>多值参数</strong></p></li><li><p><code>python</code> 中有 <strong>两种</strong> 多值参数：</p><ul><li>参数名前增加 <strong>一个</strong> <code>*</code> 可以接收 <strong>元组</strong></li><li>参数名前增加 <strong>两个</strong> <code>*</code> 可以接收 <strong>字典</strong></li></ul></li><li><p>一般在给多值参数命名时，<strong>习惯</strong>使用以下两个名字</p><ul><li><code>*args</code> —— 存放 <strong>元组</strong> 参数，前面有一个 <code>*</code></li><li><code>**kwargs</code> —— 存放 <strong>字典</strong> 参数，前面有两个 <code>*</code></li></ul></li><li><p><code>args</code> 是 <code>arguments</code> 的缩写，有变量的含义</p></li><li><p><code>kw</code> 是 <code>keyword</code> 的缩写，<code>kwargs</code> 可以记忆 <strong>键值对参数</strong></p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span>demo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"小明"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：<strong>多值参数</strong> 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，<strong>有利于我们能够读懂大牛的代码</strong></p></blockquote><h4 id="多值参数案例-——-计算任意多个数字的和"><a href="#多值参数案例-——-计算任意多个数字的和" class="headerlink" title="多值参数案例 —— 计算任意多个数字的和"></a>多值参数案例 —— 计算任意多个数字的和</h4><p><strong>需求</strong></p><ol><li>定义一个函数 <code>sum_numbers</code>，可以接收的 <strong>任意多个整数</strong></li><li>功能要求：将传递的 <strong>所有数字累加</strong> 并且返回累加结果</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_numbers</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 遍历 args 元组顺序求和</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> args<span class="token punctuation">:</span>        num <span class="token operator">+=</span> n    <span class="token keyword">return</span> num<span class="token keyword">print</span><span class="token punctuation">(</span>sum_numbers<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="元组和字典的拆包（知道）"><a href="#元组和字典的拆包（知道）" class="headerlink" title="元组和字典的拆包（知道）"></a>元组和字典的拆包（知道）</h4><ul><li>在调用带有多值参数的函数时，如果希望：<ul><li>将一个 <strong>元组变量</strong>，直接传递给 <code>args</code></li><li>将一个 <strong>字典变量</strong>，直接传递给 <code>kwargs</code></li></ul></li><li>就可以使用 <strong>拆包</strong>，简化参数的传递，<strong>拆包</strong> 的方式是：<ul><li>在 <strong>元组变量前</strong>，增加 <strong>一个</strong> <code>*</code></li><li>在 <strong>字典变量前</strong>，增加 <strong>两个</strong> <code>*</code></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span><span class="token comment"># 需要将一个元组变量/字典变量传递给函数对应的参数</span>gl_nums <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>gl_xiaoming <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">&#125;</span><span class="token comment"># 会把 num_tuple 和 xiaoming 作为元组传递个 args</span><span class="token comment"># demo(gl_nums, gl_xiaoming)</span>demo<span class="token punctuation">(</span><span class="token operator">*</span>gl_nums<span class="token punctuation">,</span> <span class="token operator">**</span>gl_xiaoming<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="04-函数的递归"><a href="#04-函数的递归" class="headerlink" title="04. 函数的递归"></a>04. 函数的递归</h2><blockquote><p>函数调用自身的 <strong>编程技巧</strong> 称为递归</p></blockquote><h3 id="4-1-递归函数的特点"><a href="#4-1-递归函数的特点" class="headerlink" title="4.1 递归函数的特点"></a>4.1 递归函数的特点</h3><p><strong>特点</strong></p><ul><li><strong>一个函数</strong> <strong>内部</strong> <strong>调用自己</strong><ul><li>函数内部可以调用其他函数，当然在函数内部也可以调用自己</li></ul></li></ul><p><strong>代码特点</strong></p><ol><li>函数内部的 <strong>代码</strong> 是相同的，只是针对 <strong>参数</strong> 不同，<strong>处理的结果不同</strong></li><li>当 <strong>参数满足一个条件</strong> 时，函数不再执行<ul><li><strong>这个非常重要</strong>，通常被称为递归的出口，否则 <strong>会出现死循环</strong>！</li></ul></li></ol><p>示例代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_numbers</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token comment"># 递归的出口很重要，否则会出现死循环</span>    <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    sum_numbers<span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    sum_numbers<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127023304.png" alt="002_递归调用示意图I" loading="lazy"></p><h3 id="4-2-递归案例-——-计算数字累加"><a href="#4-2-递归案例-——-计算数字累加" class="headerlink" title="4.2 递归案例 —— 计算数字累加"></a>4.2 递归案例 —— 计算数字累加</h3><p><strong>需求</strong></p><ol><li>定义一个函数 <code>sum_numbers</code></li><li>能够接收一个 <code>num</code> 的整数参数</li><li>计算 1 + 2 + … num 的结果</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_numbers</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token comment"># 假设 sum_numbers 能够完成 num - 1 的累加</span>    temp <span class="token operator">=</span> sum_numbers<span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 函数内部的核心算法就是 两个数字的相加</span>    <span class="token keyword">return</span> num <span class="token operator">+</span> temp<span class="token keyword">print</span><span class="token punctuation">(</span>sum_numbers<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127023305.png" alt="002_递归调用示意图" loading="lazy"></p><blockquote><p>提示：递归是一个 <strong>编程技巧</strong>，初次接触递归会感觉有些吃力！在处理 <strong>不确定的循环条件时</strong>，格外的有用，例如：<strong>遍历整个文件目录的结构</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PyCharm-的初始设置（知道）&quot;&gt;&lt;a href=&quot;#PyCharm-的初始设置（知道）&quot; class=&quot;headerlink&quot; title=&quot;PyCharm 的初始设置（知道）&quot;&gt;&lt;/a&gt;PyCharm 的初始设置（知道）&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Python" scheme="http://ccsu.top/categories/Python/"/>
    
    
    <category term="Python基础" scheme="http://ccsu.top/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>树莓派系统备份</title>
    <link href="http://ccsu.top/posts/52784c40/"/>
    <id>http://ccsu.top/posts/52784c40/</id>
    <published>2022-03-13T12:18:00.000Z</published>
    <updated>2022-05-09T01:59:12.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、全卡备份"><a href="#一、全卡备份" class="headerlink" title="一、全卡备份"></a>一、全卡备份</h1><p>全卡备份就是直接从SD卡A复制到SD卡B</p><h2 id="1-通过GUI备份"><a href="#1-通过GUI备份" class="headerlink" title="1.通过GUI备份"></a>1.通过GUI备份</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232048.png" alt="image-20220312232048461" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232726.png" alt="image-20220312232726142" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232403.png" alt="image-20220312232403516" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232959.png" alt="image-20220312232959086" loading="lazy"></p><h2 id="2-命令行备份"><a href="#2-命令行备份" class="headerlink" title="2.命令行备份"></a>2.命令行备份</h2><blockquote><p>  实测，太慢了</p></blockquote><p>更新源</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo apt update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>mmcblk0</code>是SD卡A，<code>sda</code>是SD卡B，从A复制到B</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ lsblkNAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda           8:0    1 59.5G  0 disk ├─sda1        8:1    1  256M  0 part └─sda2        8:2    1 59.2G  0 part mmcblk0     179:0    0 59.5G  0 disk ├─mmcblk0p1 179:1    0  256M  0 part &#x2F;boot└─mmcblk0p2 179:2    0 59.2G  0 part &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装<code>dc3dd</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo apt install dc3dd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>备份</p><p><code>if</code>表示要备份的卡，<code>of</code>表示要备份到的卡</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dc3dd if&#x3D;&#x2F;dev&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;sda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220313001259.png" alt="image-20220313001259177" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220313013246.png" alt="image-20220313013246475" loading="lazy"></p><h1 id="二、压缩备份"><a href="#二、压缩备份" class="headerlink" title="二、压缩备份"></a>二、压缩备份</h1><p>压缩备份是它会备份整个<code>boot</code>分区，然后<code>Root</code>分区它只会备份实际使用的容量</p><p>待续。。。。。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、全卡备份&quot;&gt;&lt;a href=&quot;#一、全卡备份&quot; class=&quot;headerlink&quot; title=&quot;一、全卡备份&quot;&gt;&lt;/a&gt;一、全卡备份&lt;/h1&gt;&lt;p&gt;全卡备份就是直接从SD卡A复制到SD卡B&lt;/p&gt;
&lt;h2 id=&quot;1-通过GUI备份&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="毕业设计" scheme="http://ccsu.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="树莓派" scheme="http://ccsu.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="备份" scheme="http://ccsu.top/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
</feed>
