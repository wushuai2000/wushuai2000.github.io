<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="Explorer"><meta name="copyright" content="Explorer"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>排序（龙哥） | explorerの博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" type="image/png" href="/./favicon.ico"><link rel="mask-icon" href="/./favicon.ico" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"ccsu.top","root":"/","title":["Wu","Shuai","の","Blog"],"version":"1.8.8","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"waline":{"config":{"enable":true,"serverURL":"https://blog-api-seven-vert.vercel.app/","comment":false,"visitor":false,"emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"2506812280@qq.com"},"requiredMeta":["nick"],"el":"#waline","lang":"en","path":"/posts/c56898db/"},"cdn":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","dark":"html.dark"},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="explorerの博客" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-BMBD00SVV4"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BMBD00SVV4');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="一、概述 1.为什么要排序 查找是计算机应用中必不可少并且使用频率很高的一个操作。在一个排序表中查找一个元素，要比在一个无序表中查找效率高得多。所以为了提高查找效率，节省CPU时间，需要排序。 2.什么是排序 所谓排序，就是整理表中的数据几素，使之按儿素的关键字递增&#x2F;递减的顺序排列。 3.排序的稳定性 当待排序元素的关键字不相同时，排序的结果是唯一的。如果待排序的表中，有多个关键字相间">
<meta property="og:type" content="article">
<meta property="og:title" content="排序（龙哥）">
<meta property="og:url" content="http://ccsu.top/posts/c56898db/index.html">
<meta property="og:site_name" content="explorerの博客">
<meta property="og:description" content="一、概述 1.为什么要排序 查找是计算机应用中必不可少并且使用频率很高的一个操作。在一个排序表中查找一个元素，要比在一个无序表中查找效率高得多。所以为了提高查找效率，节省CPU时间，需要排序。 2.什么是排序 所谓排序，就是整理表中的数据几素，使之按儿素的关键字递增&#x2F;递减的顺序排列。 3.排序的稳定性 当待排序元素的关键字不相同时，排序的结果是唯一的。如果待排序的表中，有多个关键字相间">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/Desktop/image-20210121200637084.png">
<meta property="article:published_time" content="2021-01-20T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-25T16:00:00.000Z">
<meta property="article:author" content="Explorer">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/Desktop/image-20210121200637084.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Explorer"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Explorer"><span class="site-author-status" title="努力学习">😄</span></a><div class="site-author-name"><a href="/about/">Explorer</a></div><span class="site-name">explorerの博客</span><sub class="site-subtitle"></sub><div class="site-desciption">前路漫漫，当克己，当慎独!</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">74</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">64</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wushuai2000" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=549838440" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/huan-ji-91-3/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/345844264" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2506812280@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.为什么要排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.什么是排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">3.排序的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.4.</span> <span class="toc-text">4.排序稳定性的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">5.排序方法分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">1.5.1.</span> <span class="toc-text">(1)分类方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">1.5.2.</span> <span class="toc-text">(2)分类方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-number">1.6.</span> <span class="toc-text">6.排序算法性能评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">7.相关概念总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.7.1.</span> <span class="toc-text">关于时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">二、直接插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.</span> <span class="toc-text">2.基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#step1%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.2.1.</span> <span class="toc-text">step1：找插入位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step2%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.</span> <span class="toc-text">step2：插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%94%B9%E8%BF%9B"><span class="toc-number">2.3.</span> <span class="toc-text">3.直接插入改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BE%99%E5%93%A5%E6%94%B9%E8%BF%9B%E7%89%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">（1）龙哥改进版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%89%88%E9%9B%86%E6%88%90"><span class="toc-number">2.3.2.</span> <span class="toc-text">（2）改进版集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E5%A4%96%E9%9B%86%E6%88%90%E7%89%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">（3）课外集成版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">4.直接插入排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.4.1.</span> <span class="toc-text">(1)时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a.%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">a.最坏情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b.%E6%9C%80%E5%A5%BD%E6%83%85%E5%86%B5"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">b.最好情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c.%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">c.平均情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.4.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">5.直接插入排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">6.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.1.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">三、折半插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">1.什么是折半插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">3.2.</span> <span class="toc-text">2.算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#step-1%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AEinsertion-position"><span class="toc-number">3.2.1.</span> <span class="toc-text">step
1：找插入位置（Insertion Position）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%8D%E6%88%90%E5%8A%9F"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">(1)查找不成功</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%88%90%E5%8A%9F"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">(2)查找成功</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-2%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.2.</span> <span class="toc-text">step 2：插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%8C%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">(1)先挪元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">(2)插入操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">3.折半插入排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">(1)时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">4.折半插入排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.5.</span> <span class="toc-text">5.总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">四、希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1.什么是希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-1"><span class="toc-number">4.2.</span> <span class="toc-text">2.算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">4.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">3.希尔插入排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">(1)时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">4.希尔排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.5.</span> <span class="toc-text">5.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">4.5.1.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">五、冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.</span> <span class="toc-text">1.什么是冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-2"><span class="toc-number">5.2.</span> <span class="toc-text">2.算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.2.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B"><span class="toc-number">5.2.2.</span> <span class="toc-text">代码改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">5.2.3.</span> <span class="toc-text">另外的版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">5.3.</span> <span class="toc-text">3.冒泡排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">(1)时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a.%E6%9C%80%E5%A5%BD%E6%83%85%E5%86%B5"><span class="toc-number">5.3.0.1.1.</span> <span class="toc-text">a.最好情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b.%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5"><span class="toc-number">5.3.0.1.2.</span> <span class="toc-text">b.最坏情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c.%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5-1"><span class="toc-number">5.3.0.1.3.</span> <span class="toc-text">c.平均情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">5.3.0.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">4.冒泡排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.5.</span> <span class="toc-text">5.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%9C%80%E5%BF%AB"><span class="toc-number">5.5.1.</span> <span class="toc-text">(1)什么时候最快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%9C%80%E6%85%A2"><span class="toc-number">5.5.2.</span> <span class="toc-text">(2) 什么时候最慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">5.5.3.</span> <span class="toc-text">(3)适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">六、快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">1.什么是快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-3"><span class="toc-number">6.2.</span> <span class="toc-text">2.算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">6.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B8%AD%E5%80%BC%E5%88%86%E5%89%B2%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">3.三数中值分割法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92-pivot-%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.1.</span> <span class="toc-text">快排 pivot 选择策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">6.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">6.4.</span> <span class="toc-text">4.快速排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">6.4.0.1.</span> <span class="toc-text">(1)时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a.%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5-1"><span class="toc-number">6.4.0.1.1.</span> <span class="toc-text">a.最坏情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b.%E6%9C%80%E5%A5%BD%E6%83%85%E5%86%B5-1"><span class="toc-number">6.4.0.1.2.</span> <span class="toc-text">b.最好情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c.%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5-2"><span class="toc-number">6.4.0.1.3.</span> <span class="toc-text">c.平均情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">6.4.0.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">6.5.</span> <span class="toc-text">5.快速排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.6.</span> <span class="toc-text">6.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">6.6.1.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.2.</span> <span class="toc-text">使用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">七.选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">1.什么是选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-4"><span class="toc-number">7.2.</span> <span class="toc-text">2.算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">7.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">7.3.</span> <span class="toc-text">3.选择排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-number">7.3.1.</span> <span class="toc-text">(1)时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-5"><span class="toc-number">7.3.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">7.4.</span> <span class="toc-text">4.选择排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">7.5.</span> <span class="toc-text">5.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">7.5.0.1.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB.%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">八.堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E6%8E%92%E5%BA%8Fimage-20210125185210617"><span class="toc-number">8.1.</span> <span class="toc-text">1.什么是堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-5"><span class="toc-number">8.2.</span> <span class="toc-text">2.算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E7%A9%B4%E4%B8%8A%E6%BB%A4"><span class="toc-number">8.2.1.</span> <span class="toc-text">(1)空穴上滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E7%A9%B4%E4%B8%8B%E6%BB%A4"><span class="toc-number">8.2.2.</span> <span class="toc-text">(2)空穴下滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%85%B3%E9%94%AE"><span class="toc-number">8.2.3.</span> <span class="toc-text">(3)代码实现关键</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">a.数据类型的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b.insert%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">b.Insert操作的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c.delete_min%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.3.3.</span> <span class="toc-text">c.Delete_Min操作的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d.%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.3.4.</span> <span class="toc-text">d.堆排序代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e.%E5%A0%86%E6%8E%92%E5%BA%8Fin-place%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.3.5.</span> <span class="toc-text">e.堆排序In-place版本实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">8.3.</span> <span class="toc-text">3.堆排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-6"><span class="toc-number">8.3.1.</span> <span class="toc-text">(1)时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-6"><span class="toc-number">8.3.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">8.4.</span> <span class="toc-text">4.堆排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">8.5.</span> <span class="toc-text">5.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">8.5.1.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">九.归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">9.1.</span> <span class="toc-text">1.什么是归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-6"><span class="toc-number">9.2.</span> <span class="toc-text">2.算法思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">9.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">9.3.</span> <span class="toc-text">3.归并排序的性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-7"><span class="toc-number">9.3.1.</span> <span class="toc-text">(1)时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-7"><span class="toc-number">9.3.2.</span> <span class="toc-text">(2)空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">9.4.</span> <span class="toc-text">4.归并排序稳定性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">9.5.</span> <span class="toc-text">5.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number">9.5.1.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/57%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/" style="font-size: 12px; color: #999">57步进电机</a> <a href="/tags/AT9SPro/" style="font-size: 12px; color: #999">AT9SPro</a> <a href="/tags/Anaconda/" style="font-size: 12px; color: #999">Anaconda</a> <a href="/tags/Arduino/" style="font-size: 24px; color: #3383cd">Arduino</a> <a href="/tags/CUDA/" style="font-size: 18px; color: #668eb3">CUDA</a> <a href="/tags/CUDNN/" style="font-size: 12px; color: #999">CUDNN</a> <a href="/tags/Conda/" style="font-size: 12px; color: #999">Conda</a> <a href="/tags/DHT11/" style="font-size: 12px; color: #999">DHT11</a> <a href="/tags/Docker/" style="font-size: 18px; color: #668eb3">Docker</a> <a href="/tags/ESP8266/" style="font-size: 12px; color: #999">ESP8266</a> <a href="/tags/GPIO/" style="font-size: 30px; color: #0078e7">GPIO</a> <a href="/tags/GPS/" style="font-size: 12px; color: #999">GPS</a> <a href="/tags/GPU/" style="font-size: 24px; color: #3383cd">GPU</a> <a href="/tags/HC-05/" style="font-size: 12px; color: #999">HC-05</a> <a href="/tags/HTML/" style="font-size: 18px; color: #668eb3">HTML</a> <a href="/tags/Hexo/" style="font-size: 18px; color: #668eb3">Hexo</a> <a href="/tags/Hexo%E5%AE%89%E8%A3%85/" style="font-size: 24px; color: #3383cd">Hexo安装</a> <a href="/tags/IAR%E8%BD%AF%E4%BB%B6/" style="font-size: 12px; color: #999">IAR软件</a> <a href="/tags/JavaScript/" style="font-size: 18px; color: #668eb3">JavaScript</a> <a href="/tags/Json/" style="font-size: 12px; color: #999">Json</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#6200ee;"><link itemprop="mainEntityOfPage" href="http://ccsu.top/posts/c56898db/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Explorer"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="explorerの博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">排序（龙哥）</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">Posted on</span> <time title="Created: 2021-01-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-21T00:00:00+08:00">2021-01-21</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <span class="post-meta-icon-text">Edited on</span> <time title="Modified: 2021-02-26 00:00:00" itemprop="dateModified" datetime="2021-02-26T00:00:00+08:00">2021-02-26</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">11.2k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">49m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">数据结构与算法</span></a></span> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%80%83%E7%A0%94/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">考研</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E6%8E%92%E5%BA%8F/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">排序</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="一概述">一、概述</h1>
<h2 id="为什么要排序">1.为什么要排序</h2>
<p>查找是计算机应用中必不可少并且使用频率很高的一个操作。在一个排序表中查找一个元素，要比在一个无序表中查找效率高得多。所以为了提高查找效率，节省CPU时间，需要排序。</p>
<h2 id="什么是排序">2.什么是排序</h2>
<p>所谓排序，就是整理表中的数据几素，使之按儿素的关键字递增/递减的顺序排列。</p>
<h2 id="排序的稳定性">3.排序的稳定性</h2>
<p>当待排序元素的关键字不相同时，排序的结果是唯一的。如果待排序的表中，有多个关键字相间的元素：经过排序后这些共有相同关键字的元素之间的相对次序保持不变，则称这种排序方法是稳定的；反之，若具有相同关键字的元素之间的相对次序发生变化，则称这种的方法是不稳定的。</p>
<h2 id="排序稳定性的意义">4.排序稳定性的意义</h2>
<p>什么时候需要稳定的排序方法？什么时候不需要呢？ 考虑一下这种情况：
原序列按关键字Ki排列，现在要求按关键字Km排列，期望：在结果序列中，关键字Km相同的记录按原关键字Ki排列！！
“主关键字相同，按原次关键字排列”</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210121201807023.png"
alt="image-20210121201807023" />
<figcaption aria-hidden="true">image-20210121201807023</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210121201826774.png"
alt="image-20210121201826774" />
<figcaption aria-hidden="true">image-20210121201826774</figcaption>
</figure>
<h2 id="排序方法分类">5.排序方法分类</h2>
<h3 id="分类方法一">(1)分类方法一</h3>
<p>我们根据待排序的数据元素是否全部在内存中，我们把排序方法，分为两类：
内排序：整个排序元素都在内存中处理，不涉及内、外存的数据交换。
外排序：待排序元素有一部分不在内存（如：内存装不下）</p>
<figure>
<img src="D:/Desktop/image-20210121200637084.png"
alt="image-20210121200637084" />
<figcaption aria-hidden="true">image-20210121200637084</figcaption>
</figure>
<h3 id="分类方法二">(2)分类方法二</h3>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127183540.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="排序算法性能评估">6.排序算法性能评估</h2>
<p>（1）算法的时间复杂度 评估一下算法 <strong>运行时间</strong>
T（n）=O（f（n））</p>
<p>（2）算法的空间复杂度 评估一下算法 <strong>所用空间</strong>
s（n）=O（f（n））</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127183628.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="相关概念总结">7.相关概念总结</h2>
<ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a
可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
</ul>
<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127183925.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127184114.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="关于时间复杂度">关于时间复杂度</h3>
<p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p>
<p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</p>
<p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</p>
<p>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p>
<p>关于稳定性</p>
<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>
<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
<p>名词解释：</p>
<ul>
<li>n：数据规模</li>
<li>k："桶"的个数</li>
<li>In-place：占用常数内存，不占用额外内存</li>
<li>Out-place：占用额外内存</li>
<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li>
</ul>
<h1 id="二直接插入排序">二、直接插入排序</h1>
<h2 id="定义">1.定义</h2>
<p>（基本思想）每次将一个待排序的元素，按其关键字大小插入到已经排好序的子表中的适当位置，直到全部元素插入完成为止。
直接插入排序&lt;&lt;&lt; 折半插入排序 希尔排序|</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210122183206813.png"
alt="image-20210122183206813" />
<figcaption aria-hidden="true">image-20210122183206813</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210122183231936.png"
alt="image-20210122183231936" />
<figcaption aria-hidden="true">image-20210122183231936</figcaption>
</figure>
<figure>
<img
src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="基本思路">2.基本思路</h2>
<h3 id="step1找插入位置">step1：找插入位置</h3>
<p>​ 从第一个元素开始，找到第一个比待插入元素大的元素， ​
“插入位置”I</p>
<h3 id="step2插入操作">step2：插入操作</h3>
<p>​ 从最后面，一个一个元素往后挪</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210122183653824.png"
alt="image-20210122183653824" />
<figcaption aria-hidden="true">image-20210122183653824</figcaption>
</figure>
<h3 id="代码实现">代码实现</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#define N 10
&#x2F;*
    insert:把元素x,插入到升序数组a[]中去
            a[0] a[1] ... a[n-1]
    @a:数组名
    @n:原有序表的元素个数，0,...,n-1
    @x:待插入元素
    返回值：
        无返回
*&#x2F;
void insert(int a[], int n, int x)
&#123;
    int i,j,k;
    &#x2F;&#x2F;step1:找插入位置
    for(i &#x3D; 0;i &lt; n; i++)
    &#123;
        if(a[i] &gt; x)
        &#123;
            break;
        &#125;
    &#125;
    &#x2F;&#x2F;i就是插入位置

    &#x2F;&#x2F;step: 插入操作(先挪后插入)
    for(j &#x3D; n-1; j &gt;&#x3D; i;j--)
    &#123;
        a[j+1] &#x3D; a[j];
    &#125;
    a[i] &#x3D; x;
&#125;


&#x2F;&#x2F;给数组a[n]进行 直接插入排序
void insertSort(int a[], int n)
&#123;
    int i;
    for(i &#x3D; 1; i &lt; n; i++)
    &#123;
        insert(a, i, a[i]);
    &#125;
&#125;

int main()
&#123;
    int a[N];
    int i;
    for(i &#x3D; 0;i &lt; N; i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;a[i]);
    &#125;
    insertSort(a, N);

    for(i &#x3D; 0;i &lt; N; i++)
    &#123;
        printf(&quot;%d &quot;,a[i]);
    &#125;
    printf(&quot;\n&quot;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="直接插入改进">3.直接插入改进</h2>
<p>“边比较边挪位置” 从最后面的元素，一个一个与待插入元素x比较</p>
<p>[ai] &gt; x =&gt; 把[ai]往后挪</p>
<p>​ a[i+1]-a[i] 直到a[i] &lt;= x此时i+1就是插入位置。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123090733160.png"
alt="image-20210123090733160" />
<figcaption aria-hidden="true">image-20210123090733160</figcaption>
</figure>
<h3 id="龙哥改进版">（1）龙哥改进版</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span>

<span class="token comment">/*
    insert:把元素x,插入到升序数组a[]中去
            a[0] a[1] ... a[n-1]
    @a:数组名
    @n:原有序表的元素个数，0,...,n-1
    @x:待插入元素
    返回值：
        无返回
*/</span>
<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>
    
    <span class="token comment">//debug</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token punctuation">&#125;</span> 
	 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"	\033[1;34m%d\033[0m\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//高亮打印 </span>
	 
	 
    <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        a<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    a<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//k+1就是插入位置</span>
    
    
    <span class="token comment">//debug</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[1;34m%d\033[0m "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//高亮打印 </span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> 
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">//给数组a[n]进行 直接插入排序</span>
<span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">insertSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="改进版集成">（2）改进版集成</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#define N 5

void InsertSot(int a[] , int n)
&#123;
	int i,j;
	for(i&#x3D;1;i&lt;n;i++)
	&#123;
		for(j&#x3D;i-1;j&gt;&#x3D;0 &amp;&amp; a[j]&gt;a[i];j--)
		&#123;
			a[j+1] &#x3D; a[j];
		&#125;
		a[j+1] &#x3D; a[i];
	&#125;
&#125;

int main()
&#123;
	int a[N]&#x3D;&#123;0&#125;;
	int i;
	for(i&#x3D;0;i&lt;N;i++)
	&#123;
		scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	InsertSot(a,N);
	for(i&#x3D;0;i&lt;N;i++)
	&#123;
		printf(&quot;%d&quot;,a[i]);
	&#125;
	printf(&quot;\n&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="课外集成版">（3）课外集成版</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。*&#x2F;
&#x2F;*基本有序，记录数少*&#x2F;
&#x2F;*
基本思想： 每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序 的一组元素的合适位置上去，直到元素全部插完为止。
直接插入排序； 当插入第i(i&gt;&#x3D;1)个元素时，前面的array[0],array[1],…,array[i-1]已经 排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序 进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移
元素集合越接近有序，直接插入排序算法的时间效率越高 最优情况下：时间效率为O(n) 最差情况下：时间复杂度为O(n^2) 空间复杂度：O(1)，它是一种稳定的排序算法
*&#x2F;
#include &lt;stdio.h&gt;

void InsertSort(int k[], int n)
&#123;
	int i, j, temp;

	for( i&#x3D;1; i &lt; n; i++ )
	&#123;
		if( k[i] &lt; k[i-1] )
		&#123;
			temp &#x3D; k[i];
			for( j&#x3D;i-1; k[j] &gt; temp; j-- )
			&#123;
				k[j+1] &#x3D; k[j];
			&#125;
			k[j+1] &#x3D; temp;
		&#125;
	&#125;
&#125;

int main()
&#123;
	int i, a[10] &#x3D; &#123;5, 2, 6, 0, 3, 9, 1, 7, 4, 8&#125;;

	InsertSort(a, 10);

	printf(&quot;排序后的结果是：&quot;);
	for( i&#x3D;0; i &lt; 10; i++ )
	&#123;
		printf(&quot;%d&quot;, a[i]);
	&#125;
	printf(&quot;\n\n&quot;);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="直接插入排序的性能分析">4.直接插入排序的性能分析</h2>
<h3 id="时间复杂度">(1)时间复杂度</h3>
<h4 id="a.最坏情况">a.最坏情况</h4>
<p>​ 每次来的都是“最小元素” “反序”</p>
<p>​ O(n<sup>2</sup>)</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123094724749.png"
alt="image-20210123094724749" />
<figcaption aria-hidden="true">image-20210123094724749</figcaption>
</figure>
<h4 id="b.最好情况">b.最好情况</h4>
<p>​ 每次来的都是”最大元素” 正序</p>
<p>​ O(n)</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123094916432.png"
alt="image-20210123094916432" />
<figcaption aria-hidden="true">image-20210123094916432</figcaption>
</figure>
<h4 id="c.平均情况">c.平均情况</h4>
<p>​ O(n<sup>2</sup>)</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123095227821.png"
alt="image-20210123095227821" />
<figcaption aria-hidden="true">image-20210123095227821</figcaption>
</figure>
<h3 id="空间复杂度">(2)空间复杂度</h3>
<p>​ O(1)</p>
<h2 id="直接插入排序稳定性分析">5.直接插入排序稳定性分析</h2>
<p>直接插入排序 是 稳定的。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123095704143.png"
alt="image-20210123095703913" />
<figcaption aria-hidden="true">image-20210123095703913</figcaption>
</figure>
<h2 id="总结">6.总结</h2>
<p>1.插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率。O（n）</p>
<p>但</p>
<p>2.插入排序一般来说是低效的，因为插入排序每次只能将数据移动一个位置。</p>
<h3 id="适用场景">适用场景</h3>
<p>插入排序由于O( n2
)的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。例如，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。又如，在JDK
7
java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123095753674.png"
alt="image-20210123095753674" />
<figcaption aria-hidden="true">image-20210123095753674</figcaption>
</figure>
<h1 id="三折半插入排序">三、折半插入排序</h1>
<h2 id="什么是折半插入排序">1.什么是折半插入排序</h2>
<p>（Binary Insertion
Sort）折半插入排序又称二分插入排序，是插入排序的一种。
折半插入排序是对直接插入排序的一种改进。 改进？ （直接插入排序）线性查找
—&gt; 折半查找</p>
<p>​ 减少比较次数</p>
<p>基本思路： 每次插入操作，采用折半查找的方式，查找插入位置，</p>
<p>​ 然后再插入元素（先挪后插入）。</p>
<h2 id="算法思路">2.算法思路</h2>
<h3 id="step-1找插入位置insertion-position">step
1：找插入位置（Insertion Position）</h3>
<p>待查找范围的下标 [low，high] 每次跟中间元素PK mid=（low+hiqh）/ 2</p>
<p>根据PK结果，调整待查找范围（改变low or high）</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123104037173.png"
alt="image-20210123104037173" />
<figcaption aria-hidden="true">image-20210123104037173</figcaption>
</figure>
<p>如此重复，直到查找不成功（1ow&gt;high了）或 查找到？</p>
<h4 id="查找不成功">(1)查找不成功</h4>
<p>（原有序表中没有待插入的元素）时，插入位置的确定</p>
<p>​ Insertion Position = high + 1 (low)</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123104103657.png"
alt="image-20210123104103657" />
<figcaption aria-hidden="true">image-20210123104103657</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123104624817.png"
alt="image-20210123104624817" />
<figcaption aria-hidden="true">image-20210123104624817</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105046439.png"
alt="image-20210123105046439" />
<figcaption aria-hidden="true">image-20210123105046439</figcaption>
</figure>
<h4 id="查找成功">(2)查找成功</h4>
<p>（原有序表中有待插入的元素）时，插入位置的确定</p>
<p>靠后的插入位置，更优化（后续挪动次数会少一些）</p>
<p>low = mid+1，when x == a[mid]</p>
<p>...</p>
<p>=&gt; 查找不成功</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105259464.png"
alt="image-20210123105259464" />
<figcaption aria-hidden="true">image-20210123105259464</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105909395.png"
alt="image-20210123105909395" />
<figcaption aria-hidden="true">image-20210123105909395</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105810213.png"
alt="image-20210123105810213" />
<figcaption aria-hidden="true">image-20210123105810213</figcaption>
</figure>
<h3 id="step-2插入操作">step 2：插入操作</h3>
<h4 id="先挪元素">(1)先挪元素</h4>
<p>​ [last，---&gt; Insertion Position] ​ high+1</p>
<h4 id="插入操作">(2)插入操作</h4>
<p>x-&gt;[Insertion Position]</p>
<p>​ x-&gt;a[high +1]</p>
<h3 id="代码实现-1"><strong>代码实现</strong></h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#define N 5


&#x2F;*
	BinInsert:一次折半插入
	@a:有序表，数组名
	@n:有序表的元素个数
		a[0] a[1] ... a[n-1]
	@x：待插入元素
	返回值：
		无 
*&#x2F;
void BinInsert(int a[], int n,int x)
&#123;
	int i; 
	int low &#x3D; 0;&#x2F;&#x2F;查找范围，最左边元素的下标
	int high &#x3D; n-1;&#x2F;&#x2F;查找范围，最右边元素的下标
	int mid;&#x2F;&#x2F;查找范围中间元素的下标
	
	&#x2F;&#x2F;step 1：用二分法找插入位置
	while(low &lt;&#x3D; high)
	&#123;
		mid &#x3D; (low + high)&#x2F;2;
		
		if(x &gt;&#x3D; a[mid])
		&#123;
			low &#x3D; mid + 1;
		&#125;
		else	&#x2F;&#x2F;x &lt; a[mid] 
		&#123;
			high &#x3D; mid - 1;
		&#125;
	&#125;
	&#x2F;&#x2F;high+1 就是x的插入位置 
	
	&#x2F;&#x2F;step2: 插入操作(先挪后插入) 
	for(i &#x3D; n - 1; i &gt;&#x3D; high+1; i--)
	&#123;
		a[i+1] &#x3D; a[i];
	&#125;
	a[high+1] &#x3D; x;
&#125; 

void insertSort(int a[] , int n)
&#123;
	int i,j;
	for(i &#x3D; 1; i &lt; n; i++)
	&#123;
		BinInsert(a,i,a[i]);
	&#125;
&#125;


int main()
&#123;
	int a[N]&#x3D;&#123;0&#125;;
	int i;
	for(i&#x3D;0;i&lt;N;i++)
	&#123;
		scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	insertSort(a,N);
	for(i&#x3D;0;i&lt;N;i++)
	&#123;
		printf(&quot;%d&quot;,a[i]);
	&#125;
	printf(&quot;\n&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="折半插入排序的性能分析">3.折半插入排序的性能分析</h2>
<h4 id="时间复杂度-1">(1)时间复杂度</h4>
<p>一次BinInsert的时间T=Ts +Tm</p>
<p>其中 Ts 为一次二分查找的时间</p>
<p>二分查找插入位置时，都是“查找不成功（查找最坏）”的情况</p>
<p>so，每次查找比较次数为：1og2N</p>
<p>​ Ts=t1*log2N</p>
<p>​ Tm为一次移动元素的时间 根据插入位置，每次插入移动元素的个数，分为：
最好情况：移动一个 最坏情况：移动n个 平均情况：移动（n/2）</p>
<p>所以，我们根据移动元素的情形，把折半插入排序的时间复杂度分为三种情况：
最好情况：</p>
<p>​ O(nlog<sub>2</sub>N)</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123113926334.png"
alt="image-20210123112952294" />
<figcaption aria-hidden="true">image-20210123112952294</figcaption>
</figure>
<p>最坏情况：</p>
<p>​ O( n<sup>2</sup>)</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123113826430.png"
alt="image-20210123113826430" />
<figcaption aria-hidden="true">image-20210123113826430</figcaption>
</figure>
<p>平均情况：</p>
<p>​ O( n<sup>2</sup>)</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123113926334.png"
alt="image-20210123113926334" />
<figcaption aria-hidden="true">image-20210123113926334</figcaption>
</figure>
<h4 id="空间复杂度-1">(2)空间复杂度</h4>
<p>​ O(1)</p>
<h2 id="折半插入排序稳定性分析">4.折半插入排序稳定性分析</h2>
<p>折半插入排序 是 稳定的。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123134417341.png"
alt="image-20210123134417341" />
<figcaption aria-hidden="true">image-20210123134417341</figcaption>
</figure>
<h2 id="总结-1">5.总结</h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123135701205.png"
alt="image-20210123135701205" />
<figcaption aria-hidden="true">image-20210123135701205</figcaption>
</figure>
<p>折半插入排序相比直接插入排序只优化了查找插入位置的比较次数，移动元素的次数并没有解决。所以：
（1）当数据元素比较多（N值比较大）or （2）移动元素的代价 小于
关键字比较时</p>
<p>​ 采用折半插入排序比较有优势。</p>
<h1 id="四希尔排序">四、希尔排序</h1>
<h2 id="什么是希尔排序">1.什么是希尔排序</h2>
<p>希尔排序，是由Donald
shel1于1959年提出的一种排序算法。又称“缩小增量排序”，是插入排序的一种。
基本思想： （1）把待排序列，分成多个间隔为h的子序例，</p>
<p>​ 然后对每个子序列进行直接插入排序；</p>
<p>​ 重复（1）多次，每次间隔h不同（并且越来越小），</p>
<p>​ 最后一次选取间隔h=1，完成排序。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124115913.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="算法思路-1">2.算法思路</h2>
<p>h-sorting 增量h排序 / "间隔h排序"</p>
<p>h-sorted/h-ordered 增量h有序 / ”间隔h有序"</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123140816426.png"
alt="image-20210123140816426" />
<figcaption aria-hidden="true">image-20210123140816426</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123141319425.png"
alt="image-20210123141319425" />
<figcaption aria-hidden="true">image-20210123141319425</figcaption>
</figure>
<h3 id="代码实现-2">代码实现</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#define N 5

&#x2F;*
    h_sorting：一次增量h排序 
    @a:进行增量h排序的原始序列，数组名 
    @n:原有序表的元素个数，
    	a[0] a[1] ,..., a[n-1] 
    @h:增量h&#x2F;间隔h 
    返回值：
        无返回
*&#x2F;
void h_sorting(int a[], int n, int h)
&#123;
	int i,j;
	int x;
	
	for(i &#x3D; h; i &lt; n; i++)
	&#123;
		x &#x3D; a[i];
		for(j &#x3D; i - h; j &gt;&#x3D; 0 &amp;&amp; a[j] &gt; x; j &#x3D; j-h)
		&#123;
			a[j+h] &#x3D; a[j];
		&#125;
		a[j+h] &#x3D; x;
	&#125; 
&#125; 

&#x2F;&#x2F;对数组a，进行一个shell排序 
void shell_sort(int a[], int n)
&#123;
	int i;
	&#x2F;&#x2F;增量序列 
	int h[] &#x3D; &#123;8,4,2,1&#125;; 
	for(i &#x3D; 0; i &lt; 4; i++)
	&#123;
		h_sorting(a, n, h[i]);
	&#125;
&#125;

int main()
&#123;
	int i;
    int a[N];
    for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	shell_sort(a, N);
	
	for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	printf(&quot;%d\t&quot;,a[i]);
	&#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="希尔插入排序的性能分析">3.希尔插入排序的性能分析</h2>
<p>关于希尔排序的几个基本认知：
（1）ht-Orderd序列，在后面的hi-sorting后，将仍然保持它的排序性；【定理】
（2）在h-sorting时，采用插入排序被证实比其他排序方法效率更高；
（3）不同的增量序列，对希尔排序的性能影响比较大。</p>
<h4 id="时间复杂度-2">(1)时间复杂度</h4>
<p>一般认为，希尔排序的时间复杂度为： 平均/最坏情况下
最好的情况下（本身就是有序的） O（n<sup>r</sup>），1&lt;r&lt;2
O（nlog<sub>2</sub>n）</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123144403182.png"
alt="image-20210123144403182" />
<figcaption aria-hidden="true">image-20210123144403182</figcaption>
</figure>
<h4 id="空间复杂度-2">(2)空间复杂度</h4>
<p>​ O（1）</p>
<h2 id="希尔排序稳定性分析">4.希尔排序稳定性分析</h2>
<p>​ 希尔排序是一种 不稳定 的排序方法。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123144513092.png"
alt="image-20210123144513092" />
<figcaption aria-hidden="true">image-20210123144513092</figcaption>
</figure>
<h2 id="总结-2">5.总结</h2>
<h3 id="适用场景-1">适用场景</h3>
<p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀--快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123144621673.png"
alt="image-20210123144621673" />
<figcaption aria-hidden="true">image-20210123144621673</figcaption>
</figure>
<h1 id="五冒泡排序">五、冒泡排序</h1>
<h2 id="什么是冒泡排序">1.什么是冒泡排序</h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123153036871.png"
alt="image-20210123153036871" />
<figcaption aria-hidden="true">image-20210123153036871</figcaption>
</figure>
<p>冒泡排序（BubbleSort），是一种简单的排序算法。</p>
<p>它“从头到尾”重复遍历要排序的数列，一次比较两个元素，如果他们的顺序是错的，就把他们交换过来。</p>
<p>遍历数列的工作要重复进行，直到没有元素需要交换，此时排序完成。</p>
<p>“相邻元素两两比较，如果顺序是错的，就交换他们"</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/849589-20171015223238449-2146169197.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="算法思路-2">2.算法思路</h2>
<p>（1）比较第一个和第二个元素。如果第一个比第二个大，就交换他们两个</p>
<p>（2）比较第二个和第三个元素。如果第二个比第三个大，就交换他们两个</p>
<p>……</p>
<p>（n）比较第n-1个和第n个元素。如果第n-1个比第n个大，就交换他们两个</p>
<p>​ 上面过程实际上是对每一对相邻元素作同样的比较交换工作，</p>
<p>​ 从第一对到最后一对，这一趟做完后，最大的元素会在最后的位置上。</p>
<p>​ “一趟冒泡"：把一个最大的元素归位。</p>
<p>上面冒泡"过程，重复N-1（最多N-1）趟，所有元素都会归位。</p>
<p>“N-1趟冒泡"：排序完成。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123145949207.png"
alt="image-20210123145949207" />
<figcaption aria-hidden="true">image-20210123145949207</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123150038094.png"
alt="image-20210123150038094" />
<figcaption aria-hidden="true">image-20210123150038094</figcaption>
</figure>
<h3 id="代码实现-3">代码实现</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span>

<span class="token comment">//冒泡排序</span>
<span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">//第t趟冒泡 [0, N-1] </span>
	<span class="token keyword">int</span> temp<span class="token punctuation">;</span>
	
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token comment">//[0, n-1-t] 第t趟冒泡，待排序区的下标</span>
		<span class="token comment">//一趟冒泡</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#123;</span>
				temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span> 
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">bubble_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="代码改进">代码改进</h3>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123151525102.png"
alt="image-20210123151525102" />
<figcaption aria-hidden="true">image-20210123151525102</figcaption>
</figure>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#define N 5

&#x2F;&#x2F;冒泡排序
void bubble_sort(int a[], int n)
&#123;
	int i;
	int t &#x3D; 0;	&#x2F;&#x2F;第t趟冒泡 [0, N-1] 
	int temp;
	int exchange &#x3D; 0;&#x2F;&#x2F;标记，是否有元素进行交换
					&#x2F;&#x2F;1 表示有元素进行交换
					&#x2F;&#x2F;0 表示没有元素进行交换 
	
	
	for(t &#x3D; 0; t &lt; n - 1; t++)
	&#123;
		&#x2F;&#x2F;[0, n-1-t] 第t趟冒泡，待排序区的下标
		&#x2F;&#x2F;一趟冒泡
		for(i &#x3D; 0; i &lt; n-1-t; i++)
		&#123;
			if(a[i] &gt; a[i+1])
			&#123;
				temp &#x3D; a[i];
				a[i] &#x3D; a[i+1];
				a[i+1] &#x3D; temp;
				
				exchange &#x3D; 1; 
			&#125;
		&#125; 
		if(exchange &#x3D;&#x3D; 0)&#x2F;&#x2F;刚刚那趟冒泡过程，没有发生元素交换，
		&#123;
			break;
		&#125; 
	&#125;
&#125; 

int main()
&#123;
	int i;
    int a[N];
    for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	bubble_sort(a, N);
	
	for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	printf(&quot;%d\t&quot;,a[i]);
	&#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="另外的版本">另外的版本</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*优化过的正宗版本的冒泡排序*&#x2F;
&#x2F;*用flag模拟布尔类型，如果遍历一遍后没有元素位置的交换就不再进行再次遍历排序*&#x2F;
#include &lt;stdio.h&gt;

void BubbleSort(int k[], int n)
&#123;
	int i, j, temp, count1&#x3D;0, count2&#x3D;0, flag;
	
	flag &#x3D; 1;
	for( i&#x3D;0; i &lt; n-1 &amp;&amp; flag; i++ )
	&#123;
		for( j&#x3D;n-1; j &gt; i; j-- )
		&#123;
			count1++;
			flag &#x3D; 0;
			if( k[j-1] &gt; k[j] )
			&#123;
				count2++;
				temp &#x3D; k[j-1];
				k[j-1] &#x3D; k[j];
				k[j] &#x3D; temp;
				flag &#x3D; 1;
			&#125;
		&#125;
	&#125;

	printf(&quot;总共进行了%d次比较，进行了%d次移动！&quot;, count1, count2);
&#125;

int main()
&#123;
	int i, a[10] &#x3D; &#123;5, 2, 6, 0, 3, 9, 1, 7, 4, 8&#125;;

	BubbleSort(a, 10);

	printf(&quot;排序后的结果是：&quot;);
	for( i&#x3D;0; i &lt; 10; i++ )
	&#123;
		printf(&quot;%d&quot;, a[i]);
	&#125;
	printf(&quot;\n\n&quot;);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="冒泡排序的性能分析">3.冒泡排序的性能分析</h2>
<h4 id="时间复杂度-3">(1)时间复杂度</h4>
<h5 id="a.最好情况">a.最好情况</h5>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152217350.png"
alt="image-20210123152052135" />
<figcaption aria-hidden="true">image-20210123152052135</figcaption>
</figure>
<h5 id="b.最坏情况">b.最坏情况</h5>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152217350.png"
alt="image-20210123152217350" />
<figcaption aria-hidden="true">image-20210123152217350</figcaption>
</figure>
<h5 id="c.平均情况-1">c.平均情况</h5>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152314489.png"
alt="image-20210123152314489" />
<figcaption aria-hidden="true">image-20210123152314489</figcaption>
</figure>
<h4 id="空间复杂度-3">(2)空间复杂度</h4>
<p>​ O（1）</p>
<h2 id="冒泡排序稳定性分析">4.冒泡排序稳定性分析</h2>
<p>​ 冒泡排序是一种 <strong>稳定的</strong> 排序方法。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152717358.png"
alt="image-20210123152717358" />
<figcaption aria-hidden="true">image-20210123152717358</figcaption>
</figure>
<h2 id="总结-3">5.总结</h2>
<p>简言之，冒泡排序除开它迷人的名字和导致了某些有趣的理论问题这一事实之外，似乎没有什么值得推荐的。---Knuth《计算机程序设计艺术》</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152651749.png"
alt="image-20210123152651749" />
<figcaption aria-hidden="true">image-20210123152651749</figcaption>
</figure>
<h3 id="什么时候最快">(1)什么时候最快</h3>
<p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p>
<h3 id="什么时候最慢">(2) 什么时候最慢</h3>
<p>当输入的数据是反序时（写一个 for
循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p>
<h3 id="适用场景-2">(3)适用场景</h3>
<p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p>
<h1 id="六快速排序">六、快速排序</h1>
<h2 id="什么是快速排序">1.什么是快速排序</h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123155510747.png"
alt="image-20210123155510747" />
<figcaption aria-hidden="true">image-20210123155510747</figcaption>
</figure>
<p>快速排序（英语：QuickSort）是一种高效的排序算法，最早由英国计算机科学家Tony
Hoare于1959年发明。
快速排序不断重复的一个操作是：选取一个基准值（pivot），然后把原序列划分（partition）为两部分，一部分小于基准值，另外一部分大于等于基准值，所以快速排序又称划分交换排序（partition-exchange
sort）。</p>
<figure>
<img
src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="算法思路-3">2.算法思路</h2>
<p>快速排序采用分治算法（divide-and-conquer），它是这样工作的：
（1）从待排序的数列中选择一个基准元素（pivot），然后（2）把剩余元素划分（“分割”）为两个子数列：
小于基准元素值的子序列S1和 大于等于基准元素值的子序列s2
（3）子序列S1和s2按同样的方法递归执行（1）和（2），直到序列中的元素个数为0或1。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123160026835.png"
alt="image-20210123160026835" />
<figcaption aria-hidden="true">image-20210123160026835</figcaption>
</figure>
<p>具体的算法步骤：Qsort（A[ ]，left，right）</p>
<p>关键：把序列分割成两部分：“小”基准值“大”</p>
<p>（1）（在待排序数列中）选择一个元素作为基准值pivot</p>
<p>（2）把基准值与区间最后一个元素交换</p>
<p>（3）设置两个索i，j : i从区间第一个元素开始，而 j
从区间倒数第二个开始（倒数第一个是pivot）</p>
<p>（4）i往右找下一个比pivot大（&gt;=）的元素，</p>
<p>​ while（A[i]&lt;pivot）i++；</p>
<p>j往左找下一个比pivot小的元素</p>
<p>​ while（j&gt;=0&amp;&amp;A[j]&gt;=pivot）j--；</p>
<p>（5）ifi&lt;j则交换A[i]与A[j]的位置</p>
<p>​ 重复（4），（5）直到i&gt;=j</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123165053504.png"
alt="image-20210123165053504" />
<figcaption aria-hidden="true">image-20210123165053504</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123163826922.png"
alt="image-20210123163826922" />
<figcaption aria-hidden="true">image-20210123163826922</figcaption>
</figure>
<h3 id="代码实现-4">代码实现</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>ElemType <span class="token operator">*</span>p<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	ElemType t<span class="token punctuation">;</span> 
	t <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
	<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
	<span class="token operator">*</span>s <span class="token operator">=</span> t<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
	QSort：把数列A[1eft]...A[right]进行快速的排序
	@A：数组名
	@left：待排序数列最左边元素的下标
	@right：待排序数列最右边元素的下标
	返回值：
			无。
*/</span>
<span class="token keyword">void</span> <span class="token function">QSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	ElemType pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> 
	
	<span class="token comment">//1.选取一个基准值</span>
	<span class="token comment">//2.把基准值元素与 最后一个元素交换</span>
	
	<span class="token comment">//3.设置两个索引 i,j;</span>
	<span class="token comment">//	i从第一个元素开始往右遍历</span>
	<span class="token comment">//	j从倒数第二个元素开始往左遍历</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token comment">//4.”两头点蜡“ </span>
		<span class="token comment">//i从左->右，找下一个比pivot大（>=）的元素</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
		
		<span class="token comment">//j从右->左，找下一个比pivot小的元素 </span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span>
		
		<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token comment">//交换：把大的元素放在序列的右边</span>
			<span class="token comment">//		把小的元素放在序列的左边</span>
			<span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">&#125;</span> 
		<span class="token keyword">else</span>	<span class="token comment">//i >= j</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> 
	<span class="token comment">//6.i 指向的位置就是pivot的位置</span>
	<span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//S1: A[left] ... A[i-1]</span>
	<span class="token function">QSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//S2:A[i+1] ... A[right] </span>
	<span class="token function">QSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">QSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="三数中值分割法">3.三数中值分割法</h2>
<h3 id="快排-pivot-选择策略">快排 pivot 选择策略</h3>
<p>1.每次固定选择序列中的第一个or最后一个元素作为pivo如果输入序列是随机的，那么这种策略是可以接受的但是如果输入是预排序的或反序的，那么这种策略下的分割是非常糟糕的，因为所有的元素不是被划入s1就是被划入S2</p>
<p>预排序的输入（或具有一大预排序数据的输入）是相当常见的，因此这种策略绝对是糟糕的主意</p>
<p>2.般来说这种策略非常安全，除非随机数生成器有问题，因为随机的 pivot
不可能总是产生劣质的要割方面，随机数的生成一般是昂贵的，所以这种策略根本减少了算法其余的平均运行时间</p>
<p>3.三数中值分割法（ Median-of- Three Partitioning）
pivot的最好的选择是数列的中值</p>
<p>不幸的是，这很难算出。所以中值只能估计，中值的估计量可以通过随机选取三个元素，并用它们的中值作为
pivot而得到事实上，随机性并没有多大帮助，因此一般的做法是使用左端、右端、和中心位置上三个元素的中值作为pivot</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123194012123.png"
alt="image-20210123194012123" />
<figcaption aria-hidden="true">image-20210123194012123</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/%E4%B8%89%E5%80%BC.png"
alt="image-20210123205843034" />
<figcaption aria-hidden="true">image-20210123205843034</figcaption>
</figure>
<figure>
<img
src="C:\Users\king\AppData\Roaming\Typora\typora-user-images\image-20210124112644914.png"
alt="image-20210124112644914" />
<figcaption aria-hidden="true">image-20210124112644914</figcaption>
</figure>
<h3 id="代码实现-5">代码实现</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#define N 5

typedef int ElemType;


void swap(ElemType *p,ElemType *s)
&#123;
	ElemType t; 
	t &#x3D; *p;
	*p &#x3D; *s;
	*s &#x3D; t;
&#125;

&#x2F;*
	QSort：把数列A[1eft]...A[right]进行快速的排序
	@A：数组名
	@left：待排序数列最左边元素的下标
	@right：待排序数列最右边元素的下标
	返回值：
			无。
*&#x2F;
void QSort(ElemType A[], int left, int right)
&#123;
	if(left &gt;&#x3D; right)
	&#123;
		return ;
	&#125;
	
	ElemType pivot; &#x2F;&#x2F;&#x3D; A[right]; 
	
	&#x2F;&#x2F;1.选取一个基准值
	&#x2F;&#x2F;2.把基准值元素与 最后一个元素交换
		&#x2F;&#x2F; 采用“三数分割法”
	
	int center &#x3D; (left + right)&#x2F;2;	
	if(A[left] &gt; A[center])
	&#123;
		swap(&amp;A[left], &amp;A[center]);
	&#125;
	if(A[left] &gt; A[right])
	&#123;
		swap(&amp;A[left], &amp;A[right]);
	&#125;
	if(A[center] &gt; A[right])
	&#123;
		swap(&amp;A[center], &amp;A[right]);
	&#125; 
	&#x2F;&#x2F; A[left] &lt;&#x3D; A[center] &lt;&#x3D; A[right]
	
	pivot &#x3D; A[center];
	swap(&amp;A[center], &amp;A[right-1]);	&#x2F;&#x2F;	left....right-1
									&#x2F;&#x2F; pivot:A[right - 1]
									
	
	&#x2F;&#x2F;3.设置两个索引 i,j;
	&#x2F;&#x2F;	i从第一个元素开始往右遍历
	&#x2F;&#x2F;	j从倒数第二个元素开始往左遍历
	int i &#x3D; left;
	int j &#x3D; right - 1;
	
	for(; i &lt; j ; )
	&#123;
		&#x2F;&#x2F;4.”两头点蜡“ 
		&#x2F;&#x2F;i从左-&gt;右，找下一个比pivot大（&gt;&#x3D;）的元素
		while(A[++i] &lt; pivot);
		
		&#x2F;&#x2F;j从右-&gt;左，找下一个比pivot小的元素 
		while(A[--j] &gt; pivot);
		
		if(i &lt; j)
		&#123;
			&#x2F;&#x2F;交换：把大的元素放在序列的右边
			&#x2F;&#x2F;		把小的元素放在序列的左边
			swap(&amp;A[i], &amp;A[j]); 
		&#125; 
		else	&#x2F;&#x2F;i &gt;&#x3D; j
		&#123;
			break;
		&#125;
	&#125; 
	&#x2F;&#x2F;6.i 指向的位置就是pivot的位置
	swap(&amp;A[i], &amp;A[right-1]);
	
	&#x2F;&#x2F;S1: A[left] ... A[i-1]
	QSort(A, left, i-1);
	
	&#x2F;&#x2F;S2:A[i+1] ... A[right] 
	QSort(A, i+1, right);
&#125;

void QuickSort(ElemType A[], int n)
&#123;
	QSort(A, 0, n-1);
&#125;

int main()
&#123;
	int i;
    int a[N];
    for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	QuickSort(a, N);
	
	for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	printf(&quot;%d\t&quot;,a[i]);
	&#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="快速排序的性能分析">4.快速排序的性能分析</h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113036.png"
alt="image-20210124113036589" />
<figcaption aria-hidden="true">image-20210124113036589</figcaption>
</figure>
<h4 id="时间复杂度-4">(1)时间复杂度</h4>
<h5 id="a.最坏情况-1">a.最坏情况</h5>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113157.png"
alt="image-20210124113156762" />
<figcaption aria-hidden="true">image-20210124113156762</figcaption>
</figure>
<h5 id="b.最好情况-1">b.最好情况</h5>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113251.png"
alt="image-20210124113250865" />
<figcaption aria-hidden="true">image-20210124113250865</figcaption>
</figure>
<h5 id="c.平均情况-2">c.平均情况</h5>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113557.png"
alt="image-20210124113556982" />
<figcaption aria-hidden="true">image-20210124113556982</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113438.png"
alt="image-20210124113437532" />
<figcaption aria-hidden="true">image-20210124113437532</figcaption>
</figure>
<h4 id="空间复杂度-4">(2)空间复杂度</h4>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124114022.png"
alt="image-20210124114022789" />
<figcaption aria-hidden="true">image-20210124114022789</figcaption>
</figure>
<h2 id="快速排序稳定性分析">5.快速排序稳定性分析</h2>
<p>快速排序是 不稳定 的。</p>
<h2 id="总结-4">6.总结</h2>
<h3 id="适用场景-3">适用场景</h3>
<p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124114240.png"
alt="image-20210124114240345" />
<figcaption aria-hidden="true">image-20210124114240345</figcaption>
</figure>
<p>关于快速排序对于很小的数组（&lt;=20），快速排序不如插入排序好不仅如此；因为快速排序是递归，所以这样的情形还经常发生。
通常的解决方法是对于小的数组不递归地使用快速排序，而代之以如插入排序这样对小数组有效的排序算法。
所以一般在实现快速排序算法（如：c/c++标准库中）时，定义一个递归的截止范围（
cutoff range），当序列元素个数小于这个范围时，使用直接插入排序。</p>
<h3 id="使用方法">使用方法</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define cutoff 10	&#x2F;&#x2F;数组长度小于10用插入排序，大于10使用快速排序
&#x2F;*
	对于小的数组不递归地使用快速排序，而代之以如插入排序这样对小数组有效的排序算法。
*&#x2F;
void QSort(ElemType A[], int left, int right)
&#123;
	if(right - left &lt; cutoff)
	&#123;
		insertsort(A+left, right-left+1);
	&#125;
	else
    &#123;
        ElemType pivot; &#x2F;&#x2F;&#x3D; A[right]; 
	
        &#x2F;&#x2F;1.选取一个基准值
        &#x2F;&#x2F;2.把基准值元素与 最后一个元素交换
        &#x2F;&#x2F; 采用“三数分割法”

        int center &#x3D; (left + right)&#x2F;2;	
        if(A[left] &gt; A[center])
        &#123;
            swap(&amp;A[left], &amp;A[center]);
        &#125;
        if(A[left] &gt; A[right])
        &#123;
            swap(&amp;A[left], &amp;A[right]);
        &#125;
        if(A[center] &gt; A[right])
        &#123;
            swap(&amp;A[center], &amp;A[right]);
        &#125; 
        &#x2F;&#x2F; A[left] &lt;&#x3D; A[center] &lt;&#x3D; A[right]

        pivot &#x3D; A[center];
        swap(&amp;A[center], &amp;A[right-1]);	&#x2F;&#x2F;	left....right-1
        &#x2F;&#x2F; pivot:A[right - 1]


        &#x2F;&#x2F;3.设置两个索引 i,j;
        &#x2F;&#x2F;	i从第一个元素开始往右遍历
        &#x2F;&#x2F;	j从倒数第二个元素开始往左遍历
        int i &#x3D; left;
        int j &#x3D; right - 1;

        for(; i &lt; j ; )
        &#123;
            &#x2F;&#x2F;4.”两头点蜡“ 
            &#x2F;&#x2F;i从左-&gt;右，找下一个比pivot大（&gt;&#x3D;）的元素
            while(A[++i] &lt; pivot);

            &#x2F;&#x2F;j从右-&gt;左，找下一个比pivot小的元素 
            while(A[--j] &gt; pivot);

            if(i &lt; j)
            &#123;
                &#x2F;&#x2F;交换：把大的元素放在序列的右边
                &#x2F;&#x2F;		把小的元素放在序列的左边
                swap(&amp;A[i], &amp;A[j]); 
            &#125; 
            else	&#x2F;&#x2F;i &gt;&#x3D; j
            &#123;
                break;
            &#125;
        &#125; 
        &#x2F;&#x2F;6.i 指向的位置就是pivot的位置
        swap(&amp;A[i], &amp;A[right-1]);

        &#x2F;&#x2F;S1: A[left] ... A[i-1]
        QSort(A, left, i-1);

        &#x2F;&#x2F;S2:A[i+1] ... A[right] 
        QSort(A, i+1, right);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="七.选择排序">七.选择排序</h1>
<h2 id="什么是选择排序">1.什么是选择排序</h2>
<p>选择排序（ Selection Sort）是一种简单直观的排序算法.</p>
<p>它的工作原理如下：</p>
<p>在未排序序列中（ unsorted
list，无序区）中找到最小（大）元素，和序列中的第一个元素交换位置；（这个操作会使最小元素归位）</p>
<p>然后，再从剩余的未排序元素中继续寻找最小（大）元素，重复上面的操作。</p>
<p>直到所有元素归位，排序完成</p>
<p>基本思想：</p>
<p>选择+交换</p>
<p>选择排序又分为：</p>
<p>直接选择排序（简单选择排序）</p>
<p>堆排序</p>
<h2 id="算法思路-4">2.算法思路</h2>
<figure>
<img
src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>（1）从待排序数列（无序区）中，选择一个关键字最小的元素；</p>
<p>（2）如果最小元素不是待排序数列的第一个元素，则交换他们；“一次选择交换”；</p>
<p>（3）从余下的N-1个元素中，选择最小的，重复（1）（2）步骤，直到排序完成。</p>
<p>整个序列：</p>
<p>​ 经过N-1次的选择交换，排序完成</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125181916.png"
alt="image-20210125181909128" />
<figcaption aria-hidden="true">image-20210125181909128</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125181934.png"
alt="image-20210125181934226" />
<figcaption aria-hidden="true">image-20210125181934226</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125182149.png"
alt="image-20210125182149469" />
<figcaption aria-hidden="true">image-20210125182149469</figcaption>
</figure>
<h3 id="代码实现-6">代码实现</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#define N 5

void swap(int *p,int *s)
&#123;
	int t; 
	t &#x3D; *p;
	*p &#x3D; *s;
	*s &#x3D; t;
&#125;


&#x2F;*
	selection sort：直接选择排序
	@a：待排序数组名
	@n：待排序元素个数
	返回值：
			无
*&#x2F;
void selection_sort(int a[], int n)
&#123;
	int i;
	int t;&#x2F;&#x2F;选择的次数t [0,n-1]
	int min;&#x2F;&#x2F;指向每次选择区域最小元素
	
	&#x2F;&#x2F;第t趟选择， 选择区域下标[t, n-1]
	
	for(t &#x3D; 0; t &lt; n-1; t++)
	&#123;
		min &#x3D; t;
		for(i &#x3D; t+1; i &lt; n; i++)
		&#123;
			if(a[i] &lt; a[min])
			&#123;
				min &#x3D; i;
			&#125;
		&#125;
		
		if(t !&#x3D; min)
		&#123;
			swap(&amp;a[t], &amp;a[min]);
		&#125;
	&#125;
&#125;


int main()
&#123;
	int i;
    int a[N];
    for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	selection_sort(a, N);
	
	for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	printf(&quot;%d\t&quot;,a[i]);
	&#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="选择排序的性能分析">3.选择排序的性能分析</h2>
<h3 id="时间复杂度-5">(1)时间复杂度</h3>
<p>比较次数o（n<sup>2</sup>）</p>
<p>交换次数 0次 最好情况</p>
<p>​ n-1次 最坏情况</p>
<p>​ 0&lt;，&lt;n-1 平均情况</p>
<p>然而，无论元素的初始排列如何，所需进行的关键字比较次数相同均为：n（n-1）/2</p>
<p>选择排序时间复杂度（最好、最坏、平均）为：O（n<sup>2</sup>）</p>
<h3 id="空间复杂度-5">(2)空间复杂度</h3>
<p>​ O（1）</p>
<h2 id="选择排序稳定性分析">4.选择排序稳定性分析</h2>
<p>​ 选择排序是一种 不稳定 的排序方法</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125184549.png"
alt="image-20210125184549734" />
<figcaption aria-hidden="true">image-20210125184549734</figcaption>
</figure>
<h2 id="总结-5">5.总结</h2>
<p>原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见</p>
<h4 id="适用场景-4">适用场景</h4>
<p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125184641.png"
alt="image-20210125184641554" />
<figcaption aria-hidden="true">image-20210125184641554</figcaption>
</figure>
<h1 id="八.堆排序">八.堆排序</h1>
<h2 id="什么是堆排序image-20210125185210617">1.什么是堆排序<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185210.png"
alt="image-20210125185210617" /></h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185245.png"
alt="image-20210125185245626" />
<figcaption aria-hidden="true">image-20210125185245626</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185505.png"
alt="image-20210125185505834" />
<figcaption aria-hidden="true">image-20210125185505834</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185611.png"
alt="image-20210125185611798" />
<figcaption aria-hidden="true">image-20210125185611798</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185754.png"
alt="image-20210125185754290" />
<figcaption aria-hidden="true">image-20210125185754290</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185900.png"
alt="image-20210125185900117" />
<figcaption aria-hidden="true">image-20210125185900117</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213436.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="算法思路-5">2.算法思路</h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190056.png"
alt="image-20210125190056471" />
<figcaption aria-hidden="true">image-20210125190056471</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190209.png"
alt="image-20210125190209046" />
<figcaption aria-hidden="true">image-20210125190209046</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190310.png"
alt="image-20210125190310315" />
<figcaption aria-hidden="true">image-20210125190310315</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190536.png"
alt="image-20210125190535982" />
<figcaption aria-hidden="true">image-20210125190535982</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190717.png"
alt="image-20210125190717479" />
<figcaption aria-hidden="true">image-20210125190717479</figcaption>
</figure>
<h3 id="空穴上滤">(1)空穴上滤</h3>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190913.png"
alt="image-20210125190913360" />
<figcaption aria-hidden="true">image-20210125190913360</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191021.png"
alt="image-20210125191021772" />
<figcaption aria-hidden="true">image-20210125191021772</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191142.png"
alt="image-20210125191141869" />
<figcaption aria-hidden="true">image-20210125191141869</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191409.png"
alt="image-20210125191409441" />
<figcaption aria-hidden="true">image-20210125191409441</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191513.png"
alt="image-20210125191513160" />
<figcaption aria-hidden="true">image-20210125191513160</figcaption>
</figure>
<h3 id="空穴下滤">(2)空穴下滤</h3>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191730.png"
alt="image-20210125191730431" />
<figcaption aria-hidden="true">image-20210125191730431</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191831.png"
alt="image-20210125191831299" />
<figcaption aria-hidden="true">image-20210125191831299</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125192025.png"
alt="image-20210125192025440" />
<figcaption aria-hidden="true">image-20210125192025440</figcaption>
</figure>
<h3 id="代码实现关键">(3)代码实现关键</h3>
<h4 id="a.数据类型的实现">a.数据类型的实现</h4>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125192545.png"
alt="image-20210125192545763" />
<figcaption aria-hidden="true">image-20210125192545763</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125193137.png"
alt="image-20210125193137702" />
<figcaption aria-hidden="true">image-20210125193137702</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125193310.png"
alt="image-20210125193310248" />
<figcaption aria-hidden="true">image-20210125193310248</figcaption>
</figure>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

&#x2F;&#x2F;无穷小 
#define VERY_SMALL -1

&#x2F;&#x2F;堆中结点的数据类型 
typedef int ElemType;


typedef struct Heapstruct
&#123;
	int Capacity;&#x2F;&#x2F;堆中的最大容量
	int size;&#x2F;&#x2F;堆中实际的结点数，最后那个结点的编号（下标）
	
	ElemType *Elements;
&#125;HeapStruct;

&#x2F;*
	Init Heap：分配一个堆的结构体
	@n：指定堆中最大容量
	返回值：
		返回分配到的堆的结构体的指针
*&#x2F;
HeapStruct* Init_Heap(int n)
&#123;
	Heapstruct *H&#x3D; malloc(sizeof(*H));
	H-&gt;Capacity &#x3D; n;
	H-&gt;size &#x3D; 0;
	
	H-&gt;Elements &#x3D; malloc(sizeof(ElemType)*(n+1));
	
	H-&gt;Elements[0] &#x3D; VERY_SMALL;  &#x2F;&#x2F;??
	
	return H;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="b.insert操作的实现">b.Insert操作的实现</h4>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125194713.png"
alt="image-20210125194713377" />
<figcaption aria-hidden="true">image-20210125194713377</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125195104.png"
alt="image-20210125195104011" />
<figcaption aria-hidden="true">image-20210125195104011</figcaption>
</figure>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
	Insert MinHeap：最小堆的插入操作
	@H：指向最小堆结构体指针
	@X：待插入元素
	返回值：
		无返回值。
*/</span>
<span class="token keyword">void</span> <span class="token function">Insert_MinHeap</span><span class="token punctuation">(</span>Heapstruct <span class="token operator">*</span>H<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//指向空穴结点的下标</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token operator">++</span>H<span class="token operator">-></span>size<span class="token punctuation">;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">;</span> i <span class="token operator">=</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> 
	<span class="token punctuation">&#123;</span>
		H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="c.delete_min操作的实现">c.Delete_Min操作的实现</h4>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125200153.png"
alt="image-20210125200153750" />
<figcaption aria-hidden="true">image-20210125200153750</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125200823.png"
alt="image-20210125200823587" />
<figcaption aria-hidden="true">image-20210125200823587</figcaption>
</figure>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*
	Delete_Min：删除最小堆的最小值并调整使其仍然为最小堆
	@H：指向要删除最小值的最小堆
	返回值：
		返回删除的最小值
*&#x2F;
ElemType Delete_Min(Heapstruct *H)
&#123;
	ElemType min &#x3D; H-&gt;Elements[1];
	ElemType last &#x3D; H-&gt;Elements[H-&gt;size--];
	
	int i;&#x2F;&#x2F;指向空穴结点的下标
	int child;&#x2F;&#x2F;指向空穴的较小孩子结点
	
	for(i &#x3D; 1; 2*i &lt;&#x3D; H-&gt;size; i &#x3D; child)
	&#123;
		child &#x3D; 2*i;
		&#x2F;&#x2F;如果有右孩子 并且 右孩子小于左孩子,child++ 
		if(child + 1 &lt;&#x3D; H-&gt;size &amp;&amp; 
			H-&gt;Elements[child + 1] &lt; H-&gt;Elements[child])
		&#123;
			child++;
		&#125;
		
		&#x2F;&#x2F;将孩子结点与最后一个结点比较，如果小于最后一个结点
		&#x2F;&#x2F;将孩子结点的值给父结点，此时孩子结点为新的空穴结点 
		if(H-&gt;Elements[child] &lt; last)
		&#123;
			H-&gt;Elements[i] &#x3D; H-&gt;Elements[child];
		&#125;
		else	&#x2F;&#x2F;last比最小的孩子结点还要小 
		&#123;
			break;
		&#125;
	&#125; 
	
	H-&gt;Elements[i] &#x3D; last;
	
	return min;
		
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="d.堆排序代码实现">d.堆排序代码实现</h4>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125204832.png"
alt="image-20210125204832101" />
<figcaption aria-hidden="true">image-20210125204832101</figcaption>
</figure>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">10</span></span></span>
<span class="token comment">//无穷小 </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">VERY_SMALL</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span>

<span class="token comment">//堆中结点的数据类型 </span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span>


<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Heapstruct</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> Capacity<span class="token punctuation">;</span><span class="token comment">//堆中的最大容量</span>
	<span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">//堆中实际的结点数，最后那个结点的编号（下标）</span>
	
	ElemType <span class="token operator">*</span>Elements<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>HeapStruct<span class="token punctuation">;</span>

<span class="token comment">/*
	Init Heap：分配一个堆的结构体
	@n：指定堆中最大容量
	返回值：
		返回分配到的堆的结构体的指针
*/</span>
HeapStruct<span class="token operator">*</span> <span class="token function">Init_Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	HeapStruct <span class="token operator">*</span>H<span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>H<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	H<span class="token operator">-></span>Capacity <span class="token operator">=</span> n<span class="token punctuation">;</span>
	H<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
	H<span class="token operator">-></span>Elements <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	H<span class="token operator">-></span>Elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> VERY_SMALL<span class="token punctuation">;</span>  <span class="token comment">//??</span>
	
	<span class="token keyword">return</span> H<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">/*
	Insert MinHeap：最小堆的插入操作
	@H：指向最小堆结构体指针
	@X：待插入元素
	返回值：
		无返回值。
*/</span>
<span class="token keyword">void</span> <span class="token function">Insert_MinHeap</span><span class="token punctuation">(</span>HeapStruct <span class="token operator">*</span>H<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//指向空穴结点的下标</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token operator">++</span>H<span class="token operator">-></span>size<span class="token punctuation">;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">;</span> i <span class="token operator">=</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> 
	<span class="token punctuation">&#123;</span>
		H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
	Delete_Min：删除最小堆的最小值并调整使其仍然为最小堆
	@H：指向要删除最小值的最小堆
	返回值：
		返回删除的最小值
*/</span>
ElemType <span class="token function">Delete_Min</span><span class="token punctuation">(</span>HeapStruct <span class="token operator">*</span>H<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	ElemType min <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	ElemType last <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>H<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//指向空穴结点的下标</span>
	<span class="token keyword">int</span> child<span class="token punctuation">;</span><span class="token comment">//指向空穴的较小孩子结点</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">&lt;=</span> H<span class="token operator">-></span>size<span class="token punctuation">;</span> i <span class="token operator">=</span> child<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		child <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">;</span>
		<span class="token comment">//如果有右孩子 并且 右孩子小于左孩子,child++ </span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> H<span class="token operator">-></span>size <span class="token operator">&amp;&amp;</span> 
			H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			child<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		
		<span class="token comment">//将孩子结点与最后一个结点比较，如果小于最后一个结点</span>
		<span class="token comment">//将孩子结点的值给父结点，此时孩子结点为新的空穴结点 </span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> last<span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span>	<span class="token comment">//last比最小的孩子结点还要小 </span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> 
	H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> last<span class="token punctuation">;</span>
	<span class="token keyword">return</span> min<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
	heap sort：堆排序
	@a：待排序数组
	@n：元素个数
	返回值：
			无
*/</span>
<span class="token keyword">void</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token comment">//初始化一个堆结构体</span>
	HeapStruct <span class="token operator">*</span>H <span class="token operator">=</span> <span class="token function">Init_Heap</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//堆排序的步骤：</span>
	<span class="token comment">//（1）建立堆</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">Insert_MinHeap</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> 
	
	<span class="token comment">//(2)删除最小值</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Delete_Min</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> 
	
	<span class="token function">free</span><span class="token punctuation">(</span>H<span class="token operator">-></span>Elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">heap_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="e.堆排序in-place版本实现">e.堆排序In-place版本实现</h4>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125205332.png"
alt="image-20210125205332729" />
<figcaption aria-hidden="true">image-20210125205332729</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125205641.png"
alt="image-20210125205641584" />
<figcaption aria-hidden="true">image-20210125205641584</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125210209.png"
alt="image-20210125210004430" />
<figcaption aria-hidden="true">image-20210125210004430</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125210413.png"
alt="image-20210125210413532" />
<figcaption aria-hidden="true">image-20210125210413532</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125211217.png"
alt="image-20210125210611015" />
<figcaption aria-hidden="true">image-20210125210611015</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125211206.png"
alt="image-20210125211206046" />
<figcaption aria-hidden="true">image-20210125211206046</figcaption>
</figure>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 5
#define Parent(i) (((i) - 1)&#x2F;2)
#define Lchild(i) (2*(i) + 1)
#define Rchild(i) (Lchild(i) + 1)

&#x2F;&#x2F;堆中结点的数据类型 
typedef int ElemType;

void swap(int *p,int *s)
&#123;
	int t; 
	t &#x3D; *p;
	*p &#x3D; *s;
	*s &#x3D; t;
&#125;

&#x2F;*
	PercDown：实现编号为i的结点下滤操作（最大堆）
	@A：数组名
	@i：下滤结点编号（数组下标）
	@n：数组A的有效元素个数（堆中结点数目）
		数组下标从开始，A[0]，A[1],A[2],...A[n-1]
	返回值:
			无
*&#x2F;
void PercDown(ElemType A[], int i, int n)
&#123;
	int child;&#x2F;&#x2F;指向空穴结点的较大孩子结点
	ElemType tmp;&#x2F;&#x2F;保存空穴结点的元素值
	
	for(tmp &#x3D; A[i]; Lchild(i) &lt; n; i &#x3D; child)
	&#123;
		child &#x3D; Lchild(i);
		if(child + 1 &lt; n &amp;&amp; A[child + 1] &gt; A[child])
		&#123;
			child++;
		&#125;
		
		if(A[child] &gt; tmp)
		&#123;
			A[i] &#x3D; A[child];
		&#125;
		else	&#x2F;&#x2F;tmp&gt;&#x3D; A[child]
		&#123;
			break;
		&#125;
	&#125;
	
	A[i] &#x3D; tmp;
	
&#125;

void heap_sort_v2(ElemType A[], int n)
&#123;
	int i;&#x2F;&#x2F;下滤结点下标
	&#x2F;&#x2F;1. build max heap
	&#x2F;&#x2F;逐个下滤 
	
	&#x2F;&#x2F;建立最大堆
	for(i &#x3D; Parent(n-1); i &gt;&#x3D; 0; i--)
	&#123;
		PercDown( A, i, n);
	&#125; 
	
	&#x2F;&#x2F;2.Delete_MAX
	for(i &#x3D; n-1; i &gt; 0; i--)
	&#123;
		swap(&amp;A[0], &amp;A[i]);
		PercDown( A, 0, i);
	&#125;
	
&#125;

int main()
&#123;
	int i;
    int a[N];
    for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	heap_sort_v2(a, N);
	
	for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	printf(&quot;%d\t&quot;,a[i]);
	&#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆排序的性能分析">3.堆排序的性能分析</h2>
<h3 id="时间复杂度-6">(1)时间复杂度</h3>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213026.png"
alt="image-20210125213026686" />
<figcaption aria-hidden="true">image-20210125213026686</figcaption>
</figure>
<h3 id="空间复杂度-6">(2)空间复杂度</h3>
<p>​ O（1）</p>
<h2 id="堆排序稳定性分析">4.堆排序稳定性分析</h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213250.png"
alt="image-20210125213250651" />
<figcaption aria-hidden="true">image-20210125213250651</figcaption>
</figure>
<h2 id="总结-6">5.总结</h2>
<h3 id="适用场景-5">适用场景</h3>
<p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213328.png"
alt="image-20210125213328663" />
<figcaption aria-hidden="true">image-20210125213328663</figcaption>
</figure>
<h1 id="九.归并排序">九.归并排序</h1>
<h2 id="什么是归并排序">1.什么是归并排序</h2>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide
and
Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210126193204.gif"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210126194241.png"
alt="image-20210126194241579" />
<figcaption aria-hidden="true">image-20210126194241579</figcaption>
</figure>
<h2 id="算法思路-6">2.算法思路</h2>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210126194456.png"
alt="image-20210126194456817" />
<figcaption aria-hidden="true">image-20210126194456817</figcaption>
</figure>
<figure>
<img
src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-5066-20161218163120151-452283750.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p>
<p><strong>合并相邻有序子序列</strong></p>
<p>再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127185921.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127185935.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="代码实现-7">代码实现</h3>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define N 5

typedef int ElemType;

&#x2F;*
	Merge：对两个有序表
		S[Lpos].. S[Rpos-1]
		S[Rpos].. S[RightEnd]
		进行归并操作
		@s：数组
		@Lpos：左边有序表开始元素的下标
		@Rpos：右边有序表开始元素的下标
		@RightEnd：右边有序表最后元素的下标
		@Aux：辅助数组
		返回值：
				无
*&#x2F;

void Merge(ElemType s[], int Lpos, int Rpos, int RightEnd,
			ElemType Aux[])
&#123;
	int LeftEnd &#x3D; Rpos - 1;
	int Num &#x3D; RightEnd - Lpos + 1;&#x2F;&#x2F;要归并的总共的元素个数 
	
	int C_pos &#x3D; Lpos;&#x2F;&#x2F;辅助数组的起始下标
	
	while(Lpos &lt;&#x3D; LeftEnd &amp;&amp; Rpos &lt;&#x3D; RightEnd)
	&#123;
		if(s[Lpos] &lt;&#x3D; s[Rpos])
		&#123;
			Aux[C_pos++] &#x3D; s[Lpos++];
		&#125; 
		else
		&#123;
			Aux[C_pos++] &#x3D; s[Rpos++];
		&#125;
	&#125;
	
	&#x2F;&#x2F;右边那个序列先到末尾
	while(Lpos &lt;&#x3D; LeftEnd)
	&#123;
		Aux[C_pos++] &#x3D; s[Lpos++];
	&#125; 
	
	while(Rpos &lt;&#x3D; RightEnd)
	&#123;
		Aux[C_pos++] &#x3D; s[Rpos++];
	&#125; 
	
	int i&#x3D;0;&#x2F;&#x2F;拷贝次数
	
	for(i &#x3D; 0; i &lt; Num; RightEnd--,i++)
	&#123;
		s[RightEnd] &#x3D; Aux[RightEnd];
	&#125; 
&#125;



&#x2F;*
	MSort：对数列进行归并排序
	@s：要进行归并排序的数组
	@Left：归并排序最左边元素的下标
	@Right：归并排序最右边元素的下标
	@Aux：辅助数组
	返回值：
			无。
*&#x2F;
void Msort(ElemType s[], int Left, int Right, ElemType Aux[])
&#123;
	if(Left &lt; Right)
	&#123;
		&#x2F;&#x2F;1.分割
		int mid &#x3D; (Left + Right) &#x2F; 2;
		&#x2F;&#x2F;A: Left ... mid
		&#x2F;&#x2F;B: mid+1 ... Rught
		
		
		&#x2F;&#x2F;2.对A进行归并排序
		Msort(s, Left, mid, Aux);
		
		&#x2F;&#x2F;3.对B进行归并排序
		Msort(s, mid+1, Right, Aux);
		
		&#x2F;&#x2F;4.对A和B进行归并操作
		Merge(s, Left, mid+1, Right, Aux); 
	&#125;
&#125;

void Merge_Sort(ElemType A[], int n)
&#123;
	ElemType *Aux &#x3D; malloc(sizeof(ElemType) *n);
	
	Msort(A, 0, n-1, Aux);
	
	free(Aux);
&#125;

int main()
&#123;
	int i;
    int a[N];
    for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	scanf(&quot;%d&quot;,&amp;a[i]);
	&#125;
	Merge_Sort(a, N);
	
	for(i &#x3D; 0; i &lt; N; i++)
    &#123;
    	printf(&quot;%d\t&quot;,a[i]);
	&#125;
	printf(&quot;\n&quot;); 
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="归并排序的性能分析">3.归并排序的性能分析</h2>
<h3 id="时间复杂度-7">(1)时间复杂度</h3>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127181648.png"
alt="image-20210127181641062" />
<figcaption aria-hidden="true">image-20210127181641062</figcaption>
</figure>
<h3 id="空间复杂度-7">(2)空间复杂度</h3>
<p>​ O（n）</p>
<h2 id="归并排序稳定性分析">4.归并排序稳定性分析</h2>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127181751.png"
alt="image-20210127181751056" />
<figcaption aria-hidden="true">image-20210127181751056</figcaption>
</figure>
<h2 id="总结-7">5.总结</h2>
<h3 id="适用场景-6">适用场景</h3>
<p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127181853.png"
alt="image-20210127181852807" />
<figcaption aria-hidden="true">image-20210127181852807</figcaption>
</figure>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay-qrcode.jpg"><img loading="lazy" src="/images/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/qqpay-qrcode.jpg"><img loading="lazy" src="/images/qqpay-qrcode.jpg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay-qrcode.jpg"><img loading="lazy" src="/images/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Explorer</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://ccsu.top/posts/c56898db/" title="排序（龙哥）">http://ccsu.top/posts/c56898db/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/97a88a5c/" rel="prev" title="树莓派4B引脚定义及运行实例"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">树莓派4B引脚定义及运行实例</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/b2fc5f68/" rel="next" title="ESP8266使用方法"><span class="post-nav-text">ESP8266使用方法</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div id="waline"></div><script src="/js/comments/waline.js" type="module" defer></script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">皖ICP备20002891号-2</a></div><div class="copyright"><span>&copy; 2016 – 2024 </span><span class="with-love" id="animate" title="赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Explorer</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.0.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.8</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-02-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} Days ${passHour} Hours ${passMinute} Minutes ${passSecond} Seconds`;
}
blog_live_time();
</script></div><div id="busuanzi"><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":350,"hOffset":null,"vOffset":null},"mobile":{"show":true},"log":false});</script></body></html>