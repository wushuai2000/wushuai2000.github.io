<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="Explorer"><meta name="copyright" content="Explorer"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>机组-第二章 数据的表示和运算 | explorerの博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" type="image/png" href="/./favicon.ico"><link rel="mask-icon" href="/./favicon.ico" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"ccsu.top","root":"/","title":["Wu","Shuai","の","Blog"],"version":"1.8.8","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"waline":{"config":{"enable":true,"serverURL":"https://blog-api-seven-vert.vercel.app/","comment":false,"visitor":false,"emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"2506812280@qq.com"},"requiredMeta":["nick"],"el":"#waline","lang":"en","path":"/posts/189f252b/"},"cdn":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","dark":"html.dark"},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="explorerの博客" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-BMBD00SVV4"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BMBD00SVV4');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="1.数制与编码 1.1.进位计数法1.1.1.进位计数法进位计数法：进位计数法是一种计数的方法。常用的有十进制、二进制、八进制和十六进制等。日常生活中最常使用的就是十进制，其余则主要是计算机在运算是时使用。在进行计数法中，每个数所用到的不同数码的个数称为基数。  例如：十进制的基数为 0~9，每个数位计满 10 后就会向高位进位。  每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数">
<meta property="og:type" content="article">
<meta property="og:title" content="机组-第二章 数据的表示和运算">
<meta property="og:url" content="http://ccsu.top/posts/189f252b/index.html">
<meta property="og:site_name" content="explorerの博客">
<meta property="og:description" content="1.数制与编码 1.1.进位计数法1.1.1.进位计数法进位计数法：进位计数法是一种计数的方法。常用的有十进制、二进制、八进制和十六进制等。日常生活中最常使用的就是十进制，其余则主要是计算机在运算是时使用。在进行计数法中，每个数所用到的不同数码的个数称为基数。  例如：十进制的基数为 0~9，每个数位计满 10 后就会向高位进位。  每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912268.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912461.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912380.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912137.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912688.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913061.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913503.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913478.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913271.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913535.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913538.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913568.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913783.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913110.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913671.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913974.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913053.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913125.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913854.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913736.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913069.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914467.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914964.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922275.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914546.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914234.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914548.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914829.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914087.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914877.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914071.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914648.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914193.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914754.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914575.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914040.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915178.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915296.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915632.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915807.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915862.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915796.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915363.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915457.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915299.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915348.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915986.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915616.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915952.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922316.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915361.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915631.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915177.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915336.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915213.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915005.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915877.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916535.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916032.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916244.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916466.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916740.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916389.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916563.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916756.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916619.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916443.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916294.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916482.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916944.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917673.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917825.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917852.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922277.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917448.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917468.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917366.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917274.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917705.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917782.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917943.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917345.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917641.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918673.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918762.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918072.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918039.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922278.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918651.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918767.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918572.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918982.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918842.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918152.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918274.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918789.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918065.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918334.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918042.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919520.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919343.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919010.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919493.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919072.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919393.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919526.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919777.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919658.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919947.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922279.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922280.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922281.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922282.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922283.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922285.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922286.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922287.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922288.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922289.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919060.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919061.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919062.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919063.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919064.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919065.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919066.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919067.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920163.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920765.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920285.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920412.png">
<meta property="article:published_time" content="2023-04-03T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-03T16:00:00.000Z">
<meta property="article:author" content="Explorer">
<meta property="article:tag" content="计算机组成原理">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912268.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Explorer"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Explorer"><span class="site-author-status" title="努力学习">😄</span></a><div class="site-author-name"><a href="/about/">Explorer</a></div><span class="site-name">explorerの博客</span><sub class="site-subtitle"></sub><div class="site-desciption">前路漫漫，当克己，当慎独!</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">80</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">64</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wushuai2000" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=549838440" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/huan-ji-91-3/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/345844264" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2506812280@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%95%B0%E5%88%B6%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">1.数制与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.进位计数法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1.进位计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%87%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2.计算机采用二进制编码的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.2.其他进制数转换为十进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2.十进制数转化为其他进制数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%81%E5%85%AB%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3.二进制、八进制和十六进制的相互转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%9C%9F%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E6%95%B0%EF%BC%88%E8%80%83%E7%BA%B2%E5%B7%B2%E5%88%A0%E9%99%A4%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.真值和机器数（考纲已删除）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-BCD%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">2.BCD码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF-BCD-%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.什么是 BCD 码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%B8%B8%E7%94%A8%E7%9A%84-BCD-%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.常用的 BCD 码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-8421-%E7%A0%81%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1.1.8421 码（最常用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%BD%99-3-%E7%A0%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.1.2.余 3 码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-2421-%E7%A0%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.1.3.2421 码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">3.无符号数的表示和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%9C%BA%E5%99%A8%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.机器数的定点表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.无符号整数的概念及其在计算机中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.加法运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.减法运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">4.</span> <span class="toc-text">4.有符号数的表示和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.有符号数的概念及其在计算机中应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.2.</span> <span class="toc-text">4.2.有符号数的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%8E%9F%E7%A0%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1.原码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-1-%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E7%9A%84%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">4.2.1.1.定点整数的原码表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-2-%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0%E7%9A%84%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">4.2.1.2.定点小数的原码表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%8F%8D%E7%A0%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2.反码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%A1%A5%E7%A0%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3.补码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E7%A7%BB%E7%A0%81"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4.移码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">4.3.原码、反码、补码总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1.原码、补码运算技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E7%A7%BB%E7%A0%81%E7%89%B9%E6%80%A7%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2.原码、反码、补码、移码特性（整数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0%E5%92%8C%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3.定点小数和定点整数对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%BC%95%E5%85%A5%E8%A1%A5%E7%A0%81%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">4.4.</span> <span class="toc-text">4.4.引入补码的目的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1.直接使用原码进行运算的弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%87%8F%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2.如何使用加法实现减法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.</span> <span class="toc-text">4.5.有符号数补码运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1.定点整数的补码运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-1-%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">4.5.1.1.加法运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-2-%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">4.5.1.2.减法运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0%E7%9A%84%E8%A1%A5%E7%A0%81%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2.定点小数的补码运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-1-%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">4.5.2.1.加法运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-2-%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">4.5.2.2.减法运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%BA%A2%E5%87%BA%E5%88%A4%E5%88%AB%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">4.6.溢出判别方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E9%87%87%E7%94%A8%E4%B8%80%E4%BD%8D%E7%AC%A6%E5%8F%B7%E4%BD%8D%E4%BE%9D%E6%8D%AE%E6%BA%A2%E5%87%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%A4%E6%96%AD"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1.采用一位符号位依据溢出表达式判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E9%87%87%E7%94%A8%E4%B8%80%E4%BD%8D%E7%AC%A6%E5%8F%B7%E4%BD%8D%E4%BE%9D%E6%8D%AE%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%9A%84%E8%BF%9B%E4%BD%8D%E6%83%85%E5%86%B5%E5%88%A4%E6%96%AD"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2.采用一位符号位依据数据位的进位情况判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E9%87%87%E7%94%A8%E5%8F%8C%E7%AC%A6%E5%8F%B7%E4%BD%8D%E5%88%A4%E6%96%AD%EF%BC%88%E5%B8%B8%E8%80%83%EF%BC%89"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.6.3.采用双符号位判断（常考）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95"><span class="toc-number">4.7.</span> <span class="toc-text">4.7.符号扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%80%83%E7%BA%B2%E5%88%A0%E9%99%A4%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">5.字符与字符串在计算机中的表示详解（考纲删除了解即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8E-ASCII-%E7%BC%96%E7%A0%81"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.字符编码与 ASCII 编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%B1%89%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E7%BC%96%E7%A0%81"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.汉字的表示和编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E6%B1%89%E5%AD%97%E7%9A%84%E8%BE%93%E5%85%A5%E7%BC%96%E7%A0%81"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1.汉字的输入编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2.汉字内码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-1-%E5%9B%BD%E9%99%85%E7%A0%81%EF%BC%88%E4%BA%A4%E6%8D%A2%E7%A0%81%EF%BC%89"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">5.2.2.1.国际码（交换码）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-2-%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">5.2.2.2.汉字内码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-3-%E6%B1%89%E5%AD%97%E8%BE%93%E5%87%BA%E7%A0%81%EF%BC%88%E5%AD%97%E6%A8%A1%E7%A0%81%EF%BC%89"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">5.2.2.3.汉字输出码（字模码）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-4%E6%80%BB%E7%BB%93"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">5.2.2.4总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E8%80%83%E7%BA%B2%E5%B7%B2%E5%88%A0%E9%99%A4%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">5.3.字符串（考纲已删除）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%88%E8%80%83%E7%BA%B2%E5%88%A0%E9%99%A4%E4%BD%86%E8%AE%A1%E7%BD%91%E4%BC%9A%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">6.校验码（考纲删除但计网会用建议学习）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">6.1.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1.校验码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E7%A0%81%E5%AD%97%E5%92%8C%E7%A0%81%E8%B7%9D"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2.码字和码距</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-2-%E5%B8%B8%E8%A7%81%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">6.2.常见校验码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-1-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">7.1.</span> <span class="toc-text">6.2.1.奇偶校验码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E7%A0%81"><span class="toc-number">7.2.</span> <span class="toc-text">6.2.海明校验码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E7%BA%A0%E9%94%99%E7%90%86%E8%AE%BA"><span class="toc-number">7.2.1.</span> <span class="toc-text">6.2.1.纠错理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E6%B1%82%E8%A7%A3%E6%B5%B7%E6%98%8E%E7%A0%81"><span class="toc-number">7.2.2.</span> <span class="toc-text">6.2.2.求解海明码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-4-%E8%A1%A5%E5%85%85-%E5%85%A8%E6%A0%A1%E9%AA%8C%E4%BD%8D"><span class="toc-number">7.2.3.</span> <span class="toc-text">6.2.2.4.补充 - 全校验位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81%EF%BC%88CRC-%E7%A0%81%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">6.3.循环冗余校验码（CRC 码）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%E5%92%8C%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%92%8C%E5%85%A8%E5%8A%A0%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">7.算数逻辑单元和电路基本知识以及基本逻辑运算和全加器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83-ALU"><span class="toc-number">8.1.</span> <span class="toc-text">7.1.算数逻辑单元 ALU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">8.2.</span> <span class="toc-text">7.2.最基本的逻辑运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E4%B8%8E%E3%80%81%E6%88%96%E3%80%81%E9%9D%9E"><span class="toc-number">8.2.1.</span> <span class="toc-text">7.2.1.与、或、非</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E4%B8%8E%E9%9D%9E%E3%80%81%E6%88%96%E9%9D%9E%E3%80%81%E5%BC%82%E6%88%96%E3%80%81%E5%90%8C%E6%88%96"><span class="toc-number">8.2.2.</span> <span class="toc-text">7.2.2.与非、或非、异或、同或</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">7.3.一位全加器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">8.4.</span> <span class="toc-text">7.4.串行加法器和并行加法器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">8.4.1.</span> <span class="toc-text">7.4.1.串行加法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8%EF%BC%88%E4%B8%B2%E8%A1%8C%E8%BF%9B%E4%BD%8D%EF%BC%89"><span class="toc-number">8.4.2.</span> <span class="toc-text">7.4.2.并行加法器（串行进位）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3-%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8%EF%BC%88%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%EF%BC%89"><span class="toc-number">8.4.3.</span> <span class="toc-text">7.4.3.并行加法器（并行进位）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E5%92%8C%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">9.</span> <span class="toc-text">8.补码加减运算器和标志位的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">9.1.</span> <span class="toc-text">8.1.补码加减运算器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E8%A1%A5%E7%A0%81%E5%8A%A0-x2F-%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99%E5%9B%9E%E9%A1%BE%EF%BC%88%E5%8D%B3%E6%89%8B%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">9.1.1.</span> <span class="toc-text">8.1.1.补码加 &#x2F; 减法运算规则回顾（即手算方法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">8.2.补码加减运算器原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E6%99%AE%E9%80%9A%E5%8A%A0%E6%B3%95%E5%99%A8%E5%9B%9E%E9%A1%BE"><span class="toc-number">9.2.1.</span> <span class="toc-text">8.2.1.普通加法器回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">9.2.2.</span> <span class="toc-text">8.2.2.补码加减运算器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-1-%E5%8A%A0%E6%B3%95%E5%8A%9F%E8%83%BD"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">8.2.2.1.加法功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-2-%E5%87%8F%E6%B3%95%E5%8A%9F%E8%83%BD"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">8.2.2.2.减法功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">9.3.</span> <span class="toc-text">8.3.标志位的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-OF-%E7%A1%AC%E4%BB%B6%E4%BA%A7%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.1.</span> <span class="toc-text">8.3.1.OF 硬件产生方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-SF-%E7%A1%AC%E4%BB%B6%E4%BA%A7%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.2.</span> <span class="toc-text">8.3.2.SF 硬件产生方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-ZF-%E7%A1%AC%E4%BB%B6%E4%BA%A7%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.3.</span> <span class="toc-text">8.3.3. ZF 硬件产生方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-CF-%E7%A1%AC%E4%BB%B6%E4%BA%A7%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.4.</span> <span class="toc-text">8.3.4. CF 硬件产生方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-5-%E6%80%BB%E7%BB%93"><span class="toc-number">9.3.5.</span> <span class="toc-text">8.4.5.总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">10.</span> <span class="toc-text">9.定点数的移位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D"><span class="toc-number">10.1.</span> <span class="toc-text">9.1.算数移位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E5%8E%9F%E7%A0%81%E7%9A%84%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D"><span class="toc-number">10.1.1.</span> <span class="toc-text">9.1.1.原码的算数移位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E5%8F%8D%E7%A0%81%E7%9A%84%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">10.1.2.</span> <span class="toc-text">9.1.2.反码的算术移位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-3-%E8%A1%A5%E7%A0%81%E7%9A%84%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D"><span class="toc-number">10.1.3.</span> <span class="toc-text">9.1.3.补码的算数移位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-4-%E6%80%BB%E7%BB%93"><span class="toc-number">10.1.4.</span> <span class="toc-text">9.1.4.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D"><span class="toc-number">10.2.</span> <span class="toc-text">9.2.逻辑移位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D"><span class="toc-number">10.3.</span> <span class="toc-text">9.3.循环移位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%EF%BC%88%E5%8E%9F%E7%A0%81-x2F-%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">10.定点数乘法运算（原码&#x2F;补码一位乘法）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">11.1.</span> <span class="toc-text">10.1.乘法运算基本思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">10.2.原码一位乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.2.1.</span> <span class="toc-text">10.2.1.实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E6%89%8B%E7%AE%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">11.2.2.</span> <span class="toc-text">10.2.2.手算模拟</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%EF%BC%88-Booth%E7%AE%97%E6%B3%95%EF%BC%8C%E8%80%83%E5%AF%9F%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">11.补码一位乘法（ Booth算法，考察重点）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%AE%9A%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%EF%BC%88%E5%8E%9F%E7%A0%81-x2F-%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">12.定点数除法运算（原码&#x2F;补码一位除法）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">13.1.</span> <span class="toc-text">12.1.除法运算基本思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95-%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">12.2.原码一位除法(恢复余数法)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">13.2.1.</span> <span class="toc-text">12.2.1.实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2-%E6%89%8B%E7%AE%97%E6%A8%A1%E6%8B%9F"><span class="toc-number">13.2.2.</span> <span class="toc-text">12.2.2.手算模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95%EF%BC%9A%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B3%95%EF%BC%88%E4%B8%8D%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E6%B3%95%EF%BC%89"><span class="toc-number">13.3.</span> <span class="toc-text">12.3.原码一位除法：加减交替法（不恢复余数法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E9%99%A4%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">12.4.补码一位除法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E6%80%BB%E7%BB%93"><span class="toc-number">13.5.</span> <span class="toc-text">12.5.总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E8%AF%A6%E8%A7%A3C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.</span> <span class="toc-text">13.详解C语言中的强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-number">14.1.</span> <span class="toc-text">13.1.无符号数和有符号数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E9%95%BF%E6%95%B4%E6%95%B0%E5%8F%98%E4%B8%BA%E7%9F%AD%E6%95%B4%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">13.2.长整数变为短整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E7%9F%AD%E6%95%B4%E6%95%B0%E5%8F%98%E4%B8%BA%E9%95%BF%E6%95%B4%E6%95%B0"><span class="toc-number">14.3.</span> <span class="toc-text">13.3.短整数变为长整数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-number">15.</span> <span class="toc-text">14.数据的存储和排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">14.1.大小端模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E5%86%85%E5%AD%98%EF%BC%88%E8%BE%B9%E7%95%8C%EF%BC%89%E5%AF%B9%E9%BD%90"><span class="toc-number">15.2.</span> <span class="toc-text">14.2.内存（边界）对齐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">16.</span> <span class="toc-text">15.浮点数的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">16.1.</span> <span class="toc-text">15.1.浮点数的表示格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E7%9A%84%E8%A7%84%E6%A0%BC%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">15.2.浮点数尾数的规格化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-1-%E5%B7%A6%E8%A7%84%E5%92%8C%E5%8F%B3%E8%A7%84"><span class="toc-number">17.1.</span> <span class="toc-text">15.2.1.左规和右规</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-2-%E8%A7%84%E6%A0%BC%E5%8C%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">17.2.</span> <span class="toc-text">15.2.2.规格化浮点数的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4%EF%BC%88408-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2%E5%B7%B2%E5%88%A0%E9%99%A4%EF%BC%89"><span class="toc-number">17.3.</span> <span class="toc-text">15.3.浮点数表示范围（408 考试大纲已删除）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-IEEE754%E6%A0%87%E5%87%86"><span class="toc-number">18.</span> <span class="toc-text">16.IEEE754标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1%E7%A7%BB%E7%A0%81"><span class="toc-number">18.1.</span> <span class="toc-text">16.1移码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-%E7%A7%BB%E7%A0%81%E5%9B%9E%E9%A1%BE"><span class="toc-number">18.1.1.</span> <span class="toc-text">16.1.1.移码回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-%E5%81%8F%E7%BD%AE%E5%80%BC"><span class="toc-number">18.1.2.</span> <span class="toc-text">16.1.2.偏置值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-IEEE-754-%E6%A0%87%E5%87%86"><span class="toc-number">18.2.</span> <span class="toc-text">16.2.IEEE 754 标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-1-IEEE-754-%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="toc-number">18.2.1.</span> <span class="toc-text">16.2.1.IEEE 754 标准格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-2-%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">18.2.2.</span> <span class="toc-text">16.2.2.转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-3-%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4"><span class="toc-number">18.2.3.</span> <span class="toc-text">16.2.3.表示范围</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">19.</span> <span class="toc-text">17.浮点数加减运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E4%BB%A5%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8B%E7%9A%84%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E4%B8%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">19.1.</span> <span class="toc-text">17.1.以十进制下的科学计数法的加减运算为例说明浮点数加减运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%EF%BC%88%E4%B8%8D%E8%88%8D%E5%85%A5%EF%BC%89"><span class="toc-number">19.2.</span> <span class="toc-text">17.2.浮点数的加减运算（不舍入）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%EF%BC%88%E8%88%8D%E5%85%A5%EF%BC%89"><span class="toc-number">19.3.</span> <span class="toc-text">17.3.浮点数的加减运算（舍入）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">19.4.</span> <span class="toc-text">17.4.浮点数强制类型转换</span></a></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/57%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/" style="font-size: 12px; color: #999">57步进电机</a> <a href="/tags/AT9SPro/" style="font-size: 12px; color: #999">AT9SPro</a> <a href="/tags/Anaconda/" style="font-size: 12px; color: #999">Anaconda</a> <a href="/tags/Arduino/" style="font-size: 24px; color: #3383cd">Arduino</a> <a href="/tags/CUDA/" style="font-size: 18px; color: #668eb3">CUDA</a> <a href="/tags/CUDNN/" style="font-size: 12px; color: #999">CUDNN</a> <a href="/tags/Conda/" style="font-size: 12px; color: #999">Conda</a> <a href="/tags/DHT11/" style="font-size: 12px; color: #999">DHT11</a> <a href="/tags/Docker/" style="font-size: 18px; color: #668eb3">Docker</a> <a href="/tags/ESP8266/" style="font-size: 12px; color: #999">ESP8266</a> <a href="/tags/GPIO/" style="font-size: 30px; color: #0078e7">GPIO</a> <a href="/tags/GPS/" style="font-size: 12px; color: #999">GPS</a> <a href="/tags/GPU/" style="font-size: 24px; color: #3383cd">GPU</a> <a href="/tags/HC-05/" style="font-size: 12px; color: #999">HC-05</a> <a href="/tags/HTML/" style="font-size: 18px; color: #668eb3">HTML</a> <a href="/tags/Hexo/" style="font-size: 18px; color: #668eb3">Hexo</a> <a href="/tags/Hexo%E5%AE%89%E8%A3%85/" style="font-size: 24px; color: #3383cd">Hexo安装</a> <a href="/tags/IAR%E8%BD%AF%E4%BB%B6/" style="font-size: 12px; color: #999">IAR软件</a> <a href="/tags/JavaScript/" style="font-size: 18px; color: #668eb3">JavaScript</a> <a href="/tags/Json/" style="font-size: 12px; color: #999">Json</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#6200ee;"><link itemprop="mainEntityOfPage" href="http://ccsu.top/posts/189f252b/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Explorer"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="explorerの博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">机组-第二章 数据的表示和运算</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">Posted on</span> <time title="Created: 2023-04-04 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-04T00:00:00+08:00">2023-04-04</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">23.9k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">90m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%80%83%E7%A0%94408/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">考研408</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">计算机组成原理</span></a><a class="tag-item" href="/tags/%E8%80%83%E7%A0%94/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">考研</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="1-数制与编码"><a href="#1-数制与编码" class="headerlink" title="1.数制与编码"></a>1.数制与编码</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912268.png" alt="image-20230413140118235" loading="lazy"></p>
<h2 id="1-1-进位计数法"><a href="#1-1-进位计数法" class="headerlink" title="1.1.进位计数法"></a>1.1.进位计数法</h2><h3 id="1-1-1-进位计数法"><a href="#1-1-1-进位计数法" class="headerlink" title="1.1.1.进位计数法"></a>1.1.1.进位计数法</h3><p><strong>进位计数法</strong>：进位计数法是一种计数的方法。常用的有十进制、二进制、八进制和十六进制等。日常生活中最常使用的就是十进制，其余则主要是计算机在运算是时使用。在进行计数法中，每个数所用到的不同数码的个数称为<strong>基数</strong>。</p>
<ul>
<li>例如：十进制的基数为 0~9，每个数位计满 10 后就会向高位进位。</li>
</ul>
<p><strong>每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加</strong>。</p>
<p><strong>例如</strong>：一个<code>r</code>进制数$(K_nK_{n-1}…K_0K_{-1}…K_{-m})$的数值可以表示为<br>具${K_nr^2+K_{n-1}r^{n-1}+…+K_0r^0+K_{-1}r^{-1}+…+K_{-m}r^{-m}&#x3D;\sum_{i&#x3D;n}^{-m} k_ir^i}$，具体来说：</p>
<ul>
<li><p><strong>十进制</strong>：例如 975</p>
<p>$975.36 &#x3D; 9 × 100 + 7 × 10 + 5 × 1 + 3 × 0.1 + 6 × 0.01 $ ，也即 $975 &#x3D; 9 × 1 0 ^2 + 7 × 1 0 ^1 + 5 × 1 0^ 0 + 3 × 1 0 ^{− 1} + 6 × 1 0 ^{− 2} $</p>
</li>
<li><p><strong>二进制</strong>：只有 0 和 1 两种数字符号，“逢 2 进 1”，其任意数位的权为$2^i$ ，<code>i </code>为所在位数。</p>
</li>
<li><p><strong>八进制</strong>：八进制作为二进制的一种书写形式，其基数是 8，有 0~7 共 8 个不同的数字符号，“逢 8 进 1”。由于$ r&#x3D;8&#x3D;2^{3}$。</p>
</li>
<li><p><strong>十六进制</strong>：其基数为 16，“逢 16 进 1”，其中 A、B、C、D、E、F 分别表示 10、11、12、13、14、15. 由于$r&#x3D;16&#x3D;2^{4}$。</p>
</li>
</ul>
<h3 id="1-1-2-计算机采用二进制编码的原因"><a href="#1-1-2-计算机采用二进制编码的原因" class="headerlink" title="1.1.2.计算机采用二进制编码的原因"></a>1.1.2.计算机采用二进制编码的原因</h3><p><strong>原因如下</strong>：</p>
<ul>
<li><strong>二进制只有两种状态</strong>：使用有两个稳定状态的器件就可以表示二进制数的每一位，制造成本较低。比如可以利用高低电平和电荷正负表示 0 和 1。</li>
<li><strong>二进制的 1 和 0 正好与逻辑值真和假相对应</strong>：这为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。</li>
<li><strong>二进制的编码和运算规则很简单</strong>：通过逻辑门电路可以方便地实现算数运算。</li>
</ul>
<h2 id="1-2-进制转换"><a href="#1-2-进制转换" class="headerlink" title="1.2.进制转换"></a>1.2.进制转换</h2><p><strong>进制转换黄金原则（看完下面再看）：一切转换均可借助二进制作为媒介完成</strong>。</p>
<ul>
<li><strong>八进制、十六进制和二进制之间是有位数对应的关系的。</strong></li>
<li><strong>十进制和二进制可以直接通过权值累加得到。</strong></li>
</ul>
<h3 id="1-2-2-其他进制数转换为十进制"><a href="#1-2-2-其他进制数转换为十进制" class="headerlink" title="1.2.2.其他进制数转换为十进制"></a>1.2.2.其他进制数转换为十进制</h3><p><strong>其他进制数转换为十进制：其他进制数转化为十进制较为简单，只需代入下面的公式即可<br>${K_nr^2+K_{n-1}r^{n-1}+…+K_0r^0+K_{-1}r^{-1}+…+K_{-m}r^{-m}&#x3D;\sum_{i&#x3D;n}^{-m} k_ir^i}$</strong></p>
<p><strong>例如</strong>：要把一个二进制数转为十进制数，那么上式中的 $r$ 就设为 2， 然后用二进制数的每一位乘以 $ r^{n} $，这个 n 表示的是位权（小数点左侧从右向左由 0 递增，小数点右侧从左至右由 - 1 递减），再举几个例子：</p>
<ul>
<li><p><strong>二进制数 10010010.100 转化为十进制数：</strong> $10010010.110 &#x3D; 1×2^{7}+1×2^{4}+1×2^{1}+1×2^{-1}+1×2^{-2}&#x3D;146.75 $</p>
</li>
<li><p>**八进制数 251.5 转化为十进制数：$251.5 &#x3D;2×8^{2}+5×8^{1}+1×8^{0}+5×8^{-1} $。</p>
</li>
<li><p><strong>十六进制数 AE86.1 转化为十进制数：</strong> $AE86.1&#x3D;10×16^{3}+14×16^{2}+8×16^{1}+6×16^{0}+1×16^{-1}&#x3D;44678.0625 $</p>
</li>
</ul>
<h3 id="1-2-2-十进制数转化为其他进制数"><a href="#1-2-2-十进制数转化为其他进制数" class="headerlink" title="1.2.2.十进制数转化为其他进制数"></a>1.2.2.十进制数转化为其他进制数</h3><p><strong>十进制数转化为其他进制数：需要把整个过程分为求整数部分和求小数两部分</strong>。</p>
<ul>
<li><strong>求整数：第 i 次除以基数 b 所得到的的余数即为 $A_i$，然后继续利用所得商运算，直到所得商为 0，其中$i\in (1,n) $，最后结果反着写。</strong></li>
<li><strong>求小数： 第 i次乘以基数 b 所得的整数部分即为$A_{-i}$​，其中 $i\in (1,n)$，需要注意每次乘法之后要把个位处置 0。</strong></li>
</ul>
<p><strong>例如</strong>：7562.03125 转化为 16 进制数。</p>
<p>首先，列一个表格计算整数部分：</p>
<ul>
<li>整数部分为 1D8A。</li>
</ul>
<table><thead><tr><th>除以 16</th><th>所得商</th><th>所得余数</th><th>对应符号</th></tr></thead><tbody><tr><td>7562/16</td><td>472</td><td>10</td><td>A</td></tr><tr><td>472/16</td><td>29</td><td>8</td><td>8</td></tr><tr><td>29/16</td><td>1</td><td>13</td><td>D</td></tr><tr><td>1/16</td><td>0</td><td>1</td><td>1</td></tr></tbody></table>

<p>然后计算小数部分：</p>
<ul>
<li><strong>注意</strong>：再进行下一次乘积运算时，要取上一次乘积的小数部分作为新的乘数进行运算，比如第二次运算乘积为 8，下一次运算时直接要取小数部分进行运算。</li>
<li>小数部分为 08。</li>
</ul>
<table><thead><tr><th>乘以 16</th><th>所得乘积</th><th>取乘积整数位</th><th>对应符号</th></tr></thead><tbody><tr><td>0.03125×16</td><td>0.5</td><td>0</td><td>0</td></tr><tr><td>0.5×16</td><td>8.0</td><td>8</td><td>8</td></tr><tr><td>0×16</td><td>0.0</td><td>0</td><td>0</td></tr></tbody></table>

<p><strong>到这里转换完成，答案为 1D8A.08</strong>。</p>
<p>上述方法是比较通用的方法。在实际情况中，尤其涉及编程、网络时，会频繁涉及到 10 进制数转化为 2 进制数的问题，<strong>所以这里还可以使用拼凑法，首先你需要牢记常用 $ 2^{n} $ 的值</strong>。</p>
<table><thead><tr><th>2 10 2^{10}</th><th>2 9 2^{9}</th><th>2 8 2^{8} </th><th>2 7 2^{7}</th><th>2 6 2^{6}</th><th>2 5 2^{5} </th><th>2 4 2^{4}</th><th>2 3 2^{3}</th><th>2 2 2^{2} </th><th>2 1 2^{1} </th><th>2 0 2^{0} </th><th>2 − 1 2^{-1} </th><th>2 − 2 2^{-2} </th><th>2 − 3 2^{-3} </th></tr></thead><tbody><tr><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr></tbody></table>

<p>转换时，只需要目测估值即可，比如 260.75，260&#x3D;256+4，同时 0.75 等于 0.5+0.25，相应位置填 1 即可。</p>
<table><thead><tr><th>2 10 2^{10}</th><th>2 9 2^{9}</th><th>2 8 2^{8} </th><th>2 7 2^{7}</th><th>2 6 2^{6}</th><th>2 5 2^{5} </th><th>2 4 2^{4}</th><th>2 3 2^{3}</th><th>2 2 2^{2} </th><th>2 1 2^{1} </th><th>2 0 2^{0} </th><th>2 − 1 2^{-1} </th><th>2 − 2 2^{-2} </th><th>2 − 3 2^{-3} </th></tr></thead><tbody><tr><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table>

<p>所以  $(260.75)<em>{10}\rightarrow (100000100.11)</em>{2} $</p>
<h3 id="1-2-3-二进制、八进制和十六进制的相互转换"><a href="#1-2-3-二进制、八进制和十六进制的相互转换" class="headerlink" title="1.2.3.二进制、八进制和十六进制的相互转换"></a>1.2.3.二进制、八进制和十六进制的相互转换</h3><p><strong>二进制、八进制和十六进制的相互转换：这几个进制之间是具有对应关系的，所以可以快速转换。</strong></p>
<ul>
<li><strong>八进制</strong>：八进制作为二进制的一种书写形式，其基数是 8，有 0~7 共 8 个不同的数字符号，“逢 8 进 1”。由于$ r&#x3D;8&#x3D;2^{3} $，<strong>所以 3 位二进制数码与 1 位八进制数码相对应</strong>。</li>
<li><strong>十六进制</strong>：其基数为 16，“逢 16 进 1”，其中 A、B、C、D、E、F 分别表示 10、11、12、13、14、15. 由于 $r&#x3D;16&#x3D;2^{4}$，<strong>所以 4 位二进制数码与 1 位十六进制数码相对应。</strong></li>
</ul>
<p><strong>因此转换时，以小数点作为起始点，向左向右分别进行划分，如果是八进制就是三位，如果是十六进制就是 4 位。</strong></p>
<ul>
<li>如果位数不足要把 “0” 补上，防止误判。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912461.png" loading="lazy"></p>
<p>再比如：</p>
<ul>
<li>$ (251.5)<em>{8}\rightarrow (010 101 001 . 101)</em>{2} $</li>
<li>$(AE86.1)<em>{16}\rightarrow (1010111010000110.0001 )</em>{2} $</li>
</ul>
<h2 id="1-3-真值和机器数（考纲已删除）"><a href="#1-3-真值和机器数（考纲已删除）" class="headerlink" title="1.3.真值和机器数（考纲已删除）"></a>1.3.真值和机器数（考纲已删除）</h2><p><strong>真值：日常生活中，对于正数和负数我们可以使用正号 (通常省略) 和负号来表示，如 15 和 - 8。</strong>这种带 “+” 和“-”符号的数称为真值，真值是机器数所代表的实际值。</p>
<p><strong>机器数：在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。例如后面需要学习的原码，补码和反码。这几种表示法都将数据的符号数字化，通常用 “0” 表示正，用 “1” 表示负</strong>。</p>
<h1 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2.BCD码"></a>2.BCD码</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912380.png" alt="image-20230413140143728" loading="lazy"></p>
<h2 id="2-1-什么是-BCD-码"><a href="#2-1-什么是-BCD-码" class="headerlink" title="2.1.什么是 BCD 码"></a>2.1.什么是 BCD 码</h2><p><strong>BCD 码 (Binary-Coded Decimal)：</strong>是指二进制编码的十进制数。我们可以用 4 位二进制数来表示一位十进制数中的 0~9，这种编码方法使得二进制数和十进制数之间的转换得以快速进行。4 位二进制数最多有 16 种组合，足以表示 0 到 9 这十个数，所以<strong>有 6 种状态为冗余状态</strong>。</p>
<h2 id="2-2-常用的-BCD-码"><a href="#2-2-常用的-BCD-码" class="headerlink" title="2.2.常用的 BCD 码"></a>2.2.常用的 BCD 码</h2><h3 id="2-1-1-8421-码（最常用）"><a href="#2-1-1-8421-码（最常用）" class="headerlink" title="2.1.1.8421 码（最常用）"></a>2.1.1.8421 码（最常用）</h3><p><strong>A：8421 码表示</strong></p>
<p><strong>8421 码 (Binary-Coded Decimal)：它是一种有权码，设其每一位的数值为$b1,b2,b3,b4 $，则权值从高到低依次为 8 , 4 , 2 , 1 ，它表示的十进制数为 $D&#x3D;8b_{3}+4b_{2}+2b_{1}+1b_{0}$​</strong>。</p>
<ul>
<li>例如 985 的 8421 码为<code>1001</code> <code>1000</code> <code>0101</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912137.png" loading="lazy"></p>
<p><strong>B：8421 码运算规则</strong></p>
<p><strong>8421 码运算规则：</strong></p>
<ul>
<li><strong>如果两个 8421 码相加之和小于等于$(1001)_{2}$不需要修正</strong>。</li>
<li><strong>如果两个 8421 码相加之和大于$ (1001)_{2} $则需要修正</strong>：<strong>修正时需要 + 6</strong>。</li>
</ul>
<p>以 5+8 为例：  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912688.png" loading="lazy"></p>
<h3 id="2-1-2-余-3-码"><a href="#2-1-2-余-3-码" class="headerlink" title="2.1.2.余 3 码"></a>2.1.2.余 3 码</h3><p>余 3 码：余 3 码是一种<strong>无权码</strong>，是在 8421 码的基础上加$(3)<em>{10}$，也即$ (0011)</em>{2}$形成的。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913061.png" loading="lazy"></p>
<h3 id="2-1-3-2421-码"><a href="#2-1-3-2421-码" class="headerlink" title="2.1.3.2421 码"></a>2.1.3.2421 码</h3><p>2421 码：这是一种<strong>有权码</strong>。权值由高到低分别为 2 4 2 1，特点是<strong>大于等于 5 (5<del>9)<strong>的 4 位二进制数中最高位为 1，</strong>小于 5 (0</del>4</strong>)的最高位为 0。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913503.png" loading="lazy"></p>
<h1 id="3-无符号数的表示和运算"><a href="#3-无符号数的表示和运算" class="headerlink" title="3.无符号数的表示和运算"></a>3.无符号数的表示和运算</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913478.png" alt="image-20230413140703670" loading="lazy"></p>
<h2 id="3-1-机器数的定点表示"><a href="#3-1-机器数的定点表示" class="headerlink" title="3.1.机器数的定点表示"></a>3.1.机器数的定点表示</h2><p>根据小数点的位置是否固定，在计算机中有两类数据表示方法：<strong>定点表示和浮点表示</strong>。浮点表示类似于科学计数法，将在第三节介绍。</p>
<p><strong>机器数的定点表示：定点表示就是约定机器数中的小数点位置固定不变，小数点不再使用<code>.</code>表示，而是约定其位置。理论上，小数点位置固定在任何一位都可以，但是在计算机中通常采用两种简单的约定：</strong></p>
<ul>
<li><p>定点整数：将小数点的位置固定在数据的最低位之后。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913271.png" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li><p>定点小数：将小数点的位置固定在数据的最高位之前。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913416.png" alt="在这里插入图片描述" loading="lazy"></p>
</li>
</ul>
<h2 id="3-2-无符号整数的概念及其在计算机中的应用"><a href="#3-2-无符号整数的概念及其在计算机中的应用" class="headerlink" title="3.2.无符号整数的概念及其在计算机中的应用"></a>3.2.无符号整数的概念及其在计算机中的应用</h2><p>**无符号整数（无符号数）：无符号整数是指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值，它就是我们常说的自然数； n 位无符号数其范围为$(0，2^{n}-1)$**。</p>
<p>在 C 语言中，使用关键字<code>unsigned</code>修饰后，该变量即为无符号数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>以下讨论中假设机器字长为 8 位。</li>
</ul>
<p><strong>无符号整数硬件表示：由于无符号整数全部二进制位均为数值位，没有符号位，所以数值位均有位权，也即之前说到过的二进制。注意</strong>：</p>
<ul>
<li><p><strong>最小的无符号整数为全 0</strong>。</p>
</li>
<li><p><strong>最大的无符号整数为全 1。</strong></p>
</li>
<li><p>$n$位无符号数其范围为$(0,2^{n}-1)$<strong>，一旦超出则会溢出。</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913535.png" alt="image-20230413140452529" loading="lazy"></p>
<h2 id="3-3-加法运算"><a href="#3-3-加法运算" class="headerlink" title="3.3.加法运算"></a>3.3.加法运算</h2><p><strong>无符号整数加法运算规则：从低位开始，按位相加，向更高位进位</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913538.png" alt="image-20230413140521323" loading="lazy"></p>
<h2 id="3-4-减法运算"><a href="#3-4-减法运算" class="headerlink" title="3.4.减法运算"></a>3.4.减法运算</h2><p><strong>无符号整数减法运算规则：由于减法电路实现较加法电路困难，所以成本较高，因此会将减法运算转换为加法运算来完成运算。具体来说：</strong></p>
<ul>
<li><strong>被减数不变，减数按位取反、末位 + 1。</strong></li>
<li><strong>从低位开始，按位相加，向更高位进位。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913568.png" alt="image-20230413140618463" loading="lazy"></p>
<ul>
<li>注意高位被丢弃了。</li>
</ul>
<h1 id="4-有符号数的表示和运算"><a href="#4-有符号数的表示和运算" class="headerlink" title="4.有符号数的表示和运算"></a>4.有符号数的表示和运算</h1><h2 id="4-1-有符号数的概念及其在计算机中应用"><a href="#4-1-有符号数的概念及其在计算机中应用" class="headerlink" title="4.1.有符号数的概念及其在计算机中应用"></a>4.1.有符号数的概念及其在计算机中应用</h2><p>有符号数：由于计算机是无法直接识别数的正负的，所以可以将<strong>符号数值化</strong>。规定：对于有符号数，用 <strong>“0” 表示正</strong>，<strong>用 “1” 表示负</strong>，且<strong>通常约定二进制数位的最高位为符号位</strong>。<strong>有符号数</strong>分为<strong>定点整数</strong>和<strong>定点小数</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913802.png" alt="image-20230413143308253" loading="lazy"></p>
<p><strong>定点整数和定点小数可以原码、反码、补码和移码(只有定点整数有)来表示。假设真值为<code>x</code>，则：</strong></p>
<ul>
<li><strong>原码</strong>： $[x]_{原}$</li>
<li><strong>反码</strong>： $[x]_{反}$</li>
<li><strong>补码</strong>： $ [x]_{补} $</li>
<li><strong>移码</strong>： [$[x]_{移}$</li>
</ul>
<h2 id="4-2-有符号数的表示"><a href="#4-2-有符号数的表示" class="headerlink" title="4.2.有符号数的表示"></a>4.2.有符号数的表示</h2><h3 id="4-2-1-原码"><a href="#4-2-1-原码" class="headerlink" title="4.2.1.原码"></a>4.2.1.原码</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913076.png" alt="image-20230413142430182" loading="lazy"></p>
<p><strong>原码：原码是一种比较简单、直观的机器数表示法。用机器数的最高位表示该数的符号，其余的各位表示数的绝对值，其中 0 表示正，1 表示负</strong>。</p>
<p>以 <code>19.75 </code> 为例，假设机器字长为 8 位：</p>
<ul>
<li>整数部分：19</li>
<li>小数部分：0.75</li>
</ul>
<h4 id="4-2-1-1-定点整数的原码表示"><a href="#4-2-1-1-定点整数的原码表示" class="headerlink" title="4.2.1.1.定点整数的原码表示"></a>4.2.1.1.定点整数的原码表示</h4><p>①：表示方法</p>
<p><strong>定点整数的原码表示方法</strong>：按照二进制的位权书写即可，不足位可以用 0 补齐。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913783.png" loading="lazy"></p>
<p>②：原码整数的表示范围</p>
<p><strong>原码整数的表示范围</strong>：假如机器字长为<code>n</code>位，那么原码整数的表示范围为$ -(2^{n-1}-1) \leqslant x \leqslant 2^{n-1}-1 $。</p>
<p>③：真值 0</p>
<ul>
<li>真值 0 有 <code>+ 0 0 0</code> 和 <code>- 0 0 0 </code><strong>两种形式。</strong></li>
</ul>
<h4 id="4-2-1-2-定点小数的原码表示"><a href="#4-2-1-2-定点小数的原码表示" class="headerlink" title="4.2.1.2.定点小数的原码表示"></a>4.2.1.2.定点小数的原码表示</h4><p>①：表示方法</p>
<p><strong>定点小数的原码表示方法</strong>：按照二进制的位权书写即可，不足位可以用 0 补齐。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913110.png" loading="lazy"></p>
<p>②：原码小数的表示范围</p>
<p><strong>原码小数数的表示范围</strong>：假如机器字长为 <code>n </code> 位，那么原码小数数的表示范围为$ -(1-2^{-n+1}) \leqslant x \leqslant 1-2^{-n+1} $。</p>
<p>③：真值 0</p>
<ul>
<li>真值 0 有<code>+ 0 0 0</code>和<code> - 0 0 0</code> <strong>两种形式</strong>。</li>
</ul>
<h3 id="4-2-2-反码"><a href="#4-2-2-反码" class="headerlink" title="4.2.2.反码"></a>4.2.2.反码</h3><p><strong>反码：反码是原码转换为补码的一个中间状态。</strong></p>
<p><strong>①：如果是正数，则反码与原码相同</strong></p>
<ul>
<li><p>例如 + 19D，其$ [x]<em>{原}&#x3D;0,0010011 [x] $， $ [x]</em>{反}&#x3D;0,0010011 $</p>
</li>
<li><p>例如 + 0.75D，其$[x]<em>{原}&#x3D;0.1100000 $， $[x]</em>{反}&#x3D;0.1100000$</p>
</li>
</ul>
<p><strong>②：如果是负数，则除符号位外，其他位按位取反</strong></p>
<ul>
<li><p>例如 - 19D，其$ [x]<em>{原}&#x3D;1,0010011$， $[x]</em>{反}&#x3D;1,1101100 [x] $</p>
</li>
<li><p>例如 - 0.75D，其 $ [x]<em>{原}&#x3D;1.1100000$， $[x]</em>{反}&#x3D;1.0011111 [x] $</p>
</li>
</ul>
<p><strong>③：特别注意真值 0 的 + 0 和 - 0 所对应的形式</strong></p>
<ul>
<li><p>[$ [+0]<em>{原}&#x3D;00000000 [+0] $，$[+0]</em>{反}&#x3D;00000000$</p>
</li>
<li><p>$ [-0]<em>{原}&#x3D;10000000$，$ [-0]</em>{反}&#x3D;11111111$</p>
</li>
</ul>
<h3 id="4-2-3-补码"><a href="#4-2-3-补码" class="headerlink" title="4.2.3.补码"></a>4.2.3.补码</h3><p><strong>①：如果是正数，则补码和原码一致</strong></p>
<ul>
<li><p>例如 + 19D，其 $ [x]<em>{原}&#x3D;0,0010011$， $ [x]</em>{反}&#x3D;0,0010011$， $[x]_{补}&#x3D;0,0010011$</p>
</li>
<li><p>例如 + 0.75D，其$[x]<em>{原}&#x3D;0.1100000 [x] $， $[x]</em>{反}&#x3D;0.1100000 [x] $， $ [x]_{补}&#x3D;0.1100000$</p>
</li>
</ul>
<p><strong>②：如果是负数，则补码 &#x3D; 反码 + 1（注意进位）</strong></p>
<ul>
<li><p>例如 - 19D，其$ [x]<em>{原}&#x3D;1,0010011 $，$[x]</em>{反}&#x3D;1,1101100 [x] $， $ [x]_{补}&#x3D;1,1101101 $</p>
</li>
<li><p>例如 - 0.75D，其 $ [x]<em>{原}&#x3D;1.1100000 $， $ [x]</em>{反}&#x3D;1.0011111 [x] $， $ [x]_{补}&#x3D;1.0100000$</p>
</li>
</ul>
<p><strong>③：特别注意的是补码的真值 0 只有一种表现形式</strong></p>
<p>因为 $ [-0]<em>{原}&#x3D;10000000 $， $ [-0]</em>{反}&#x3D;11111111 [−0] $，其补码如果在此基础再加 1，就会超出机器数位的限制（这里假定 8 位），变为$1,00000000 $。这样一来，低八位就又变成了 $00000000$，反而和 <code>+ 0 0 0 </code>冲突了，并且显得浪费，所以把我们这个**特殊的补码直接规定为 $−128$*<em>。所以这里如果机器字长为 n 位，那么</em>补码整数的表示范围就为（多了一个<code>-128</code>）：  </p>
<p>​                                $ -(2^{n-1}) \leqslant x \leqslant 2^{n-1}-1 $</p>
<p>相应的，<strong>补码小数 1.00000000 1.00000000 1.00000000 的表示范围会变为（多了一个 - 1）</strong>。<br>                                $-1 \leqslant x \leqslant 1-2^{-n+1} $</p>
<h3 id="4-2-4-移码"><a href="#4-2-4-移码" class="headerlink" title="4.2.4.移码"></a>4.2.4.移码</h3><blockquote>
<p><strong>移码只能用来表示整数，而不能表示小数</strong>。</p>
</blockquote>
<p><strong>移码：移码是在补码的基础上将符号位取反，需要注意移码只能用于表示整数，且移码和补码的真值 0 是保持一致的</strong></p>
<ul>
<li><p>例如 + 19D，其$ [x]<em>{原}&#x3D;0,0010011 $，$ [x]</em>{反}&#x3D;0,0010011 [x] $， $ [x]<em>{补}&#x3D;0,0010011 $， $ [x]</em>{移}&#x3D;1,0010011 $</p>
</li>
<li><p>例如 - 19D，其 $ [x]<em>{原}&#x3D;1,0010011 $， $ [x]</em>{反}&#x3D;1,1101100 [x] $， $ [x]<em>{补}&#x3D;1,1101101 $，$ [x]</em>{移}&#x3D;0,1101101 $</p>
</li>
</ul>
<p><strong>移码是补码的符号位取反，可以将其看做一个无符号数，因此真值增大时移码也在增大，可以很方便的使用移码对数的大小进行比较</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913671.png" loading="lazy"></p>
<h2 id="4-3-原码、反码、补码总结"><a href="#4-3-原码、反码、补码总结" class="headerlink" title="4.3.原码、反码、补码总结"></a>4.3.原码、反码、补码总结</h2><h3 id="4-3-1-原码、补码运算技巧"><a href="#4-3-1-原码、补码运算技巧" class="headerlink" title="4.3.1.原码、补码运算技巧"></a>4.3.1.原码、补码运算技巧</h3><ul>
<li>如果已经知道 X 的补码，让你求 - X 的补码，只需<strong>所有位全部取反，末位 + 1 即可</strong>。</li>
<li>负数补码是在反码末位 + 1 后得到的，所以这就导致反码最右边连续的 1 都会因为进位而变为 0，直到进位碰到第一个 0 为止。因此，负数补码中，<strong>最右边的（最后一个 1）及其右面与原码相同，而其左面则与反码相同。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913413.png" alt="image-20230413143849083" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913974.png" alt="image-20230413143041534" loading="lazy"></p>
<h3 id="4-3-2-原码、反码、补码、移码特性（整数）"><a href="#4-3-2-原码、反码、补码、移码特性（整数）" class="headerlink" title="4.3.2.原码、反码、补码、移码特性（整数）"></a>4.3.2.原码、反码、补码、移码特性（整数）</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913053.png" alt="image-20230413143152103" loading="lazy"></p>
<h3 id="4-3-3-定点小数和定点整数对比"><a href="#4-3-3-定点小数和定点整数对比" class="headerlink" title="4.3.3.定点小数和定点整数对比"></a>4.3.3.定点小数和定点整数对比</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913125.png" alt="image-20230413143430341" loading="lazy"></p>
<h2 id="4-4-引入补码的目的"><a href="#4-4-引入补码的目的" class="headerlink" title="4.4.引入补码的目的"></a>4.4.引入补码的目的</h2><h3 id="4-4-1-直接使用原码进行运算的弊端"><a href="#4-4-1-直接使用原码进行运算的弊端" class="headerlink" title="4.4.1.直接使用原码进行运算的弊端"></a>4.4.1.直接使用原码进行运算的弊端</h3><p>对于<strong>无符号数</strong>，直接使用原码进行运算是没有问题的，如下图：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913854.png" loading="lazy"></p>
<p> 但对于<strong>有符号数</strong>，由于最高位表示的是符号位，所以下面计算的结果<strong>明显是错误的</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913956.png" loading="lazy">  </p>
<p>要想得到正确的运算结果，那就得要求计算机能够识别加减运算，也即算术逻辑单元 ALU 不只需要加法器，还得需要减法器才行。<strong>但由于减法器实现比较困难且成本巨大，所以一个可行的方案就是使用加法代替减法。</strong></p>
<h3 id="4-4-2-如何使用加法实现减法"><a href="#4-4-2-如何使用加法实现减法" class="headerlink" title="4.4.2.如何使用加法实现减法"></a>4.4.2.如何使用加法实现减法</h3><p><strong>如下是一个时钟，指针开始时指向的是 10，如果要让其指向 7，那么有两种方法</strong>：</p>
<ul>
<li><strong>逆时针旋转至 7</strong>：相当于做了减法，即<code>10-3=7</code>。</li>
<li><strong>顺时针旋转至 7</strong>：相当于做了加法，但这里应该加多少呢？可以加 9，然后由于表盘最大数为 12，所以<code>19%12=7</code>，便指向了 7。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913736.png" loading="lazy"></p>
<p><strong>这个例子说明了一个道理：一个减法操作可以转换为一个与之对应的加法操作，而这里采用的是取余</strong></p>
<ul>
<li>-3 和 + 9 在 <strong>mod 12</strong> 这样的情况下是等价的，而这两个数相差正好就是 12。还有很多这样的数，比如 21、33、-15 等等，<strong>这些数之间的差距均为 12 或其倍数。</strong></li>
</ul>
<p>其实，上例中的 - 3 和 9 <strong>互为补数</strong>，因为<strong>这两个数的绝对值之和为 12。</strong></p>
<p>$ -a(a&gt;0) 的补数 &#x3D; 模 -|a| $</p>
<p><strong>补数的性质非常重要，假设互为补数的两数之和为 <code> m</code>，那么在 <code>mod m</code> 的条件下，若能找到负数的补数，就可以用正数的加法代替减法</strong></p>
<p>如下例  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913069.png" loading="lazy"> </p>
<p>按照上面所述，要完成运算，<strong>只需要找到 - 14 的补数即可</strong>。这里机器字长为<code>8bit</code>，所以可以表示的数范围为$2^{8}− 1 $，这个$2^{8}− 1 $就相当于表盘上的 12，<strong>所以当某数大于 $2^{8}− 1 $ 时，由于机器字长的限制，计算机便帮助我们 “自动” 进行了一个 mod 运算，该数会被重新映射到合法范围内</strong>。</p>
<ul>
<li><code>mod 12</code>把数映射到了 0-11 这个范围内，<code>mod</code> $2^{8}$把数映射到了 $ 0-2^{8}-1 $这个范围内。</li>
</ul>
<p>因此，**-14 的补数为 $+ 1 , 00000000 - 00001110 &#x3D; 11110010 $<strong>，</strong>大家认真观察就可以发现 -14 的补数其实就是 - 14 的补码**。</p>
<p>最后，使用 11110010 11110010 11110010 替换原来的减法完成运算，其结果就是 0（截断）  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914467.png" loading="lazy"></p>
<h2 id="4-5-有符号数补码运算"><a href="#4-5-有符号数补码运算" class="headerlink" title="4.5.有符号数补码运算"></a>4.5.有符号数补码运算</h2><ul>
<li>原码运算不用多说，以下运算中必须把运算数全部转换为<strong>补码</strong>进行（特指负数）。</li>
</ul>
<h3 id="4-5-1-定点整数的补码运算"><a href="#4-5-1-定点整数的补码运算" class="headerlink" title="4.5.1.定点整数的补码运算"></a>4.5.1.定点整数的补码运算</h3><h4 id="4-5-1-1-加法运算"><a href="#4-5-1-1-加法运算" class="headerlink" title="4.5.1.1.加法运算"></a>4.5.1.1.加法运算</h4><p><strong>定点整数补码加法运算规则：从最低位开始，按位相加（符号位参与运算），向更高位进位</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914964.png" alt="image-20230413144152183" loading="lazy"></p>
<h4 id="4-5-1-2-减法运算"><a href="#4-5-1-2-减法运算" class="headerlink" title="4.5.1.2.减法运算"></a>4.5.1.2.减法运算</h4><p><strong>定点整数补码减法运算规则：$ [A]<em>{补} - [B]</em>{补}&#x3D;  [A]<em>{补} +  [-B]</em>{补}$，重点问题在于已知 $ [B]<em>{补} $如何求$ [-B]</em>{补}$，如下</strong>  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922275.png" alt="image-20230413144231881" loading="lazy"></p>
<p><strong>这样一来，减法就转变为了加法，剩余步骤同上</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914938.png" alt="image-20230413144349687" loading="lazy"></p>
<h3 id="4-5-2-定点小数的补码运算"><a href="#4-5-2-定点小数的补码运算" class="headerlink" title="4.5.2.定点小数的补码运算"></a>4.5.2.定点小数的补码运算</h3><h4 id="4-5-2-1-加法运算"><a href="#4-5-2-1-加法运算" class="headerlink" title="4.5.2.1.加法运算"></a>4.5.2.1.加法运算</h4><ul>
<li>同定点整数运算规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914914.png" loading="lazy"></p>
<h4 id="4-5-2-2-减法运算"><a href="#4-5-2-2-减法运算" class="headerlink" title="4.5.2.2.减法运算"></a>4.5.2.2.减法运算</h4><ul>
<li>同定点整数运算规则</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914546.png" loading="lazy"></p>
<h2 id="4-6-溢出判别方法"><a href="#4-6-溢出判别方法" class="headerlink" title="4.6.溢出判别方法"></a>4.6.溢出判别方法</h2><p>如下，求 $ [A+C]<em>{补} $和 $ [B-C]</em>{补} $​。运算过后你会得到一非常奇怪的结果。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914234.png" loading="lazy"></p>
<p>这是因为<strong>发生了溢出</strong>，溢出分为上溢和下溢：</p>
<ul>
<li><p><strong>正数 + 正数导致上溢</strong>：正 + 正 &#x3D; 负  。</p>
</li>
<li><p><strong>负数 + 负数导致下溢</strong>：负 + 负 &#x3D; 正  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914548.png" loading="lazy"></p>
</li>
</ul>
<h3 id="4-6-1-采用一位符号位依据溢出表达式判断"><a href="#4-6-1-采用一位符号位依据溢出表达式判断" class="headerlink" title="4.6.1.采用一位符号位依据溢出表达式判断"></a>4.6.1.采用一位符号位依据溢出表达式判断</h3><p>对于上面的例子：</p>
<ul>
<li>$[A+C]_{补}&#x3D;0,0001111+0,1111100&#x3D;1,0001011$，真值 - 117</li>
<li>$ [B-C]_{补}&#x3D;1,1101000+1,0000100&#x3D;0,1101100$，真值 + 108</li>
</ul>
<p>假设 A 的符号位为 $A_{s} $， B  的符号位为$ B_{S} $，其运算结果符号位为 $S_{s} $，则<strong>溢出逻辑表达式为</strong>：</p>
<ul>
<li>$V&#x3D;0 $表示无溢出。</li>
<li>$ V&#x3D;1$ 表示有溢出。</li>
</ul>
<p>​                                $V&#x3D;(A_{s}B_{s}(\overline S_{s} ))+ ((\overline A_{s})( \overline B_{s})S_{s}) $</p>
<blockquote>
<p>注意逻辑运算规则：</p>
<ul>
<li><strong>与</strong>： $A B C$表示与运算，A 与 B 与 C，当 A、B、C 全部为 1 时结果为 1，有一个为 0 结果为 0</li>
<li><strong>或</strong>： $A+B+C $ 表示或运算，A 或 B 或 C，当 A、B、C 全部为 0 时结果为 0，有一个为 1 结果为 1</li>
<li><strong>非</strong>： $\overline A $ 表示非运算，比如 $A $为 1 则 $  \overline A$ 为 0</li>
</ul>
</blockquote>
<p>在上面的例子中：</p>
<ul>
<li>$ [A]<em>{补}$​符号位为 <strong>0</strong>， $ [C]</em>{补} $符号位为 <strong>0</strong>， $ S_{s}&#x3D; [ A + C]<em>{补} $​符号位为 <strong>1</strong>，则 $\overline S</em>{s} $为 0 ，因此$A_{s}C_{s}\overline S_{s}$逻辑运算结果为 0；</li>
<li>$ \overline [A]<em>{补} $​为 <strong>1</strong>，$ \overline[C]</em>{补} $为 <strong>1</strong>, 则$ (\overline A_{s})( \overline C_{s})S_{s}$结果为 1。</li>
</ul>
<p>于是 $ V&#x3D;000 + 111&#x3D;0+1&#x3D;1$（有溢出），其实这也对应了正数 + 正数必有溢出的结论。</p>
<ul>
<li>负数 + 负数，也即 [ B − C ] 补 [B-C]_{补} [B−C] 补​读者可以根据上面的逻辑自行验证，会发现也是溢出的。</li>
</ul>
<p><strong>逻辑表达式有了，接着就可以设计与之对应的电路结构，计算机在判断溢出时可根据此逻辑进行判断</strong>。</p>
<h3 id="4-6-2-采用一位符号位依据数据位的进位情况判断"><a href="#4-6-2-采用一位符号位依据数据位的进位情况判断" class="headerlink" title="4.6.2.采用一位符号位依据数据位的进位情况判断"></a>4.6.2.采用一位符号位依据数据位的进位情况判断</h3><p><strong>这里有两个进位需要区别开来</strong>：</p>
<ul>
<li><p>**符号位的进位$ C_{s}$**：最高数值位向符号位进的位。</p>
</li>
<li><p><strong>最高数值位的进位 $C_{1} $​</strong>：最高数值位得到的进位。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914829.png" loading="lazy"></p>
</li>
</ul>
<p><strong>溢出判断规则为：</strong></p>
<ul>
<li><strong>上溢</strong>： $C_{s}&#x3D;0 $， $ C_{1}&#x3D;1$。</li>
<li><strong>下溢</strong>：$ C_{s}&#x3D;1 $， $C_{1}&#x3D;0$。</li>
</ul>
<p>比如$ [A+C]<em>{补} $会上溢，所以运算时有$C</em>{s}&#x3D;0 $，$ C_{1}&#x3D;1 $ 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914087.png" loading="lazy"></p>
<p>可以发现只要发生溢出$C_{s} 和 C_{1} $一定是不同的，计算机在判断时会<strong>使用异或运算</strong>。</p>
<ul>
<li>$V &#x3D; 0 $表示无溢出。</li>
<li>$V &#x3D; 1 $ 表示有溢出。</li>
</ul>
<p>$V&#x3D;C_{s}⊕C_{1}$</p>
<h3 id="4-6-3-采用双符号位判断（常考）"><a href="#4-6-3-采用双符号位判断（常考）" class="headerlink" title="4.6.3.采用双符号位判断（常考）"></a>4.6.3.采用双符号位判断（常考）</h3><p>之前符号位都是一位，这种方法将符号位扩展为了 2 位。</p>
<ul>
<li><strong>“00” 表示正数</strong></li>
<li><strong>“11 表示负数”</strong></li>
</ul>
<p>如下为运算过程：</p>
<ul>
<li>$[A+C]_{补}&#x3D;00,0001111+00,1111100&#x3D;01,0001011$，真值 - 117。</li>
<li>$ [B-C]_{补}&#x3D;11,1101000+11,0000100&#x3D;10,1101100 $，真值 + 108。</li>
</ul>
<p>运算结果符号位自然也有两位，<strong>这两个符号位第一位表示本来应该的符号，第二位符号表示实际得到的符号</strong>。比如<code>A+C </code> 结果中本来正数 + 正数应该是正数，但是实际是负数，所以判断溢出，而且是上溢。</p>
<p><strong>记这两个符号位为$S_{s1}S_{s2} $​，则溢出表达式为</strong>：</p>
<ul>
<li>$V &#x3D; 0 $ 无溢出。</li>
<li>$V &#x3D; 1$ 有溢出。</li>
</ul>
<p>$ V&#x3D;S_{s1}⊕S_{s2} $</p>
<h2 id="4-7-符号扩展"><a href="#4-7-符号扩展" class="headerlink" title="4.7.符号扩展"></a>4.7.符号扩展</h2><p>从上面的叙述中可以看出，溢出现象发生的本质原因就是机器字长不够。所以最容易想到的一个方式就是把<strong>短数据扩展为长数据</strong>，比如<code>int-&gt;long</code>，那么这又带来一个新的问题就是：<strong>多出来的那些位应该如何填补</strong>？</p>
<p>对于<strong>定点正整数</strong>来说，由于其原码、反码和补码都一样，因此直接补<code> 0</code> 即可  。<br>如 <code>0,1011010 0,1011010 0,1011010—&gt; 0,000000001011010 0,00000000 1011010 0,000000001011010</code>。</p>
<p>对于<strong>定点负整数</strong>来说，原码补 <code>0</code>，反码则对应位置补 <code>1</code>，而补码根据前面讲到的规则从右向左数第一个 1 开始（包括）左侧部分同补码  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914877.png" loading="lazy">  </p>
<p>对于<strong>定点正小数</strong>，最后面补 0 即可  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914071.png" loading="lazy"></p>
<p>对于<strong>定点负小数</strong>，和定点负整数同理  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914648.png" loading="lazy"></p>
<h1 id="5-字符与字符串在计算机中的表示详解（考纲删除了解即可）"><a href="#5-字符与字符串在计算机中的表示详解（考纲删除了解即可）" class="headerlink" title="5.字符与字符串在计算机中的表示详解（考纲删除了解即可）"></a>5.字符与字符串在计算机中的表示详解（考纲删除了解即可）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914193.png" loading="lazy"></p>
<p>现代计算机不仅要处理数值领域的问题，而且还要处理大量<strong>非数值领</strong>域的问题。这样一来，必然要引入<strong>文字、字母及某些专用符号</strong>，以便表示文字语言、逻辑语言等信息。例如，人机交换信息时使用英文字母、标点符号、十进制数及诸如<code>$</code>、<code>%</code>、<code>+</code>等符号。然而，<strong>数字计算机只能处理二进制数据</strong>，因此，上述信息应用到计算机中时，<strong>都必须编写成二进制格式的代码，也就是字符信息用数据表示，称为符号数据</strong>。</p>
<h2 id="5-1-字符编码与-ASCII-编码"><a href="#5-1-字符编码与-ASCII-编码" class="headerlink" title="5.1.字符编码与 ASCII 编码"></a>5.1.字符编码与 ASCII 编码</h2><p><strong>ASCII 编码：这是目前国际上普遍采用的一种字符系统，其美国版称为 ASCII 码 (美国国家信息交换标准字符码)。它包括 10 个十进制数码，26 个英文字母和一定数量的专用符号，如<code>$</code>、<code>%</code>、<code>+</code>等，总共 128 个元素。因此二进制编码需要 7 位，再加上一个校验位，共 8 位，刚好为一个字节</strong>。</p>
<p><strong>ASCII 码字符排布情况如下</strong>：</p>
<ul>
<li>0~31 为控制字符, 用于通信控制和设备的功能控制。</li>
<li>127 是 DEL 码。</li>
<li><strong>32 是空格码。</strong></li>
<li>32~196 共 95 个字符为可打印字符。</li>
<li><strong>65~90 为大写字母范围。</strong></li>
<li><strong>97~122 位小写字母范围</strong>。</li>
<li>数字 0-9 的 ASCII 码为 48(011 0000) 到 57(011 1001)。注意去掉高三位后剩余部分正好是它们对应的 BCD 码形式。<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914754.png" alt="ASCII码表" loading="lazy"></li>
</ul>
<h2 id="5-2-汉字的表示和编码"><a href="#5-2-汉字的表示和编码" class="headerlink" title="5.2.汉字的表示和编码"></a>5.2.汉字的表示和编码</h2><p><strong>汉字编码：在不同情况下需要使用到不同搞得汉字编码，主要有：</strong></p>
<ul>
<li><strong>输入码</strong>：为了<strong>方便汉字输入</strong>而采取的编码方式。</li>
<li><strong>内码</strong>：为了在<strong>计算机内部表示汉字</strong>而采取的编码方式。</li>
<li><strong>输出码（字模码）</strong>：为了<strong>显示、打印汉字</strong>而采取的编码方式。</li>
</ul>
<h3 id="5-2-1-汉字的输入编码"><a href="#5-2-1-汉字的输入编码" class="headerlink" title="5.2.1.汉字的输入编码"></a>5.2.1.汉字的输入编码</h3><p><strong>汉字的输入编码：为了能直接使用西文标准键盘把汉字输入到计算机，就必须为汉字设计相应的输入编码方法，主要有以下三类：</strong></p>
<ul>
<li><p><strong>数字编码（主要使用）</strong>：数字编码用<strong>数字串</strong>代表一个汉字输入。常用的是<strong>区位码</strong>，区位码是将国家标准局公布的 6763 个两级汉字分为 94 个区，每个区 94 位。也就说把汉字表示成二维数组，<strong>每个汉字在数组的下</strong>标就是区位码。<strong>区码和位码</strong>总共是两位十进制数字，<strong>所以输入一个汉字需要键入四次</strong>。例如下面的 “啊” 字位于第 16 区 01 位，所以它的区位码就是 1601。使用数字编码方式输入<strong>无重码，且与内码转换较为方便</strong>，但缺点即使代码<strong>太难记忆</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914304.png" loading="lazy"></p>
</li>
<li><p><strong>拼音码</strong>：拼音码是以<strong>汉语拼音</strong>为基础的输入方法，只要掌握汉语拼音就可以轻松输入。但由于<strong>汉字同音字太多，所以输入的重码率会很高，输入速度也会受到影响。</strong></p>
</li>
<li><p><strong>字形编码</strong>：汉字总数虽然很多，但所有汉字都由最基本的笔画构成，因此全部汉字的部件和笔画是有限的。所以可以把<strong>汉字的笔画部件用字母或数字进行编码</strong>，按笔画的顺序依次输入就可以表示一个汉字。例如<strong>五笔打字。</strong></p>
</li>
</ul>
<h3 id="5-2-2-汉字内码"><a href="#5-2-2-汉字内码" class="headerlink" title="5.2.2.汉字内码"></a>5.2.2.汉字内码</h3><h4 id="5-2-2-1-国际码（交换码）"><a href="#5-2-2-1-国际码（交换码）" class="headerlink" title="5.2.2.1.国际码（交换码）"></a>5.2.2.1.国际码（交换码）</h4><p><strong>国际码（交换码）：上面说到的区位码还考虑一个问题，那就是必须要避开 ASCII 字符中 0~32 的不可显示字符和空格字符。因此会在区位码的基础上让其向后偏移 32，也就是加上 20H（十六进制），形成国际码。</strong></p>
<ul>
<li><strong>注意</strong>：区码和位码必须同时加上 20H（因为区码和位码分别代表一个字节）。也即<strong>国际码 &#x3D;(区位码)16+20H</strong></li>
</ul>
<h4 id="5-2-2-2-汉字内码"><a href="#5-2-2-2-汉字内码" class="headerlink" title="5.2.2.2.汉字内码"></a>5.2.2.2.汉字内码</h4><p><strong>国际码（交换码）</strong>：国标码还不能直接在计算机上使用，因为它还<strong>会和 ASCII 中的除控制字符外的其他字符冲突</strong></p>
<ul>
<li>这里 以<code>“中”</code>字为例，其国标码中的高位字节为 86，这会与 ASCII 中大写字母’V’冲突，低位字节为 80，会与’P’冲突。</li>
</ul>
<p>因此，为避免这种情况，<strong>规定：国标码中的每个字节的最高位都从 0 换成 1，相当于每个字节都再加上 128(十六进制为 80，即 80H；二进制为 1000 0000)<strong>，从而得到国标码的 “</strong>机内码</strong>” 表示，简称 <strong>“内码”</strong>。也即 <strong>汉字内码 &#x3D;(国际码)16+ 80 H 80H 80H</strong>。</p>
<ul>
<li>另外，由于 ASCII 码只用了一个字节的低 7 位，所以，<strong>一旦首位为 1 就表示这是汉字编码，若为 0 就是这是 ASCII 字符</strong>。</li>
</ul>
<p><strong>总之它们的关系如下</strong>：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914575.png" loading="lazy"></p>
<h4 id="5-2-2-3-汉字输出码（字模码）"><a href="#5-2-2-3-汉字输出码（字模码）" class="headerlink" title="5.2.2.3.汉字输出码（字模码）"></a>5.2.2.3.汉字输出码（字模码）</h4><p><strong>汉字输出码（字模码）</strong>： 为了显示或输出汉字，我们把汉字按图形符号设计成<strong>点阵图</strong>，就得到了相应的<strong>点阵代码 (字形码)<strong>。具体来说是用 0、1 表示汉字的字形，然后将汉字放入 $n$行 × $n$列的正方形 (<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%82%B9%E9%98%B5&spm=1001.2101.3001.7020">点阵</a>) 内，该正方形共有 n 2 n^{2} n2 个小方格，</strong>每个小方格用一位二进制表示，凡是笔划经过的方格值为 1，未经过的值为 0</strong>。</p>
<ul>
<li>**字节数 &#x3D; 点阵行数 ×(点阵列数 &#x2F; 8)**。</li>
</ul>
<p>同时，汉字信息处理系统还需要配有<strong>汉字字形库，也称字模库，简称字库</strong>，它集中了汉字的字形信息。当显示输出或打印输出时才检索字库，输出子模点阵，得到字形。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914040.gif" alt="点阵描述字形" loading="lazy"></p>
<h4 id="5-2-2-4总结"><a href="#5-2-2-4总结" class="headerlink" title="5.2.2.4总结"></a>5.2.2.4总结</h4><p><strong>综上所述，这三类码关系如下</strong>：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915178.jpeg" loading="lazy"></p>
<h2 id="5-3-字符串（考纲已删除）"><a href="#5-3-字符串（考纲已删除）" class="headerlink" title="5.3.字符串（考纲已删除）"></a>5.3.字符串（考纲已删除）</h2><p><strong>字符串</strong>：字符串是指<strong>连续的一串字符</strong>。通常情况下，它们占用主存连续的多个字节，<strong>每个字节存一个字符</strong>。</p>
<p><strong>英文字符，以 “abc” 为例。</strong></p>
<ul>
<li><p>计算机按字节编址，每个内存地址对应一个字节，最后一个字符往往是结束标志  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915296.png" loading="lazy">  </p>
<p><strong>中文字符，以 “abc 啊” 为例</strong>。</p>
</li>
<li><p>两字节表示一个汉字  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915632.png" loading="lazy"></p>
</li>
</ul>
<h1 id="6-校验码（考纲删除但计网会用建议学习）"><a href="#6-校验码（考纲删除但计网会用建议学习）" class="headerlink" title="6.校验码（考纲删除但计网会用建议学习）"></a>6.校验码（考纲删除但计网会用建议学习）</h1><h2 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1.基本概念"></a>6.1.基本概念</h2><h3 id="6-1-1-校验码"><a href="#6-1-1-校验码" class="headerlink" title="6.1.1.校验码"></a>6.1.1.校验码</h3><p><strong>校验码：校验码是指能够发现或自动纠正错误的数据编码，也称检错纠错编码。具体实现时，校验码会增加一些冗余码，来帮助检验或纠错</strong>。</p>
<h3 id="6-1-2-码字和码距"><a href="#6-1-2-码字和码距" class="headerlink" title="6.1.2.码字和码距"></a>6.1.2.码字和码距</h3><p><strong>为了实现网络传输，会把原信息进行编码，形成二进制序列，这里就会涉及两个概念。</strong></p>
<ul>
<li><strong>码字</strong>：由若干位代码组成的<strong>一个字</strong>称为码字，比如下图中 “00”，“01”。</li>
<li><strong>码距</strong>：将两个码字逐位比较，<strong>具有不同的位的个数称为两个码字的距离</strong>，比如下图中 “00” 和“10”距离就是 1；<strong>一种编码方法可能有若干合法码字，各合法码字之间的最小距离称为 “码距”</strong>，下图所示编码方案其码距为 1。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915122.png" loading="lazy"></p>
<p><strong>码距大小与校验码的检错和纠错能力直接相关</strong>。</p>
<ul>
<li>码距为 1 <strong>无检错能力</strong>。</li>
<li>码距大于等于 2 具有<strong>检错能力</strong>。</li>
<li><strong>码距越大，检错、纠错能力就越强。</strong></li>
<li>检错能力总大于等于纠错能力。</li>
</ul>
<h1 id="6-2-常见校验码"><a href="#6-2-常见校验码" class="headerlink" title="6.2.常见校验码"></a>6.2.常见校验码</h1><h2 id="6-2-1-奇偶校验码"><a href="#6-2-1-奇偶校验码" class="headerlink" title="6.2.1.奇偶校验码"></a>6.2.1.奇偶校验码</h2><p><strong>在原编码的基础上增加一个校验码，它的码距为 2，可以检测出一位错误 (或奇数位错误)，但不能确定出错位置，也不能检测出偶数位出错，增加的冗余位称为奇偶校验位</strong>。</p>
<p>实现方法：由若干位有效信息（比如 1B，0001 1011），再加上一个二进制位（检验位）组成校验码。如下图所示，<strong>校验位的取值为 0 或 1，它的加入使整个校验码中 “1” 的个数要么是奇数要么是偶数，所以就有两种可选的校验规律</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915807.png" loading="lazy"></p>
<ul>
<li><strong>奇校验码</strong>：整个检验码中 “1” 的个数为奇数。</li>
<li><strong>偶校验码</strong>：整个校验码中 “1” 的个数为偶数。</li>
</ul>
<p>举个例子，1001101 的奇校验码和偶校验码设置如下：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915862.png" loading="lazy">  </p>
<p>奇偶校验具有很大的局限性，<strong>只能发现数据代码中的奇数位出错的情况</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915796.jpeg" loading="lazy">  </p>
<p>校验原理：传输前，发送端和接收端会协议确定彼此之间采用奇校验还是偶校验。以偶校验为例，<strong>计算机首先会将二进制所有位进行异或运算，所得结果就是偶校验位</strong>，比如上面信息 “1001101”，进行异或运算“1⊕0⊕0⊕1⊕1⊕0⊕1&#x3D;0”，这表明 1 的个数为偶数个，故偶校验位为 0；<strong>接收端再接受信息后会进行异或运算，一旦结果出现 1 表明错误</strong>，比如上图中第一个例子，再接受到之后进行异或运算 “0⊕1⊕0⊕1⊕1⊕1⊕0⊕1&#x3D;1”，所以结果错误（同时大家也可以发现如果再更改一位为 1，那么最终结果仍然是，这就是奇偶校验的局限性)。</p>
<h2 id="6-2-海明校验码"><a href="#6-2-海明校验码" class="headerlink" title="6.2.海明校验码"></a>6.2.海明校验码</h2><p>海明码是一种广泛采用的有效的校验码，本质是一种多重奇偶校验码。<strong>其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到奇偶校验组中。当某一位出现错误后，就会引起有关的几个校验位的值发生变化。它不但可以发现错误位置，还可以为自动纠错提供依据。</strong></p>
<h3 id="6-2-1-纠错理论"><a href="#6-2-1-纠错理论" class="headerlink" title="6.2.1.纠错理论"></a>6.2.1.纠错理论</h3><p><strong>假设信息位为 <code> n</code>，校验位为<code> k</code>，因此 <code> k</code> 个比特位一共可以映射$2^{k} $ 种状态；海明码由信息位和校验位组成，因此共有 $n + k$ 位， $n+k$ 位每一个位置都有可能出现错误，因此这$2^{k} $种状态要把这$n+k $ 种全部映射到，但是要注意其中还要包含一种全部正确的情况。</strong></p>
<p>综上所述，得出下面的重要不等式：</p>
<p>$2^{k}\geqslant n+k+1 $</p>
<h3 id="6-2-2-求解海明码"><a href="#6-2-2-求解海明码" class="headerlink" title="6.2.2.求解海明码"></a>6.2.2.求解海明码</h3><p><strong>范例：求 1010 的海明码</strong>，具体流程如下  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915363.png" loading="lazy"></p>
<p><strong>6.2.2.1.确定海明码位数</strong></p>
<p>此二进制序列信息位$n&#x3D;4$，根据前述不等式 ： $2^{k}\geqslant n+k+1$，可知$ k $ 为 3 时不等式方可成立。</p>
<ul>
<li><p>除了实际计算，也可以熟悉下面这张表，从而快速写出  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915112.png" loading="lazy"></p>
</li>
</ul>
<p>为了区分信息位和校验位，我们用$D_{4}D_{3}D_{2}D_{1} $表示<strong>信息位</strong>（对应$1010$）；用 $ P_{3}P_{2}P_{1} $表示<strong>校验位</strong>；整个<strong>海明码</strong>序列可以表示为 $ H_{7}H_{6}H_{5}H_{4}H_{3}H_{2}H_{1} $。</p>
<p><strong>6.2.2.2.确定校验位分布</strong></p>
<p><strong>海明码中校验位不能直接放在信息位的头部和尾部</strong>。 </p>
<p>规定：<strong>校验位 $p_{i}$应该放在海明码 $H_{2^{i-1}} $​的位置</strong>，因此 $P_{1}P_{2}P_{3} $​分别对应 $ H_{1}H_{2}H_{4}$​，其实也就是 2 进制的权值。</p>
<p>校验位分布如下，首先放入校验位，信息位从低到高依次补全空位。</p>
<table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td></td><td>0</td><td></td><td></td></tr></tbody></table>

<p>接下来，<strong>由于校验位为 3 位，因此信息位需要根据校验位分为 3 组，每个分组分别进行偶校验</strong>。</p>
<p><strong>6.2.2.3.求校验位的值</strong></p>
<p>首先，<strong>我们需要海明码中对应位置为信息位的下标（也就是所处位置）转为二进制序列</strong>，比如上面表格中，$H_{7} $对应位置为信息，其下标为<code>7 </code>，对应二进制序列为 <code>111</code>。</p>
<table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>信息位值</strong></td><td>1</td><td>0</td><td>1</td><td></td><td>0</td><td></td><td></td></tr></tbody></table>

<p><strong>然后我们需要根据二进制序列确定每个校验位所在组包括哪些信息位</strong>。</p>
<p><strong>前面我们说过， $P_{3}P_{2}P_{1} $实则对应的是二进制的权值<code>421</code>，而分组依据就是根据这个权值，比如 $P_{1} $​表示所有二进制序列第 0 位为 1 的分到该组，  所以 $ H_{3}H_{5}H_{7} $就分到了这一组</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915457.jpeg" loading="lazy"></p>
<p>分为三个组后，我们就要对每一组进行偶校验。<strong>上面内容提到，偶校验码计算实则通过异或运算完成，因此对每组进行异或运算，确定 <code>P </code> 的取值</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915299.jpeg" loading="lazy">  </p>
<p>填充表格如下：</p>
<table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td><strong>0</strong></td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table>

<p><strong>6.2.2.4.校验纠错</strong></p>
<p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查。这里是偶校验，如果$S_{3}S_{2}S_{1}$​为 “000”，表明无错误。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915348.jpeg" loading="lazy">  </p>
<p>如果 $ S_{3}S_{2}S_{1}$​为 “010”，表明第 2 位出现错误  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915986.jpeg" loading="lazy">  </p>
<p>其原理可以用下面的这张图解释。  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915616.jpeg" loading="lazy"></p>
<ul>
<li>比如$D_{3} $信息位发生变化，由于$D_{3} $包含于 $ P_{2} 和 P_{3} $​，同时 $ P_{2} 和 P_{3}$​又在 $ S_{2}S_{3}$​的校验方程中，导致 $ S_{3}S_{2}S_{1} $为 <code>110 </code>， 也就是$ H_{6} $发生改变。</li>
<li>再比如校验位 $ P_{2} $发生改变时，其只存在于$S_{2}$的校验方程中，所以 $ S_{3}S_{2}S_{1} $​为 $ 010 $，也就是 $H_{2} $发生改变。</li>
</ul>
<h3 id="6-2-2-4-补充-全校验位"><a href="#6-2-2-4-补充-全校验位" class="headerlink" title="6.2.2.4.补充 - 全校验位"></a>6.2.2.4.补充 - 全校验位</h3><p><strong>海明码具有 1 位的纠错能力和 2 位的检错能力</strong></p>
<p>刚才设计的海明码，在使用时还是有一定问题的，比如发送刚数据为：</p>
<table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table>

<p>发送中， $ P_{2}P_{1} $这两个校验位发生改变。</p>
<table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>0</strong></td><td><strong>1</strong></td></tr></tbody></table>

<p>那么按照之前的校验规则，$ S_{3}S_{2}S_{1} $的值为 “110”，表明$H_{3} $位置发生错误。很明显发现，判断错误，此时发生的是两个比特位的改变。<strong>所以之前的方案是没有办法区分 1 位错误，还是 2 位错误的。</strong></p>
<p><strong>为此，在使用时我们在海明码首部加入 “全校验位”，对整体统一进行一次偶校验</strong>。</p>
<p>发送方数据：</p>
<table><thead><tr><th>海明码位置</th><th> H8​</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td>二进制</td><td></td><td>111</td><td>110</td><td>101</td><td></td><td>011</td><td></td><td></td></tr><tr><td><strong>分布情况</strong></td><td>P 全​</td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table>

<ul>
<li>如果此时接收方校验后 $S_{3}S_{2}S_{1} $的值为 “000”，并且全体偶校验成功，表明没有错误；</li>
<li>如果$S_{3}S_{2}S_{1}$​的值不为 “000”，并且全体偶校验失败，表明有 1 位错误，纠正即可；</li>
<li>如果 $S_{3}S_{2}S_{1} $​的值不为 “000”，并且全体偶校验成功，很明显产生了两位错误，此时无法纠正，需要重传。</li>
</ul>
<h2 id="6-3-循环冗余校验码（CRC-码）"><a href="#6-3-循环冗余校验码（CRC-码）" class="headerlink" title="6.3.循环冗余校验码（CRC 码）"></a>6.3.循环冗余校验码（CRC 码）</h2><p>举个例子，A 要向 B 传送数据<code>882</code>，为了校验数据是否准确，A 和 B 约定了一个除数<code>7</code>，<code>882</code>除以<code>7</code>是可以出除尽的。在 B 接受到数据之后用，使用 882 除以 7，如果没有余数，表示数据可能正确，<strong>但如果有余数那么一定错误</strong>。</p>
<p>其实，CRC 的基本思想和刚才的除法思想基本一致。<strong>发送方和接收方提前约定好一个数，作为除数（这里的数自然指的是二进制序列），在 <code>K </code>个信息位后拼接 <code>R</code>个校验位作为被除数（添加校验位需要保证除法余数为 0），接受方在接收到数据之后进行相应除法运算，检查余数是否为 0。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915952.png" loading="lazy"></p>
<p><strong>一般来说题目会将除数表现一种多项式的形式</strong>，比如：**设多项式 $ G(x)&#x3D;x^{3}+x^{2}+1 $**，信息码为 $101001$，求对应的$ C R C$ 码。</p>
<p>多项式 $G (x) $的<strong>完整形式</strong>实则为 $G(x)&#x3D;1\times x^{3}+1\times x^{2}+0\times x^{1}+1\times x^{0} $，<strong>取系数</strong>，指明除数为 $1101 $。</p>
<p><strong>1：确定<code>K</code>、 <code>R </code>以及生成多项式对应的二进制码</strong></p>
<p>其中 $R&#x3D; 生成多项式最高幂次 &#x3D; 3 $， $K&#x3D; 信息码长度的 &#x3D; 6 $，于是整个编码位数$N&#x3D;K+R&#x3D;9 $<br>多项式$ G (x) $对应二进制码为$ 1101 $</p>
<p><strong>2：移位</strong></p>
<p>现在我们要确保添加的 <code>3</code> 位校验位形成的被除数可以整除除数，<strong>因此首先将信息码 <code>101001 </code>左移 R 位，低位补 0，也即 <code>101001000</code>，称其为新信息码。</strong></p>
<p><strong>3：相除</strong><br>对于新信息码，用生成多项式进行<strong>模 2 除</strong>法，产生余数。  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915441.png" loading="lazy"></p>
<ul>
<li><p>举个例子，用 1001000 作为被除数，1011 作为除数，模 2 除法为的是求余数，不关心商。  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922316.png" loading="lazy"></p>
<p>首先商为 1，得出结果  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915361.png" loading="lazy"></p>
<p>此时不应该做减法，而应该做对应为的异或运算  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915631.png" loading="lazy">  </p>
<p>接着如果高位为 0，就抹去一位，同时后面用被除数的补齐一位  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922276.png" loading="lazy">  </p>
<p>这里经过异或运算，然后抹位补位得到的结果（比如上图 0100）中，如果首位为 0 就商 0，首位为 1 就商 1  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915177.png" loading="lazy">  </p>
<p>继续异或，然后抹位，补位后  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915336.png" loading="lazy">  </p>
<p>继续  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915213.png" loading="lazy">  </p>
<p>运算到这里，其实可以进行快捷操作。异或后前面有多少 0 都全部扔掉，再从被除数哪里补齐相应位即可。但是这里很明显只能取一个，于是就得到下面的结果，此时也是最终结果，<strong>因为余数位数小于除数</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915005.png" loading="lazy"></p>
</li>
</ul>
<p>好的，回到正题。此时运算出的余数为 001，作为校验位。于是整个 CRC 码即为$信息码 + 校验码 &#x3D; 101001001 $。</p>
<p><strong>4：检验纠错</strong></p>
<p>接收方接受到到数据后，使用约定的除数进行模 2 除运算，如果余数为 000，结果正确。<br>如果接收方数据为<code> 101001011</code>（导数第二位出现错误），计算结果为 010，对应是十进制数为 2，表示第二位出现错误，<strong>但是特别注意这只是巧合，出错位置与计算结果没有必然联系，但是也有一定联系</strong>。</p>
<p>我们把每一个位置出错的情况统计如下，大家可以发现，余数为 3 位最多映射 8 种情况，因此第 1-7 位是属于一个周期，但是从第 8 位又开始了一个新的周期，因此 010 有可能对应第 2 位出错，也有可能是第 9 位  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915877.png" loading="lazy"></p>
<p>难道说 CRC 码不能确定出错位置吗？其实也不是的，出现这种情况的原因主要在于信息位过长，无法一一映射。所以要想确定纠错位置就要选择合适的多项式 (纠错 1 位)，具体关系如下面不等式：</p>
<p>​                                                                    $ 2^{R}\geq K+R+1$</p>
<p>其实这和海明码类似。但是实际应用中，尤其在网络中主要用来检错。</p>
<h1 id="7-算数逻辑单元和电路基本知识以及基本逻辑运算和全加器"><a href="#7-算数逻辑单元和电路基本知识以及基本逻辑运算和全加器" class="headerlink" title="7.算数逻辑单元和电路基本知识以及基本逻辑运算和全加器"></a>7.算数逻辑单元和电路基本知识以及基本逻辑运算和全加器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916535.png" alt="image-20230413170602808" loading="lazy"></p>
<h2 id="7-1-算数逻辑单元-ALU"><a href="#7-1-算数逻辑单元-ALU" class="headerlink" title="7.1.算数逻辑单元 ALU"></a>7.1.算数逻辑单元 ALU</h2><p>数字运算过程中一直离不开一个十分重要的部件——<strong>运算器</strong>，其构成如下  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916032.png" loading="lazy"></p>
<p>其中有一个<strong>核心部件——算数逻辑单元 ( Arithmetic and Logic Unit )，也即 ALU</strong>，其作用主要有以下三类</p>
<ul>
<li><strong>算数运算</strong>：如加、减、乘、除等。</li>
<li><strong>逻辑运算</strong>：如与、或、非、异或等。</li>
<li><strong>辅助功能</strong>：如移位、求补等。</li>
</ul>
<p>大家在课本中见到的 ALU 经常会被画成这样：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916244.png" loading="lazy"></p>
<ul>
<li>$A_{i}B_{i} $：是<strong>输入信号</strong>，这是一种电信号。通过高低电平，输入不同的电信号。</li>
<li>$F_{i} $：这是<strong>输出信号</strong>，也就是运算结果。</li>
<li>$K_{i} $​：这<strong>是控制信号</strong>，由控制单元发出 (CU)；控制单元负责解析指令，比如这个运算是什么类型的运算等等。</li>
</ul>
<p>上面是抽象图，下面是一个比较具体的图象，经典的 74181 芯片，是一个 4 位的 ALU  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916276.png" loading="lazy"> </p>
<p>上面的 M 会指明当前是一个逻辑运算还是算数运算（M&#x3D;1 是逻辑运算，M&#x3D;0 是算数运算)。<strong>总之，ALU 是在输入输出和控制信号下工作的</strong>。</p>
<h2 id="7-2-最基本的逻辑运算"><a href="#7-2-最基本的逻辑运算" class="headerlink" title="7.2.最基本的逻辑运算"></a>7.2.最基本的逻辑运算</h2><h3 id="7-2-1-与、或、非"><a href="#7-2-1-与、或、非" class="headerlink" title="7.2.1.与、或、非"></a>7.2.1.与、或、非</h3><p><strong>无论是多复杂的逻辑还是算数运算，都是通过最基本的逻辑运算复合而成的，这里最基本的逻辑运算指的是一个位的运算，他们分别是 “与”、“或” 和非。</strong></p>
<ul>
<li><strong>与：全 1 才是 1，有 0 就是 0。</strong></li>
<li><strong>或：全 0 才是 0，有 1 就是 1</strong>。</li>
<li><strong>非：0 为，1 为 0。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916466.png" loading="lazy"></p>
<p><strong>上面是从数学抽象的角度来描述的，它们对应的真实电路是如下三个门电路（从左到右依次为：与、或和非）</strong>：</p>
<ul>
<li><p><strong>与：只有 A 和 B 全部输入为高电平时，Y 才会是高电平，只要有一个是低电平 Y 就会是低电平。</strong></p>
</li>
<li><p><strong>或：如果 A 和 B 输入中有一个是高电平时，Y 就会是高电平，只有全部输入为低电平时，输出才会是低电平</strong>。</p>
</li>
<li><p><strong>非：输入的是高输出的就是低，反之亦然</strong> 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916740.png" loading="lazy"></p>
</li>
</ul>
<p><strong>另外需要注意这几个运算的表达式：</strong></p>
<ul>
<li><strong>与</strong>： $ Y&#x3D;A▪B$</li>
<li><strong>或</strong>： $ Y&#x3D;A+B$</li>
<li><strong>非</strong>： $&#x3D;A+\bar{B} $</li>
</ul>
<p><strong>其中与的优先级要大于或，也就是对于 $ AB+CD $，要先计算与再计算或，他们也满足一些计算定律</strong>：</p>
<ul>
<li><strong>分配律</strong>： $ A(C+D)&#x3D;AC+AD $</li>
<li><strong>结合律</strong>： $ABC&#x3D;A(BC) $、$A+B+C&#x3D;A+(B+C) $</li>
</ul>
<p><strong>在掌握与、或、非这三种基本运算后，我们就可以实现任何一种复杂的逻辑运算了</strong>。</p>
<p><strong>例如：实现 $ AC+AD$</strong></p>
<p>这是一个逻辑运算，可以让 A 和 C 以及 A 和 D 分别进行与运算然后结果再进行或运算 。 </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916389.png" loading="lazy"></p>
<p>也可以转变为等价的运算，即$A(C+D) $，先让 C 和 D 进行或运算，然后再和 A 进行与运算，这样一来还节省了一个电路元件  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916563.png" loading="lazy"></p>
<h3 id="7-2-2-与非、或非、异或、同或"><a href="#7-2-2-与非、或非、异或、同或" class="headerlink" title="7.2.2.与非、或非、异或、同或"></a>7.2.2.与非、或非、异或、同或</h3><ul>
<li><strong>与非：实则是与运算取反；也就是说全 1 则为 0，全 0 则为 1，有 1 则是 1。</strong></li>
<li><strong>或非：实则是或运算取反；也就是说全 1 则为 0，全 0 则为 1，有 0 则是 0</strong>。</li>
<li><strong>异或：相同数异或运算结果为 0,0 异或任何数是任何数。</strong></li>
<li><strong>同或：相同数异或运算结果为 1,1 异或任何数是任何数。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916756.png" loading="lazy"></p>
<p><strong>他们对应的电路符号分别为</strong>：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916619.png" loading="lazy"></p>
<h2 id="7-3-一位全加器"><a href="#7-3-一位全加器" class="headerlink" title="7.3.一位全加器"></a>7.3.一位全加器</h2><p><strong>一位全加器：一位全加器（FA）是最基本的加法单元，首先注意以下两个概念</strong>。</p>
<ul>
<li><strong>本位</strong>：<strong>指的是当前运算的那一位</strong>。</li>
<li><strong>本位的和</strong>：<strong>包括本位对应的两个数和来自低位向本位的进位。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916443.png" loading="lazy"></p>
<p><strong>运算时是按照一位一位的方式加的，来自本位的两个数和来自低位的进位会确定本位的和，同时确定向高位进位的数值。</strong></p>
<p><strong>因此输入共有三个</strong>：</p>
<ul>
<li>$A_{i} $和 $B_{i} $以及$ C_{i-1}$</li>
</ul>
<p><strong>输出共有两个：</strong></p>
<ul>
<li>**第一个是$ S_{i} $**：由于是二进制，因此$ S_{i} $只能是 1 或者是 0，所以就可以使用异或运算确定输入中 1 的奇偶个数，如果有奇数个 1 那么结果为 1，否则为 0，也即$ S_{i}&#x3D;A_{i}⊕B_{i}⊕C_{i-1}$。</li>
<li><strong>第二个是 $C_{i} $<strong>：</strong>第一种情况</strong>就是 $ A_{i}&#x3D;1 且 B_{i}&#x3D;1 $，那么无论进位为多少都要进一位；<strong>第二种情况</strong>就是$A_{i} 和 B_{i}$中有一个本位为 1 并且来自低位的进位是 1。这两种情况属于或的关系，因此逻辑表达式为：$ C_{i}&#x3D;A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}$</li>
</ul>
<p><strong>因此电路表示可以为</strong>  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916294.png" loading="lazy">  </p>
<p><strong>屏蔽内部实现细节后：</strong>  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916482.png" loading="lazy"></p>
<h2 id="7-4-串行加法器和并行加法器"><a href="#7-4-串行加法器和并行加法器" class="headerlink" title="7.4.串行加法器和并行加法器"></a>7.4.串行加法器和并行加法器</h2><h3 id="7-4-1-串行加法器"><a href="#7-4-1-串行加法器" class="headerlink" title="7.4.1.串行加法器"></a>7.4.1.串行加法器</h3><p><strong>串行加法器：串行加法器中只有一个全加器，数据会逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算</strong>。</p>
<ul>
<li><strong>缺点</strong>：如果操作数为 <code>n</code>位，加法就要分 <code>n </code>次进行，每次产生一位和并且串行逐位送回寄存器中，所以效率非常低。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916944.png" loading="lazy"></p>
<h3 id="7-4-2-并行加法器（串行进位）"><a href="#7-4-2-并行加法器（串行进位）" class="headerlink" title="7.4.2.并行加法器（串行进位）"></a>7.4.2.并行加法器（串行进位）</h3><p><strong>串行进位的并行加法器：最简单的并行加法器是串行进位的并行加法器：是将多个加法器串联在一起，这样就能同时输入两个 $n$位的数，每一位都可以使用一个加法器进行就算，且低位加法器产生的进位，会作为下一个高位加法器的输入信号</strong>。</p>
<ul>
<li><p><strong>缺陷</strong>：电信号的传递时需要时间的，因此高位的操作会受到低位的限制  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917673.png" loading="lazy"></p>
</li>
</ul>
<h3 id="7-4-3-并行加法器（并行进位）"><a href="#7-4-3-并行加法器（并行进位）" class="headerlink" title="7.4.3.并行加法器（并行进位）"></a>7.4.3.并行加法器（并行进位）</h3><p><strong>并行加法器（并行进位）：与串行进位的并行加法器相比，并行进位的并行加法器的各级进位信号同时生成，即同时进位</strong>。</p>
<p>如下，记 $G_{i}&#x3D;A_{i}B_{i} $， $P_{i}&#x3D;A_{i}⊕B_{i} $，则由</p>
<p>$ C_{i}&#x3D;A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}&#x3D;G_{i}+P_{i}C_{i-1} $</p>
<p><strong>所以 $G_{i} $和 $P_{i}$会被同时送入加法器，大大提高了效率</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917827.png" loading="lazy"></p>
<h1 id="8-补码加减运算器和标志位的生成"><a href="#8-补码加减运算器和标志位的生成" class="headerlink" title="8.补码加减运算器和标志位的生成"></a>8.补码加减运算器和标志位的生成</h1><h2 id="8-1-补码加减运算器"><a href="#8-1-补码加减运算器" class="headerlink" title="8.1.补码加减运算器"></a>8.1.补码加减运算器</h2><h3 id="8-1-1-补码加-x2F-减法运算规则回顾（即手算方法）"><a href="#8-1-1-补码加-x2F-减法运算规则回顾（即手算方法）" class="headerlink" title="8.1.1.补码加 &#x2F; 减法运算规则回顾（即手算方法）"></a>8.1.1.补码加 &#x2F; 减法运算规则回顾（即手算方法）</h3><ul>
<li>n bit 补码 $X$+ $Y$：直接按位相加即可。</li>
<li>n bit 补码 $X$- $Y$：<strong>将$ [Y]_{补} $​全部按位取反，末位 + 1</strong>，得到$ [-Y]_{补} $​，使<strong>减法变为加法</strong>。</li>
</ul>
<p><strong>例如：$X&#x3D;-8 $， $Y&#x3D;7 $，即 $ [X]<em>{补}&#x3D;1000 $， $ [Y]</em>{补}&#x3D;0111$，则</strong></p>
<ul>
<li>$X+Y&#x3D;1111$</li>
<li>$ X-Y&#x3D;1000+(1000+1)&#x3D;0001$（溢出）</li>
</ul>
<p><strong>例如： $X&#x3D;3 $，$Y&#x3D;4 $，即$ [X]<em>{补}&#x3D;0011$，$ [Y]</em>{补}&#x3D;0100$，则</strong></p>
<ul>
<li>$X+Y&#x3D;0111 $</li>
<li>$X-Y&#x3D;0011+(1011+1)&#x3D;1111$（溢出）</li>
</ul>
<h2 id="8-2-补码加减运算器原理"><a href="#8-2-补码加减运算器原理" class="headerlink" title="8.2.补码加减运算器原理"></a>8.2.补码加减运算器原理</h2><h3 id="8-2-1-普通加法器回顾"><a href="#8-2-1-普通加法器回顾" class="headerlink" title="8.2.1.普通加法器回顾"></a>8.2.1.普通加法器回顾</h3><p><strong>下图是前面讲过的普通加法器原理图，并没有实现补码加减功能，其中</strong>：</p>
<ul>
<li>$ A$ 和 $B$：这是两个 n bit 的操作数，它们需要按位相加。</li>
<li>$Cin$：这是来自低位的进位，该进位需要加在 $ A$ 和 $B$ 的最低位。</li>
<li>$F$：这是运算后产生的结果。</li>
<li>$Cout $：这是运算后产生的进位，该进位由 $ A$ 和 $B$ 的最高位运算后给出。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917825.png" loading="lazy"></p>
<h3 id="8-2-2-补码加减运算器"><a href="#8-2-2-补码加减运算器" class="headerlink" title="8.2.2.补码加减运算器"></a>8.2.2.补码加减运算器</h3><p><strong>如下是补码加减运算器，其中红色线上方和普通的加法器是一样的，下方是为实现补码运算所增加的电路。在进行补码运算时，对加减运算的区分会由信号 Sub 给出（0 为加，1 为减），该信号会传送给多路选择器 MUX，让其接通加法或减法电路</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917852.png" loading="lazy"></p>
<h4 id="8-2-2-1-加法功能"><a href="#8-2-2-1-加法功能" class="headerlink" title="8.2.2.1.加法功能"></a>8.2.2.1.加法功能</h4><p><strong>实现加法功能时，Sub 为 0，多路选择器直接连接 $Y$ 的一端会被选通，让 cin 为 0，然后进行运算即可。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922277.png" loading="lazy"></p>
<h4 id="8-2-2-2-减法功能"><a href="#8-2-2-2-减法功能" class="headerlink" title="8.2.2.2.减法功能"></a>8.2.2.2.减法功能</h4><p><strong>实现减法功能时，Sub 为 1， $Y$ 会进入带有非门的一端，经过非门后 $Y$ 会被取反，然后让 cin 为 1，相当于取反后再 + 1，接着完成运算即可。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917448.png" loading="lazy"></p>
<h2 id="8-3-标志位的生成"><a href="#8-3-标志位的生成" class="headerlink" title="8.3.标志位的生成"></a>8.3.标志位的生成</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917021.png" alt="image-20230413170657697" loading="lazy"></p>
<p><strong>加法器在产生运算结果 $F$ 的同时，还会产生如下 4 个标志位，用于辅助后续运算判断</strong>：</p>
<ul>
<li><strong>$OF $（Overflow Flag 溢出标志）：溢出为 1，否则为 0</strong>，<strong>对于无符号数运算，OF没有意义。</strong></li>
<li><strong>$ SF $（sign Flag 符号标志）：结果是负为 1，否则为 0</strong>，<strong>对于无符号数运算，SF没有意义。</strong></li>
<li><strong>$ ZF $（Zero Flag 零标志）：运算结果是 0 位 1，否则为 0</strong>，<strong>无符号数和带符号数运算，ZF都有意义。</strong></li>
<li><strong>$ CF $（Carry Flag进位 &#x2F; 借位标志）：进位 &#x2F; 借位时为 1，否则为 0</strong>，<strong>判断是否发生溢出。</strong></li>
</ul>
<h3 id="8-3-1-OF-硬件产生方法"><a href="#8-3-1-OF-硬件产生方法" class="headerlink" title="8.3.1.OF 硬件产生方法"></a>8.3.1.OF 硬件产生方法</h3><p><strong>OF 硬件产生方法：$最高位产生的进位 C_{s} ⊕ 次高位产生的进位C_{1} $</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917468.png" loading="lazy"></p>
<p><strong>例如</strong>：$ [A+C]<em>{补}&#x3D;0,0001111+0,1111100&#x3D;1,0001011 $，真值 - 117。由于 $C</em>{s}&#x3D;0 $， $ C_{1}&#x3D;1 $，所以溢出。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917366.png" loading="lazy"></p>
<h3 id="8-3-2-SF-硬件产生方法"><a href="#8-3-2-SF-硬件产生方法" class="headerlink" title="8.3.2.SF 硬件产生方法"></a>8.3.2.SF 硬件产生方法</h3><p><strong>SF 硬件产生方法：它等于最高位的本位和，注意 SF 对无符号数加减无意义</strong>。</p>
<h3 id="8-3-3-ZF-硬件产生方法"><a href="#8-3-3-ZF-硬件产生方法" class="headerlink" title="8.3.3. ZF 硬件产生方法"></a>8.3.3. ZF 硬件产生方法</h3><p><strong>ZF 硬件产生方法：只有当运算结果所有比特位全为 0 时，ZF 才等于 1</strong>。</p>
<h3 id="8-3-4-CF-硬件产生方法"><a href="#8-3-4-CF-硬件产生方法" class="headerlink" title="8.3.4. CF 硬件产生方法"></a>8.3.4. CF 硬件产生方法</h3><p><strong>CF 硬件产生方法：$最高位产生的进位 C_{s} ⊕ sub $信号，注意 CF 对有符号数的加减法无意义</strong>。</p>
<h3 id="8-4-5-总结"><a href="#8-4-5-总结" class="headerlink" title="8.4.5.总结"></a>8.4.5.总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917217.png" loading="lazy"></p>
<h1 id="9-定点数的移位运算"><a href="#9-定点数的移位运算" class="headerlink" title="9.定点数的移位运算"></a>9.定点数的移位运算</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917274.png" alt="image-20230413172430011" loading="lazy"></p>
<p><strong>定点数的移位运算：根据操作对象的不同可以划分为</strong></p>
<ul>
<li><p><strong>算数移位：</strong> <strong>有符号数</strong>的移位。</p>
</li>
<li><p><strong>逻辑移位：</strong> 操作对象是逻辑代码，可视为<strong>无符号数</strong>。</p>
</li>
</ul>
<p><strong>其实我们很早之前就已经接触过移位运算了</strong>。</p>
<ul>
<li>比如 $ 985.211 × 10^{1} &#x3D;9852.11 $就相当于小数点右移 <code>1</code> 位。</li>
<li>比如 $985.211 \div 10^{1}&#x3D;98.5211 $ 就相当于小数点左移 <code>1</code>位。</li>
</ul>
<p><strong>移位的本质：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。</strong></p>
<h2 id="9-1-算数移位"><a href="#9-1-算数移位" class="headerlink" title="9.1.算数移位"></a>9.1.算数移位</h2><p><strong>算数移位：</strong> 算数移位的对象是<strong>有符号数</strong>，在移位的过程中<strong>符号位保持不变</strong>。</p>
<h3 id="9-1-1-原码的算数移位"><a href="#9-1-1-原码的算数移位" class="headerlink" title="9.1.1.原码的算数移位"></a>9.1.1.原码的算数移位</h3><p><strong>算数右移：</strong></p>
<ul>
<li>如果移出去的是 0，那么算数右移相当于<strong>除以了 2。</strong></li>
<li>如果移出去的是 1，<strong>会丢失精度。</strong></li>
</ul>
<p>如下是 - 20 的原码：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917705.png" loading="lazy">  </p>
<p>算数右移时：<strong>符号位不动，向右移动 1 位，高位补 0</strong>。</p>
<ul>
<li><p>由于移出去的是 0，所以 - 20 变为了 - 10,-10 变为了 - 5 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917782.png" loading="lazy"></p>
</li>
</ul>
<p>此时最低位为 1，再次右移一位，其结果为 - 2。</p>
<ul>
<li><p>移出去的是 1，精度丢失  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917943.png" loading="lazy"></p>
</li>
</ul>
<p><strong>算数左移：</strong></p>
<ul>
<li>如果移出去的是 0，那么算数左移相当于<strong>乘以了 2。</strong></li>
<li>如果移出去的是非 0，<strong>会丢失精度。</strong></li>
</ul>
<p>算数左移时：<strong>符号位不动，低位补 0</strong>。</p>
<ul>
<li><p>由于移出去的是 0，所以 - 20 变为了 - 40，-40 变为了 - 80  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917345.png" loading="lazy"></p>
</li>
</ul>
<p>此时最高位为 1，再次左移一位，出现严重误差。</p>
<ul>
<li><p>左移时，要将高位的 1 抛弃，而 7 位二进制表示范围为 - 128~128，理想的结果 - 160，自然超出了范围  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917641.png" loading="lazy"></p>
</li>
</ul>
<h3 id="9-1-2-反码的算术移位"><a href="#9-1-2-反码的算术移位" class="headerlink" title="9.1.2.反码的算术移位"></a>9.1.2.反码的算术移位</h3><p><strong>正数的反码算数移位和原码相同</strong>。</p>
<p><strong>负数的反码算数移位</strong>：反码除了符号位外其余各位和原码是一一取反的，因此反码的 1 对应原码的 0，反码的 0 对应原码的 1。<strong>所以反码算数右移时高位补 1，低位舍弃；算数左移时低位补 1，高位舍弃</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918673.png" loading="lazy"></p>
<h3 id="9-1-3-补码的算数移位"><a href="#9-1-3-补码的算数移位" class="headerlink" title="9.1.3.补码的算数移位"></a>9.1.3.补码的算数移位</h3><p><strong>正数的补码算数移位和原码相同。</strong></p>
<p><strong>负数的补码算数移位</strong>：负数补码是在反码末位 + 1 后得到的，所以这就导致<strong>反码最右边连续的 1 都会因为进位而变为 0，直到进位碰到第一个 0 为止</strong>。因此，负数补码中，<strong>最右边的（最后一个 1）及其右面与原码相同，而其左面则与反码相同。</strong></p>
<p>因此，<strong>补码算数右移时和反码相同，也即高位补 1，低位舍弃；而算数左移时又会和原码相同，也就是低位补 0，高位舍弃</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918036.png" loading="lazy"></p>
<h3 id="9-1-4-总结"><a href="#9-1-4-总结" class="headerlink" title="9.1.4.总结"></a>9.1.4.总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918762.png" loading="lazy"></p>
<h2 id="9-2-逻辑移位"><a href="#9-2-逻辑移位" class="headerlink" title="9.2.逻辑移位"></a>9.2.逻辑移位</h2><p><strong>逻辑移位：</strong> 逻辑移位比较简单，可以看作是<strong>对 “无符号数” 的算数移位。</strong></p>
<ul>
<li><p><strong>逻辑右移时高位补 0，低位舍弃。</strong></p>
</li>
<li><p><strong>逻辑左移时低位补 0，高位舍弃</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918072.png" loading="lazy"></p>
</li>
</ul>
<h2 id="9-3-循环移位"><a href="#9-3-循环移位" class="headerlink" title="9.3.循环移位"></a>9.3.循环移位</h2><p><strong>循环移位：循环移位分为如下两种</strong></p>
<ul>
<li>带<strong>进位标志位 CF</strong> 的循环移位（大循环）。</li>
<li><strong>不带进行标志位</strong>的循环移位（小循环）。</li>
</ul>
<p><strong>循环移位的特点是：移出的数位又被移入数据中，是否需要进位则看有没有将进位标志加入循环位移。循环位移十分适合将数据的低字节和高字节之间进行互换</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918039.png" loading="lazy"></p>
<h1 id="10-定点数乘法运算（原码-x2F-补码一位乘法）"><a href="#10-定点数乘法运算（原码-x2F-补码一位乘法）" class="headerlink" title="10.定点数乘法运算（原码&#x2F;补码一位乘法）"></a>10.定点数乘法运算（原码&#x2F;补码一位乘法）</h1><h2 id="10-1-乘法运算基本思想"><a href="#10-1-乘法运算基本思想" class="headerlink" title="10.1.乘法运算基本思想"></a>10.1.乘法运算基本思想</h2><p>关定点数的乘法，其实我们在小学就学习过，就是经典<strong>列竖式相乘</strong>：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922278.png" loading="lazy"></p>
<p>其中，我们印象最深的应该就是计算过程中的<strong>错位问题</strong>了。</p>
<p>在计算机中，相乘时使用的二进制，其基本逻辑和竖式相乘一致。如下是两个二进制数相乘，其中被乘数为<code>0.1101</code>，乘数为 <code>0.1011</code> 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918651.png" loading="lazy"></p>
<p>我们将乘数看作为位权之和，即$ 0.1011&#x3D;1×2^{-1}+0×2^{-2}+1×2^{-3}+1×2^{-4} $。<br>，被乘数写成 $ A$ 与$ 2^{n} $相乘的形式，即 $ 0.1101&#x3D;1101×2^{-4}$。</p>
<p>那么此乘法过程可以等价为下面的形式  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918767.png" loading="lazy"> </p>
<p>把竖式写全也就是下面的这个样子  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918421.png" loading="lazy"></p>
<p><strong>由于二进制的乘数每一位只可能出现 0 或 1，因此每次运算的结果要么是全 0，要么只是被乘数乘以 $2^{n}$，实际结果只是小数点的不同，而计算机处理小数点位置非常方面，使用移位操作即可完成</strong>。</p>
<h2 id="10-2-原码一位乘法"><a href="#10-2-原码一位乘法" class="headerlink" title="10.2.原码一位乘法"></a>10.2.原码一位乘法</h2><h3 id="10-2-1-实现原理"><a href="#10-2-1-实现原理" class="headerlink" title="10.2.1.实现原理"></a>10.2.1.实现原理</h3><p>逻辑看似很简单，但是如何让机器实现这是一个问题。如果要实现这一问题，必须解决以下三个问题：</p>
<ul>
<li>实际数字有正有负，符号位应当如何处理？</li>
<li>乘积运算时位数扩大很厉害，如何处理？</li>
<li>每次运算时的结果都要保存下来，如果相加？</li>
</ul>
<p>其中符号位很方便处理，符号位 &#x3D; $s &#x3D;x_{s}⊕y_{s} $即可判断，让数值位取绝对值进行乘法运算即可。</p>
<p><strong>case：机器字长为 $n+1&#x3D;5$位， $ [x]<em>{原}&#x3D;0.1101，[y]</em>{原}&#x3D;0.1011 $，采用原码一位乘法求 $xy $。</strong></p>
<p>还记得 <a href="">(计算机组成原理) 第一章计算机系统概述 -计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这一节我们讲到过的运算器的组成吗？其中涉及乘法时会用到 $ACC $， $MQ $， $X$ 这三个寄存器  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918572.png" loading="lazy">  </p>
<p>接下来我们详细叙述一下这个过程。<strong>开始， $X$ 是被乘数， $Y$ 是乘数，因此 $X$ 位于 X 寄存器中， $Y$ 位于 MQ 寄存器中，并且运算开始前要将 ACC 置为 0</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918982.png" loading="lazy"></p>
<p>对应我们竖式乘法的逻辑，<strong>此时从低位到高位，依次用乘数的每一位乘被乘数</strong>，因此在这里进行第一次运算时我们把 MQ 寄存器中参与运算的那一位方块的颜色加深  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918842.png" loading="lazy">  </p>
<p><strong>如果当前参与运算的乘数的这一位是 1，则 $ACC $ 加上被乘数；如果当前位是 0，则 $ACC $ 加上 0</strong>，也即<code>(ACC)+(X)-&gt;(ACC)</code>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918152.png" loading="lazy"></p>
<p>在进行下一位竖式运算时，必须偏移一个位置，对应于计算机处理时则是<strong>让 ACC 和 MQ 中的数据统一逻辑右移一位</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918274.png" loading="lazy"></p>
<ul>
<li>这样做本质实现的就是错位相加。</li>
</ul>
<p>接着次低位来到了最低位的位置，再次进行<code>(ACC)+(X)-&gt;(ACC)</code>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918007.png" loading="lazy"></p>
<p>  <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918789.png" loading="lazy">  </p>
<p>剩余的步骤均重复上述过程。</p>
<h3 id="10-2-2-手算模拟"><a href="#10-2-2-手算模拟" class="headerlink" title="10.2.2.手算模拟"></a>10.2.2.手算模拟</h3><p>考试的时候，如果出到这样的题目，<strong>具体步骤如下</strong>  ：</p>
<p>设 $s [X]<em>{原}&#x3D;x</em>{s}$，$ s [Y]<em>{原}&#x3D;y</em>{s}$</p>
<ol>
<li>被乘数和乘数均取绝对值参与运算，符号位为 $ x_{s}⊕y_{s}$。</li>
<li>部分积的长度同被乘数，取 $n+1 $位，以便存放乘法过程中绝对值大于等于的值，初值为<code> 0</code>。</li>
<li><strong>从乘数的最低位 $y_{n}$​开始判断：若$y_{n}&#x3D;1$，则部分积加上被乘数 $|x| $，然后右移一位；若 $y_{n}&#x3D;0 $，则部分积加上 0，然后右移一位。</strong></li>
<li>重复步骤 3，判断 $n$次。</li>
</ol>
<p>注意：</p>
<ul>
<li>由于乘积的数值部分是两数绝对值相乘的结果，<strong>因此原码一位乘法运算过程中的右移均为逻辑右移</strong>。</li>
<li>考虑到运算时可能出现绝对值大于 1 的情况（但并非溢出），<strong>所以部分积和被乘数取双符号</strong>。</li>
</ul>
<p>**case: 设机器字长为 5 位（n+1）, $ x&#x3D;-0.1101$，$ y&#x3D;0.1011$，采用原码一位乘法求解 $xy $**。</p>
<p>解： $|x|&#x3D;00.1101 $, $ |y|&#x3D;00.1011$，过程如下  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918065.png" loading="lazy"></p>
<p>**因此符号位为 $ P_{s}&#x3D;x_{s}⊕y_{s}&#x3D;1&#x3D;1⊕0&#x3D;1 $，得 $ x·y&#x3D;-0.10001111 $**。</p>
<h1 id="11-补码一位乘法（-Booth算法，考察重点）"><a href="#11-补码一位乘法（-Booth算法，考察重点）" class="headerlink" title="11.补码一位乘法（ Booth算法，考察重点）"></a>11.补码一位乘法（ Booth算法，考察重点）</h1><p>定点数乘法中最有可能考察的便是补码一位乘法。因为机器做加减法时采用的是补码，倘若做乘法前再将补码转为原码，计算完成之后再转化为补码，那就很麻烦了，还不如直接用补码计算。</p>
<p>补码一位乘法主要分为<strong>校正法和比较法</strong>，校正法了解即可，而比较法（又叫Booth算法）则是考察的重点。具体规则如下：</p>
<p>①：<strong>被乘数与部分积一般取双符号位，并且符号位参与运算</strong>。</p>
<ul>
<li>一个原因是一旦符号位参与运算就一定要使用多符号位，因为一旦溢出，单符号位就会出错</li>
<li>另一个原因是，补码的右移时要看符号位而定的，如果采用单符号位，一旦数值部分的进位把符号给移掉了，下次移位就不知道该怎么办了。</li>
</ul>
<p>②：<strong>乘数取单符号位以决定最后一步是否需要校正，也即是否需要加$[-x]_{补}$​</strong><br>③：<strong>乘数末尾增设辅助位，$y_{n+1} $，初始值为 0</strong><br>④：<strong>根据 ($y_{n} $，$ y_{n+1} $)判断位，进行运算，步骤和上面原码一位乘法一致</strong><br>⑤：<strong>按上述算法进行 n+1, 其中最后一步也即 n+1 步不再移位，仅根据 $ y_{0},y_{1} $​比较结果决定是否需要加减 $ x_[补] $</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918334.png" loading="lazy">  </p>
<p>从上面图中大家可以看出 MQ 中的最低位现在是辅助位，这里就和原码乘法的最低位不一致了，<strong>所以这里我们用带有双引号的——“最低位” 表示运算时真正的最低位，而不是辅助位</strong></p>
<ul>
<li>辅助位<strong>减</strong> “最低位”&#x3D;1 时，$ (ACC)+[x]_{补}$</li>
<li>辅助位<strong>减</strong> “最低位”&#x3D;0 时，$ (ACC)+0$</li>
<li>辅助位<strong>减</strong> “最低位”&#x3D;-1 时， $ (ACC)+[-x]_{补}$</li>
</ul>
<p>**$case $: 假设机器字长为 5 位（含 1 位符号位，$n&#x3D;4 $）， $x&#x3D;-0.1101$，$y&#x3D;0.1011$，采用 $Booth$ 算法求 $xy $**。</p>
<p>解：$[x]<em>{补}&#x3D;11.0011$，$ [-x]</em>{补}&#x3D;00.1101$，$ [y]_{补}&#x3D;0.1011 $。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918042.jpeg" loading="lazy"></p>
<h1 id="12-定点数除法运算（原码-x2F-补码一位除法）"><a href="#12-定点数除法运算（原码-x2F-补码一位除法）" class="headerlink" title="12.定点数除法运算（原码&#x2F;补码一位除法）"></a>12.定点数除法运算（原码&#x2F;补码一位除法）</h1><h2 id="12-1-除法运算基本思想"><a href="#12-1-除法运算基本思想" class="headerlink" title="12.1.除法运算基本思想"></a>12.1.除法运算基本思想</h2><p>关于定点数的除法，我们在小学其实就已经学习过了，就是<strong>列竖式除法</strong>, 比如 $0.211÷0.985 $，我们首先习惯同时扩大 $n$倍。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919136.png" loading="lazy">  </p>
<p>在上面的例子中， $ 0.211÷0.985&#x3D;0.214 $ 余 210，<strong>它就等价于</strong> $0.211&#x3D;0.985×0.214+0.000210 $，也就是说这可以转为成乘法的，也即  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919337.png" loading="lazy">  </p>
<p>在计算机中，运算时使用的是二进制，比如$ x&#x3D;0.1011$（被除数），$y&#x3D;0.1101$（除数)， $ x÷y $ 如下：</p>
<p><strong>运算时忽略小数点，每确定一位商就进行一次减法，得到 4 位余数，在余数末尾补 0，再确定下一位商，确定 5 位商即可停止（这里机器字长是 5 位）</strong>。</p>
<ul>
<li>如果补位后所得余数部分大于除数，那么就商 1。</li>
<li>如果补位后所得余数部分小于余数，那么就商 0。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919520.png" loading="lazy"></p>
<p>和乘法一样，补全位数后就是下面这样  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919343.png" loading="lazy"></p>
<p>因此 $x÷y$ 结果为 0.1101，余数为 $0.00000111$。</p>
<h2 id="12-2-原码一位除法-恢复余数法"><a href="#12-2-原码一位除法-恢复余数法" class="headerlink" title="12.2.原码一位除法(恢复余数法)"></a>12.2.原码一位除法(恢复余数法)</h2><h3 id="12-2-1-实现原理"><a href="#12-2-1-实现原理" class="headerlink" title="12.2.1.实现原理"></a>12.2.1.实现原理</h3><p>逻辑看似很简单，但是如何让机器实现这是一个问题。其中符号位的处理就不用再强调了，和乘法一样，仍然使用异或完成，于是实际运算时采用两个数的绝对值完成。</p>
<p>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $x÷y$</p>
<ul>
<li>$∣x∣&#x3D;0.1011$</li>
<li>$ |y|&#x3D;0.1101$</li>
<li>$ [|y|]_{补}&#x3D;0.1101$</li>
<li>$[-|y|]_{补}&#x3D;1.0011 $</li>
</ul>
<p>还记得 <a href="">(计算机组成原理) 第一章计算机系统概述 - 计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这一节我们讲到过的运算器的组成吗，其中涉及除法时会用到 $ACC $， $MQ $， $X$ 这三个寄存器  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919010.png" loading="lazy"></p>
<p>开始的时候， <strong>$Y$ 是除数，位于 X 寄存器内，ACC 寄存器存放的是被除数（x）或余数，MQ 中存放商，MQ 中灰色加重的方格表示当前要确定的一位商</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919493.png" loading="lazy"></p>
<p>前面手算时，每一位商到底取 0 还是 1，<strong>是通过判断当前余数和除数的大小确定的</strong>，因此很显然，我们的 ACC 寄存区和 X 寄存区天然就存储了余数和除数。但实际情况是，<strong>计算机并不会进行比较，它会不管三七二十一直接商 1，如果出错再改为商 0，并恢复余数。</strong></p>
<ul>
<li>商 1 时，其实就是余数减去除数, 也即是<code>(ACC)-(X)-&gt;ACC</code>。</li>
</ul>
<p>于是，这里首先计算机先商 1（但是本应该先商 0），因此此时就会求余数：<code>(ACC)-(X)-&gt;ACC</code>, 也即$[-|y|]_{补} $（计算机依靠加法实现减法），也即$ 01011+10011&#x3D;11110 $。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919072.jpeg" loading="lazy"></p>
<p><strong>此时符号位 1，计算机察觉错误，于是改为商 0，同时既然是商 0，那么就不应该减去除数，而应该减去 0（什么也不做），所以这里直接采取逆过程，加上除数即可。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919393.jpeg" loading="lazy"></p>
<p><strong>所以现在我们就完成了一位的商，在手算中，我们商完一位后会错位一位补位，然后再商下一位，而在这里对应的就是将 ACC 和 MQ 中的内容逻辑左移即可</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919526.png" loading="lazy"></p>
<p>接着计算机再次商 1，此时检查符号位为 0，说明是正的，说明计算机没有商错误，那么不需要恢复余数  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919777.png" loading="lazy"></p>
<p>剩下的就是不断左移，运算的过程了。 </p>
<p>最后我们假定的机器字长为 5 位，因此只能求 5 位的商。<strong>不过需要注意的是，如果最后一位商 1 后，导致了 ACC 出现负数，那么仍然需要改为 0，并恢复余数</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919658.png" loading="lazy">  </p>
<p><strong>最后，我们这里举的例子是小数，所以其小数点的位置隐含在符号位后面。最后实际的余数是 $2^{-n} $（ $n$为机器字长）</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919947.png" loading="lazy"></p>
<h3 id="12-2-2-手算模拟"><a href="#12-2-2-手算模拟" class="headerlink" title="12.2.2.手算模拟"></a>12.2.2.手算模拟</h3><p>考试的时候，如果出到这样的题目，<strong>具体步骤如下</strong> 。<br>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $x÷y$</p>
<ul>
<li>$∣x∣&#x3D;0.1011$</li>
<li>$ |y|&#x3D;0.1101$</li>
<li>$ [|y|]_{补}&#x3D;0.1101$</li>
<li>$[-|y|]_{补}&#x3D;1.0011 $</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922279.png" loading="lazy"></p>
<h2 id="12-3-原码一位除法：加减交替法（不恢复余数法）"><a href="#12-3-原码一位除法：加减交替法（不恢复余数法）" class="headerlink" title="12.3.原码一位除法：加减交替法（不恢复余数法）"></a>12.3.原码一位除法：加减交替法（不恢复余数法）</h2><p>可以看出恢复余数法实际还是挺繁琐的，主要是当余数为负时，它还要加上除数，恢复到上一状态再左移。</p>
<p>而加减交替法是恢复余数的优化，具体规则为：<strong>若余数为负，直接商 0，并让余数左移 1 位再加上除数</strong></p>
<p>$case$ : 设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $X$÷ $Y$</p>
<ul>
<li>$∣x∣&#x3D;0.1011$</li>
<li>$ |y|&#x3D;0.1101$</li>
<li>$ [|y|]_{补}&#x3D;0.1101$</li>
<li>$[-|y|]_{补}&#x3D;1.0011 $</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922280.png" loading="lazy"></p>
<p><strong>注意：最后一步如果出现负数，仍然需要恢复余数！！！</strong></p>
<h2 id="12-4-补码一位除法"><a href="#12-4-补码一位除法" class="headerlink" title="12.4.补码一位除法"></a>12.4.补码一位除法</h2><p>补码除法采用加减交替法完成，与原码除法的有所区别的是：</p>
<ul>
<li><strong>符号位参与运算。</strong></li>
<li>被除数（余数）、除数采用双符号位。</li>
</ul>
<p>运算的具体细节区别如下：</p>
<ul>
<li>原码除法，首先一上来就会让被除数减去除数的绝对值的补码；<strong>在补码除法中，若被除数和除数同号，则被除数减去除数，如果异号，则被除数加上除数</strong>。</li>
<li>得到新的余数后判断：<strong>若余数和除数同号，则商 1，余数左移一位减去除数；若余数和除数异号，则商 0，余数左移一位加上除数。</strong></li>
<li>在原码除法中如果最后一步余数出现负值，那么需要进行恢复余数；<strong>在补码除法中，我们直接把最后一位商置为 1 即可，这样做很省事，其精度也不会超过 $2^{-n} $。</strong></li>
</ul>
<p>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位），$+x&#x3D;0.1000 $， $y&#x3D;-0.1011 $，采用补码加减交替法求 $x÷y$</p>
<ul>
<li>$ [x]_{补}&#x3D;00.1000 $</li>
</ul>
<ul>
<li>$ [y]_{补}&#x3D;11.0101 $</li>
<li>$ [-y]_{补}&#x3D;00.1011 $</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922281.png" loading="lazy"></p>
<p>因此最后的结果$[x&#x2F;y]_{补}&#x3D;1.0101$，余数为 $0.0111×2^{-4} $。</p>
<h2 id="12-5-总结"><a href="#12-5-总结" class="headerlink" title="12.5.总结"></a>12.5.总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922282.png" alt="image-20230413183656017" loading="lazy"></p>
<h1 id="13-详解C语言中的强制类型转换"><a href="#13-详解C语言中的强制类型转换" class="headerlink" title="13.详解C语言中的强制类型转换"></a>13.详解C语言中的强制类型转换</h1><h2 id="13-1-无符号数和有符号数"><a href="#13-1-无符号数和有符号数" class="headerlink" title="13.1.无符号数和有符号数"></a>13.1.无符号数和有符号数</h2><p>有如下代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">short</span> x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span><span class="token comment">//短整型，顶点负整数</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span><span class="token comment">//无符号短整型</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们知道在计算机中数据是以<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A5%E7%A0%81&spm=1001.2101.3001.7020">补码</a>的形式保存的，因此变量<code>x</code>的补码形式为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0001</span> <span class="token number">1111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>第二句代码进行强制类型转换，把一个有符号转换为了无符号，并用无符号变量保存；<strong>在这个过程中数据的内容是没有被改变的，只是改变了解释的方式</strong>，也就说说变量 y 的内容依然是：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0001</span> <span class="token number">1111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>但是在解释是计算机会把第一位的符号位当作数值位，因此 y 对应的真值是 61215</strong>。</p>
<h2 id="13-2-长整数变为短整数"><a href="#13-2-长整数变为短整数" class="headerlink" title="13.2.长整数变为短整数"></a>13.2.长整数变为短整数</h2><p>有如下代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">165537</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token operator">-</span><span class="token number">34991</span><span class="token punctuation">;</span><span class="token comment">//整形</span>
<span class="token keyword">short</span> c<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
<span class="token keyword">short</span> d<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token comment">//强制类型转换，长整形转为短整型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这个例子中短整型为 16 位，整形为 32 位，因此将长整形转换为短整型，短整型的变量肯定不能完全保存，会丢失精度。具体规则为：<strong>高位截断，保留低位</strong>。</p>
<p>比如 a 的十六进制为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x000286a1</span>
<span class="token number">0010</span> <span class="token number">1000</span> <span class="token number">0110</span> <span class="token number">1010</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用 c 保存后，值为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x86a1</span>
<span class="token number">1000</span> <span class="token number">0110</span> <span class="token number">1010</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>1000 0110 1010 0001</code>是 c 的补码，属于有符号数，是一个负数，其原码（负数原码等于补码除符号位按位取反后 + 1）为<code>1111 1001 0101 1111</code>，对应真值 - 31071。</p>
<p>再比如，b 的十六进制为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0xffff7751</span>
<span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">0111</span> <span class="token number">0111</span> <span class="token number">0101</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用 d 保存后，值为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x7751</span>
<span class="token number">0111</span> <span class="token number">0111</span> <span class="token number">0101</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><code>0111 0111 0101 0001</code>是 d 的补码，属于有符号数，是一个正数，其原码（正数原码和补码一致）为<code>0111 0111 0101 0001</code>，对应真值 30545。</p>
<h2 id="13-3-短整数变为长整数"><a href="#13-3-短整数变为长整数" class="headerlink" title="13.3.短整数变为长整数"></a>13.3.短整数变为长整数</h2><p>有如下代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">short</span> x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span><span class="token comment">//短整型</span>
<span class="token keyword">int</span> m<span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment">//使用整形保存短整型</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> n<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span><span class="token comment">//将x强制转为为无符号，然后复制给无符号短整型</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> p <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token comment">//把无符号短整型n变为无符号整形</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这属于之前讲到过的符号扩展问题。<strong>这里 x 是一个负数，所以会在符号位和原有的数值位之间添上 1</strong>，这样做最后的结果不改变，只是补码的长度发生改变  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922283.png" loading="lazy">  </p>
<p><code>unsigned short n=(unsigned short)x</code>将 x 这个有符号短整型转换为了无符号短整型，<strong>计算机会将其补码原封不动的赋值给 n，但是会按照无符号的规则解析真值</strong>，真值为 61215。</p>
<p><code>unsigned int p = n</code>属于无符号到无符号的转换，<strong>直接填 0 即可</strong>。  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922285.png" loading="lazy"></p>
<h1 id="14-数据的存储和排列"><a href="#14-数据的存储和排列" class="headerlink" title="14.数据的存储和排列"></a>14.数据的存储和排列</h1><h2 id="14-1-大小端模式"><a href="#14-1-大小端模式" class="headerlink" title="14.1.大小端模式"></a>14.1.大小端模式</h2><p>在存储数据的时候，数据从低位到高位可以从左到右排列，也可以按从右到左的方式排列。因此，我们无法用最左或最右来表征数据的最高位或最低位，<strong>通常用最低有效字节（$LSB $）和最高有效字节 ( $ MSB $) 来分别表示数的低位和高位</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922286.png" loading="lazy"></p>
<p><strong>现代计算机基本采用字节编址，即每个地址编号存放一个字节</strong>。不同类型的数据占用的字节数不同，（int 和 float 的数据占用 4 个字节，double 则占用 8 个字节等），但程序中的每个数据只给定了一个地址。假设变量 i 的地址为 80 00H，字节 01H、23H、45H、67H 应该各有一个内存地址，<strong>那么地址 0800H 对应 4 字节中哪字节的地址呢？这就是字节排列顺序的问题了。</strong></p>
<p><strong>多字节数据都存放在连续的字节序列当中，根据数据中各字节在连续字节序列中的排列顺序不同，可以有两种方式：大端方式（bid endian）和小端方式 (little endian)</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922287.png" loading="lazy"></p>
<ul>
<li><strong>大端方式</strong>：按照最高有效字节到最低有效字节的顺序存储数据，符合人类阅读习惯。</li>
<li><strong>小端方式</strong>：按照最低有效字节到最高有效字节的顺序存储数据。</li>
</ul>
<p>也可以这样描述 </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922288.png" loading="lazy"></p>
<ul>
<li><strong>大端方式</strong>：数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地中；</li>
<li><strong>小端方式</strong>：数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中</li>
</ul>
<p>我们的计算机一般都是小端机，采用小端方式是有好处的，方便计算机处理。</p>
<p>例如下面机器代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">400</span>d3<span class="token operator">:</span> <span class="token number">01</span> <span class="token number">05</span> <span class="token number">64</span> <span class="token number">94</span> <span class="token number">04</span> <span class="token number">08</span>       add <span class="token operator">%</span> eax<span class="token punctuation">,</span><span class="token number">0x8049464</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>4004d3</code>：十六进制表示的地址。</li>
<li><code>01 05 43 0b 20 00</code>：指令的机器代码。</li>
<li><code>add %eax,0x8049464</code>：指令的汇编形式，该指令的操作数是一个立即数<code>0x8049464。</code></li>
</ul>
<p>执行指令时，从指令代码的后 4 字节取出该立即数，立即数存放的字节序列为 64H,94H,04H,08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到 08049464H，去掉开头 0，得到值 0x8049464，<strong>在阅读小端存储方式机器代码时，注意是相反顺序</strong>，比如下面：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922289.png" loading="lazy"></p>
<h2 id="14-2-内存（边界）对齐"><a href="#14-2-内存（边界）对齐" class="headerlink" title="14.2.内存（边界）对齐"></a>14.2.内存（边界）对齐</h2><p>假设存储字长为 32 位，<strong>可按照字节、半字节和字寻址</strong>。<strong>对于机器字长为 32 位的计算机，数据以边界对齐方式存储，半字地址一定是 2 的整数倍，子地址一定是 4 的整数倍，这样无论所取的数据是字节、半字还是字，均可以一次取出，当存储的数据不满足上述要求时，通常填充空白字节使其符合要求</strong>，典型的以空间换时间的做法。</p>
<p>如下：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919060.png" loading="lazy">  </p>
<p>更多关于内存对齐的问题，可以移步这篇文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39183034/article/details/116457144?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162823137816780269873401%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162823137816780269873401&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-116457144.pc_v2_rank_blog_default&utm_term=%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90&spm=1018.2226.3001.4450">C 语言重难点：内存对齐和位段</a></p>
<h1 id="15-浮点数的表示"><a href="#15-浮点数的表示" class="headerlink" title="15.浮点数的表示"></a>15.浮点数的表示</h1><p><strong>浮点表示法是指以适当的方式将比例因子表示在数据中，让小数点的位置根据需要而浮动</strong> 。<br>这样，在位数有限的情况下，即扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量（$9×10^{-28}g $）或太阳的质量（$ 2×3^{33}g $）是非常不方便的。</p>
<h2 id="15-1-浮点数的表示格式"><a href="#15-1-浮点数的表示格式" class="headerlink" title="15.1.浮点数的表示格式"></a>15.1.浮点数的表示格式</h2><p>在小学学习科学计数时，我们知道对于： $ +302657264526 $这么长的数字可以用科学计数法表示为：  </p>
<ul>
<li>$+3.026×10^{11} $</li>
</ul>
<p>而浮点数的表示格式与科学计数法有异曲同工之妙  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919061.png" loading="lazy"></p>
<ul>
<li><strong>阶码</strong>：反映浮点数的表示范围及小数点的实际位置。</li>
<li><strong>尾数</strong>：其数值部分的位数 $n$反映了浮点数的精度  。<br>因此，通常浮点数表示为：<br>$N&#x3D;r^{E}×M$</li>
</ul>
<p>其中 <code>r</code> 是浮点数阶码的底（隐含），与尾数的基数相同（二进制中 $ r&#x3D;2$），<strong>E 是阶码，是一个常用补码或移码表示的定点整数，M 是尾数，是一个常用原码或补码表示的定点小数。</strong></p>
<p>因此，这种格式可以这样理解：<strong>尾数给出了一个小数（数符指明其正负性），同时阶码指明了小数点要向前（阶符为负）还是向后（阶符为正）移动几位</strong>。</p>
<p>$ case1: $: 例如浮点数 a 的阶码（补码）为 $ 0,01 $，尾数（补码）为$ 1.1001$，空间中存储的方式就是下面这样的  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919062.png" loading="lazy"></p>
<p>a 的阶码对应的真值为 + 1，$尾数对应的真值为 &#x3D;-(  2^{-2}+2^{-3}+2^{-4})&#x3D;- 0.0111 $，则 a 的真值为：$ 2^{1}×(-0.0111)&#x3D;-0.111 $</p>
<p>$case2 $：例如 b 的阶码（补码）为 0 , 10 0,10 0,10，尾数（补码）为 $ 0.01001$，空间存储如下  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919063.png" loading="lazy"></p>
<ul>
<li>上述后面 1 被抛弃了，精度丢失。</li>
</ul>
<p>b 的阶码对应真值为 + 2，尾数对应真值为 $ +(2^{-2}+2^{5})&#x3D;+0.01001 $，因此 b 的真值为： $2^{2}×(+0.01001)&#x3D;+1.001 $。</p>
<h1 id="15-2-浮点数尾数的规格化"><a href="#15-2-浮点数尾数的规格化" class="headerlink" title="15.2.浮点数尾数的规格化"></a>15.2.浮点数尾数的规格化</h1><h2 id="15-2-1-左规和右规"><a href="#15-2-1-左规和右规" class="headerlink" title="15.2.1.左规和右规"></a>15.2.1.左规和右规</h2><p>可以看到，上面的 $case 2 $ 中，由于尾数位数不够，因此最后一位 1 丢失，<strong>导致该种表示方法下的浮点数精度丢失</strong>。就像我们在学习科学计数法的时候要求过的一样，尽量保证不要有$0.003×10^{13} $ 这样的形式出现，必须保证最高位是一个有效位，因为无效的 0 不但不会增加精度，反而会占用位数。</p>
<p><strong>因此为了提高运算的精度，需要充分利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值</strong>。非规格化浮点数<strong>需要进行规格化操作</strong>才能变成规格化浮点数。所谓规格化操作，是指通过调整一个非规划浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高位上保证是一个有效值。</p>
<p>规格化方法主要有两种：</p>
<ul>
<li><strong>左规</strong>：<strong>将尾数算数左移一位，阶码就减 1（基数为 2</strong>），<strong>左规可能要进行多次</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919064.png" loading="lazy"></p>
<ul>
<li><strong>右规</strong>：当浮点数运算的结果尾数出现溢出（双符号位为 01 或 10）时，<strong>将尾数算数右移一位，阶码加 1（基数为 2 时）</strong> 的方法称为右规，<strong>右规只需进行一次。</strong></li>
</ul>
<p>下面是一个需要右规的例子  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919065.png" loading="lazy"></p>
<h2 id="15-2-2-规格化浮点数的特点"><a href="#15-2-2-规格化浮点数的特点" class="headerlink" title="15.2.2.规格化浮点数的特点"></a>15.2.2.规格化浮点数的特点</h2><p>规格化浮点数的尾数 M M M 的绝对值应该满足 $ \frac{1}{r} \leq |M| \leq 1 $，若 <code>r</code>为 2，则有 $ \frac{1}{2} \leq |M| \leq 1 $。规格化表示的尾数形式如下：</p>
<p><strong>1：原码规格化后</strong></p>
<p>_规格化的原码尾数，最高数值位一定是 1_。</p>
<ul>
<li><strong>正数</strong>：形式为<code>0.1××...×</code>，其最大值表示为<code>0.111...1</code>，最小值表示为<code>0.100...0</code>，尾数的表示范围为 $ \frac{1}{2} \leq M \leq (1-2^{-n}) $</li>
<li><strong>负数</strong>：形式为<code>1.1××...×</code>，其最大值表示为<code>1.10×××0</code>，最小值表示为<code>1.111...1</code>，尾数的表示范围为 $ -\frac{1}{2} \geq M \geq -(1-2^{-n}) $</li>
</ul>
<p><strong>2：补码规格化后</strong></p>
<p>_规格化的补码尾数，符号位与最高数值位一定相反_。</p>
<ul>
<li><strong>正数</strong>：形式为<code>0.1××...×</code>，其最大值表示为<code>0.111...1</code>，最小值表示为<code>0.100...0</code>，尾数的表示范围为 $ \frac{1}{2} \leq M \leq (1-2^{-n}) $。</li>
<li><strong>负数</strong>：形式为<code>1.0××...×</code>，其最大值表示为<code>1.01×××1</code>，最小值表示为<code>1.00...0</code>，尾数的表示范围为 $-1 \leq M \leq -(\frac{1}{2}+2^{-n}) $。</li>
</ul>
<p>$ case3：$若某浮点数的阶码，尾数用补码表示，共 4+8 位：<code>0.110;1.1110100</code>，问如何规格化？</p>
<p>答：在这个例子中，阶数为 + 6，前面说过我们规定规格化的补码尾数的负数形式一定为<code>1.0××...×</code>，因此可以将<code>1.1110100</code>算数左移三位（补码的算数左移是低位补 0，算数右移是高位补 1），结果为<code>1.010000</code>，阶码变为 + 3。</p>
<h2 id="15-3-浮点数表示范围（408-考试大纲已删除）"><a href="#15-3-浮点数表示范围（408-考试大纲已删除）" class="headerlink" title="15.3.浮点数表示范围（408 考试大纲已删除）"></a>15.3.浮点数表示范围（408 考试大纲已删除）</h2><p>如下图所示，运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称为上溢。<strong>数据一旦产生上溢，计算机必须进行中断操作，进行溢出处理</strong>。 </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919066.png" loading="lazy"></p>
<p>当运算结果在 0 到最小正数之间时称为正下溢，在 0 到绝对值最小负数之间时称为负下溢，正下溢和负下溢统称为下溢，<strong>数据下溢时，浮点数区域 0，计算机仅将其当做机器零处理</strong>。</p>
<h1 id="16-IEEE754标准"><a href="#16-IEEE754标准" class="headerlink" title="16.IEEE754标准"></a>16.IEEE754标准</h1><h2 id="16-1移码"><a href="#16-1移码" class="headerlink" title="16.1移码"></a>16.1移码</h2><h3 id="16-1-1-移码回顾"><a href="#16-1-1-移码回顾" class="headerlink" title="16.1.1.移码回顾"></a>16.1.1.移码回顾</h3><p>本节内容涉及移码，有关移码的基础内容请移步</p>
<blockquote>
<p><a href="">(计算机组成原理) 第二章数据的表示和运算 - 定点数的表示（原码、反码、补码和移码）</a></p>
</blockquote>
<h3 id="16-1-2-偏置值"><a href="#16-1-2-偏置值" class="headerlink" title="16.1.2.偏置值"></a>16.1.2.偏置值</h3><p>前面我们说过：<strong>移码是在补码的基础上将符号位取反得到的。</strong></p>
<p>其实移码的真正定义为：<strong>移码 &#x3D; 真值 + 偏置值</strong>，只不过前面的讲述中我们的偏置值取定为了$2^{7}&#x3D;128$，也即 1000 0000。所以，假如真值为 - 127，也即 1000 0001，那么其所对应的移码就是 1000 0001+1000 0000&#x3D;0000 0001。其余数值也是这样，从下面的表格中可以看出，移码只是将补码的符号位取反了。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919067.png" loading="lazy"></p>
<p>其实，偏置值也是可以设置为其他值的。<strong>比如今天我们学习的浮点数当中的 IEEE754 标准中，就用移码表示阶码，其偏置值取$ 2^{n-1}-1$，也即 0111 1111（127）。</strong></p>
<p>这样的偏置值就导致移码会产生两个非常特殊的状态：<strong>1111 1111 和 0000 0000（真值 - 128 和 - 127），它们都对应无符号数 255；从真值 - 126 开始，对应无符号数 1，一直到无符号数 254</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920163.png" loading="lazy"></p>
<h2 id="16-2-IEEE-754-标准"><a href="#16-2-IEEE-754-标准" class="headerlink" title="16.2.IEEE 754 标准"></a>16.2.IEEE 754 标准</h2><h3 id="16-2-1-IEEE-754-标准格式"><a href="#16-2-1-IEEE-754-标准格式" class="headerlink" title="16.2.1.IEEE 754 标准格式"></a>16.2.1.IEEE 754 标准格式</h3><p>IEEE 754 将浮点数分为<strong>短浮点数、长浮点数和临时浮点数</strong>三类，C 语言遵循这个标准，因此它们分别对应<code>float</code>、<code>double</code>和<code>long double。</code></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920765.png" loading="lazy"></p>
<ul>
<li><strong>数符</strong>：表示了整个浮点数的正负性。</li>
<li><strong>阶码</strong>：采用移码表示，<strong>并且短浮点数的偏置值为 127</strong>。所以原本 8 位的移码表示的真值范围为 - 128~127，但是 127 的偏置值会使真值 - 127 和 - 128 较为特殊，其移码是全 0 和全 1，全 0 和全 1 在该标准下具有特殊作用，<strong>所以实际上 8 位的阶码表示真值的范围应该是 - 126 到 127</strong>。</li>
<li><strong>尾数</strong>：注意采用原码表示。并且我们知道使用原码表示浮点需要进行规格化，也就是最高位格式应该是<code>1.M</code>，<strong>所以短浮点数这里尾数部分写的虽然是 23 位，但是实则是 24 位</strong>，一位暗含。</li>
</ul>
<h3 id="16-2-2-转换方法"><a href="#16-2-2-转换方法" class="headerlink" title="16.2.2.转换方法"></a>16.2.2.转换方法</h3><p>我们知道移码等于真值阶码 + 偏置值，那么自然而然阶码真值 &#x3D; 移码 - 偏置值  。<br>因此 IEEE 754 标准中，规格化的短浮点数和长浮点数的真值分别为：<br>$ (-1)^{s}×1.M×2^{E-127} $                                </p>
<p>$ (-1)^{s}×1.M×2^{E-1023} $</p>
<p>上式中， $s&#x3D;0$ 表示正数，$ s&#x3D;1$ 表示负数。</p>
<p><strong>$ case:$ 将十进制数 - 0.75 转化为 IEEE 754 的单精度浮点数格式表示（十进制转换为浮点数）</strong><br>答：转换步骤如下</p>
<ul>
<li><strong>将十进制数转化为二进制数并规格化</strong>： $ (-0.75)<em>{10} \xrightarrow{转换为二进制}(-0.11)</em>{2} \xrightarrow{浮点数规格化}(-1.1)_{2}×2^{-1}$</li>
<li><strong>确定数符号</strong>：可以看出是负数，因此数符为 1。</li>
<li><strong>确定尾数部分</strong>：前面说过暗含了高位为 1，因此尾数部分是<code>.100000...</code></li>
<li><strong>确定阶码真值</strong>：基数指数部分是 - 1，因此阶码真值是 - 1。</li>
<li><strong>确定偏移值</strong>：127</li>
<li><strong>确定移码</strong>：移码 &#x3D;-1+ 0111 1111&#x3D;0111 1110（126，注意凑够 8 位）。</li>
<li><strong>最终形式</strong>（红色是数符，蓝色是阶码，绿色是尾数）：1 01111110 10000000000000000000000000000000。</li>
</ul>
<p><strong>$case$：IEEE 754 的单精度浮点数 C0 A0 00 00 的值为多少</strong> ?</p>
<p>答：转换步骤如下：</p>
<ul>
<li><strong>将十六进制转化为二进制</strong>（红色是数符，蓝色是阶码，绿色是尾数）：1100 0000 1010 0000 0000 0000 0000 0000</li>
<li><strong>数符为 1</strong>：这是个负数</li>
<li><strong>确定尾数部分</strong>：<code>.01000</code>，因此尾数真值为 $1.01_{2} $</li>
<li><strong>确定移码</strong>：是<code>10000001</code>，可看作无符号数 129</li>
<li><strong>确定偏移值</strong>：127</li>
<li><strong>确定阶码真值</strong>：$阶码真值 &#x3D; 移码 - 偏移值 &#x3D; 1000 0001-0111 1111&#x3D;(0000 0010)<em>{2} &#x3D;  (2)</em>{10} $</li>
<li><strong>确定浮点数真值</strong>：根据公式 $ (-1)^{s}×1.M×2^{E-127} $，可得真值 &#x3D;$ (-1)^{1}×(1.01)_{2}×2^{129-127}$。</li>
</ul>
<h3 id="16-2-3-表示范围"><a href="#16-2-3-表示范围" class="headerlink" title="16.2.3.表示范围"></a>16.2.3.表示范围</h3><p>IEEE 754 单精度浮点型表示的最小绝对值和最大绝对值。</p>
<ul>
<li><strong>最小绝对值</strong>：尾数全为 0，阶码真值最小为 - 126，对应机器数为 0000 0001，此时整体的真值为 $(1.0)_{2}×2^{-126}$</li>
<li><strong>最大绝对值</strong>：尾数全为 1，阶码真值最大为 - 127，对应机器数为 1111 1110，此时整体的真值为$ (1.111….11)_{2}×2^{127} $。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920285.png" loading="lazy"></p>
<p>当然即便这样，还是有溢出的问题的，<strong>因此前面提到的阶码全 0 和全 1 就派上用途了。</strong></p>
<ul>
<li>当阶码全为 0，尾数不全为 0 时，表示<strong>非规格化小数</strong>，也即$ (+&#x2F;-)(0.××××)_{2}×2^{-126} $，阶码的隐含最高位为 0。</li>
<li>当阶码全为 0，尾数全为 0 时，表示<strong>真值正负 0。</strong></li>
<li>当阶码全为 1，尾数全为 0 时，<strong>表示无穷大（正负）。</strong></li>
<li>当阶码全为 1，尾数不全为 0 时，<strong>表示非数值 NaN（Not a Number）</strong>，比如 0&#x2F;0。</li>
</ul>
<h1 id="17-浮点数加减运算"><a href="#17-浮点数加减运算" class="headerlink" title="17.浮点数加减运算"></a>17.浮点数加减运算</h1><h2 id="17-1-以十进制下的科学计数法的加减运算为例说明浮点数加减运算"><a href="#17-1-以十进制下的科学计数法的加减运算为例说明浮点数加减运算" class="headerlink" title="17.1.以十进制下的科学计数法的加减运算为例说明浮点数加减运算"></a>17.1.以十进制下的科学计数法的加减运算为例说明浮点数加减运算</h2><p>比如有浮点数 $ 9.85211×10^{12}+9.96007×10^{10} $，其运算基本步骤如下：</p>
<p><strong>1：对阶</strong><br>所谓对阶就是对齐两个浮点数的阶数，由于计算机内部尾数是定点小数，<strong>所以对阶是一律向大阶看齐</strong><br>也即 $ 9.85211×10^{12}+0.0996007×10^{12} $。</p>
<p><strong>2：尾数相减</strong><br>也即 $ 9.9517107×10^{12} $。</p>
<p><strong>3：规格化</strong><br>由于我们已经对阶了，所以这里就不用规格化了。</p>
<ul>
<li>如果尾加减出现了 $ 0.0099517×10^{12} $，就需要左规；如果尾数加减出现了 $99.517107×10^{12} $时，需要右规。</li>
</ul>
<p><strong>4：舍入</strong><br>假如规定了机器只能保持 6 位有效尾数，<strong>则 $ 9.9517107×10^{12}$中多余尾数部分应该砍掉</strong>，也即 $ 9.95171×10^{12} $。</p>
<ul>
<li>也可以采用四舍五入，也即 $9.95171×10^{12} $。</li>
<li>也可以采用 “若砍掉部分非 0，则入 1” 的原则，即 $ 9.95172×10^{12}$。</li>
</ul>
<p><strong>5：判溢出</strong><br><strong>假如规定了阶码不能超过两位，若运算后的阶码超出范围则溢出</strong>。比如 $ 9.85211×10^{99}+9.96007×19^{99}&#x3D;19.81218×10^{99} $，规格化后并采用四<br>舍五入原则保留 6 位尾数得：$ 1.98122×10^{100} $，因此这里产生了溢出。</p>
<ul>
<li>需要注意的是<strong>尾数溢出并不是真正的溢出</strong>，因为有可能通过规格化来拯救。</li>
</ul>
<h2 id="17-2-浮点数的加减运算（不舍入）"><a href="#17-2-浮点数的加减运算（不舍入）" class="headerlink" title="17.2.浮点数的加减运算（不舍入）"></a>17.2.浮点数的加减运算（不舍入）</h2><p><strong>$ case$：已知十进制数 $X&#x3D;-\frac{5}{256}$、 $ Y&#x3D;+\frac{59}{1024} $，按机器补码浮点运算规则计算$ X-Y $，结果用二进制表示，浮点数格式如下</strong>：</p>
<ul>
<li>阶符 2 位、阶码 2 位、数符 2 位、尾数 9 位。</li>
</ul>
<p><strong>预备步骤 1：格式转换</strong></p>
<ul>
<li><strong>对于$ X&#x3D;-\frac{5}{256}$​</strong>：其中分子 $ (101)_{2}$​，而 $ \frac{1}{256}&#x3D;2^{-8} $，因此 $ X&#x3D;-101× 2^{-8}&#x3D;-0.101×2^{-5}&#x3D;-0.101×2^{-101} $</li>
<li>**对于 $Y&#x3D;+\frac{59}{1024} $**：其中分子 $ 59&#x3D;(111011)_{2} $​，而 $ \frac{1}{1024}&#x3D;2^{-10} $，因此 $ Y&#x3D;+111011×2^{-10}&#x3D;+0.111011×2^{-4}&#x3D;+0.111011×2^{-100} $。</li>
</ul>
<p><strong>预备步骤 2：确定浮点数</strong></p>
<p>题目规定：阶符 2 位、阶码 2 位、数符 2 位、尾数 9 位。</p>
<p>①：对于 $X$</p>
<ul>
<li><strong>阶码</strong>：其阶码部分为 $-5 $，对应原码为 $ 1101 $，对应补码为 $1011 $，因为阶符 2 位、阶码 3 位，因此必须增添 1 位，采用双符号位，<strong>也即补码为 11011 11011 11011;</strong></li>
<li><strong>尾数</strong>：其尾数部分为$-0.101 $，对应原码为 $ 1.101 $，对应补码为$ 1.011 $, 因为数符 2 位、尾数 9 位，因此必须增添 1 位，采用双符号位，也即补码为$ 11.011 $, 再进行符号扩展，<strong>也即补码为 $11.011000000$。</strong></li>
</ul>
<p>因此 $X$ 的浮点数形式为：11011，11.011000000。</p>
<p>②：对于 $Y$</p>
<ul>
<li><strong>阶码</strong>：其阶码部分为 $-4 $，对应原码为 1100，对应补码为 $1100 $，因为阶符 2 位、阶码 3 位，因此必须增添 1 位，采用双符号位，<strong>也即补码为 $11100 $</strong></li>
<li><strong>尾数</strong>：其尾数部分为$+0.111011$, 对应原码为 $ 0.111011 $，对应补码为$ 0.111011 $，因为数符 2 位、尾数 9 位，因此必须增添 1 位，采用双符号位，也即补码为 $ 00.111011 $，再进行符号扩展，<strong>也即补码为 $00.111011000 $。</strong></li>
</ul>
<p>因此 $Y$ 的浮点数形式为：11100，00.111011000。</p>
<p><strong>第一步：对阶</strong>：<strong>使两个数的阶码相等，小阶向大阶看齐。</strong></p>
<ul>
<li><strong>求阶差（减法采用加法实现）</strong>：$ [\Delta E]_{补}&#x3D;11011+00100&#x3D;11111 $，也即 11001 11001 11001，也就是 $− 1 $，这意味着 $X$ 的阶数要比 $Y$ 低一阶。</li>
<li>**对阶 (小的对齐，尾数每右移一位，阶码就加 1)**：因此 $X$ 尾数部分右移一位，同时注意阶码部分 + 1，也即 11011，11.011000000—–&gt;11100，11.101100000。</li>
</ul>
<p><strong>第二步：尾数相减</strong>：</p>
<ul>
<li>**先求出 - $Y$**：$ [-Y]_{补}&#x3D;11100,11.000101000$。</li>
<li><strong>再尾数相减</strong>： 因此尾数部分 $ X-Y&#x3D;11.101100000+11.000101000&#x3D;10.110001000 $（根据之前我们学习的双符号位的运算规则，大家可以发现此时其实已经溢出了），<strong>因此 $ X-Y&#x3D;11100,10.110001000 $。</strong></li>
</ul>
<p><strong>第三步：规格化</strong>：</p>
<p>尾数采用双符号位的好处就是，我们可以通过右规的操作挽救刚才的溢出 <strong>，算数右移时小数点前的 0 会被移动到小数点后面，补多少看双符号位的高位，因为双符号位的高位表示的是正确的本应该得到的符号，因此这里补 1</strong>，同时右移不要忘记啊阶码 + 1。</p>
<p>因此：11100，10.110001000—–&gt;11101，11.011000100</p>
<p><strong>第四步：舍入</strong>：</p>
<p>这个例子中算数右移时, 抛弃了最低位的 0，0 对精度没有任何影响，因此不舍入（后面会有一个需要舍入的例子）。</p>
<p><strong>第五步：判断溢出</strong>：</p>
<p>由于阶码采用双符号位，因此我们只需要让其 + 1，如果相同那么没有溢出，在这个例子中很明显没有溢出。</p>
<p><strong>收尾步骤：翻译真值</strong></p>
<p>$X-Y&#x3D; 11101,11.011000100$</p>
<ul>
<li>阶码：$ 2^{-3} $</li>
<li>尾数： $ -0.1001111 $</li>
</ul>
<p>因此 $ 2 X-Y&#x3D;2^{-3}×(-0.1001111)_{2}$</p>
<h2 id="17-3-浮点数的加减运算（舍入）"><a href="#17-3-浮点数的加减运算（舍入）" class="headerlink" title="17.3.浮点数的加减运算（舍入）"></a>17.3.浮点数的加减运算（舍入）</h2><p>前面的所有例子中都没有涉及到舍入这个步骤。浮点数加减运算舍入有两种：</p>
<ul>
<li><strong>舍 “0” 入“1”</strong>：类似于十进制中的四舍五入，<strong>即在尾数右移时，被移去的最高数位为 0，则舍去；被移去的最高数值位为 1</strong>，则在尾数的末位加 1，这样做可能会使尾数又溢出，此时需要再做一次右规。</li>
</ul>
<p>比如某次尾数相减结果：$X-Y&#x3D;11100,10.110001011 $，此时产生溢出，接着进行右规结果为 11101,11.011000101 1(抛弃)，由于这一位抛弃的是 1，因此再继续加 1，正确结果就为 11101,11.011000110 1(抛弃)（如果加上之后还要进位，可能导致又溢出，再进行右规即可）；如果舍弃的是 0 就不用加了。</p>
<ul>
<li><strong>恒置 “1” 法</strong>：尾数右移时，<strong>不论丢掉的最高数值位是 “1” 还是“0”，都使右移后的尾数末尾恒置为“1”</strong>。这种方法同样有可能使尾数变大或变小。</li>
</ul>
<h2 id="17-4-浮点数强制类型转换"><a href="#17-4-浮点数强制类型转换" class="headerlink" title="17.4.浮点数强制类型转换"></a>17.4.浮点数强制类型转换</h2><p>C 语言中的<code>float</code>和<code>double</code>类型分别对应于 IEEE 754 单精度浮点数和双精度浮点数。<code>long double</code> 类型对应于扩展双精度浮点数，但是<code>long double</code>的长度和格式会随编译器和处理器类型的不同而与所不同。</p>
<p>在 C 程序中等式的赋值和判断常会强制类型转换，以下两种最为常见，<strong>其最前到后范围和精度都从小到大，转换过程没有损失</strong></p>
<ul>
<li><code>char</code>-&gt;<code>int</code>-&gt;<code>long</code>-&gt;<code>double</code></li>
<li><code>float</code>-&gt;<code>double</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920412.png" loading="lazy"></p>
<ul>
<li>从<code>int</code>转换为<code>float</code>时，虽然不会发生溢出，但是<code>int</code>可以保留 32 位，<code>float</code>保留 24 位，可能有数据舍入；若<code>int</code>转换为<code>double</code>则不会出现这种情况。</li>
<li>从<code>int</code>或 float 转化为<code>double</code>时，由于<code>double</code>有效位数更多，因此能够保留精度。</li>
<li>从<code>double</code>转换<code>float</code>时，由于<code>float</code>表示的范围更小，因此可能发生溢出。此外，由于有效位数变少，因此可能被舍入。</li>
<li>从<code>float</code>或<code>double</code>转换为 int 时，由于<code>int</code>没有小数部分，所以数据可能会向 0 方向被截断（仅保留整数部分），影响精度，同时由于<code>int</code>的表示范围更小，因此可能发生溢出。</li>
</ul>
<p>类型转换是一个让人很恼火的话题，如果处理不正确，极容易出现 bug。</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay-qrcode.jpg"><img loading="lazy" src="/images/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/qqpay-qrcode.jpg"><img loading="lazy" src="/images/qqpay-qrcode.jpg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay-qrcode.jpg"><img loading="lazy" src="/images/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Explorer</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://ccsu.top/posts/189f252b/" title="机组-第二章 数据的表示和运算">http://ccsu.top/posts/189f252b/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/189f252b/" rel="prev" title="机组-第二章 数据的表示和运算"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">机组-第二章 数据的表示和运算</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/c441e7e0/" rel="next" title="机组-第一章 计算机发展历程"><span class="post-nav-text">机组-第一章 计算机发展历程</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div id="waline"></div><script src="/js/comments/waline.js" type="module" defer></script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">皖ICP备20002891号-2</a></div><div class="copyright"><span>&copy; 2016 – 2023 </span><span class="with-love" id="animate" title="赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Explorer</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.0.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.8</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-02-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} Days ${passHour} Hours ${passMinute} Minutes ${passSecond} Seconds`;
}
blog_live_time();
</script></div><div id="busuanzi"><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":350,"hOffset":null,"vOffset":null},"mobile":{"show":true},"log":false});</script></body></html>