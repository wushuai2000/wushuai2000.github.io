<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="Explorer"><meta name="copyright" content="Explorer"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>计组-第一章 计算机发展历程 | explorerの博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" type="image/png" href="/./favicon.ico"><link rel="mask-icon" href="/./favicon.ico" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"ccsu.top","root":"/","title":["Wu","Shuai","の","Blog"],"version":"1.8.8","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"waline":{"config":{"enable":true,"serverURL":"https://blog-api-seven-vert.vercel.app/","comment":false,"visitor":false,"emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"2506812280@qq.com"},"requiredMeta":["nick"],"el":"#waline","lang":"en","path":"/posts/c441e7e0/"},"cdn":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","dark":"html.dark"},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="explorerの博客" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-BMBD00SVV4"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BMBD00SVV4');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="1.计算机发展历程 1.1.计算机硬件的发展①：电子管时代：第一代计算机（1946-1957 年） 逻辑元件采用电子管；使用机器语言进行编程；主存用延迟线或磁鼓存储信息，容量极小；体积庞大，成本高；运算速度较低，一般只有几千次到几万次每秒。  ②：晶体管时代：第二代计算机（1958-1964 年） 逻辑元件采用晶体管；运算速度提高到几万次到几十万次每秒；主存使用磁芯存储器；计算机软件也得到了发展，">
<meta property="og:type" content="article">
<meta property="og:title" content="计组-第一章 计算机发展历程">
<meta property="og:url" content="http://ccsu.top/posts/c441e7e0/index.html">
<meta property="og:site_name" content="explorerの博客">
<meta property="og:description" content="1.计算机发展历程 1.1.计算机硬件的发展①：电子管时代：第一代计算机（1946-1957 年） 逻辑元件采用电子管；使用机器语言进行编程；主存用延迟线或磁鼓存储信息，容量极小；体积庞大，成本高；运算速度较低，一般只有几千次到几万次每秒。  ②：晶体管时代：第二代计算机（1958-1964 年） 逻辑元件采用晶体管；运算速度提高到几万次到几十万次每秒；主存使用磁芯存储器；计算机软件也得到了发展，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121446238.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033369.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034743.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121452420.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450055.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450737.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532810.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171053506.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121458028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121503264.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121508014.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121510905.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121513033.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520952.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520495.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520536.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520639.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520072.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162032683.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034679.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033681.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033562.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033265.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033330.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033644.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033315.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034823.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033504.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121547792.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121536129.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121609226.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121550702.png">
<meta property="article:published_time" content="2023-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-31T16:00:00.000Z">
<meta property="article:author" content="Explorer">
<meta property="article:tag" content="计算机组成原理">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121446238.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Explorer"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Explorer"><span class="site-author-status" title="努力学习">😄</span></a><div class="site-author-name"><a href="/about/">Explorer</a></div><span class="site-name">explorerの博客</span><sub class="site-subtitle"></sub><div class="site-desciption">前路漫漫，当克己，当慎独!</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">73</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">64</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wushuai2000" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=549838440" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/huan-ji-91-3/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/345844264" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2506812280@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">1.计算机发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.计算机硬件的发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%83%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0%E6%8D%A2%E4%BB%A3"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.计算机元件的更新换代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.计算机软件的发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"><span class="toc-number">1.4.</span> <span class="toc-text">1.4.计算机的分类与发展方向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1.分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2.发展方向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">2.计算机硬件的基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.冯诺依曼机特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.现代计算机的组织结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%90%84%E4%B8%AA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.各个硬件的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.存储器（第三章重点学习）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9B%B8%E5%85%B3%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.3.1.存储器相关基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.3.2存储器的基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9B%B8%E5%85%B3%E5%B0%8F%E8%80%83%E7%82%B9"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.3.3.存储器相关小考点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%BF%90%E7%AE%97%E5%99%A8%EF%BC%88%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.运算器（第五章重点学习）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%BF%90%E7%AE%97%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1.运算器基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%BF%90%E7%AE%97%E5%99%A8%E8%BF%87%E7%A8%8B%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2.运算器过程伪代码描述（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AB%A0%E9%87%8D%E7%82%B9%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.控制器（第四章重点学习）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1.指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2.控制器基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BF%87%E7%A8%8B%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3.控制器过程伪代码描述（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.计算机的工作过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">4.计算机层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.计算机系统的多级层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">4.2.计算机软件的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3.解释程序和编译程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">4.4.</span> <span class="toc-text">4.4.机器语言、汇编语言和高级语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.</span> <span class="toc-text">4.5.计算机体系结构和计算机组成原理概念区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">5.</span> <span class="toc-text">5.计算机性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E6%8C%87%E6%A0%87"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.主存容量指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%BF%90%E7%AE%97%E9%80%9F%E5%BA%A6%E6%8C%87%E6%A0%87"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.运算速度指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-CPU-%E4%B8%BB%E9%A2%91%EF%BC%88%E6%97%B6%E9%92%9F%E9%A2%91%E7%8E%87%EF%BC%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1.CPU 主频（时钟频率）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-CPU-%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2.CPU 时钟周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-CPI"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3.CPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-CPU-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4.CPU 执行时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-IPS-%E5%92%8C-FLOPS"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.2.5.IPS 和 FLOPS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">5.3.</span> <span class="toc-text">5.3.系统整体性能指标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">6.本章总结</span></a></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/57%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/" style="font-size: 12px; color: #999">57步进电机</a> <a href="/tags/AT9SPro/" style="font-size: 12px; color: #999">AT9SPro</a> <a href="/tags/Anaconda/" style="font-size: 12px; color: #999">Anaconda</a> <a href="/tags/Arduino/" style="font-size: 24px; color: #3383cd">Arduino</a> <a href="/tags/CUDA/" style="font-size: 18px; color: #668eb3">CUDA</a> <a href="/tags/CUDNN/" style="font-size: 12px; color: #999">CUDNN</a> <a href="/tags/Conda/" style="font-size: 12px; color: #999">Conda</a> <a href="/tags/DHT11/" style="font-size: 12px; color: #999">DHT11</a> <a href="/tags/Docker/" style="font-size: 18px; color: #668eb3">Docker</a> <a href="/tags/ESP8266/" style="font-size: 12px; color: #999">ESP8266</a> <a href="/tags/GPIO/" style="font-size: 30px; color: #0078e7">GPIO</a> <a href="/tags/GPS/" style="font-size: 12px; color: #999">GPS</a> <a href="/tags/GPU/" style="font-size: 24px; color: #3383cd">GPU</a> <a href="/tags/HC-05/" style="font-size: 12px; color: #999">HC-05</a> <a href="/tags/HTML/" style="font-size: 18px; color: #668eb3">HTML</a> <a href="/tags/Hexo/" style="font-size: 18px; color: #668eb3">Hexo</a> <a href="/tags/Hexo%E5%AE%89%E8%A3%85/" style="font-size: 24px; color: #3383cd">Hexo安装</a> <a href="/tags/IAR%E8%BD%AF%E4%BB%B6/" style="font-size: 12px; color: #999">IAR软件</a> <a href="/tags/JavaScript/" style="font-size: 18px; color: #668eb3">JavaScript</a> <a href="/tags/Json/" style="font-size: 12px; color: #999">Json</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#6200ee;"><link itemprop="mainEntityOfPage" href="http://ccsu.top/posts/c441e7e0/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Explorer"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="explorerの博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">计组-第一章 计算机发展历程</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">Posted on</span> <time title="Created: 2023-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-01T00:00:00+08:00">2023-04-01</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">10.1k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">36m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%80%83%E7%A0%94408/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">考研408</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">计算机组成原理</span></a><a class="tag-item" href="/tags/%E8%80%83%E7%A0%94/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">考研</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="1-计算机发展历程"><a href="#1-计算机发展历程" class="headerlink" title="1.计算机发展历程"></a>1.计算机发展历程</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121446238.png" alt="image-20230412144653181" loading="lazy"></p>
<h2 id="1-1-计算机硬件的发展"><a href="#1-1-计算机硬件的发展" class="headerlink" title="1.1.计算机硬件的发展"></a>1.1.计算机硬件的发展</h2><p><strong>①：电子管时代：第一代计算机（1946-1957 年）</strong></p>
<p>逻辑元件采用电子管；使用机器语言进行编程；主存用延迟线或磁鼓存储信息，容量极小；体积庞大，成本高；运算速度较低，一般只有几千次到几万次每秒。</p>
<hr>
<p><strong>②：晶体管时代：第二代计算机（1958-1964 年）</strong></p>
<p>逻辑元件采用晶体管；运算速度提高到几万次到几十万次每秒；主存使用磁芯存储器；计算机软件也得到了发展，开始出现了高级语言及其编译程序，有了操作系统的雏形。</p>
<hr>
<p><strong>③：中小规模集成电路时代：第三代计算机（1965-1971 年）</strong></p>
<p>逻辑元件采用中小规模集成电路：半导体存储器开始取代磁芯存储器；高级语言发展迅速，操作系统也进一步发展，开始有了分时操作系统。</p>
<hr>
<p><strong>④：超大规模集成电路时代：第四代计算机（1927 年 - 现在）</strong></p>
<p>逻辑元件采用大规模集成电路和超大规模集成电路，产生了微处理器：诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中。</p>
<hr>
<p><strong>⑤：智能计算机</strong></p>
<p>具备人工智能，运算速度极快，软件系统能够处理知识信息，以<strong>神经网络计算机</strong>为代表。</p>
<hr>
<p><strong>⑥：生物计算机和量子计算机</strong></p>
<ul>
<li><p>生物计算机是指使用生物分子或细胞作为计算元件的计算机。生物计算机的运算方式与传统的计算机不同，它们利用生物分子的结构和运动来进行计算，从而实现高效的计算能力。生物计算机具有较低的功耗和较长的计算时间，但它们需要更为复杂的技术和材料来实现。</p>
</li>
<li><p>量子计算机是指使用量子比特 (qubit) 来进行计算的计算机。与传统计算机使用的二进制比特 (bit) 不同，量子比特可以处于多种状态的叠加态，这种叠加态可以在量子计算机中实现高效的并行计算。量子计算机的运算速度非常快，但目前尚处于研究和开发阶段，需要解决许多技术难题才能实现。</p>
</li>
</ul>
<hr>
<h2 id="1-2-计算机元件的更新换代"><a href="#1-2-计算机元件的更新换代" class="headerlink" title="1.2.计算机元件的更新换代"></a>1.2.计算机元件的更新换代</h2><p><strong>注意以下三点或概念即可</strong>：</p>
<ul>
<li><strong>摩尔定律：</strong> 每平方英寸电路板上的晶体管数量<strong>每 18 个月</strong>翻一番。</li>
<li><strong>微处理器的出现和发展</strong>：自1971年Intel公司开发出第一个微处理器<code>Intel4004</code>至今，微处理器经历了<code>Intel8008（8位）</code>、<code>Intel8086（16位）</code>、<code>Intel80386（32位）</code>、<code>Pentium（32位）</code>、<code> Pentium III（64位）</code>、<code>Pentium4（64位）</code>、<code>Core i7（64位）</code>等。这里的32位、64位指的是机器字长，是指<strong>计算机进行一次整数运算所能处理的二进制数据的位数</strong>。</li>
<li><strong>半导体存储器的发展：</strong> 1970年，仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代：单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB和现在的1GB。</li>
</ul>
<h2 id="1-3-计算机软件的发展"><a href="#1-3-计算机软件的发展" class="headerlink" title="1.3.计算机软件的发展"></a>1.3.计算机软件的发展</h2><p><strong>计算机语言的发展</strong>： 机器语言 - 汇编语言 - 高级语言。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033369.png" alt="image-20230416203359301" loading="lazy"></p>
<p><strong>操作系统的发展</strong>：例如 DOS，Windows，MAC 等等。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034743.png" alt="image-20230416203429681" loading="lazy"></p>
<h2 id="1-4-计算机的分类与发展方向"><a href="#1-4-计算机的分类与发展方向" class="headerlink" title="1.4.计算机的分类与发展方向"></a>1.4.计算机的分类与发展方向</h2><h3 id="1-4-1-分类"><a href="#1-4-1-分类" class="headerlink" title="1.4.1.分类"></a>1.4.1.分类</h3><p><strong>电子计算机</strong></p>
<ul>
<li>电子模拟计算机</li>
<li>电子数字计算机</li>
</ul>
<p><strong>数字计算机</strong></p>
<ul>
<li>专用计算机</li>
<li>通用计算机</li>
</ul>
<p><strong>通用计算机</strong></p>
<ul>
<li>巨型机</li>
<li>大型机</li>
<li>中型机</li>
<li>小型机</li>
<li>微型机</li>
<li>单片机</li>
</ul>
<p><strong>依照指令与数据流划分：</strong></p>
<ul>
<li><strong>单指令流与单数据流（SISD）</strong>：冯诺依曼体系结构。</li>
<li><strong>单指令流与多数据流（SIMD）</strong>：阵列存储器与向量存储器。</li>
<li><strong>多指令流与单数据流（MISD）</strong>：不存在。</li>
<li><strong>多指令流与多数据流（MIMD）</strong>：多处理器和计算机系统。</li>
</ul>
<h3 id="1-4-2-发展方向"><a href="#1-4-2-发展方向" class="headerlink" title="1.4.2.发展方向"></a>1.4.2.发展方向</h3><p><strong>两极化发展方向</strong></p>
<ul>
<li><strong>微型计算机：微型化、网络化、高性能、多用途。</strong></li>
<li><strong>巨型计算机：巨型化、超高速、并行处理、智能化。</strong></li>
</ul>
<h1 id="2-计算机硬件的基本组成"><a href="#2-计算机硬件的基本组成" class="headerlink" title="2.计算机硬件的基本组成"></a>2.计算机硬件的基本组成</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121452420.png" alt="image-20230412145256346" loading="lazy"></p>
<h2 id="2-1-冯诺依曼机特点"><a href="#2-1-冯诺依曼机特点" class="headerlink" title="2.1.冯诺依曼机特点"></a>2.1.冯诺依曼机特点</h2><ol>
<li>计算机硬件系统由<strong>运算器、存储器、控制器、输入和输出设备</strong> 5 部分组成。</li>
<li><strong>指令和数据</strong>以同等地位存储在<strong>存储器</strong>，并可按<strong>地址</strong>寻访。</li>
<li>指令由<strong>操作码和地址码</strong>组成，操作码用于表示这是一个<strong>什么类型的操作</strong>，地址码用于表示<strong>操作数在存储器中的存放位置。</strong></li>
<li>指令在存储器内<strong>按顺序存放</strong>（一般情况下是这样的，但在特定条件下也可以进行设定）。</li>
<li><strong>早期的冯诺依曼机器以运算器为中心</strong>，输入输出设备通过运算器与存储器传送数据。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450055.png" alt="image-20230412145004989" loading="lazy"></p>
<ul>
<li>上图中，<strong>实线是数据线，虚线是控制线</strong>（双向）。</li>
</ul>
<p><strong>冯诺依曼机缺陷（早期）</strong></p>
<p>在控制器的指挥下，输入和输出设备输入一些数据交给运算器进行运算，如果产生中间结果，就会传送给存储器，计算完成后最终结果会给输出设备。<strong>可以发现这种层次结构容易受到输入和输出设备的牵制，因为他们的速度相较于运算器太慢了（短板效应）。</strong></p>
<h2 id="2-2-现代计算机的组织结构"><a href="#2-2-现代计算机的组织结构" class="headerlink" title="2.2.现代计算机的组织结构"></a>2.2.现代计算机的组织结构</h2><p>为了解决 I&#x2F;O 设备的速度和 CPU 速度差异悬殊的问题，<strong>现如今的计算机则采用以存储器为中心的计算机组织结构</strong>，这种结果使 I&#x2F;O 操作尽可能绕过 CPU，直接<strong>在 I&#x2F;O 设备和存储器之间完成</strong>，以提高系统的整体运行效率。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450737.png" alt="image-20230412145050674" loading="lazy"></p>
<h1 id="3-各个硬件的工作原理"><a href="#3-各个硬件的工作原理" class="headerlink" title="3.各个硬件的工作原理"></a>3.各个硬件的工作原理</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532810.png" alt="image-20230412153254738" loading="lazy"></p>
<h2 id="3-1-存储器（第三章重点学习）"><a href="#3-1-存储器（第三章重点学习）" class="headerlink" title="3.1.存储器（第三章重点学习）"></a>3.1.存储器（第三章重点学习）</h2><h3 id="3-3-1-存储器相关基本定义"><a href="#3-3-1-存储器相关基本定义" class="headerlink" title="3.3.1.存储器相关基本定义"></a>3.3.1.存储器相关基本定义</h3><p><strong>存储器相关基本定义：目前我们采用半导体器件来承担存储任务，一个半导体触发器由于有 0 和 1 两个状态，就可以记忆一个二进制代码，关于存储器有如下五个非常重要的概念</strong>：</p>
<ul>
<li><p><strong>存储元</strong>：也可称为存储元件和存储基元，用来存放<strong>一位二进制信息</strong>。</p>
</li>
<li><p><strong>存储单元</strong>：由若干个存储元组成，能存放<strong>多位二进制信息。</strong></p>
</li>
<li><p><strong>存储体</strong>：许多存储单元可组成存储体，也即<strong>存储矩阵。</strong></p>
</li>
<li><p><strong>存储字</strong>：每个存储单元中<strong>二进制代码的组合</strong>即为存储字，可代表数值、指令和地址等。</p>
</li>
<li><p><strong>存储字长</strong>：每个存储单元中<strong>二进制代码的位数</strong>就是存储字长。</p>
</li>
</ul>
<p><strong>上述概念可以这样记忆</strong>：主存储器由许多存储单元组成，每个存储单元包含多个存储元，每个存储元存储 1 位二进制代码 0 或 1，故存储单元可存储一串二进制代码，称这串代码为存储字，而这串代码的位数称为存储字长，存储字长一般是一个字节（8 位）或字节的偶数倍。</p>
<h3 id="3-3-2存储器的基本结构"><a href="#3-3-2存储器的基本结构" class="headerlink" title="3.3.2存储器的基本结构"></a>3.3.2存储器的基本结构</h3><p><strong>存储器基本结构：存储器主要分为</strong>：</p>
<ul>
<li><strong>主存（内存）</strong>：CPU <strong>可以直接访问</strong>；主要存放<strong>程序和数据</strong>；是计算机实现 “<strong>存储程序</strong>” 控制的基础；外存中信息必须<strong>加载进主存后</strong> CPU 才可以访问。</li>
<li><strong>辅存（外存）</strong>：CPU <strong>不可以直接访问。</strong></li>
</ul>
<p><strong>主存的基本构成如下图所示</strong></p>
<ul>
<li><strong>存储体 M</strong>：存放<strong>二进制信息。</strong></li>
<li><strong>MAR（地址寄存器）</strong>：存放的是<strong>访存地址</strong>（经过地址译码后找到所选存储单元）。</li>
<li><strong>MDR（数据寄存器）</strong>：存放的是要从存储器中<strong>读入或写入的信息。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171053506.png" alt="image-20230417105309384" loading="lazy"></p>
<p>内部原理图如下。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121458028.png" loading="lazy"></p>
<h3 id="3-3-3-存储器相关小考点"><a href="#3-3-3-存储器相关小考点" class="headerlink" title="3.3.3.存储器相关小考点"></a>3.3.3.存储器相关小考点</h3><p><strong>此部分内容将在【第三章：存储系统】学习，所以看不太懂没有关系，其中一些常考考点汇总如下</strong>：</p>
<ul>
<li>数据在存储体中是<strong>按照地址存储的，每个地址对应一个存储单元</strong>。</li>
<li><strong>存储单元数目 &#x3D; $2^{MAR 位数}$<strong>（如果 MAR 为 10 位，则存储单元数目为 $2^{10}&#x3D;1024$）。它用于</strong>寻址</strong>，其长度和 PC（程序计数器）长度一致。</li>
<li><strong>MDR 的位数表示存储字长</strong>（例如 MDR 为 16，表示存储字长为 16，也表示 1 个字 (word)&#x3D;16bit）。</li>
<li>注意区分<strong>字（word）和字节（Byte），1 个字节等于 8 个 bit</strong>，而 1 个字的大小取决于机器。</li>
<li><strong>1B&#x3D;1 个字节，1b &#x3D; 1个bit</strong>。</li>
</ul>
<h2 id="3-2-运算器（第五章重点学习）"><a href="#3-2-运算器（第五章重点学习）" class="headerlink" title="3.2.运算器（第五章重点学习）"></a>3.2.运算器（第五章重点学习）</h2><p><strong>运算器：是计算机的执行部件，主要进行</strong>：</p>
<ul>
<li><strong>算数运算</strong>：比如加减乘除。</li>
<li><strong>逻辑运算</strong>：比如与、或、非、异或、比较等等。</li>
</ul>
<h3 id="3-2-1-运算器基本结构"><a href="#3-2-1-运算器基本结构" class="headerlink" title="3.2.1.运算器基本结构"></a>3.2.1.运算器基本结构</h3><p><strong>运算器基本结构：由以下四部分构成</strong>：</p>
<ul>
<li><strong>ALU（算数逻辑单元）</strong>：运算器中造价最为高昂的部分，本质是一对电路；通过内部复杂的电路实现算数运算、逻辑运算。</li>
<li><strong>ACC（累加器）</strong>：辅助 ALU，累加器，用于存放操作数，或运算结果。</li>
<li><strong>MQ（乘商寄存器）</strong>：辅助 ALU，乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。</li>
<li><strong>X（通用操作数寄存器）</strong>：辅助 ALU，通用的操作数寄存器，用于存放操作数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121503264.png" alt="image-20230412150310212" loading="lazy"></p>
<h3 id="3-2-2-运算器过程伪代码描述（了解）"><a href="#3-2-2-运算器过程伪代码描述（了解）" class="headerlink" title="3.2.2.运算器过程伪代码描述（了解）"></a>3.2.2.运算器过程伪代码描述（了解）</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121508014.png" alt="image-20230412150802918" loading="lazy"></p>
<p>设 M 为主存中的某一个存储单元，<code>(M)</code>表示取 M 中的数据，<code>-&gt;</code>表示将内容送入寄存器。</p>
<p><strong>加法实现</strong>：假设 ACC 中已经存在一个数，那么首先取 M 的内容送入通用操作数寄存器 X，即<code>(M)-&gt;X</code>；然后两者相加重新送入寄存器 ACC 中，即<code>(ACC)+(M)-&gt;(ACC)。</code></p>
<p><strong>乘法实现</strong>：假设 ACC 中已经存在一个数，那么首先取 M 的内容送入乘商寄存器 MQ 作为乘数，即<code>(M)-&gt;MQ</code>，再取 ACC 寄存器的内容放入 X 寄存器作为被乘数，即<code>ACC-&gt;X</code>，接着将 ACC 清零，即<code>0-&gt;ACC</code>，然后乘数乘以被乘数，一个送入乘积高位，一个送入乘积低位，即<code>(X)×(MQ)-&gt;ACC//MQ。</code></p>
<p><strong>除法实现</strong>：假设 ACC 中已经存在一个数，首先取 M 的内容送入 X 作为除数，即<code>(M)-&gt;X</code>，ACC 中的内容作为被除数，结果一个放入 MQ 作为整数部分，即<code>(ACC)/(X)-&gt;MQ</code>，另一个放入 ACC 作为余数，即<code>(ACC)%(X)-&gt;ACC。</code></p>
<h2 id="3-3-控制器（第四章重点学习）"><a href="#3-3-控制器（第四章重点学习）" class="headerlink" title="3.3.控制器（第四章重点学习）"></a>3.3.控制器（第四章重点学习）</h2><p><strong>运算器：是计算机的指挥中心，由其指挥各部件自动协调地进行工作。</strong></p>
<h3 id="3-3-1-指令"><a href="#3-3-1-指令" class="headerlink" title="3.3.1.指令"></a>3.3.1.指令</h3><p><strong>指令：是指指挥机器工作的指示和命令。程序本质就是一系列按照一定顺序排列的指令。人们用程序表达自己的意图，控制器则通过指令指挥机器工作。指令 &#x3D; 操作码 + 地址码。</strong></p>
<ul>
<li><strong>操作码</strong>：指示计算机要干什么。</li>
<li><strong>地址码</strong>：干这些事情需要的原材料在哪里。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121510905.png" loading="lazy">  </p>
<h3 id="3-3-2-控制器基本结构"><a href="#3-3-2-控制器基本结构" class="headerlink" title="3.3.2.控制器基本结构"></a>3.3.2.控制器基本结构</h3><p><strong>控制器基本结构：由以下三部分构成</strong>：</p>
<ul>
<li><strong>控制单元（CU）</strong>：分析指令、发出信号、协调操作。</li>
<li><strong>指令寄存器（IR）</strong>：存放<strong>当前要执行的指令</strong>。注意其内容来源于 MDR，因为指令和数据本质是一样的，都被存放在存储器。</li>
<li><strong>程序计数器（PC）</strong>：存放<strong>当前要执行的指令地址</strong>。注意其与 MAR 直接连通，并且可以自动 + 1。</li>
</ul>
<h3 id="3-3-3-控制器过程伪代码描述（了解）"><a href="#3-3-3-控制器过程伪代码描述（了解）" class="headerlink" title="3.3.3.控制器过程伪代码描述（了解）"></a>3.3.3.控制器过程伪代码描述（了解）</h3><p>完成一条指令的过程为：<strong>取指令（PC）-&gt; 分析指令（IR）-&gt; 执行指令（CU）。</strong></p>
<p>具体过程：首先取出指令，即<code>(IR)</code>，接着获取指令的操作码，即<code>OP(IR)</code>，然后获取指令的地址码，即<code>AD(IR)</code>，然后将操作码送入控制单元分析，即<code>OP(IR)-&gt;CU</code>，操作码表示需要干什么，但是干活需要原材料，所以再把指令的地址码送入 MAR，<code>AD(IR)-&gt;MAR</code>, 从 MAR 指示的存储体取出原材料即可。</p>
<p>结合前面的加法，我们可以写出完整的加法运算的过程的： 首要取加法指令，而指令存储在存储体中，想要取出指令必须要知道的指令的地址，而这个地址就存放在 PC 中，PC 又和 MAR 直接相连，即<code>(PC)-&gt;MAR</code>，于是指令此时被放入了 MDR 中，那么接着将指令放入 IR 中，即<code>(MDR)-&gt;IR</code>, 接着取指令的操作码送入控制单元，即<code>OP(IR)-&gt;CU</code>，然后再把原材料（就是一些操作数）的地址码送入 MAR，即<code>AD(IR)-&gt;MAR</code>。接着就可以进行加法操作了，由于上一步已经将操作数的地址码送入了 MDR 中，所以现在送入操作数寄存器，即<code>(MDR)-&gt;X</code>，然后<code>(ACC)+(X)-&gt;ACC</code>，最后 PC 要自增，即<code>(PC)+1-&gt;PC</code>，表示下一条指令。</p>
<h2 id="3-4-计算机的工作过程"><a href="#3-4-计算机的工作过程" class="headerlink" title="3.4.计算机的工作过程"></a>3.4.计算机的工作过程</h2><p><strong>接下来以一段简单的 C 语言代码为例展示计算机在背后所做的工作。</strong></p>
<ul>
<li>以下程序非常简单，声明了 4 个变量并赋值，然后在 main 函数内进行运算。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	y<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token operator">+</span>c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>经过编译器编译后，这段程序在主存中就是这样的  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121513033.png" alt="image-20230412151300971" loading="lazy"></p>
<ul>
<li>下半部分是定义的变量，上半部分则是对应于高级语言对应的机器指令。</li>
</ul>
<p>为了方便演示，我们将控制器、运算器和存储体也放在旁。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520952.png" loading="lazy"></p>
<p>第一组<br>1：程序开始运行，PC 的值为 0，保存的是第一条指令的地址。然后将 PC 的内容，也就是指令的地址送入到 MAR 中，即 (PC)-&gt;MAR,MAR&#x3D;0。也就是说控制器向存储器指明，我接下来要访问主存 0 号地址处的数据，同时告诉存储器进行读操作 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520320.png" loading="lazy"></p>
<p>2+3：主存储器会根据 MAR 记录的地址信息，到存储体中找出 0 号地址对应的二进制数据，并将其放入到 MDR 中，此时 MDR 中存放了第一条指令。即 M(MAR)-&gt;MDR，此时 <code>MDR=000001 0000000101</code></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520452.png" loading="lazy"></p>
<p>4：接着将 MDR 中的指令放入 IR 中，于是控制器就存放了当前要执行的指令。即 (MDR)-&gt;IR，<code>(IR)=000001 0000000101 </code></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520495.png" loading="lazy"></p>
<p>  5：这条指令的前 6 个比特位是操作码，会被送入到控制单元<code> CU</code> 中，<code>CU </code>分析后，得知这是一条取数命令。即 <code>OP(IR)-&gt;CU </code></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520536.png" loading="lazy"></p>
<p> 6：取数指令会将变量 a 的内容放入寄存器 ACC 中。但是现在变量 a 不知道在哪里，所以现在会把指令的地址码送到 MAR 当中，即<code>(MAR)=5</code></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520751.png" loading="lazy"></p>
<p>  7+8：接着主存储器根据 MAR 指明的地址，也就是 a 的地址（5），去存储体中找出 5 号地址的数据，并将其放入 MDR 当中。即<code> M(MAR)-&gt;MDR</code>，<code>(MDR)=0000000000000010</code>，也即 <code>(MDR)=2  </code></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520409.png" loading="lazy"></p>
<p>  9：接着在控制单元的指挥下，MDR 中的数据就被放入到了 ACC 中。至此第一条指令完成  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520639.png" loading="lazy"></p>
<p>  10：最后 PC 自增 1，进行下一条指令，即 (PC)&#x3D;1  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520072.png" alt="image-20230412152035976" loading="lazy"></p>
<p>接下来进行下一组操作  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162032683.png" loading="lazy"> </p>
<p>1：程序接着运行，PC 的值为 1，保存的是第二条指令的地址。然后将 PC 的内容，也就是指令的地址送入到 MAR 中，即<code> (PC)-&gt;MAR</code>，<code>MAR=1</code>。也就是说控制器向存储器指明，我接下来要访问主存 1 号地址处的数据，同时告诉存储器进行读操作  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034679.png" loading="lazy"></p>
<p>  2+3：主存储器会根据 MAR 记录的地址信息，到存储体中找出 1 号地址对应的二进制数据，并将其放入到 MDR 中，此时 MDR 中存放了第二条指令。即<code> M(MAR)-&gt;MDR</code>，此时<code>MDR=000100 0000000110 </code>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033681.png" loading="lazy"></p>
<p>4：接着将 MDR 中的指令放入 IR 中，于是控制器就存放了当前要执行的指令。即<code> (MDR)-&gt;IR</code>，<code>(IR)=000100 0000000110  </code>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033562.png" loading="lazy"></p>
<p>5：这条指令的前 6 个比特位是操作码，会被送入到控制单元 CU 中，CU 分析后，得知这是一条乘法命令。即<code>OP(IR)-&gt;CU </code>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033265.png" loading="lazy"></p>
<p>6：接着把指令的地址码送到 MAR 当中，即<code>(MAR)=6 </code>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033330.png" loading="lazy"></p>
<p>7+8：接着主存储器根据 MAR 指明的地址，也就是 b 的地址（6），去存储体中找出 6 号地址的数据，并将其放入 MDR 当中。即<code> M(MAR)-&gt;MDR</code>，<code>(MDR)=0000000000000011</code>，也即<code>(MDR)=3</code> 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033644.png" loading="lazy"></p>
<p>9：由于是乘法，所以控制单元将 MDR 中的内容送入到乘商寄存器 MQ 中，即 <code>(MDR)-&gt;MQ</code>，此时 <code>(MQ)=0000000000000011=3 </code> 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033315.png" loading="lazy"></p>
<p>10：先把 a 的值放入通用寄存器 X 中，即<code> (ACC)-&gt;X</code>，<code>(X)=2  </code>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034823.png" loading="lazy"></p>
<p>11：CU 告诉 ALU，让其进行乘法运算。即<code> (MQ)×(X)-&gt;ACC</code>，<code>(ACC)=6</code>。注意如果乘积过大，需要 MQ 辅助存储，也就是最上面讲到过的 <code>(X)×(MQ)-&gt;ACC/MQ</code>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033141.png" loading="lazy"></p>
<p>接着进行下一组操作，具体过程就不详细演示了，步骤如下：</p>
<ul>
<li><strong>1</strong>:PC 存储 2 号指令的地址，<code>(PC)-&gt;MAR</code>，<code>(MAR)=2</code></li>
<li><strong>2+3</strong>:<code>M(MAR)-&gt;MDR</code>，<code>(MDR)=000011 0000000111</code></li>
<li><strong>4</strong>:<code>(MDR)-&gt;IR</code>，<code>(IR)=000011 0000000111</code></li>
<li><strong>5</strong>:<code>OP(IR)-&gt;CU</code>,CU 分析操作码，得知这是加法执行</li>
<li><strong>6</strong>:<code>Ad(IR)-&gt;MAR</code>，将指令的地址码送入 MAR，<code>(MAR)=7</code></li>
<li><strong>7+8</strong>:<code>M(MAR)-&gt;MDR</code>，<code>(MDR)=00000000 00000001=1</code></li>
<li><strong>9</strong>:<code>(MDR)-&gt;x</code>，<code>(X)= 00000000 00000001=1</code></li>
<li><strong>10</strong>:<code>(ACC)+(X)-&gt;ACC</code>，<code>(ACC)-&gt;7</code>，由 ALU 实现加法运算</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033988.png" loading="lazy"></p>
<p>接着进行下一组操作：</p>
<ul>
<li><strong>1</strong>:<code>(PC)-&gt;MAR</code>，<code>(MAR)=3</code></li>
<li><strong>2+3</strong>:<code>M(MAR)-&gt;MDR</code>，<code>MDR=000010 0000001000</code></li>
<li><strong>4:</strong><code>(MDR)-&gt;IR</code>，<code>(IR)000010 0000001000</code></li>
<li>**5:<code>**OP(IR)-&gt;CU</code>，CU 分析得知，这是存数指令</li>
<li><strong>6</strong>:<code>AD(IR)-&gt;MAR</code>，<code>(MAR)=8</code></li>
<li><strong>7+8</strong>:<code>(ACC)-&gt;MDR</code>，<code>MDR=7</code></li>
<li><strong>9</strong>:<code>(MDR)-&gt; 地址为 8 的存储单元</code>，导致<code> y=7</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033504.png" loading="lazy"></p>
<p>最后再读取到停机指令时，计算机通过中断机制就结束了程序的运行。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532924.png" alt="image-20230412153204838" loading="lazy"></p>
<h1 id="4-计算机层次结构"><a href="#4-计算机层次结构" class="headerlink" title="4.计算机层次结构"></a>4.计算机层次结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121547792.png" alt="image-20230412154711717" loading="lazy"></p>
<h2 id="4-1-计算机系统的多级层次结构"><a href="#4-1-计算机系统的多级层次结构" class="headerlink" title="4.1.计算机系统的多级层次结构"></a>4.1.计算机系统的多级层次结构</h2><p><strong>计算机系统的多级层次结构：现代计算机是一个硬件与软件组成的综合体，自下而上依次为：</strong></p>
<ul>
<li><p><strong>第一级是微程序机器层</strong>：这是一个实在的<strong>硬件层</strong>，它由机器硬件直接执行<strong>微指令。</strong></p>
</li>
<li><p><strong>第二级是传统机器语言层</strong>：它是一个实际的<strong>机器层</strong>，由<strong>微程序</strong>解释机器指令系统。</p>
</li>
<li><p><strong>第三级是操作系统层</strong>：它由<strong>操作系统</strong>实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称为<strong>混合层。</strong></p>
</li>
<li><p><strong>第四级是汇编语言层</strong>：他为用户提供一种<strong>符号化的语言</strong>，借此可编写汇编语言源程序。</p>
</li>
<li><p><strong>第五级是高级语言层</strong>：它是<strong>面向用户的</strong>，是为方便用户编写应用程序而设置的。</p>
</li>
<li><p>在高级语言层之上，还可以<strong>有应用层</strong>，它由解决实际问题的程序组成（比如 word，chrome 等等）。</p>
</li>
</ul>
<p><strong>这样的分层结构，使得本层的使用者无需关心下一层的实现细节。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121536129.png" alt="image-20230412153640058" loading="lazy"></p>
<ul>
<li>注意：在很多情况下，计算机的某些功能既可以由硬件实现，也可以由软件来实现，<strong>因此硬件和软件没有严格的界限</strong>。</li>
</ul>
<h2 id="4-2-计算机软件的分类"><a href="#4-2-计算机软件的分类" class="headerlink" title="4.2.计算机软件的分类"></a>4.2.计算机软件的分类</h2><p><strong>软件：软件是人们事先编制的具有各类特殊功能的程序，他们通常存放在计算机的主存或外存中，按其功能可以分为以下两类:</strong></p>
<ul>
<li><strong>系统软件</strong>：是一组<strong>保证计算机系统高效，正确运行的基础软件</strong>，通常作为系统资源提供给用户使用。<strong>系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序，分布式软件系统、网络软件系统、标准库程序、服务型程序等。</strong></li>
<li><strong>应用软件</strong>：是指<strong>用户为解决某个应用领域中的各类问题而编制的程序</strong>、如各种<strong>科学计算类程序，工程设计类程序，数据统计与处理程序等</strong>。</li>
</ul>
<h2 id="4-3-解释程序和编译程序"><a href="#4-3-解释程序和编译程序" class="headerlink" title="4.3.解释程序和编译程序"></a>4.3.解释程序和编译程序</h2><ul>
<li><strong>解释程序</strong>：它将源语言书写的源程序作为输入，<strong>解释一句就提交给计算机执行一句</strong>，并<strong>不形成目标程序</strong>；例如 Python、JavaScript 等都是解释型语言。</li>
<li><strong>编译程序</strong>：把高级语言源程序作为输入，进行翻译转换，<strong>产生出的机器语言作为目标程序</strong>，然后让计算机去执行这个目标程序，得到计算结果；例如 C&#x2F;C++、Java 等都是编译型语言。</li>
</ul>
<p>对于编译程序来说，<strong>其产生目标代码的执行速度要比解释程序的执行速度快</strong>。</p>
<h2 id="4-4-机器语言、汇编语言和高级语言"><a href="#4-4-机器语言、汇编语言和高级语言" class="headerlink" title="4.4.机器语言、汇编语言和高级语言"></a>4.4.机器语言、汇编语言和高级语言</h2><ul>
<li><strong>机器语言</strong>：又称二进制代码语言，用 <strong>二进制 “0” 和“1”</strong> 描述不同指令，编程人员需要记忆每一条指令的二进制编码。其优点就是<strong>计算机可以直接识别并执行</strong>。</li>
<li><strong>汇编语言</strong>：其实质和机器语言是相同的，都是直接对硬件操作，只不过指令<strong>采用了英文缩写的标识符，更容易识别和记忆</strong>。汇编语言的程序必须经过一个称为<strong>汇编程序</strong>的系统软件的翻译，将其转化为机器语言，才能在计算机的硬件系统上运行。</li>
<li><strong>高级语言</strong>：高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常需要经过<strong>编译程序</strong>编译成汇编语言程序，然后经过<strong>汇编操作</strong>得到机器语言程序。其优点在于<strong>方便编程人员写出解决问题的方案和解题过程。</strong></li>
</ul>
<p>由于计算机无法直接理解和执行高级语言程序，需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：</p>
<ul>
<li><strong>汇编程序（汇编器）</strong>。将汇编语言程序翻译成机器语言程序。</li>
<li><strong>解释程序（解释器）</strong>。将源程序中的语句按执行额序逐条翻译成机器指令并立即执行。</li>
<li><strong>编译程序（编译器）</strong>。将高级语言程序翻译成汇编语言或机器语言程序。</li>
</ul>
<h2 id="4-5-计算机体系结构和计算机组成原理概念区别"><a href="#4-5-计算机体系结构和计算机组成原理概念区别" class="headerlink" title="4.5.计算机体系结构和计算机组成原理概念区别"></a>4.5.计算机体系结构和计算机组成原理概念区别</h2><ul>
<li><strong>计算机体系结构</strong>：研究的是机器语言程序所见的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O 机理）。<strong>也就是说是如何设计硬件与软件之间的接口</strong>，举例：无乘法指令。</li>
<li><strong>计算机组成原理</strong>：研究的是计算机体系结构体现出来的属性，对于程序员来说是 “透明的”。<strong>也就是说是如何使用硬件实现所定义的接口</strong>，举例：如何实现乘法指令。</li>
</ul>
<h1 id="5-计算机性能指标"><a href="#5-计算机性能指标" class="headerlink" title="5.计算机性能指标"></a>5.计算机性能指标</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121609226.png" alt="image-20230412160927153" loading="lazy"></p>
<h2 id="5-1-主存容量指标"><a href="#5-1-主存容量指标" class="headerlink" title="5.1.主存容量指标"></a>5.1.主存容量指标</h2><p><strong>主存容量指标：主要有两个</strong></p>
<ul>
<li><strong>MAR 位数</strong>：反映<strong>存储单元</strong>的个数。</li>
<li><strong>MDR 位数</strong>：它等于<strong>存储字长</strong>，等于<strong>每个存储单元的大小</strong>。</li>
</ul>
<p>**所以有：存储体总容量 &#x3D; 存储单元个数 × 存储字长 (bit)&#x3D; 存储单元个数 ×(存储字长 &#x2F; 8)(Byte)**。</p>
<ul>
<li>例如 MAR 为 32 位，MDR 为 8 位，则总容量为$2^{32}×8bit&#x3D;4GB$。</li>
</ul>
<p>为快速计算，请熟记$2^{n}$对应数值：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121550702.png" alt="image-20230412155043652" loading="lazy"></p>
<blockquote>
<p>注意：在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如$1Kb&#x3D;2^{10}b$；在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如$1kb&#x2F;s&#x3D;10^{3}b&#x2F;s$。通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。</p>
</blockquote>
<h2 id="5-2-运算速度指标"><a href="#5-2-运算速度指标" class="headerlink" title="5.2.运算速度指标"></a>5.2.运算速度指标</h2><h3 id="5-2-1-CPU-主频（时钟频率）"><a href="#5-2-1-CPU-主频（时钟频率）" class="headerlink" title="5.2.1.CPU 主频（时钟频率）"></a>5.2.1.CPU 主频（时钟频率）</h3><ul>
<li><strong>单位：Hz</strong></li>
</ul>
<p><strong>CPU 主频（时钟频率）</strong>：你在买电脑的时候，一定关注过 CPU 的主频。比如我手头的这台电脑就是 Intel Core-i7-7700HQ 2.8GHz，<strong>这里的 2.8GHz 就是电脑的主频（Frequency&#x2F;Clock Rate）</strong>。这个 2.8GHz，<strong>我们可以先粗浅地认为表示：CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条。</strong></p>
<p>如果想要更准确一点描述，<strong>这个 2.8GHz 就代表，CPU 的一个 “钟表” 能够识别出来的最小的时间间隔</strong>。就像我们挂在墙上的挂钟，都是 “滴答滴答” 一秒一秒地走，所以通过墙上的挂钟能够识别出来的最小时间单位就是秒。</p>
<p><strong>而在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡（OscillatorCrystal）的东西，简称为晶振</strong>。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次 “滴答”，就是时钟周期时间。</p>
<h3 id="5-2-2-CPU-时钟周期"><a href="#5-2-2-CPU-时钟周期" class="headerlink" title="5.2.2.CPU 时钟周期"></a>5.2.2.CPU 时钟周期</h3><ul>
<li><strong>单位：us 或 ns</strong><br><strong>CPU 时钟周期</strong>：接上面，在我这个 2.8GHz 的 CPU 上，<strong>这个时钟周期时间，就是 1&#x2F;2.8G</strong>。我们的 CPU，是按照这个 “时钟” 提示的时间来进行自己的操作。<strong>主频越高，意味着这个表走得越快，我们的 CPU 也就 “被逼” 着走得越快</strong>。</li>
</ul>
<p>如果你自己组装过台式机的话，可能听说过 “<strong>超频</strong>” 这个概念，<strong>本质就是把买回来的 CPU 内部的钟给调快了，于是 CPU 的计算跟着这个时钟的节奏</strong>，也就自然变快了。当然这个快不是没有代价的，CPU 跑得越快，散热的压力也就越大。就和人一样，超过生理极限，CPU 就会崩溃了。</p>
<p><strong>所以：CPU 主频（时钟频率）&#x3D;1&#x2F;CPU 时钟周期</strong>，主频通常以Hz（赫兹）为单位，1Hz表示每秒1次。</p>
<h3 id="5-2-3-CPI"><a href="#5-2-3-CPI" class="headerlink" title="5.2.3.CPI"></a>5.2.3.CPI</h3><p><strong>CPI</strong>：对于 CPU 时钟周期数，我们可以再做一个分解，<strong>把它变成 “指令数 × 每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）”</strong>。不同的指令需要的指令数是不同的。</p>
<ul>
<li>加法和乘法都对应着一条 CPU 指令，但是乘法需要的指令数就比加法要多，自然也就慢。</li>
</ul>
<h3 id="5-2-4-CPU-执行时间"><a href="#5-2-4-CPU-执行时间" class="headerlink" title="5.2.4.CPU 执行时间"></a>5.2.4.CPU 执行时间</h3><p><strong>CPU 执行时间</strong>：CPI 会受到很多因素的影响，因此用它衡量 CPU 速度是不合理的，<strong>所以我们把 CPU 执行时间定义为： CPU 执行时间 &#x3D; 指令数 ×CPI× 时钟周期 &#x3D;(指令数 ×CPI)&#x2F; 主频</strong>。</p>
<ul>
<li>例如：某 CPU 主频为 1000Hz，某程序包含 100 条指令，平均来看指令的 CPI&#x3D;3，则该程序执行时间为 $100×3×\frac{1}{1000}&#x3D;0.3s $。</li>
</ul>
<p>总结一下：</p>
<ul>
<li><strong>时钟周期时间，就是计算机主频，这个取决于计算机硬件</strong>：我们所熟知的摩尔定律就一直在不停地提高我们计算机的主频。比如说，我最早使用的 80386 主频只有 33MHz，现在手头的笔记本电脑就有 2.8GHz，在主频层面，就提升了将近 100 倍。</li>
<li><strong>每条指令的平均时钟周期数 CPI，就是一条指令到底需要多少 CPU Cycle</strong>：现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。因此，对于 CPI 的优化，也是计算机组成和体系结构中的重要一环。</li>
<li><strong>指令数，代表执行我们的程序到底需要多少条指令、用哪些指令</strong>：这个很多时候就把挑战交给了编译器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。</li>
</ul>
<p>我们可以把自己想象成一个 CPU，坐在那里写程序。<strong>计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。CPI 相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少</strong>。如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的 “性能” 从外面来看就是好的。</p>
<h3 id="5-2-5-IPS-和-FLOPS"><a href="#5-2-5-IPS-和-FLOPS" class="headerlink" title="5.2.5.IPS 和 FLOPS"></a>5.2.5.IPS 和 FLOPS</h3><ul>
<li><strong>IPS(Instructions Per Second)<strong>：每秒可以执行</strong>多少条指令</strong>，$ IPS&#x3D;\frac{主频}{平均 CPI}$。</li>
<li><strong>FLOPS(Floating-point Operation Per Second)<strong>：每秒执行</strong>多少次浮点运算。</strong></li>
</ul>
<p><strong>IPS 前面可以加入 K 或 M</strong></p>
<ul>
<li>KIPS：每秒可以多少千条指令。</li>
<li>MIPS：每秒可以执行多少百万条指。</li>
</ul>
<p><strong>FLOPS 前面加入 M、G 和 T</strong></p>
<ul>
<li>MFLOPS：每秒执行多少百万次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $10^{6} $)。</li>
<li>GFLOPS：每秒执行多少十亿次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $10^{9} $)。</li>
<li>TFLOPS：每秒执行多少万亿次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $ 10^{12} $)。</li>
</ul>
<p><strong>2021考研大纲新增</strong>：PFLOPS，EFLOPS，ZFLOPS，$P&#x3D;10^3T$，$E&#x3D;10^3P$，$Z&#x3D;10^3E$。</p>
<p><strong>最后需要注意</strong>：</p>
<ul>
<li><strong>在描述容量、文件大小时</strong>，K、M、G、T 通常用 <strong>2 的幂次表示</strong>。如 $1Kb&#x3D; 2^{10} b$。</li>
<li><strong>在描述速率、频率时</strong>，k、M、G、T 通常用 <strong>10 的幂次表示</strong>，如 $1kb&#x2F;s&#x3D;  10^{3} b&#x2F;s$。</li>
</ul>
<h2 id="5-3-系统整体性能指标"><a href="#5-3-系统整体性能指标" class="headerlink" title="5.3.系统整体性能指标"></a>5.3.系统整体性能指标</h2><ul>
<li><strong>数据通路带宽</strong>：是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度有可能不同。</li>
<li><strong>吞吐量</strong>：指信息流入、处理和流出系统的速率。它取决于 CPU 能够多快的取指令，数据能够多快地从内存取出或存入，以及所得结果能够多块地从内存送到输出设备。这些决定因素中的任何一步都与主存息息相关，<strong>因此吞吐量主要取决于主存的存取周期</strong>。</li>
<li><strong>响应时间</strong>：指的是用户向计算机发送一个请求，到系统对该请求作出相应并获得所需结果的等待时间。通常包括 CPU 时间（运行程序花费）与等待时间（例如 I&#x2F;O 操作）。</li>
</ul>
<h1 id="6-本章总结"><a href="#6-本章总结" class="headerlink" title="6.本章总结"></a>6.本章总结</h1><p>1：冯诺依曼机以<strong>运算器</strong>为核心，最根本的特征是<strong>存储程序原理</strong>，基本方式是<strong>控制流驱动。</strong></p>
<p>2：<strong>取指阶段</strong>取出的是指令、<strong>执行阶段</strong>取出的是数据。</p>
<p>3：以下概念易混淆：</p>
<ul>
<li>MAR(Memory Adress Regiater)：存放想要访问的存储单元的地址。</li>
<li>PC：存放下一条指令的地址。</li>
<li>IR：存放当前执行的指令。</li>
<li>MDR(Memory Data Regiater)：存放取来的数据。</li>
</ul>
<p>4：软件和硬件在逻辑功能上是<strong>等效的而不是等价的</strong>。</p>
<p>5：计算机的位数指的就是机器字长。</p>
<p>6：科学计算机主要关注浮点运算性能。</p>
<p>7：IR、MAR、MDR 是 CPU 内部寄存器，<strong>不可见。</strong></p>
<p>8：需要注意 CPU 的 <strong>CPI 与主频是没有关系的</strong>，但是主频却会加快指令执行速度。</p>
<p>9：评价计算机系统的综合参数是<strong>吞吐率</strong>。</p>
<p>10：当前设计高性能计算机的重要技术途径是<strong>采用并行处理技术</strong>。</p>
<hr>
<p><strong>Q:软件和硬件</strong></p>
<p><strong>A:<strong>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础; 软件是一种信息，看不见、摸不到。</strong>但在逻辑功能上，软件和硬件是等效的</strong>。因此，在计算机系统中，<strong>许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。</strong></p>
<ul>
<li>例如，乘法运算既可用专门的乘法器 (主要由加法器和移位器组成) 实现，也可用乘法子程序 (主要由加法指令和移位指令等组成) 来实现。</li>
</ul>
<hr>
<p><strong>Q:计算机由哪儿部分组成？以哪部分为中心？</strong></p>
<p><strong>A:<strong>计算机由</strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>及<strong>输出设备</strong>五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量I&#x2F;O设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。<strong>现代计算机</strong>已经发展为<strong>以存储器为中心</strong>，使I&#x2F;O操作尽可能地绕过CPU，直接在I&#x2F;O设备和存储器之间完成，以提高系统的整体运行效率。</p>
<hr>
<p><strong>Q:主频高的CPU一定比主频低的CPU快吗？为什么？</strong></p>
<p>**A:**衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频，即CPU内核工作的时钟频率。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、Cache大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的CPU实际运算速度较低的现象。</p>
<hr>
<p><strong>Q:翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？</strong></p>
<p><strong>A:<strong>翻译程序有两种：一种是</strong>编译程序</strong>，它<strong>将高级语言源程序一次全部翻译成目标程序</strong>，只要源程序不变，就无须重新翻译。另一种是<strong>解释程序</strong>，它<strong>将源程序的一条语向翻译成对应的机器目标代码，并立即执行</strong>，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</p>
<p><strong>汇编程序</strong>也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。</p>
<p><strong>编译程序与汇编程序的区别</strong>：若源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</p>
<hr>
<p><strong>Q:不同级别的语言编写的程序有什么区别？那种语言编写的程序能被硬件直接执行？</strong></p>
<p>**A:**机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。<br>其中机器语言可以被硬件直接执行。</p>
<hr>
<p><strong>Q:什么是透明性？透明是指什么都能看见吗？</strong></p>
<p><strong>A:<strong>在计算机领域中，</strong>站在某类用户的角度，若感觉不到某个事物或属性的存在</strong>，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。<br>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。<br><strong>在CPU中，IR、MAR和MDR对各类程序员都是透明的。</strong></p>
<hr>
<p><strong>Q:字、字长、机器字长、指令字长、存储字长的区别和联系是什么？</strong></p>
<p><strong>A:<strong>在通常所说的“某16位或32位机器”中，16、32指的是字长，也称</strong>机器字长</strong>。所谓字长通常是指CPU内部用于整数运算的数据通路的宽度，因此<strong>字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度</strong>，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。<br>            <strong>指令字长</strong>：一个指令字中包含的二进制代码的位数。<br>            <strong>存储字长</strong>：一个存储单元存储的二进制代码的长度。<br>            <strong>机器字长</strong>：计算机能直接处理的二进制数据的位数，<strong>机器字长一般等于内部寄存器的大小</strong>，它决定了计算机运算的精度</p>
<p>​        它们<strong>都必须是字节的整数倍</strong>。<br>​        早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。</p>
<p>注意：<strong>指令字长一般取存储字长的整数倍，若指令字长等于存储字长 2 倍，则需要 2 次访存才能取出一条指令，这导致取指周期就会是机器周期的 2 倍</strong>；<strong>若指令字长等于存储字长，则取指周期等于机器周期。</strong></p>
<hr>
<p><strong>Q:计算机体系结构和计算机组成的区别和联系是什么？</strong></p>
<p><strong>计算机体系结构</strong>：是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性</p>
<p><strong>计算机组成</strong>：是指<strong>如何实现计算机体系结构所体现的属性</strong>, 它包含对许多对程序员来说透明的硬件细节。例如，<strong>指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题</strong>。因此，<strong>当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的</strong>。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</p>
<hr>
<p><strong>Q:基准程序执行得越快说明机器的性能越好吗？</strong></p>
<p>**A:**一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p>
<hr>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay-qrcode.jpg"><img loading="lazy" src="/images/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/qqpay-qrcode.jpg"><img loading="lazy" src="/images/qqpay-qrcode.jpg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay-qrcode.jpg"><img loading="lazy" src="/images/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Explorer</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://ccsu.top/posts/c441e7e0/" title="计组-第一章 计算机发展历程">http://ccsu.top/posts/c441e7e0/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/189f252b/" rel="prev" title="计组-第二章 数据的表示和运算"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">计组-第二章 数据的表示和运算</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/bd50b816/" rel="next" title="MQTT协议"><span class="post-nav-text">MQTT协议</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div id="waline"></div><script src="/js/comments/waline.js" type="module" defer></script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">皖ICP备20002891号-2</a></div><div class="copyright"><span>&copy; 2016 – 2023 </span><span class="with-love" id="animate" title="赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Explorer</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.0.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.8</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-02-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} Days ${passHour} Hours ${passMinute} Minutes ${passSecond} Seconds`;
}
blog_live_time();
</script></div><div id="busuanzi"><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":350,"hOffset":null,"vOffset":null},"mobile":{"show":true},"log":false});</script></body></html>