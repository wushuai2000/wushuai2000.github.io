<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="Explorer"><meta name="copyright" content="Explorer"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>机组-第四章 指令系统 | explorerの博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" type="image/png" href="/./favicon.ico"><link rel="mask-icon" href="/./favicon.ico" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"ccsu.top","root":"/","title":["Wu","Shuai","の","Blog"],"version":"1.8.8","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"waline":{"config":{"enable":true,"serverURL":"https://blog-api-seven-vert.vercel.app/","comment":false,"visitor":false,"emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"2506812280@qq.com"},"requiredMeta":["nick"],"el":"#waline","lang":"en","path":"/posts/de459af/"},"cdn":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","dark":"html.dark"},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="explorerの博客" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-BMBD00SVV4"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BMBD00SVV4');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="1.指令和指令格式 1.1.指令的概念及构成指令（机器指令）：指示计算机执行某种操作的命令，是计算机运行的最小功能单位。  指令集（指令系统）：一台计算机的所有指令的集合。  注意：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。例如 X86 和 ARM。   一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。指令通常包括操作码字段和地址码字段两个部分：  操作码：指明了">
<meta property="og:type" content="article">
<meta property="og:title" content="机组-第四章 指令系统">
<meta property="og:url" content="http://ccsu.top/posts/de459af/index.html">
<meta property="og:site_name" content="explorerの博客">
<meta property="og:description" content="1.指令和指令格式 1.1.指令的概念及构成指令（机器指令）：指示计算机执行某种操作的命令，是计算机运行的最小功能单位。  指令集（指令系统）：一台计算机的所有指令的集合。  注意：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。例如 X86 和 ARM。   一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。指令通常包括操作码字段和地址码字段两个部分：  操作码：指明了">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152005362.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151952547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151954484.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955003.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955085.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956996.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956072.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152001244.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152009401.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010438.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010492.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152029832.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152030447.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152049452.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152039616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152041940.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152043693.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152044979.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152045696.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053245.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152054671.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152223607.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152055941.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053399.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152056041.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057481.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057887.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057215.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152058012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152059943.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152100062.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152105746.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152107218.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152221646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152111168.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152112597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152113336.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152114002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152115537.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152116381.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152117766.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152119029.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152120334.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152121255.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152122415.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152123253.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152126019.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152129027.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209013.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209886.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214569.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214515.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152213132.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152216907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152217826.png">
<meta property="article:published_time" content="2023-04-07T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-07T16:00:00.000Z">
<meta property="article:author" content="Explorer">
<meta property="article:tag" content="计算机组成原理">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152005362.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Explorer"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Explorer"><span class="site-author-status" title="努力学习">😄</span></a><div class="site-author-name"><a href="/about/">Explorer</a></div><span class="site-name">explorerの博客</span><sub class="site-subtitle"></sub><div class="site-desciption">前路漫漫，当克己，当慎独!</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">73</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">64</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wushuai2000" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=549838440" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/huan-ji-91-3/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/345844264" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2506812280@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E5%92%8C%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">1.指令和指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9E%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.指令的概念及构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%8C%87%E4%BB%A4%E5%AD%97%E9%95%BF%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF%E5%92%8C%E5%AD%98%E5%82%A8%E5%AD%97%E9%95%BF"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.指令字长、机器字长和存储字长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%9A%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97%E5%92%8C%E5%8F%98%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.定长指令字和变长指令字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2.指令的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8C%89%E6%93%8D%E4%BD%9C%E6%95%B0%E5%9C%B0%E5%9D%80%E7%A0%81%E7%9A%84%E6%95%B0%E7%9B%AE%E4%B8%8D%E5%90%8C%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.按操作数地址码的数目不同进行分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1.零地址指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2.一地址指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E4%BA%8C%E3%80%81%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3.二、三地址指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4.四地址指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8C%89%E6%93%8D%E4%BD%9C%E7%A0%81%E9%95%BF%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.按操作码长度分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%8C%89%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">2.3.按操作类型分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">3.扩展操作码指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%87%8D%E8%BF%B0%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.重述几个概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.为什么要扩展操作码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.扩展操作码方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%9C%80%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1.最常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2.其他方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.经典例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">4.</span> <span class="toc-text">4.指令寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.什么是指令寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%A4%E7%B1%BB%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text">4.1.两类指令寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E9%A1%BA%E5%BA%8F%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.1.2.顺序寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E8%B7%B3%E8%B7%83%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.1.2.跳跃寻址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-number">5.</span> <span class="toc-text">5.数据寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.什么是数据寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1.理解什么是数据寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2.数据寻址分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3.数据寻址指令格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%EF%BC%88%E5%B0%86%E5%BD%A2%E5%BC%8F%E5%9C%B0%E5%9D%80%E6%8C%89%E7%85%A7%E6%9F%90%E7%A7%8D%E8%A7%84%E5%88%99%E8%A7%A3%E9%87%8A%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.第一类数据寻址（将形式地址按照某种规则解释）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1.直接寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2.间接寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3.寄存器寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4.寄存器间接寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.2.5.隐含寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">5.2.6.</span> <span class="toc-text">5.2.6.立即寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-7-%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80"><span class="toc-number">5.2.7.</span> <span class="toc-text">5.2.7.堆栈寻址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%EF%BC%88%E5%B0%86%E5%BD%A2%E5%BC%8F%E5%9C%B0%E5%9D%80%E8%A7%86%E4%B8%BA%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">6.第二类数据寻址（将形式地址视为偏移量）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">6.1.</span> <span class="toc-text">6.1.基址寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2.基址寻址的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">6.2.</span> <span class="toc-text">6.2.变址寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2.变址寄存器的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E5%A4%8D%E5%90%88%E5%AF%BB%E5%9D%80%EF%BC%88%E5%9F%BA%E5%9D%80-%E5%8F%98%E5%9D%80%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3.复合寻址（基址 + 变址）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">6.3.</span> <span class="toc-text">6.3.相对寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E4%BD%9C%E7%94%A8"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2.相对寻址作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80%E6%80%BB%E7%BB%93"><span class="toc-number">6.4.</span> <span class="toc-text">6.4.数据寻址总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%81%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80"><span class="toc-number">7.</span> <span class="toc-text">7.高级语言、汇编语言、机器语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8"><span class="toc-number">7.1.</span> <span class="toc-text">7.1.汇编程序简单入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-2-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4-jcondition"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">8.3.2.2.条件转移指令 jcondition</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">7.2.</span> <span class="toc-text">8.4.选择语句的机器级表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">7.3.</span> <span class="toc-text">8.5.循环语句的机器级表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.3.1.</span> <span class="toc-text">8.5.1.使用条件转移指令实现循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-2-%E4%BD%BF%E7%94%A8-loop-%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.3.2.</span> <span class="toc-text">8.5.2.使用 loop 指令实现循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-cmp%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">8.6.cmp指令的底层原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-CISC%E5%92%8CRISC%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">9.CISC和RISC简单了解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88CISC%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">9.1.复杂指令系统计算机（CISC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88RISC%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">9.2.精简指令系统计算机（RISC）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-CISC-%E5%92%8C-RISC-%E6%AF%94%E8%BE%83"><span class="toc-number">8.3.</span> <span class="toc-text">9.3.CISC 和 RISC 比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">9.4.计算机的工作过程</span></a></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/57%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/" style="font-size: 12px; color: #999">57步进电机</a> <a href="/tags/AT9SPro/" style="font-size: 12px; color: #999">AT9SPro</a> <a href="/tags/Anaconda/" style="font-size: 12px; color: #999">Anaconda</a> <a href="/tags/Arduino/" style="font-size: 24px; color: #3383cd">Arduino</a> <a href="/tags/CUDA/" style="font-size: 18px; color: #668eb3">CUDA</a> <a href="/tags/CUDNN/" style="font-size: 12px; color: #999">CUDNN</a> <a href="/tags/Conda/" style="font-size: 12px; color: #999">Conda</a> <a href="/tags/DHT11/" style="font-size: 12px; color: #999">DHT11</a> <a href="/tags/Docker/" style="font-size: 18px; color: #668eb3">Docker</a> <a href="/tags/ESP8266/" style="font-size: 12px; color: #999">ESP8266</a> <a href="/tags/GPIO/" style="font-size: 30px; color: #0078e7">GPIO</a> <a href="/tags/GPS/" style="font-size: 12px; color: #999">GPS</a> <a href="/tags/GPU/" style="font-size: 24px; color: #3383cd">GPU</a> <a href="/tags/HC-05/" style="font-size: 12px; color: #999">HC-05</a> <a href="/tags/HTML/" style="font-size: 18px; color: #668eb3">HTML</a> <a href="/tags/Hexo/" style="font-size: 18px; color: #668eb3">Hexo</a> <a href="/tags/Hexo%E5%AE%89%E8%A3%85/" style="font-size: 24px; color: #3383cd">Hexo安装</a> <a href="/tags/IAR%E8%BD%AF%E4%BB%B6/" style="font-size: 12px; color: #999">IAR软件</a> <a href="/tags/JavaScript/" style="font-size: 18px; color: #668eb3">JavaScript</a> <a href="/tags/Json/" style="font-size: 12px; color: #999">Json</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#6200ee;"><link itemprop="mainEntityOfPage" href="http://ccsu.top/posts/de459af/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Explorer"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="explorerの博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">机组-第四章 指令系统</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">Posted on</span> <time title="Created: 2023-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-08T00:00:00+08:00">2023-04-08</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">14k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">55m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%80%83%E7%A0%94408/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">考研408</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">计算机组成原理</span></a><a class="tag-item" href="/tags/%E8%80%83%E7%A0%94/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">考研</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="1-指令和指令格式"><a href="#1-指令和指令格式" class="headerlink" title="1.指令和指令格式"></a>1.指令和指令格式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152005362.png" alt="image-20230415200545273" loading="lazy"></p>
<h2 id="1-1-指令的概念及构成"><a href="#1-1-指令的概念及构成" class="headerlink" title="1.1.指令的概念及构成"></a>1.1.指令的概念及构成</h2><p><strong>指令（机器指令）：指示计算机执行某种操作的命令，是计算机运行的最小功能单位</strong>。</p>
<ul>
<li><p>指令集（指令系统）：一台计算机的所有指令的集合。</p>
</li>
<li><p><strong>注意</strong>：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。例如 X86 和 ARM。</p>
</li>
</ul>
<p><strong>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。指令通常包括操作码字段和地址码字段两个部分</strong>：</p>
<ul>
<li><p><strong>操作码：指明了该指令是一个什么类型的指令，也即它具有怎样的功能。它是识别指令，了解指令功能及操作数地址的关键信息</strong>。比如：操作码可以指出该操作是 “算数加” 还是 “算数减” 运算，是 “程序转移” 还是 “返回操作” 等等。</p>
</li>
<li><p><strong>地址码</strong>：<strong>给出了被操作的信息（指令或数据）的地址。</strong> 比如：“参与运算的一个和多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址” 等等  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151952547.png" alt="image-20230415195203431" loading="lazy"></p>
</li>
</ul>
<h2 id="1-2-指令字长、机器字长和存储字长"><a href="#1-2-指令字长、机器字长和存储字长" class="headerlink" title="1.2.指令字长、机器字长和存储字长"></a>1.2.指令字长、机器字长和存储字长</h2><ul>
<li><strong>指令字长</strong>：一条指令的<strong>总长度</strong>（可能会变），也即<strong>一条指令中所包含的二进制代码的位数</strong>，它取决于<strong>操作码的长度、操作数地址码的长度和操作数地址的个数</strong>。</li>
<li><strong>机器字长</strong>：CPU 进行<strong>一次运算所能处理的二进制数据的位数</strong>（通常和 ALU 直接相关）。</li>
<li><strong>存储字长</strong>：一个<strong>存储单元</strong>中的二进制代码位数（通常和 MDR 位数相同）。</li>
</ul>
<p><strong>注意</strong>：指令字长与机器字长<strong>没有固定的关系</strong>，它可以等于机器字长，也可以大于或小于。<strong>通常，把指令字长等于机器字长的指令称为单字长指令</strong>，相应地还有<strong>半字长指令、双字长指令</strong>。指令字长会影响取指令所需时间，例如，当机器字长 &#x3D; 存储字长 &#x3D; 16bit，则取一条双字长指令就需要两次访存操作。</p>
<h2 id="1-3-定长指令字和变长指令字"><a href="#1-3-定长指令字和变长指令字" class="headerlink" title="1.3.定长指令字和变长指令字"></a>1.3.定长指令字和变长指令字</h2><p><strong>定长指令字结构</strong>：在一个指令系统中，如果<strong>所有指令的长度都是相等的</strong>，则称为定长指令字结构。具有定长指令字结构的指令其<strong>执行速度快，控制简单。</strong></p>
<p><strong>变长指令字结构</strong>：各种指令的长度<strong>随指令功能而不同</strong>。由于主存一般是按字节编址的，所以指令字长多为<strong>字节的整数倍。</strong></p>
<h1 id="2-指令的分类"><a href="#2-指令的分类" class="headerlink" title="2.指令的分类"></a>2.指令的分类</h1><h2 id="2-1-按操作数地址码的数目不同进行分类"><a href="#2-1-按操作数地址码的数目不同进行分类" class="headerlink" title="2.1.按操作数地址码的数目不同进行分类"></a>2.1.按操作数地址码的数目不同进行分类</h2><h3 id="2-1-1-零地址指令"><a href="#2-1-1-零地址指令" class="headerlink" title="2.1.1.零地址指令"></a>2.1.1.零地址指令</h3><p><strong>零地址指令：它只给出了操作码 OP，没有给出显式地址，有以下两种情况</strong>：</p>
<ul>
<li><strong>该指令本身就不需要操作数</strong>：比如<strong>空操作</strong>、<strong>停机</strong>、<strong>关中断</strong>等等。</li>
<li><strong>零地址的运算类指令它仅仅会用于堆栈计算机中</strong>：通常参与运算的两个操作<strong>隐含地从栈顶和次栈顶弹出</strong>，送到运算器进行运算，运算结果再隐含地压入堆栈。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151954484.png" loading="lazy"></p>
<p>对于第二种情况，最为经典的例子就是后缀表达式的计算，扫描后缀表达式时遇到操作数就会压栈，遇到运算符就会取操作数再运算，结果仍会压入栈中  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955003.png" alt="image-20230415195551908" loading="lazy"></p>
<h3 id="2-1-2-一地址指令"><a href="#2-1-2-一地址指令" class="headerlink" title="2.1.2.一地址指令"></a>2.1.2.一地址指令</h3><p><strong>一地址指令：一地址指令有两种常见的形态，需要根据操作的含义确定究竟属于哪一种</strong>：</p>
<ul>
<li>**只有目的操作数：根据地址 $A_{1} $读取操作数，进行 $OP $操作后，结果存回原地址，也即 $OP(A_{1}) $-&gt; $A_{1} $**。比如常见的 “加 1、减 1、求反、求补” 等操作。完成一条指令需要3次访存：取指→读A1→写A1。</li>
<li><strong>需要两个操作数，但其中一个操作数隐含在某个寄存器中，比如 ACC：也即 $ (ACC)OP(A_{1})-&gt;A_{1} $，其中 $A_{1} $指某个主存地址， $ (A_{1}) $ 表示地址中的内容，可以类比 C 语言中的指针理解</strong>。完成一条指令需要2次访存：取指→读A1。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955085.png" loading="lazy"></p>
<h3 id="2-1-3-二、三地址指令"><a href="#2-1-3-二、三地址指令" class="headerlink" title="2.1.3.二、三地址指令"></a>2.1.3.二、三地址指令</h3><p>**二地址指令：二地址指令往往就是常见的算数和逻辑运算，它们需要使用两个操作数，也即目的操作数和。地址中会给出目的操作数和源操作数的地址，其中目的操作数地址还可用于保存本次运算的结果，也即$(A_{1})OP(A_{2}) $-&gt; $A_{1} $**。完成一条指令需要访存4次，取指→读A1→读A2→写A1。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956996.png" loading="lazy"></p>
<p><strong>三地址指令：相比二地址指令，三地址指令需要新的地址来存储运算结果，也即 $ (A_{1})OP(A_{2}) $-&gt; $A_{3} $</strong>  。完成一条指令需要访存4次，取指→读A1→读A2→写A3。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956072.png" loading="lazy"></p>
<h3 id="2-1-4-四地址指令"><a href="#2-1-4-四地址指令" class="headerlink" title="2.1.4.四地址指令"></a>2.1.4.四地址指令</h3><p>**四地址指令：相比三地址指令，多了一个用于指明下一条指令地址的功能。这样就实现了指令的跳转功能（如果没有跳转，指令将会正常 + 1），也即$ (A_{1})OP(A_{2})- &gt; A_{3} $， $A_{4}&#x3D; 下一条指令的地址$**。完成一条指令需要访存4次，取指→读A1→读A2→写A3。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152001244.png" loading="lazy"></p>
<h2 id="2-2-按操作码长度分类"><a href="#2-2-按操作码长度分类" class="headerlink" title="2.2.按操作码长度分类"></a>2.2.按操作码长度分类</h2><p><strong>定长操作码：</strong>在指令字的最高位部分分配固定的若干位（定长）表示操作码。指令系统中<strong>所有指令的操作码长度都相同</strong>，有 $n $ 位就有 $2^{n} $条指令。定长操作码的控制器译码电路<strong>设计简单，但是灵活较差</strong>。</p>
<ul>
<li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。</li>
<li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</li>
</ul>
<p><strong>扩展操作码（不定长操作码）：</strong>全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。指令系统中<strong>各指令的操作码长度可变</strong>。可变长操作码控制器译码电路<strong>设计复杂，但灵活性很高</strong>。</p>
<ul>
<li>优：在指令字长有限的前提下仍保持比较丰富的指令种类。</li>
<li>缺：增加了指令译码和分析的难度，使控制器的设计复杂化。</li>
</ul>
<h2 id="2-3-按操作类型分类"><a href="#2-3-按操作类型分类" class="headerlink" title="2.3.按操作类型分类"></a>2.3.按操作类型分类</h2><p><strong>数据传送（进行主存与CPU之间的数据传送）</strong></p>
<ul>
<li><strong><code>LOAD</code>作用</strong>：把存储器中的数据放到寄存器。</li>
<li><strong><code>STORE</code>作用</strong>：把寄存器中的数据放到存储器。</li>
</ul>
<p><strong>算数逻辑操作（运算类）</strong></p>
<ul>
<li><strong>算数</strong>：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算等。</li>
<li><strong>逻辑</strong>：与、或、非、异或、位操作、位测试、位清除、位求反。</li>
</ul>
<p><strong>移位操作（运算类）</strong></p>
<ul>
<li>算数移位、逻辑移位、循环移位。</li>
</ul>
<p><strong>转移操作（程序控制类：改变程序执行的顺序）</strong></p>
<ul>
<li>无条件转移<code>JMP</code></li>
<li>条件转移（<code>JZ</code>: 结果为 0；<code>JP</code>：结果溢出；<code>JC</code>：结果有进位）。</li>
<li>调用和返回<code>CALL</code>及<code>RETURN。</code></li>
<li>陷阱（<code>Trap</code>）与陷阱指令。</li>
</ul>
<p><strong>输入和输出操作（输入输出类（I&#x2F;0）：进行CPU和I&#x2F;0设备之间的数据传送）</strong></p>
<ul>
<li>CPU 寄存器与 IP 端口之间的数据传送（端口即 IO 接口中的寄存器）。</li>
</ul>
<h1 id="3-扩展操作码指令格式"><a href="#3-扩展操作码指令格式" class="headerlink" title="3.扩展操作码指令格式"></a>3.扩展操作码指令格式</h1><h2 id="3-1-重述几个概念"><a href="#3-1-重述几个概念" class="headerlink" title="3.1.重述几个概念"></a>3.1.重述几个概念</h2><p><strong>指令格式：有两部分构成</strong>：</p>
<ul>
<li><strong>操作码</strong>。</li>
<li><strong>地址码。</strong></li>
</ul>
<p><strong>根据指令字长是否固定对指令分类：</strong></p>
<ul>
<li><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等。</li>
<li><strong>变长指令字结构</strong>：指令系统中各种指令的长度不固定。</li>
</ul>
<p><strong>根据操作码字段长度是否固定对指令分类：</strong></p>
<ul>
<li><strong>定长操作码</strong>：指令系统中所有指令的操作码长度都固定且相同。</li>
<li><strong>变长操作码</strong>：指令系统中各指令的操作码长度不固定。</li>
</ul>
<p><strong>所以这里会有以下四种类型：</strong></p>
<ul>
<li><strong>定长指令字定长操作码</strong>。</li>
<li><strong>定长指令字变长操作码：本节扩展操作码基于此类进行，也就是说不同地址数的指令会使用不同长度的操作码。</strong></li>
<li><strong>变长指令字定长操作码</strong>。</li>
<li><strong>变长指令字变长操作码。</strong></li>
</ul>
<h2 id="3-2-为什么要扩展操作码"><a href="#3-2-为什么要扩展操作码" class="headerlink" title="3.2.为什么要扩展操作码"></a>3.2.为什么要扩展操作码</h2><p>**如下图，假设指令字长为 16 位，其中前 4 位为操作码字段 $ OP $，另外有 3 个 4 位的地址字段 $A_{1} $、 $A_{2} $和 $ A_{3} $**。</p>
<p>如果 4 位操作码全部用于三地址指令，由于 $2^{4}&#x3D;16 $，所以该结构<strong>仅能表示 16 条指令</strong>。但这种方式是不合理的，因为所能表示的<strong>指令数是在是太少了</strong>。所以我们要做适当的处理，<strong>使其虽然不能涵盖全部的三地址指令，但是我能在牺牲有限条三地址指令的情况下向下扩展出更多的二地址、一地址、零地址指令，这样一来，所能表示的指令数目将会大大增大</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152009401.png" loading="lazy"></p>
<h2 id="3-3-扩展操作码方法"><a href="#3-3-扩展操作码方法" class="headerlink" title="3.3.扩展操作码方法"></a>3.3.扩展操作码方法</h2><h3 id="3-3-1-最常用方法"><a href="#3-3-1-最常用方法" class="headerlink" title="3.3.1.最常用方法"></a>3.3.1.最常用方法</h3><ul>
<li>以上图为例。</li>
</ul>
<p><strong>扩展二地址指令：</strong></p>
<ul>
<li><strong>三地址指令操作码范围为</strong><code>0000</code>~&#96;1111。&#96;</li>
<li>将<code>1111</code>留作扩展码，也即<code>1111</code>开头的指令不再代表三地址指令，此时三地址指令<strong>变更为 15 条</strong>，<strong>操作码范围为<code>0000</code>~&#96;1110。&#96;</strong></li>
<li>于是，二地址指令操作码将会以<code>1111</code>开头。</li>
<li><strong>实际上，CPU 在取得一条指令时，一定是直接读入 16 位，所以只需要根据所读入的是否为<code>1111</code>即可判断它是三地址还是二地址指令。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010007.png" loading="lazy"></p>
<p><strong>扩展一地址指令：</strong></p>
<ul>
<li><strong>此时二地址指令操作码范围为<code>1111</code> <code>0000</code>~&#96;1111<code> </code>1111。&#96;</strong></li>
<li>将<code>1111</code> <code>1111</code>留作扩展码，也即<code>1111</code> <code>1111</code>开头的指令不再代表二地址指令，<strong>此时二地址指令变更为 15 条，操作码范围<code>1111</code> <code>0000</code>~&#96;1111<code> </code>1110。&#96;</strong></li>
<li>于是，一地址指令操作码将会以<code>1111</code> <code>1111</code>开头。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010438.png" loading="lazy"></p>
<p><strong>扩展零地址指令：</strong></p>
<ul>
<li><p>**此时二地址指令操作码范围为<code>1111</code> <code>1111</code> <code>0000</code> ~&#96;1111<code> </code>1111<code> </code>1111&#96;**。</p>
</li>
<li><p>将<code>1111</code> <code>1111</code> <code>1111</code>留作扩展码，也即<code>1111</code> <code>1111</code> <code>1111</code>开头的指令不再代表一地址指令，<strong>此时一地址指令变更为 15 条，操作码范围为<code>1111</code> <code>1111</code> <code>0000</code> ~&#96;1111<code> </code>1111<code> </code>1110。&#96;</strong></p>
</li>
<li><p>于是，零地址指令操作码将会以<code>1111</code> <code>1111</code> <code>1111</code>开头。</p>
</li>
<li><p>由于<strong>零地址指令不需要再向后扩展</strong>，所以是 16 条，范围为<code>1111</code> <code>1111</code> <code>1111</code> <code>0000</code> ~ <code>1111</code> <code>1111</code> <code>1111</code> <code>1111。</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010492.png" loading="lazy"></p>
<p><strong>总之，在整个扩展过程中，操作码的位数会随着地址码位数的减少而增加。相比于之前的 16 条三地址指令。经过扩展，仅损失了一个三地址指令，却增加了 15 条二地址指令、15 条一地址指令和 16 条零地址指令，这是很划算的。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152029832.png" alt="image-20230415202944745" loading="lazy"></p>
<h3 id="3-3-2-其他方法"><a href="#3-3-2-其他方法" class="headerlink" title="3.3.2.其他方法"></a>3.3.2.其他方法</h3><p><strong>上面展示的是扩展操作码比较常用的一种方法，还有很多种设计方案。不过，不论使用哪种方法，在设计时一定要注意以下几点</strong>：</p>
<ul>
<li><strong>不允许短码是长码的前缀，也即短操作码不能与长操作码的前面部分相同</strong>：这一点，类似于<strong>哈夫曼树的前缀编码</strong>，比如<code>0011</code>和<code>0011</code> <code>0000</code>，如果这样设计就会产生歧义。</li>
<li><strong>各指令操作码不能重复。</strong></li>
</ul>
<p>通常情况下，<strong>对于使用频率较高的指令，分配较短的操作码；对使用频率较低的指令则分配较长的操作码</strong>，从而尽可能减少指令译码和分析的时间。</p>
<ul>
<li>这一点其实可通过哈夫曼树看出。</li>
</ul>
<h2 id="3-4-经典例题"><a href="#3-4-经典例题" class="headerlink" title="3.4.经典例题"></a>3.4.经典例题</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152030447.png" loading="lazy">  </p>
<p>设地址长度为 $n $，上一层留出 $m$种状态，则下一层可以扩展出 $ m×2^{n} $种状态。</p>
<h1 id="4-指令寻址"><a href="#4-指令寻址" class="headerlink" title="4.指令寻址"></a>4.指令寻址</h1><ul>
<li><p><strong>指令寻址</strong>：下一条欲执行指令的地址会由<strong>程序计数器 $PC $ <strong>给出，分为</strong>顺序寻址</strong>和<strong>跳跃寻址。</strong></p>
</li>
<li><p><strong>数据寻址</strong>：执行一条指令时，<strong>将地址码当作形式地址码，需要对其按照一定规则进行解释翻译，才能得到真实的地址</strong>。当按不同方式进行解释时，就会形成不同的数据寻址方式，共有十种。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png" alt="image-20230415205156229" loading="lazy"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152049452.png" alt="image-20230415204957355" loading="lazy"></p>
<h2 id="4-1-什么是指令寻址"><a href="#4-1-什么是指令寻址" class="headerlink" title="4.1.什么是指令寻址"></a>4.1.什么是指令寻址</h2><ul>
<li>程序运行实则就是指令执行，<strong>指令可以顺序执行也可以跳跃执行</strong>，这就涉及到指令寻址的问题了。</li>
</ul>
<p><strong>指令寻址：我们编写的程序最终会被翻译等价的机器指令，指令和数据无差别地存放在主存当中。CPU 中有一个很重要的寄存器——程序计数器 PC（Program-Counter），它指明了下一条指令的存放地址，CPU 在执行完一条指令后会让程序计数器自动 + 1。</strong></p>
<ul>
<li><strong>注意</strong>：这里的 “+1” 不是简单的 + 1，下面会在顺序寻址中说明。</li>
</ul>
<p><strong>指令寻址有两类</strong>：</p>
<ul>
<li><p>顺序寻址。</p>
</li>
<li><p>跳跃寻址  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152039616.png" alt="image-20230415203927527" loading="lazy"></p>
</li>
</ul>
<h2 id="4-1-两类指令寻址"><a href="#4-1-两类指令寻址" class="headerlink" title="4.1.两类指令寻址"></a>4.1.两类指令寻址</h2><h3 id="4-1-2-顺序寻址"><a href="#4-1-2-顺序寻址" class="headerlink" title="4.1.2.顺序寻址"></a>4.1.2.顺序寻址</h3><p><strong>顺序寻址：顺序寻址可以简单的理解为：(PC)+“1”-&gt;PC，但是这里的 “1” 要理解为一个指令字长，要视具体的指令长度、编址方式的不同而定</strong>。</p>
<p><strong>只有在系统采用定长指令字结构，并且指令字长 &#x3D; 存储字长 &#x3D; 16bit&#x3D;2B，且主存按字编址时，PC 才能简单的 + 1。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152041940.png" alt="image-20230415204101855" loading="lazy"></p>
<p><strong>其余条件不变，如果主存按字节编址，即每一条指令会占两个地址，此时 PC 要 + 2</strong> 。 </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152043693.png" alt="image-20230415204343610" loading="lazy"></p>
<p><strong>如果采用变长指令字结构同时按字节编址，此时不同指令的字长是不一样的。由于 CPU 无法确定当前指向的指令占多少存储字，此时 CPU 可以先读入一个字，操作码一定会包含在其中，因此可以通过操作码来判断这是一个几地址的指令，就可以确定这条指令具体占的字节数 n，接着 PC+n 即可。</strong></p>
<ul>
<li><p>下图中相同颜色表示一条指令。</p>
</li>
<li><p><strong>注意</strong>：在这种方式下，由于 CPU 无法预先知道总字节数，所以可能会进行多次访存，每次读入一个字，对于一条指令可能要读多次才能读干净  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152044979.png" alt="image-20230415204409893" loading="lazy"></p>
</li>
</ul>
<h3 id="4-1-2-跳跃寻址"><a href="#4-1-2-跳跃寻址" class="headerlink" title="4.1.2.跳跃寻址"></a>4.1.2.跳跃寻址</h3><p><strong>跳跃寻址：所谓跳跃，是指下一条指令的地址码不再由程序计数器给出，而由本条指令给出下一条指令地址的计算方式。跳跃寻址通过转移类指令实现</strong>。</p>
<ul>
<li>无条件转移<code>JMP。</code></li>
<li>条件转移（<code>JZ</code>: 结果为 0；<code>JP</code>：结果溢出；<code>JC</code>：结果有进位）。</li>
<li>调用和返回<code>CALL</code>及<code>RETURN。</code></li>
<li>陷阱（<code>Trap</code>）与陷阱指令。</li>
</ul>
<p>如下，CPU 正常执行指令，<strong>在遇到无条件转移指令<code>JMP</code>时会把 PC 中的内容强制改为 7</strong>，意味着下次执行要从 7 的位置开始执行，这有点类似<code>goto</code> 语句。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152045696.png" alt="image-20230415204503605" loading="lazy"></p>
<h1 id="5-数据寻址"><a href="#5-数据寻址" class="headerlink" title="5.数据寻址"></a>5.数据寻址</h1><ul>
<li><p><strong>指令寻址</strong>：下一条欲执行指令的地址会由<strong>程序计数器 $PC $ <strong>给出，分为</strong>顺序寻址</strong>和<strong>跳跃寻址。</strong></p>
</li>
<li><p><strong>数据寻址</strong>：执行一条指令时，<strong>将地址码当作形式地址码，需要对其按照一定规则进行解释翻译，才能得到真实的地址</strong>。当按不同方式进行解释时，就会形成不同的数据寻址方式，共有十种。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png" loading="lazy"></p>
</li>
</ul>
<h2 id="5-1-什么是数据寻址"><a href="#5-1-什么是数据寻址" class="headerlink" title="5.1.什么是数据寻址"></a>5.1.什么是数据寻址</h2><h3 id="5-1-1-理解什么是数据寻址"><a href="#5-1-1-理解什么是数据寻址" class="headerlink" title="5.1.1.理解什么是数据寻址"></a>5.1.1.理解什么是数据寻址</h3><p><strong>数据寻址：借用上一节文章中最后一个例子，该程序是从主存地址为 0 的单元开始向后存储的，执行到<code>JMP</code>指令后会把 PC 改为 7，所以接下来会直接跳转到 7 这个地方，因此这里的 7 就是真实的地址，没有歧义。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053245.png" alt="image-20230415205335170" loading="lazy"></p>
<p><strong>但在实际情况中，几乎不可能保证当前运行的程序恰好就从主存位置为 0 的地方开始存储。比如下面，该程序是从主存位置为 100 的单元向后存储的。在这种情况下，如果<code>JMP</code>依旧采用之前的方式去理解，那么在 103 执行完毕之后，它仍然会跳转到 7 这个位置</strong>。</p>
<p><strong>这显然是不合理的，因为 7 的位置是一个未知区域，甚至有可能是别的程序正在使用的区域，这就属于非法越界了</strong>。<strong>因此这里的 7 则可以解释为基于程序开始位置 100 的偏移量，也即 107</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152054671.png" alt="image-20230415205420595" loading="lazy"></p>
<p>当然还有其它解释方式，例如下图可以解释为：<strong>JMP 执行完成之后 PC 会自动 + 1，然后从 PC 所指向的位置向后偏移 3 个单位开始执行</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152223607.png" alt="image-20230415222358516" loading="lazy"></p>
<h3 id="5-1-2-数据寻址分类"><a href="#5-1-2-数据寻址分类" class="headerlink" title="5.1.2.数据寻址分类"></a>5.1.2.数据寻址分类</h3><p><strong>可以发现，不同的解读方式下地址码会有不同的含义，也就会产生不同的寻址方式。所以，我们会在地址码的前边新加入寻址方式位（寻址特征）来标识该指令的地址会采用何种方式来解释（或寻址）。主要会有以下十种寻址方式。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152055941.png" loading="lazy"></p>
<h3 id="5-1-3-数据寻址指令格式"><a href="#5-1-3-数据寻址指令格式" class="headerlink" title="5.1.3.数据寻址指令格式"></a>5.1.3.数据寻址指令格式</h3><p><strong>共有十种寻址方式，所以寻址方式位（寻址特征）需要 4 个比特位。总之，根据寻址方式位（寻址特征）可以确定形式地址$ (A)$采用怎样的方式解读，得到相应的真实地址（称为有效地址 $ (EA) $）。</strong></p>
<ul>
<li><strong>注意</strong>：n 地址指令需要 n 个寻址特征。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053399.png" alt="image-20230415205302318" loading="lazy"></p>
<p><strong>在下面的介绍中，假设指令字长 &#x3D; 机器字长 &#x3D; 存储字长，且操作数为 3。</strong></p>
<h2 id="5-2-第一类数据寻址（将形式地址按照某种规则解释）"><a href="#5-2-第一类数据寻址（将形式地址按照某种规则解释）" class="headerlink" title="5.2.第一类数据寻址（将形式地址按照某种规则解释）"></a>5.2.第一类数据寻址（将形式地址按照某种规则解释）</h2><h3 id="5-2-1-直接寻址"><a href="#5-2-1-直接寻址" class="headerlink" title="5.2.1.直接寻址"></a>5.2.1.直接寻址</h3><p><strong>直接寻址：指令字中的形式地址 A 就是操作数的真实地址，即 EA&#x3D;A</strong>。</p>
<ul>
<li><p><strong>访存次数</strong>：取指令的 1 次 + 执行指令的 1 次 &#x3D;<strong>2 次</strong>（暂不考虑存结果）。</p>
</li>
<li><p><strong>优点：</strong> <strong>简单</strong>，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。</p>
</li>
<li><p><strong>缺点：</strong> A 的位数决定了该指令操作数的<strong>寻址范围</strong>，且操作数的地址<strong>不易修改</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152056041.png" alt="image-20230415205648964" loading="lazy"></p>
</li>
<li><p>上图是一个取数指令。</p>
</li>
</ul>
<h3 id="5-2-2-间接寻址"><a href="#5-2-2-间接寻址" class="headerlink" title="5.2.2.间接寻址"></a>5.2.2.间接寻址</h3><p>**间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数的有效地址所在存储单元的地址，也就是操作数地址的地址，即 EA&#x3D;(A)**。</p>
<ul>
<li><strong>访存次数</strong>：取指令的 1 次 + 执行指令的 2 次 &#x3D;<strong>3 次</strong>（暂不考虑存结果）。</li>
<li><strong>优点</strong>：可以<strong>扩大寻址范围</strong>（有效地址 EA 的位数大于形式地址 A 的位数）；便于<strong>编写程序</strong>（间接寻址方式可以很方便地完成子程序返回）。</li>
<li><strong>缺点：</strong>：指令在执行阶段要<strong>多次访存</strong>（一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存）。</li>
</ul>
<p>下图一次间接寻址：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057481.png" alt="image-20230415205716403" loading="lazy"></p>
<p>下图两次间接寻址 ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057887.png" alt="image-20230415205724809" loading="lazy"></p>
<h3 id="5-2-3-寄存器寻址"><a href="#5-2-3-寄存器寻址" class="headerlink" title="5.2.3.寄存器寻址"></a>5.2.3.寄存器寻址</h3><p><strong>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 EA&#x3D;Rs，所其操作数就在由 Rs 所指的寄存器内存放</strong>。</p>
<ul>
<li><strong>访存次数</strong>：取指令 1 次 + 执行指令 0 次 &#x3D;<strong>1 次</strong>（暂不考虑存结果）。</li>
<li><strong>优点</strong>：指令在执行阶段<strong>不访问主存</strong>，只访问寄存器；指令字段且执行<strong>速度快</strong>，支<strong>持向量 &#x2F; 矩阵</strong>运算。</li>
<li><strong>缺点</strong>：寄存器<strong>价格昂贵</strong>，<strong>个数有限。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057215.png" alt="image-20230415205755139" loading="lazy"></p>
<h3 id="5-2-4-寄存器间接寻址"><a href="#5-2-4-寄存器间接寻址" class="headerlink" title="5.2.4.寄存器间接寻址"></a>5.2.4.寄存器间接寻址</h3><p><strong>寄存器间接寻址：寄存器 Ri 中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA&#x3D;（R）。</strong></p>
<p><strong>访存次数：</strong> 取指令 1 次 + 执行指令 1 次 &#x3D;<strong>2 次</strong>（暂不考虑存结果）  。<br><strong>特点：</strong> 与一般间接寻址方式相比速度更快，但指令的执行阶段需要访问主存。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152058012.png" alt="image-20230415205826937" loading="lazy"></p>
<h3 id="5-2-5-隐含寻址"><a href="#5-2-5-隐含寻址" class="headerlink" title="5.2.5.隐含寻址"></a>5.2.5.隐含寻址</h3><p><strong>隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</strong></p>
<ul>
<li><strong>优点</strong>：有利于<strong>缩短指令字长。</strong></li>
<li><strong>缺点</strong>：需要<strong>增加存储操作数和隐含地址的硬件。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152059943.png" alt="image-20230415205938862" loading="lazy"></p>
<h3 id="5-2-6-立即寻址"><a href="#5-2-6-立即寻址" class="headerlink" title="5.2.6.立即寻址"></a>5.2.6.立即寻址</h3><p><strong>立即寻址：形式地址 A 就是操作数本身，又称为立即数，一般采用补码形式。它的寻址特征为<code>#</code>，<code>#</code>表示立即寻址特征。</strong></p>
<ul>
<li><strong>访存次数</strong>： 取指令 1 次 + 执行指令 0 次 &#x3D;<strong>1 次</strong>（暂不考虑存结果）。</li>
<li><strong>优点：</strong> 指令执行阶段不需要访问主存，<strong>指令执行时间最短。</strong></li>
<li><strong>缺点：</strong> A 的<strong>位数限制了立即数的范围</strong>  。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152100062.png" alt="image-20230415210026975" loading="lazy"></li>
</ul>
<h3 id="5-2-7-堆栈寻址"><a href="#5-2-7-堆栈寻址" class="headerlink" title="5.2.7.堆栈寻址"></a>5.2.7.堆栈寻址</h3><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出(LIFO)”原则管理的存储区，该存储区中被读&#x2F;写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。</p>
<p><strong>堆栈寻址：是指操作数存放在堆栈中，隐含使用堆栈指针 ($SP$) 作为操作数地址。其中，堆栈是存储器（或专用寄存器组）中一块特定的按 “先进后出” 原则管理的存储区，该存储区中被读 &#x2F; 写单元的地址由一个特定的寄存器给出的，也就是我们上面说到的堆栈指针（$SP$）。</strong></p>
<p><strong>如下，记栈顶单元为 $ M_{sp} $​，那么完成一次加法运算的过程为</strong>：</p>
<ul>
<li>首先是<code>POP ACC</code>，也就是将栈顶单元弹出并将其内容送入<code> ACC</code>，也即 $(M_{sp})-&gt;ACC$，同时栈顶指针向下移动，也即<code> (SP)+1=SP</code>，指向次栈顶元素。</li>
<li>接着是<code>POP X</code>，将操作数放到 <code>X </code>寄存器中，重复。</li>
<li>然后进行加法运算<code>ADD Y</code>，结果保存在变量 <code>Y</code> 中，也即<code> (ACC)+(X)-&gt;Y</code>。</li>
<li>接着进行压栈，结果压回栈顶<code>PUSH Y</code>，栈顶指针向上移动，结果送入此时的栈顶，也即 <code>(SP-1)-&gt;SP</code> 和$ (Y)-&gt;(M_{sp})$。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152105746.png" alt="image-20230415210524651" loading="lazy"></p>
<p><strong>堆栈可以分为硬堆栈和软堆栈两种（上面的例子属于硬堆栈）。</strong></p>
<ul>
<li><strong>硬堆栈</strong>：又称为寄存器堆栈，其成本较高，不适合做大容量的堆栈。</li>
<li><strong>软堆栈（最常用）</strong>：是指从主存中划分一段区域来做堆栈。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152107218.png" alt="image-20230415210726133" loading="lazy"></p>
<h1 id="6-第二类数据寻址（将形式地址视为偏移量）"><a href="#6-第二类数据寻址（将形式地址视为偏移量）" class="headerlink" title="6.第二类数据寻址（将形式地址视为偏移量）"></a>6.第二类数据寻址（将形式地址视为偏移量）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152221646.png" loading="lazy"></p>
<p>主要介绍以下三种数据寻址方式，它们都是将形式地址视为 “偏移量”。**</p>
<ul>
<li><strong>基址寻址</strong>：以程序的起始存放地址作为起点，即 <code>EA=(BR)+A</code>。</li>
<li><strong>变址寻址</strong>：程序员自己决定从哪里作为起点，即 <code>EA=(IX)+A</code>。</li>
<li><strong>相对寻址</strong>：以程序计数器 <code>PC</code> 所指地址作为起点，即<code> EA=(PC)+A</code>。</li>
</ul>
<h2 id="6-1-基址寻址"><a href="#6-1-基址寻址" class="headerlink" title="6.1.基址寻址"></a>6.1.基址寻址</h2><h3 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1.基本概念"></a>6.1.1.基本概念</h3><p>**基址寻址：将 CPU 中基址寄存器 BR 中的内容加上指令格式中的形式地址 A，从而形成操作数的有效地址，也即<code> EA=(BR)+A</code>**。</p>
<p><strong>如下，采用基址寻址，指令中会包含一个形式地址 A，BR 会指向当前程序存放的起始位置</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152111168.png" alt="image-20230415211139086" loading="lazy"></p>
<p>需要注意，有的计算机内部不会专门设计一个基址寄存器，而会使用<strong>通用寄存器</strong>代替基址寄存器。如果采用通用寄存器，除了要给明寻址特征外，<strong>指令中还要多出几位 ( $R_{0} $​) 用于说明要将哪个通用寄存器作为基址寄存器使用。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152112597.png" alt="image-20230415211214513" loading="lazy"></p>
<h3 id="6-1-2-基址寻址的作用"><a href="#6-1-2-基址寻址的作用" class="headerlink" title="6.1.2.基址寻址的作用"></a>6.1.2.基址寻址的作用</h3><p><strong>基址寻址作用：基址寻址利于程序浮动，程序存储位置可以更改，但指令内容不需要修改，只需要更改基址寄存器，让其始终指向程序的起始地址，这&#x3D;&#x3D;有利于多道程序并发运行&#x3D;&#x3D;；另外，采用基址寻址可以扩大寻址范围（因为基址寄存器的位数大于形式地址 A 的位数）。</strong></p>
<p>例如下面有这样一段 C 语言段程序：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	y<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token operator">*</span>c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>翻译为等价的机器指令</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152113336.png" alt="image-20230415211325256" loading="lazy"></p>
<p>下图中该程序从 <strong>主存 “100”</strong> 处开始存储，第一个指令是一个取数指令，目的是<strong>为了把 “105” 处的变量<code>a=2</code>取到 <code>ACC </code>中</strong>，此时该地址码就会被解释为<strong>偏移量</strong>，因此<strong>真实地址 &#x3D; 基址寄存器 + 地址码</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152114002.png" alt="image-20230415211429896" loading="lazy"></p>
<h2 id="6-2-变址寻址"><a href="#6-2-变址寻址" class="headerlink" title="6.2.变址寻址"></a>6.2.变址寻址</h2><h3 id="6-2-1-基本概念"><a href="#6-2-1-基本概念" class="headerlink" title="6.2.1.基本概念"></a>6.2.1.基本概念</h3><p><strong>变址寻址：有效地址 EA 等于形式地址 $A $与变址寄存器 IX 中的内容相加之和，也即 $ EA&#x3D;(IX)+A $。其中 IX 可以是专用的，也可以将通用寄存器用作变址寄存器</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152115537.png" alt="image-20230415211546457" loading="lazy"></p>
<p><strong>可以看出变址寄存器和基址寄存器非常相像，那么他们的区别又在哪里呢？</strong></p>
<ul>
<li><p><strong>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间无关性。在程序执行过程中，基址寄存器内容不变（作为基地址）、形式地址可变（作为偏移量）；另外，采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但是其内容仍然由操作系统确定</strong>。</p>
</li>
<li><p><strong>变址寄存器是面向用户的，在程序的执行过程中，变址寄存器中的内容可以由用户改变，其中 IX 作为偏移量，形式地址 A 不变，作为基地址，这一点和基址寄存器恰好相反</strong>。</p>
</li>
</ul>
<h3 id="6-2-2-变址寄存器的作用"><a href="#6-2-2-变址寄存器的作用" class="headerlink" title="6.2.2.变址寄存器的作用"></a>6.2.2.变址寄存器的作用</h3><p><strong>变址寻址作用：变址寻址特别适合编写循环程序，例如在下面所述的数组处理过程中，可将形式地址 A 设置为基地址，这里就是数组的首地址，而变址寄存器 $ IX $的内容为偏移量，也就是循环变量。</strong></p>
<p>依旧采用基址寻址，如下有一段 C 语言程序，其作用是对<code>a[0]~a[9]</code>进行求和，涉及到了循环语句。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>	
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>翻译为等价的机器指令：</p>
<ul>
<li>第 0 条指令是立即寻址，将 0 取到 ACC 中。</li>
<li>第 1 条第 10 条均为加法指令，从地址码指示位置取得操作数然后和 ACC 中内容相加并送入 ACC 中。</li>
<li>第 11 条是一个取数指令，将累加结果放回到 sum 中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152116381.png" alt="image-20230415211627288" loading="lazy"></p>
<p>可以发现对于基址寻址，它在处理循环时显得不那么合适，一旦数组的内容成百上千，难道还要继续这样操作吗？答案显然不是这样的，这时候就要用到变址寻址了。</p>
<ul>
<li>第 0 条指令是取数指令，取到 <code>ACC</code> 中。</li>
<li>第 1 条指令是取数指令，取到<code> IX</code> 中。</li>
<li>第 2 条指令采用变址寻址，也即<code> EA=(IX)+A</code>。这条指令的 A 指向了 “7”，也就是数组的起始位置，此时执行这条指令的结果<strong>就是把 <code>ACC</code> 中的内容（目前为 0）加上$ IX$偏移 7 后所指内存单元中的内容（也即<code>a[0]</code>），然后再放到<code> ACC</code> 中，完成第一轮循环。</strong></li>
<li>第 3 条指令是 IX+1，对应于循环变量<code>i++。</code></li>
<li>第 4 条指令是 IX 与 10 做比较，来决定是执行第 5 条指令还是第 6 条指令。<strong>如果 IX&lt;10 参见第 5 条指令，如果 IX&gt;&#x3D;10 参见第 6 条指令。</strong></li>
<li>第 5 条指令是条件跳转，程序会跳转至 “2”，进行第 2 轮循环，然后依次类推。</li>
<li>第 6 条指令是存数指令，此时结束循环。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152117766.png" alt="image-20230415211759664" loading="lazy"></p>
<h3 id="6-2-3-复合寻址（基址-变址）"><a href="#6-2-3-复合寻址（基址-变址）" class="headerlink" title="6.2.3.复合寻址（基址 + 变址）"></a>6.2.3.复合寻址（基址 + 变址）</h3><p>实际上，基址和变址这两种寻址方式通常会配合使用，上面变址的例子中仅仅展示了当程序从主存 “0” 位置开始存储的情形，当然是没有问题的，<strong>但是一旦改变程序的起始位置，那么仅仅依靠变址寻址就不行了。</strong></p>
<p>基本规则如下：</p>
<ul>
<li><strong>基址寻址</strong>：<code>EA=(BR)+A</code>。</li>
<li><strong>变址寻址</strong>：<code>EA=(IX)+A</code>。</li>
<li><strong>先基址再变址</strong>：<code>EA=(IX)+((BR)+A)</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152119029.png" alt="image-20230415211930926" loading="lazy"></p>
<h2 id="6-3-相对寻址"><a href="#6-3-相对寻址" class="headerlink" title="6.3.相对寻址"></a>6.3.相对寻址</h2><h3 id="6-3-1-基本概念"><a href="#6-3-1-基本概念" class="headerlink" title="6.3.1.基本概念"></a>6.3.1.基本概念</h3><p><strong>相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，也即 <code>EA=(PC)+A</code>，其中 A 是相对于 PC 所指地址的偏移量，可正可负，使用补码表示</strong>。</p>
<p>前面说过，当前指令执行完毕之后，<strong>PC 会自动 +“1”</strong>（注意这里的 “1” 仅仅表示下一步的意思，并不是实际 + 1，这要视具体情况而定，具体细节读者可查看上一节）  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152120334.png" alt="image-20230415212029247" loading="lazy"></p>
<h3 id="6-3-2-相对寻址作用"><a href="#6-3-2-相对寻址作用" class="headerlink" title="6.3.2.相对寻址作用"></a>6.3.2.相对寻址作用</h3><p><strong>相对寻址的作用：相对寻址中，操作数地址不是固定不变的，可以随 PC 值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序的浮动（注意区分基址寻址的浮动，这里的浮动是指&#x3D;&#x3D;一段代码在程序内部的浮动&#x3D;&#x3D;），相对寻址&#x3D;&#x3D;广泛应用在转移指令中&#x3D;&#x3D;。</strong></p>
<p>还是这样一段加和程序：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>	
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>循环部分对应的指令如下：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152121255.png" alt="image-20230415212116157" loading="lazy"></p>
<p>在编写程序时我们常常有跳转的需求，比如上面的那一段程序可能循环未结束，我们需要马上执行它下面的一段程序，那么在这种情况下如果进行跳转，会出现很大的问题  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152122415.png" alt="image-20230415212211319" loading="lazy">  </p>
<p>为了解决这样的问题，引入相对寻址。<strong>在上图中，执行完 “M+3” 处的指令后会自动跳转至 “M+4”，如果想要跳回至 “M” 处，那么就要将 “M+3” 中的地址码改为 - 4 即可</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152123253.png" alt="image-20230415212306147" loading="lazy">  </p>
<p>自此，这段程序就似乎自我形成了一个封闭的体系，无论你把程序放到什么位置，只要他们的相对位置不变，总能跳转到正确的位置。</p>
<h2 id="6-4-数据寻址总结"><a href="#6-4-数据寻址总结" class="headerlink" title="6.4.数据寻址总结"></a>6.4.数据寻址总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152126019.png" alt="image-20230415212429695" loading="lazy"></p>
<h1 id="7-高级语言、汇编语言、机器语言"><a href="#7-高级语言、汇编语言、机器语言" class="headerlink" title="7.高级语言、汇编语言、机器语言"></a>7.高级语言、汇编语言、机器语言</h1><p><strong>使用高级语言编写的源程程序会经过以下两步转变为与之对应的机器语言</strong>：</p>
<ul>
<li><strong>编译：</strong> 高级语言经<strong>编译程序</strong> 编译后 转变为汇编语言，<strong>一条高级语言语句可能对应多条汇编语言语句。</strong></li>
<li><strong>汇编：</strong> 汇编语言经<strong>汇编程序</strong> 汇编后 转变为机器语言，<strong>一条汇编语言语句对应一条机器语言语句</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152129027.png" alt="image-20230415212955901" loading="lazy"></p>
<h2 id="7-1-汇编程序简单入门"><a href="#7-1-汇编程序简单入门" class="headerlink" title="7.1.汇编程序简单入门"></a>7.1.汇编程序简单入门</h2><p>如下为一段 C 语言程序，输出 “Hello World”：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

  <span class="token keyword">int</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 gcc 生成汇编程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>file <span class="token string">"hello.c"</span> 
      <span class="token punctuation">.</span>intel_syntax noprefix
      <span class="token punctuation">.</span>section <span class="token punctuation">.</span>rodata
  <span class="token punctuation">.</span>LC0<span class="token operator">:</span>
      <span class="token punctuation">.</span>string <span class="token string">"Hello, world!"</span>
      <span class="token punctuation">.</span>text
      <span class="token punctuation">.</span>globl   main
      <span class="token punctuation">.</span>type    main<span class="token punctuation">,</span> @function
  main<span class="token operator">:</span>
      push     rbp
      mov      rbp<span class="token punctuation">,</span> rsp
      sub      rsp<span class="token punctuation">,</span> <span class="token number">16</span>
      mov      DWORD PTR <span class="token punctuation">[</span>rbp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> edi
      mov      QWORD PTR <span class="token punctuation">[</span>rbp<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rsi
      mov      edi<span class="token punctuation">,</span> OFFSET FLAT<span class="token operator">:</span><span class="token punctuation">.</span>LC0
      call     puts
      mov      eax<span class="token punctuation">,</span> <span class="token number">0</span>
      leave
      ret
      <span class="token punctuation">.</span>size    main<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token operator">-</span>main
      <span class="token punctuation">.</span>ident   <span class="token string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9)"</span>
      <span class="token punctuation">.</span>section <span class="token punctuation">.</span>note<span class="token punctuation">.</span>GNU<span class="token operator">-</span>stack<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>一个汇编程序由如下 4 个基本组件构成</strong>：</p>
<ul>
<li><p><strong>指令（instruction）</strong>：是 CPU 执行的<strong>实际操作</strong>。</p>
</li>
<li><p><strong>伪指令（directive）</strong>：告诉汇编工具生成特定数据，并<strong>将指令或数据放在指定的节。</strong></p>
</li>
<li><p><strong>标号（label）</strong>：在汇编工具中在<strong>汇编工具中引用指令或数据的符号名称。</strong></p>
</li>
<li><p><strong>注释（comment）</strong>：在汇编程序中，可以使用 <code>COMMENT</code> 伪指令来定义注释。</p>
</li>
<li><p>&#96;&#96;&#96;c<br>COMMENT [regexp] ; 在此处输入注释内容    </p>
<pre class="line-numbers language-none"><code class="language-none">
  **例如**：

| 类型   | 示例                  | 含义                            |
| ------ | --------------------- | ------------------------------- |
| 指令   | mov eax,0             | 给 eax 赋值为 0                 |
| 伪指令 | .section .text        | 将以下代码放入.text 节          |
| 伪指令 | .string &quot;foobar&quot;      | 定义包含&quot;foobar”的 ASCII 字符串 |
| 伪指令 | .long 0x12345678      | 定义一个双字 0x12345678         |
| 标号   | foo: .string &quot;foobar&quot; | 使用符号定义“foobar”&quot;字符串     |
| 注释   | #这是注释             | 可读注释                        |

注意：上面的示例是伪指令和标号的示例，它们并不是实际的汇编代码。在实际的汇编代码中，指令和伪指令的顺序是固定的，并且伪指令和标号后面的字符串必须是唯一的。

7.2.什么是 x86 架构
------------

**x86 架构：是微处理器执行的计算机语言指令集，指一个 intel 通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。1978 年 6 月 8 日，Intel 发布了新款 16 位微处理器 “8086”，也同时开创了一个新时代——x86 架构。**

![image-20230415213903625](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152139726.png)

7.3.x86 指令结构
----------

### 7.3.1.x86 的汇编层表示

**x86 的汇编层表示：x86 指令通常表示为助记符 目标地址，源地址。**

*   **助记符**：是人类可读的机器指令表示。
*   **源地址和目标地址**：指令的操作数。

**如汇编指令&#96;mov rbx,rax&#96;就是将寄存器&#96;rax&#96;的值赋给&#96;rbx。&#96;**

![image-20230415214114111](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152141207.png)

### 7.3.2.x86 指令的机器级结构

**x86 指令的机器级结构：由以下部分组成**：

*   **前缀**（可选）：前缀**可以修改指令的行为**，如让一条指令重复执行多次或访问不同的内存段。
*   **操作码**：是指令对其进行**操作的数据**。
*   **寻址模式字节**（可选）：包含有关指令操作数类型的元数据，SIB（scale&#x2F;index&#x2F;base）字节和偏移（displacement）用来表示内存操作数，立即数字段（immediate）包含立即操作数（常量数值），**标识特定的寻址方式。**

![](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152141551.png)

### 7.3.3.x86 操作数来源

**x86 中操作数有三个来源**：

*   寄存器。
*   内存。
*   操作数。

#### 7.3.3.1.寄存器操作数

**x86 寄存器操作数：x86 下只需关注如下 8 个寄存器，每个寄存器以&#96;E&#96;开头，表示&#96;Extended&#96;，长度为 32bit。分为三类**：

*   **以&#96;X&#96;结尾**：通用寄存器。
*   **以&#96;I&#96;结尾**：变址寄存器。
*   **以&#96;P&#96;结尾**：堆栈寄存器。

![image-20230415214508206](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152145304.png)

**对于上面的四个通用寄存器，也可以只使用低 16bit 或低 8bit。**

![image-20230415214540807](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152145906.png)

![image-20230415214552671](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152148376.png)

#### 7.3.3.2.内存操作数

**内存操作数：在 x86 中，可以用&#96;[base+index*scale+displacement]&#96;指定内存操作数**。

*   &#96;base&#96;和&#96;index&#96;：是 64 位寄存器。
*   &#96;scale&#96;：1、2、4 或 8 的整数值。
*   &#96;displacement&#96;（偏移）：是 32 位常量或符号。

**例如&#96;mov eax, dword ptr[af966h]&#96;就表示将内存地址 af996h 所指的 32bit 值复制到寄存器&#96;eax&#96;中**。

*   &#96;dword ptr&#96;：双字（32bit）。
*   &#96;word ptr&#96;：单字（16bit）。
*   &#96;byte ptr&#96;：字节（8bit）。

#### 7.3.3.1.立即数

**立即数：立即数就是指令中硬编码的常量整数操作数，如指令&#96;add rax,42&#96;，其中 42 就是一个立即数。**

7.4.x86 指令例子
----------

*   &#96;mov eax, ebx&#96;：将寄存器&#96;ebx&#96;的值复制到寄存器&#96;eax&#96;中。
*   &#96;mov eax, 5&#96;：将立即数 5 复制到寄存器&#96;eax&#96;中。
*   &#96;mov eax, dword ptr[af996h]&#96;：将内存地址 af996h 所指的 32bit 值复制到寄存器&#96;eax&#96;中。
*   &#96;mov byte prt[af996h], 5&#96;：将立即数 5 复制到内存地址 af996h 所指的一字节中。
*   &#96;mov eax, dword ptr[ebx]&#96;：将&#96;ebx&#96;所指主存地址的 32bit 复制到&#96;eax&#96;寄存器中。
*   &#96;mov dword ptr[ebx], eax&#96;：将&#96;eax&#96;的内容复制到&#96;ebx&#96;所指主存地址的 32bit 中。
*   &#96;mov eax byte ptr[ebx]&#96;：将&#96;ebx&#96;所指的主存地址的 8bit 复制到&#96;eax&#96;中。
*   &#96;mov eax, [ebx]&#96;: 若未指明主存读写长度，默认 32 bit。
*   &#96;mov [af996h], eax&#96;：将&#96;eax&#96;的内容复制到 af996h 所指的地址（未指明长度默认 32 bit）。
*   &#96;mov eax, dword ptr[ebx+8]&#96;：将&#96;ebx+8&#96;所指主存地址的 32bit 复制到&#96;eax&#96;寄存器中。

7.5.AT&amp;T 格式和 intel 格式对比
---------------------

![image-20230415220645899](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152206018.png)

**表示 x86 机器指令的语法格式主要有两种，其中 intel 格式考试最为常见**：

*   **AT&amp;T 格式**（Linux）：显式地在每个**寄存器名称**的前面加上 % 符号，每个**常量**前面加上 $ 符号；源操作数在目的操作数**前面**。
*   **Intel 格式**（Windows）：相对简洁、不加符号；源操作数在目的操作数**后面。**

**区别一：操作数位置**。

*   **AT&amp;T 格式源操作数在左，目的操作数在右面**：&#96;op s, d。&#96;
*   **intel 格式目的操作数在左，源操作数在右面**：&#96;op d, s。&#96;

**区别二：寄存器表示。**

*   **AT&amp;T 格式寄存器名之前必须加&#96;%&#96;**：&#96;mov %ebx, %eax。&#96;
*   **intel 格式直接写寄存器名即可**： &#96;mov eax, ebx。&#96;

**区别三：立即数表示**。

*   **AT&amp;T 格式立即数之前必须加&#96;$&#96;**：&#96;mov $985, %eax。&#96;
*   **intel 格式直接写立即数即可**： &#96;mov eax, 985。&#96;

**区别四：主存地址表示。**

*   **AT&amp;T 格式使用中括号&#96;()&#96;表示主存地址**：&#96;mov $eax, (af996h)。&#96;
*   **intel 格式使用中括号&#96;[]&#96;表示主存地址**： &#96;mov [af996], eax。&#96;

**区别五：读写长度表示。**

*   **AT&amp;T 格式使用&#96;b&#96;、&#96;w&#96;、&#96;l&#96;分别代表&#96;byte&#96;、&#96;word&#96;、&#96;dword&#96;，写到指令的后面**：&#96;movb $5, (af997h)&#96;、&#96;movw $5, (af997h)&#96;、&#96;movl $5, (af997h)&#96;。
*   **intel 格式在主存地址前面使用&#96;byte&#96;、&#96;word&#96;、&#96;dword&#96;说明**：&#96;mov byte ptr [af996h], 5&#96;、&#96;mov word ptr [af996h], 5&#96;、&#96;mov dword ptr [af996h], 5&#96;。

**区别六：主存地址偏移量表示**

*   **AT&amp;T 格式使用&#96;偏移量(基址)&#96;或&#96;偏移量（基址,变址,比例因子）&#96;表示**：&#96;movl -8(%ebx), %eax&#96;、&#96;mov eax,[ebx+ecx*32+4]&#96;。
*   **intel 格式使用&#96;[基址+偏移量]&#96;或&#96;[基址+变址*比例因子+偏移量]&#96;表示**： &#96;mov eax, [ebx-8]&#96;、&#96;mov eax, [ebx+ecx*32+4]&#96;。

# 8.常用的x86汇编指令、选择和循环语句的机器级表示

![image-20230415220429441](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152204539.png)

8.1.常见的算数运算指令
-----------

**注意**：

*   除法中&#96;s&#96;作除数，被除数会被**提前放置**到&#96;edx&#96;和&#96;eax&#96;当中。
*   &#96;edx:eax&#96;：在进行除法运算之前，需要把被除数进行**位扩展**为 64bit，所以需要两个寄存器。

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文名&lt;&#x2F;th&gt;&lt;th&gt;英文名&lt;&#x2F;th&gt;&lt;th&gt;汇编指令&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;加&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;add&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;add d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;计算&lt;code&gt;d+s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;减&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;subtract&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;sub d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;计算&lt;code&gt;d-s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;乘&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;multiply&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;mul d,s&lt;&#x2F;code&gt; 和&lt;code&gt;imul d, s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;无符号数&lt;code&gt;d*s&lt;&#x2F;code&gt;和有符号数&lt;code&gt;d*s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;除&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;divide&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;div d,s&lt;&#x2F;code&gt;和&lt;code&gt;idiv d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;无符号数和有符号除法&lt;code&gt;edx:eax&#x2F;s&lt;&#x2F;code&gt; ，其中商存入&lt;code&gt;eax&lt;&#x2F;code&gt;，余数存入&lt;code&gt;edx&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;取负数&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;negative&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;neg d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;取负数，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;自增&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;increase&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;inc d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;也即&lt;code&gt;d++&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;自减&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;decrease&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;dec d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;也即&lt;code&gt;d--&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;

**举例**：

*   &#96;sub eax, 10&#96;：计算&#96;eax-10&#96;并存入&#96;eax&#96;。
*   &#96;add byte ptr [var], 10&#96;：&#96;var&#96;所指内存地址一字节值与 10 相加，结果存入&#96;var&#96;所指内存地址处。

8.2.常见的逻辑运算指令
-----------

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文名&lt;&#x2F;th&gt;&lt;th&gt;英文名&lt;&#x2F;th&gt;&lt;th&gt;汇编指令&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;与&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;and&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;and d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位相与，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;或&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;or&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;or d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位相或，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;非&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;not&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;not d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逐位取反，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;异或&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;exclusive or&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;xor d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位异或，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;左移&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shift left&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shl d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逻辑左移&lt;code&gt;s&lt;&#x2F;code&gt;位，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;右移&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shift rightft&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shr d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逻辑右移&lt;code&gt;s&lt;&#x2F;code&gt;位，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;

8.3.其他类型指令
--------

### 8.3.1.数据传送类指令

*   &#96;mov&#96;：将第二个操作数 (寄存器的内容、内存中的内容或常数值) **复制**到第一个操作数 (寄存器或内存)。但不能用于直接从内存复制到内存。
*   &#96;push&#96;：将**操作数压入内存的栈**，常用于函数调用。ESP 是栈顶，压栈前先将 ESP 值减 4 (栈增长方向与内存地址增长方向相反)，然后将操作数压入 ESP 指示的地址。
*   &#96;pop&#96;：与 push 指令相反，pop 指令执行的是**出栈工作**，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4。

### 8.3.2.控制流指令

**指令指针寄存器 IP（相当于 ARM 型 CPU 中的程序计数器 PC）：x86 处理器维持着一个指示当前执行指令的指令指针 (IP)， 当一条指令执行后，此指针自动指向下一条指令。IP 寄存器不能直接操作，但可以用控制流指令更新。通常用标签 (label) 指示程序中的指令地址，在 x86 汇编代码中，可在任何指令前加入标签。**

*   &#96;jmp&#96;：**无条件转移指令**，控制 IP 转移到 **label 所指示的地址** (从 label 中取出指令执行)。
*   &#96;jcondition&#96;：**条件转移指令**，依据 CPU 状态字中的一系列条件状态转移。CPU 状态字中包括指示最后一个算术运算结果是否为 0，运算结果是否为负数等。
*   &#96;comp&#x2F;test&#96;：&#96;cmp&#96;指令用于**比较两个操作数的值**，&#96;test&#96; 指令**对两个操作数进行逐位与运算**，这两类指今都不保存操作结果，仅根据运算结果**设置 CPU 状态字中的条件码。**
*   &#96;call&#x2F;ret&#96;：**无条件转移指令**，分别用于实现子程序 (过程、函数等) 的调用及返回。

**对于无条件转移指令&#96;call&#x2F;ret&#96;，其过程调用的执行步骤如下，假设$P$ 调用 $Q$**

*   $P$ 将入口参数 (实参) 放在 $Q$ 能访问到的地方。
*   $P$ 将返回地址存到特定的地方，然后将控制转移到 $Q$。
*   $Q$ 保存$P$ 的现场 (通用寄存器的内容)，并为自己的非静态局部变量分配空间
*   执行过程 $Q$。
*   $Q$ 恢复$P$ 的现场，将返回结果放到$P$ 能访问到的地方，并释放局部变量所占空间。
*   $Q$ 取出返回地址，将控制转移到$P$。

#### 8.3.2.1.无条件转移指令 jmp

![image-20230415220911290](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152209403.png)

**对于&#96;jmp&#96;指令，有如下四种使用方法**：

*   &#96;jmp 128&#96;：地址由常数给出。
*   &#96;jmp eax&#96;：地址可以来自于寄存器。
*   &#96;jmp[999]&#96;：地址可以来自于主存。
*   &#96;jmp NEXT&#96;：地址可以由 “标号” 给出，类似于 C 语言中的 goto 语句。

&#96;&#96;&#96;c
mov eax, 7
mov ebx, 6
jmp NEXT
mov ecx, ebx
NEXT:
mov ecx, eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="8-3-2-2-条件转移指令-jcondition"><a href="#8-3-2-2-条件转移指令-jcondition" class="headerlink" title="8.3.2.2.条件转移指令 jcondition"></a>8.3.2.2.条件转移指令 jcondition</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209013.png" alt="image-20230415220928884" loading="lazy"></p>
<p><strong><code>jmp</code>指令是很不灵活的，无法实现一些复杂条件转移操作，所以需要借助条件转移指令<code>jcondition</code>来完成，同时要借助<code>cmp a, b</code>（比较<code>a</code>和<code>b</code>的大小）。</strong></p>
<ul>
<li><code>je &lt;地址&gt;</code>：若<code>a == b</code> 则跳转（ZF &#x3D;&#x3D; 1）。</li>
<li><code>jne &lt;地址&gt;</code>：若 <code>a != b</code> 则跳转（ZF &#x3D;&#x3D; 0）。</li>
<li><code>jg &lt;地址&gt;</code>：若 <code>a &gt; b</code> 则跳转（ZF &#x3D;&#x3D; 0 &amp;&amp; SF &#x3D;&#x3D; OF）。</li>
<li><code>jge &lt;地址&gt;</code>：若 <code>a &gt;= b</code> 则跳转（ SF &#x3D;&#x3D; OF）。</li>
<li><code>jl &lt;地址&gt;</code>：若 <code>a &lt; b</code> 则跳转（ SF !&#x3D; OF）。</li>
<li><code>jle &lt;地址&gt;</code>：若 <code>a &lt;= b</code> 则跳转（ SF !&#x3D; OF || ZF &#x3D;&#x3D; 1）。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">cmp eax<span class="token punctuation">,</span>ebx # 比较寄存器eax和ebx里的面的值
jg NEXT #若eax<span class="token operator">></span>ebx则跳转至NEXT位置处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="8-4-选择语句的机器级表示"><a href="#8-4-选择语句的机器级表示" class="headerlink" title="8.4.选择语句的机器级表示"></a>8.4.选择语句的机器级表示</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209886.png" alt="image-20230415220954778" loading="lazy"></p>
<p>如下是 C 语言中的<code>if-else</code>语句：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	c <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
	c <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应机器级表示如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">mov eax<span class="token punctuation">,</span> <span class="token number">7</span>  # 变量a<span class="token operator">=</span><span class="token number">7</span>，存入eax中
mov ebx<span class="token punctuation">,</span> <span class="token number">6</span>  # 变量b<span class="token operator">=</span><span class="token number">6</span>，存入ebx中
cmp eax<span class="token punctuation">,</span> ebx  # 比较a和b
jg NEXT  # 若a<span class="token operator">></span>b，跳转至NEXT处
mov ecx<span class="token punctuation">,</span> ebx  # 使用ecx存入变量c，使c<span class="token operator">=</span>b
jmp END
NEXT<span class="token operator">:</span>
mov ecx<span class="token punctuation">,</span> eax  # 使用ecx存入变量c，使c<span class="token operator">=</span>a
END：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="8-5-循环语句的机器级表示"><a href="#8-5-循环语句的机器级表示" class="headerlink" title="8.5.循环语句的机器级表示"></a>8.5.循环语句的机器级表示</h2><h3 id="8-5-1-使用条件转移指令实现循环"><a href="#8-5-1-使用条件转移指令实现循环" class="headerlink" title="8.5.1.使用条件转移指令实现循环"></a>8.5.1.使用条件转移指令实现循环</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214569.png" alt="image-20230415221409430" loading="lazy"></p>
<p><strong>使用条件转移指令实现循环由以下 4 部分构成</strong>：</p>
<ul>
<li>循环前的初始化。</li>
<li>是否直接跳过循环。</li>
<li>循环主体。</li>
<li>是否继续循环。</li>
</ul>
<p>如下代码是 C 语言中的<code>for</code>循环，用于求解 1+2+…+100。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	result <span class="token operator">+=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应机器级表示如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">mov eax<span class="token punctuation">,</span><span class="token number">0</span>  # 使用eax保存result，初始值为<span class="token number">0</span>
mov edx<span class="token punctuation">,</span><span class="token number">1</span>  # 使用edx保存i，初始值为<span class="token number">1</span>

cmp edx<span class="token punctuation">,</span><span class="token number">100</span> # 比较i和<span class="token number">100</span>的大小
jg L2 # 如果i<span class="token operator">></span><span class="token number">100</span>，跳转至L2处

L1<span class="token operator">:</span> # 循环主体
add eax<span class="token punctuation">,</span>edx # result <span class="token operator">+=</span> i
inc edx # i<span class="token operator">++</span>
cmp edx<span class="token punctuation">,</span><span class="token number">100</span> # 比较i和<span class="token number">100</span>的大小
jle L1 # 如果i<span class="token operator">&lt;=</span><span class="token number">100</span>，跳转至L1处

l2<span class="token operator">:</span>  # 结束循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-5-2-使用-loop-指令实现循环"><a href="#8-5-2-使用-loop-指令实现循环" class="headerlink" title="8.5.2.使用 loop 指令实现循环"></a>8.5.2.使用 loop 指令实现循环</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214515.png" alt="image-20230415221427405" loading="lazy"></p>
<p><strong>从理论上讲，能用 loop 指令实现的功能也一定能用条件转移指令实现。loop 指令的存在目的是为了使代码更加清晰、简洁，让其余分支语句区别更明显</strong>。</p>
<p>如下代码是 C 语言中的<code>for</code>循环，固定循环 500 次：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">do</span> something<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>对应机器级表示如下，其中：</p>
<ul>
<li><code>loop Looptop</code>：等价于<code>dec ecx</code>、<code>cmp ecx, 0</code>、<code>jne Looptop</code>。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">mov ecx<span class="token punctuation">,</span> <span class="token number">500</span>  # ecx是循环变量
Looptop<span class="token operator">:</span>  # 循环开始
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">do</span> something
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

loop Looptop  # ecx<span class="token operator">--</span>，若ecx <span class="token operator">!=</span> <span class="token number">0</span>，跳转至Looptop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="8-6-cmp指令的底层原理"><a href="#8-6-cmp指令的底层原理" class="headerlink" title="8.6.cmp指令的底层原理"></a>8.6.cmp指令的底层原理</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152213132.png" alt="image-20230415221302986" loading="lazy"></p>
<h1 id="9-CISC和RISC简单了解"><a href="#9-CISC和RISC简单了解" class="headerlink" title="9.CISC和RISC简单了解"></a>9.CISC和RISC简单了解</h1><p>指令系统的设计如今朝着两个截然不同的方向发展：</p>
<p><strong>一是增强原有指令的功能，设置为更复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC），典型的如 ×86 架构的计算机；二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC），典型的有 ARM，MIPS 架构的计算机</strong>。</p>
<h2 id="9-1-复杂指令系统计算机（CISC）"><a href="#9-1-复杂指令系统计算机（CISC）" class="headerlink" title="9.1.复杂指令系统计算机（CISC）"></a>9.1.复杂指令系统计算机（CISC）</h2><p>随着 VLSI 技术的发展，硬件成本不断降低，软件成本不断上升，促使人们在系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了 CISC。其主要特点如下：</p>
<ol>
<li>指令系统复杂庞大，指令数目一般为 200 条以上。</li>
<li>指令的长度不固定，指令格式多，寻址方式多。</li>
<li>可以访存的指令不受限制。</li>
<li>各种指令使用的频度相差很大。</li>
<li>各种指令执行时间相差很大，大多数指令需要多个时钟周期才能完成。</li>
<li>控制器大多数采用微程序编程。有的指令非常复杂，以至于无法采用硬连线控制。</li>
<li>难以用优化编译生成高效的目标代码途径。</li>
</ol>
<p>如此庞大的指令系统，对指令的设计提出了极高的要求，胭研制周期变得很长。后来人们发现一味地追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径。对传统 CISC 指令系统测试表明，各种指令的使用频率相差悬殊，从这一事实出发，人们开始了指令系统合理性的研究，于是 RISC 随之诞生。</p>
<h2 id="9-2-精简指令系统计算机（RISC）"><a href="#9-2-精简指令系统计算机（RISC）" class="headerlink" title="9.2.精简指令系统计算机（RISC）"></a>9.2.精简指令系统计算机（RISC）</h2><p>RISC 的中心思想是要求指令系统简化，尽量使用寄存器 - 寄存器操作指令，指令格式力求一致。其主要特点如下：</p>
<ol>
<li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令组合实现。</li>
<li>指令长度固定，指令格式种类少，寻址方式种类少。</li>
<li>只有 Load&#x2F;Store(取数 &#x2F; 存数) 指令访存，其余指令的操作都在寄存器之间进行。</li>
<li>CPU 中通用寄存器的数量相当多。</li>
<li>RISC 一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li>
<li>以硬布线控制为主，少用或者不用微程序控制。</li>
<li>特别重视编译优化工作，以减少程序执行时间。</li>
</ol>
<p>值得注意的是，从指令系统的兼容性来看，CISC 大多能够实现软件兼容，即高高档机包含了低档机的全部指令，并可以进行扩充。但 RISC 简化了指令系统，指令条数少，格式也不同于老机器，因此大多数 RISC 机不能与老机器兼容。由于 RISC 具有更强的实用性，因此应该是未来处理器发展的方向。但事实上，当今时代 Intex 几乎一统江湖，且早期很多软件都是根据 CISC 设计的，单纯的 RISC 将无法兼容。此外，现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分，其性能差距已经越来越小。CISC 可以提供更多的功能，这一点是程序设计所需要的。</p>
<h2 id="9-3-CISC-和-RISC-比较"><a href="#9-3-CISC-和-RISC-比较" class="headerlink" title="9.3.CISC 和 RISC 比较"></a>9.3.CISC 和 RISC 比较</h2><p>和 CISC 相比，RISC 的优点主要集中在以下几个方面：</p>
<ol>
<li><strong>RISC 更能充分利用 VLSI 芯片的面积</strong>。CISC 的控制器大多采用微程序控制，其控制存储器在 CPU 芯片内所占面积会达到 50% 以上，而 RISC 控制器采用组合逻辑控制，其硬布线逻辑只占 CPU 芯片面积的 10% 左右。</li>
<li><strong>RISC 更能提高运行速度</strong>。RISC 的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。</li>
<li><strong>RISC 便于设计</strong>，可以降低成本，提高可靠性。RISC 指令系统简单，因此机器设计周期短，其逻辑简单。</li>
<li><strong>RISC 有利于程序优化</strong>。RISC 指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更加高效化。</li>
</ol>
<p>RISC 和 CISC 具体区别如下 ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152216907.png" alt="image-20230415221635811" loading="lazy"></p>
<h2 id="9-4-计算机的工作过程"><a href="#9-4-计算机的工作过程" class="headerlink" title="9.4.计算机的工作过程"></a>9.4.计算机的工作过程</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152217826.png" alt="image-20230415221755716" loading="lazy"></p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay-qrcode.jpg"><img loading="lazy" src="/images/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/qqpay-qrcode.jpg"><img loading="lazy" src="/images/qqpay-qrcode.jpg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay-qrcode.jpg"><img loading="lazy" src="/images/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Explorer</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://ccsu.top/posts/de459af/" title="机组-第四章 指令系统">http://ccsu.top/posts/de459af/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/ea8ec112/" rel="prev" title="机组-第五章 中央处理器"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">机组-第五章 中央处理器</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/2dbdbfc/" rel="next" title="机组-第三章 存储系统"><span class="post-nav-text">机组-第三章 存储系统</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div id="waline"></div><script src="/js/comments/waline.js" type="module" defer></script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">皖ICP备20002891号-2</a></div><div class="copyright"><span>&copy; 2016 – 2023 </span><span class="with-love" id="animate" title="赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Explorer</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.0.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.8</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-02-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} Days ${passHour} Hours ${passMinute} Minutes ${passSecond} Seconds`;
}
blog_live_time();
</script></div><div id="busuanzi"><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":350,"hOffset":null,"vOffset":null},"mobile":{"show":true},"log":false});</script></body></html>