<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="Explorer"><meta name="copyright" content="Explorer"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>机组-第五章 中央处理器 | explorerの博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" type="image/png" href="/./favicon.ico"><link rel="mask-icon" href="/./favicon.ico" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"ccsu.top","root":"/","title":["Wu","Shuai","の","Blog"],"version":"1.8.8","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"waline":{"config":{"enable":true,"serverURL":"https://blog-api-seven-vert.vercel.app/","comment":false,"visitor":false,"emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"2506812280@qq.com"},"requiredMeta":["nick"],"el":"#waline","lang":"en","path":"/posts/ea8ec112/"},"cdn":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","dark":"html.dark"},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="explorerの博客" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-BMBD00SVV4"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BMBD00SVV4');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="1.CPU的基本功能和结构 1.1.CPU 的功能1.1.1.CPU 的具体功能CPU 具体功能包括：  指令控制：完成取指令、分析指令和执行指令的操作，也即程序的顺序控制。 操作控制：一条指令的功能是通过若干操作信号组合来实现的。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应部件，从而控制这些部件按指令的要求进行动作。 时间控制：对各种操作加以时间上的控制。时间控制要为">
<meta property="og:type" content="article">
<meta property="og:title" content="机组-第五章 中央处理器">
<meta property="og:url" content="http://ccsu.top/posts/ea8ec112/index.html">
<meta property="og:site_name" content="explorerの博客">
<meta property="og:description" content="1.CPU的基本功能和结构 1.1.CPU 的功能1.1.1.CPU 的具体功能CPU 具体功能包括：  指令控制：完成取指令、分析指令和执行指令的操作，也即程序的顺序控制。 操作控制：一条指令的功能是通过若干操作信号组合来实现的。CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应部件，从而控制这些部件按指令的要求进行动作。 时间控制：对各种操作加以时间上的控制。时间控制要为">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161552750.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161531640.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532177.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532930.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161533771.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161534435.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161540190.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161541097.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161544495.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161550448.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161611723.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161554507.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161555299.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556575.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557897.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558392.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161559158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558096.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161601516.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161602831.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171116631.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161604726.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161605611.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161606339.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608679.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608595.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161614739.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161616080.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161617187.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618824.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161619583.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161628556.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161629503.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161630911.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161634185.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161635806.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161636910.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637327.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161638315.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639870.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424883.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640100.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161649331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647652.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161428320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647475.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161648003.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161713047.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652162.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652735.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161653434.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655637.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655839.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657694.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657883.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657606.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161658376.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161659864.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161700481.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161701021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161705356.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708366.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708736.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709818.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162018083.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709168.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161719373.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161714659.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161715734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161716475.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161718354.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161725625.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721386.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721563.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721619.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722551.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722368.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723204.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161724375.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161750234.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161738357.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161747220.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752751.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161757080.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161945862.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758588.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758581.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758172.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017986.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161759655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171125130.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161802331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810973.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161806136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161805535.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807614.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809003.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161808032.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807591.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809667.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810398.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161811432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161947573.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161948409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161950321.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162004915.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955615.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955174.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161956973.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161957622.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161959391.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162011405.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012378.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012684.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013395.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013448.png">
<meta property="article:published_time" content="2023-04-09T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-09T16:00:00.000Z">
<meta property="article:author" content="Explorer">
<meta property="article:tag" content="计算机组成原理">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161552750.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Explorer"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Explorer"><span class="site-author-status" title="努力学习">😄</span></a><div class="site-author-name"><a href="/about/">Explorer</a></div><span class="site-name">explorerの博客</span><sub class="site-subtitle"></sub><div class="site-desciption">前路漫漫，当克己，当慎独!</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">73</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">64</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wushuai2000" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=549838440" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/huan-ji-91-3/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/345844264" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2506812280@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">1.CPU的基本功能和结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-CPU-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.CPU 的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-CPU-%E7%9A%84%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1.CPU 的具体功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%AF%8F%E4%B8%AA%E9%83%A8%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2.每个部件的功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%90%E7%AE%97%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.运算器基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E8%BF%90%E7%AE%97%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1.运算器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2.两种数据通路设计方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-1-%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.2.2.1.专用数据通路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-2-CPU-%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF%EF%BC%88%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">1.2.2.2.CPU 内部单总线（主要使用）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.控制器基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1.控制器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2.控制器控制过程概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-CPU-%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%94%E2%80%94%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93"><span class="toc-number">1.4.</span> <span class="toc-text">1.4.CPU 的本质——寄存器的集合体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">2.指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.指令周期是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.指令周期流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1.取指周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2.间址周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3.执行周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4.中断周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-1-%E4%B8%AD%E6%96%AD"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">2.2.4.1.中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-2-%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2.2.4.2.中断周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">2.3.指令执行方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%8D%95%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1.单指令周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%A4%9A%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2.多指令周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3.流水线方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">3.数据通路单总线结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.有关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-CPU-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1.CPU 中数据的流动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2.数据通路和控制信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3.数据通路种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%86%85%E9%83%A8%E6%80%BB%E7%BA%BF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4.内部总线与系统总线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.寄存器之间的数据流动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%B8%BB%E5%AD%98%E4%B8%8E-CPU-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.主存与 CPU 之间的数据流动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E-ALU-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.寄存器与 ALU 之间的数据流动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%9C%89%E5%85%B3-CPU-%E5%86%85%E9%83%A8%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">3.5.有关 CPU 内部单总线经典例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E4%B8%93%E7%94%A8%E9%80%9A%E8%B7%AF%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">4.数据通路专用通路结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BE%8B%E9%A2%98"><span class="toc-number">4.2.</span> <span class="toc-text">4.2.例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">5.硬布线控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%86%85%E5%AE%B9%E5%9B%9E%E9%A1%BE%E5%92%8C%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.内容回顾和一些概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.硬布线控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-CU-%E5%A6%82%E4%BD%95%E5%8F%91%E5%87%BA%E5%BE%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1.CU 如何发出微命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E9%80%BB%E8%BE%91%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2.逻辑化表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.3.</span> <span class="toc-text">5.3.硬布线控制器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1.硬布线控制器设计步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E5%88%86%E6%9E%90%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2.步骤一：分析各个阶段的微操作序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E5%AE%89%E6%8E%92%E5%BE%AE%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3.步骤三：安排微操作时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E6%AD%A5%E9%AA%A4%E5%9B%9B%EF%BC%9A%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%EF%BC%89"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4.步骤四：组合逻辑设计（电路设计）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.</span> <span class="toc-text">5.4.总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">6.微程序控制器的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">6.1.</span> <span class="toc-text">6.1.微程序控制器的设计思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">6.2.微程序控制器的基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1.微程序控制器基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.1.微程序控制器工作过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">6.3.微程序控制器的工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">7.微指令的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">7.1.微指令的格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E6%B0%B4%E5%B9%B3%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1.水平型微指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E5%9E%82%E7%9B%B4%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2.垂直型微指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E6%B7%B7%E5%90%88%E5%9E%8B%E5%BE%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3.混合型微指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">7.2.微指令的编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%EF%BC%88%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1.直接编码（直接控制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2.字段直接编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3.字段间接编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">7.3.微指令的地址形成方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E4%B8%8B%E5%9C%B0%E5%9D%80%E7%BB%99%E5%87%BA"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1.下地址给出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E6%93%8D%E4%BD%9C%E7%A0%81%E5%BD%A2%E6%88%90"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2.操作码形成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E5%A2%9E%E9%87%8F%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">7.3.3.</span> <span class="toc-text">7.3.3.增量计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-%E5%88%86%E6%94%AF%E8%BD%AC%E7%A7%BB"><span class="toc-number">7.3.4.</span> <span class="toc-text">7.3.4.分支转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-5-%E9%80%9A%E8%BF%87%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C"><span class="toc-number">7.3.5.</span> <span class="toc-text">7.3.5.通过测试网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-6-%E7%94%B1%E7%A1%AC%E4%BB%B6%E4%BA%A7%E7%94%9F%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="toc-number">7.3.6.</span> <span class="toc-text">7.3.6.由硬件产生微程序入口地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text">8.微程序控制单元的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.1.</span> <span class="toc-text">8.1.微程序控制单元设计步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%88%86%E6%9E%90%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1.第一步：分析每个阶段的微操作序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%86%99%E5%87%BA%E5%AF%B9%E5%BA%94%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%8A%82%E6%8B%8D%E5%AE%89%E6%8E%92"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2.第二步：写出对应机器指令的微操作命令及节拍安排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.1.3.</span> <span class="toc-text">8.1.3.第三步：确定微指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-4-%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E7%BC%96%E5%86%99%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%A0%81%E7%82%B9"><span class="toc-number">8.1.4.</span> <span class="toc-text">8.1.4.第四步：编写微指令码点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%86%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">8.2.微程序设计分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E9%9D%99%E6%80%81%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%8A%A8%E6%80%81%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1.静态微程序设计和动态微程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E6%AF%AB%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2.毫微程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E6%AF%94%E8%BE%83"><span class="toc-number">8.3.</span> <span class="toc-text">8.3.硬布线控制器和微程序控制器比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">9.</span> <span class="toc-text">9.中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">9.1.中断的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.2.</span> <span class="toc-text">9.2.中断的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E5%A4%96%E4%B8%AD%E6%96%AD%EF%BC%88%E4%B8%AD%E6%96%AD%EF%BC%89"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1.外中断（中断）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E5%86%85%E4%B8%AD%E6%96%AD%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%89"><span class="toc-number">9.2.2.</span> <span class="toc-text">9.2.2.内中断（异常）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">9.3.</span> <span class="toc-text">9.3.中断的处理过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">10.</span> <span class="toc-text">10.指令流水线基本概念性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">10.1.指令流水的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">10.1.1.顺序执行方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-%E4%B8%80%E6%AC%A1%E9%87%8D%E5%8F%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.2.</span> <span class="toc-text">10.1.2.一次重叠方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-3-%E4%BA%8C%E6%AC%A1%E9%87%8D%E5%8F%A0%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.3.</span> <span class="toc-text">10.1.3.二次重叠执行方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">10.2.流水线的表示方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE"><span class="toc-number">10.2.1.</span> <span class="toc-text">10.2.1.指令执行过程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E6%97%B6%E7%A9%BA%E5%9B%BE"><span class="toc-number">10.2.2.</span> <span class="toc-text">10.2.2.时空图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">10.3.</span> <span class="toc-text">10.3.流水线性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-1-%E5%90%9E%E5%90%90%E7%8E%87"><span class="toc-number">10.3.1.</span> <span class="toc-text">10.3.1.吞吐率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-2-%E5%8A%A0%E9%80%9F%E6%AF%94"><span class="toc-number">10.3.2.</span> <span class="toc-text">10.3.2.加速比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-3-%E6%95%88%E7%8E%87"><span class="toc-number">10.3.3.</span> <span class="toc-text">10.3.3.效率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0%E5%88%86%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">11.指令流水线影响因素分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%BD%B1%E5%93%8D%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">11.1.</span> <span class="toc-text">11.1.影响指令流水线的因素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1-%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%EF%BC%88%E8%B5%84%E6%BA%90%E5%86%B2%E7%AA%81%EF%BC%89"><span class="toc-number">11.1.1.</span> <span class="toc-text">11.1.1.结构相关（资源冲突）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">11.1.1.1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.1.2.</span> <span class="toc-text">11.1.1.2.解决方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-2-%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%EF%BC%88%E6%95%B0%E6%8D%AE%E5%86%B2%E7%AA%81%EF%BC%89"><span class="toc-number">11.1.2.</span> <span class="toc-text">11.1.2.数据相关（数据冲突）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.2.1.</span> <span class="toc-text">11.1.2.1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.2.2.</span> <span class="toc-text">11.1.2.2.解决方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-3-%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%EF%BC%88%E6%8E%A7%E5%88%B6%E5%86%B2%E7%AA%81%EF%BC%89"><span class="toc-number">11.1.3.</span> <span class="toc-text">11.1.3.控制相关（控制冲突）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.3.1.</span> <span class="toc-text">11.1.3.1.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.3.2.</span> <span class="toc-text">11.1.3.2.解决方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">11.2.流水线的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E6%A0%B9%E6%8D%AE%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BA%A7%E5%88%AB%E4%B8%8D%E5%90%8C%E5%88%86%E7%B1%BB"><span class="toc-number">11.2.1.</span> <span class="toc-text">11.2.1.根据流水线使用的级别不同分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E6%A0%B9%E6%8D%AE%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E4%BB%A5%E5%AE%8C%E6%88%90%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB"><span class="toc-number">11.2.2.</span> <span class="toc-text">11.2.2.根据流水线可以完成的功能分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E6%A0%B9%E6%8D%AE%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E5%86%85%E5%90%84%E6%AE%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">11.2.3.</span> <span class="toc-text">11.2.3.根据同一时间内各段之间的连接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-%E6%A0%B9%E6%8D%AE%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%90%84%E4%B8%AA%E5%8A%9F%E8%83%BD%E6%AE%B5%E4%B9%8B%E9%97%B4%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%8D%E9%A6%88%E4%BF%A1%E5%8F%B7"><span class="toc-number">11.2.4.</span> <span class="toc-text">11.2.4.根据流水线的各个功能段之间是否有反馈信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF"><span class="toc-number">11.3.</span> <span class="toc-text">11.3.流水线多发技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-1-%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF"><span class="toc-number">11.3.1.</span> <span class="toc-text">11.3.1.超标量技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-2-%E8%B6%85%E6%B5%81%E6%B0%B4%E6%8A%80%E6%9C%AF"><span class="toc-number">11.3.2.</span> <span class="toc-text">11.3.2.超流水技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-3-%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97"><span class="toc-number">11.3.3.</span> <span class="toc-text">11.3.3.超长指令字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E4%BA%94%E6%AE%B5%E5%BC%8F%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">12.</span> <span class="toc-text">12.五段式指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E8%BF%90%E7%AE%97%E7%B1%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">12.1.</span> <span class="toc-text">12.1.运算类指令的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-LOAD-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">12.2.</span> <span class="toc-text">12.2.LOAD 指令执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-STORE-%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">12.3.</span> <span class="toc-text">12.3.STORE 指令执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">12.4.</span> <span class="toc-text">12.4.条件转移指令执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">12.5.</span> <span class="toc-text">12.5.无条件转移指令执行过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">13.</span> <span class="toc-text">13.多处理器基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-SISD%E3%80%81SIMD%E3%80%81MIMD-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">13.1.</span> <span class="toc-text">13.1.SISD、SIMD、MIMD 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1-%E5%8D%95%E6%8C%87%E4%BB%A4%E5%8D%95%E6%95%B0%E6%8D%AE%E6%B5%81-SISD"><span class="toc-number">13.1.1.</span> <span class="toc-text">13.1.1.单指令单数据流 SISD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-%E5%8D%95%E6%8C%87%E4%BB%A4%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81-SIMD"><span class="toc-number">13.1.2.</span> <span class="toc-text">13.1.2.单指令多数据流 SIMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-3-%E5%A4%9A%E6%8C%87%E4%BB%A4%E5%8D%95%E6%95%B0%E6%8D%AE%E6%B5%81-MISD"><span class="toc-number">13.1.3.</span> <span class="toc-text">13.1.3.多指令单数据流 MISD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-4-%E5%A4%9A%E6%8C%87%E4%BB%A4%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81-MIMD"><span class="toc-number">13.1.4.</span> <span class="toc-text">13.1.4.多指令多数据流 MIMD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-4-1-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.1.4.1.</span> <span class="toc-text">13.1.4.1.多处理器系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-4-2-%E5%A4%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.1.4.2.</span> <span class="toc-text">13.1.4.2.多计算机系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">13.2.</span> <span class="toc-text">13.2.向量处理器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E7%A1%AC%E4%BB%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">14.</span> <span class="toc-text">14.硬件多线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E7%BB%86%E7%B2%92%E5%BA%A6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">14.1.</span> <span class="toc-text">14.1.细粒度多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E7%B2%97%E7%B2%92%E5%BA%A6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">14.2.</span> <span class="toc-text">14.2.粗粒度多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E5%90%8C%E6%97%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">14.3.</span> <span class="toc-text">14.3.同时多线程</span></a></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/57%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/" style="font-size: 12px; color: #999">57步进电机</a> <a href="/tags/AT9SPro/" style="font-size: 12px; color: #999">AT9SPro</a> <a href="/tags/Anaconda/" style="font-size: 12px; color: #999">Anaconda</a> <a href="/tags/Arduino/" style="font-size: 24px; color: #3383cd">Arduino</a> <a href="/tags/CUDA/" style="font-size: 18px; color: #668eb3">CUDA</a> <a href="/tags/CUDNN/" style="font-size: 12px; color: #999">CUDNN</a> <a href="/tags/Conda/" style="font-size: 12px; color: #999">Conda</a> <a href="/tags/DHT11/" style="font-size: 12px; color: #999">DHT11</a> <a href="/tags/Docker/" style="font-size: 18px; color: #668eb3">Docker</a> <a href="/tags/ESP8266/" style="font-size: 12px; color: #999">ESP8266</a> <a href="/tags/GPIO/" style="font-size: 30px; color: #0078e7">GPIO</a> <a href="/tags/GPS/" style="font-size: 12px; color: #999">GPS</a> <a href="/tags/GPU/" style="font-size: 24px; color: #3383cd">GPU</a> <a href="/tags/HC-05/" style="font-size: 12px; color: #999">HC-05</a> <a href="/tags/HTML/" style="font-size: 18px; color: #668eb3">HTML</a> <a href="/tags/Hexo/" style="font-size: 18px; color: #668eb3">Hexo</a> <a href="/tags/Hexo%E5%AE%89%E8%A3%85/" style="font-size: 24px; color: #3383cd">Hexo安装</a> <a href="/tags/IAR%E8%BD%AF%E4%BB%B6/" style="font-size: 12px; color: #999">IAR软件</a> <a href="/tags/JavaScript/" style="font-size: 18px; color: #668eb3">JavaScript</a> <a href="/tags/Json/" style="font-size: 12px; color: #999">Json</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#6200ee;"><link itemprop="mainEntityOfPage" href="http://ccsu.top/posts/ea8ec112/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Explorer"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="explorerの博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">机组-第五章 中央处理器</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">Posted on</span> <time title="Created: 2023-04-10 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-10T00:00:00+08:00">2023-04-10</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">20.9k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">75m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%80%83%E7%A0%94408/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">考研408</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">计算机组成原理</span></a><a class="tag-item" href="/tags/%E8%80%83%E7%A0%94/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">考研</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="1-CPU的基本功能和结构"><a href="#1-CPU的基本功能和结构" class="headerlink" title="1.CPU的基本功能和结构"></a>1.CPU的基本功能和结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161552750.png" alt="image-20230416155227635" loading="lazy"></p>
<h2 id="1-1-CPU-的功能"><a href="#1-1-CPU-的功能" class="headerlink" title="1.1.CPU 的功能"></a>1.1.CPU 的功能</h2><h3 id="1-1-1-CPU-的具体功能"><a href="#1-1-1-CPU-的具体功能" class="headerlink" title="1.1.1.CPU 的具体功能"></a>1.1.1.CPU 的具体功能</h3><p><strong>CPU 具体功能包括</strong>：</p>
<ul>
<li><strong>指令控制</strong>：完成<strong>取指令、分析指令和执行指令</strong>的操作，也即程序的<strong>顺序控制</strong>。</li>
<li><strong>操作控制</strong>：<strong>一条指令的功能是通过若干操作信号组合来实现的</strong>。CPU 管理并产生由内存取出的每条指令的操作信号，<strong>把各种操作信号送往相应部件，从而控制这些部件按指令的要求进行动作。</strong></li>
<li><strong>时间控制</strong>：对各种操作加以时间上的控制。时间控制要为每条指令按<strong>时间顺序</strong>提供应有的控制信号。</li>
<li><strong>数据加工</strong>：对数据进行<strong>算数和逻辑运算。</strong></li>
<li><strong>中断处理</strong>：对计算机运行过程中出现的<strong>异常情况和特殊请求</strong>进行处理。</li>
</ul>
<h3 id="1-1-2-每个部件的功能"><a href="#1-1-2-每个部件的功能" class="headerlink" title="1.1.2.每个部件的功能"></a>1.1.2.每个部件的功能</h3><p><strong>CPU 由运算器和控制器构成，其中运算器主要作用就是对数据进行加工</strong>；<strong>控制器主要作用就是协调和控制计算机各部件执行程序的指令序列，具体来说</strong>：</p>
<ul>
<li><strong>取指令</strong>：自动形成<strong>指令地址</strong>，自动发出取指令的命令。</li>
<li><strong>分析指令</strong>：操作码<strong>译码</strong>（分析本条指令要完成什么操作）；产生操作数的<strong>有效地址。</strong></li>
<li><strong>执行指令</strong>：由 “操作命令” 和“操作数地址”，形成<strong>操作信号控制序列</strong>，控制运算器、存储器以及 I&#x2F;O 设备完成相应的操作。</li>
<li><strong>中断处理</strong>：管理<strong>总线</strong>及输入输出；处理<strong>异常情况</strong>（比如掉电、浮点异常等）和<strong>特殊情况</strong>的请求（打印机请求打印一行字符等）。</li>
</ul>
<h2 id="1-2-运算器基本结构"><a href="#1-2-运算器基本结构" class="headerlink" title="1.2.运算器基本结构"></a>1.2.运算器基本结构</h2><h3 id="1-2-1-运算器概述"><a href="#1-2-1-运算器概述" class="headerlink" title="1.2.1.运算器概述"></a>1.2.1.运算器概述</h3><p>运算器核心是 <strong>ALU 算数逻辑单元</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161531640.png" loading="lazy">  </p>
<p>ALU需要<strong>两个操作数</strong>，经过处理后，就会输出运算结果。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532177.png" loading="lazy"></p>
<p><strong>运算器是计算机中加工数据的中心</strong>，除了 ALU 外，它还有很多寄存器，这里先给出它们的大致功能：</p>
<ul>
<li><strong>暂存寄存器</strong>：用于<strong>暂存从主存读过来的数据</strong>，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对<strong>应用程序员</strong>是透明的。</li>
<li><strong>累加寄存器</strong>：它是一个通用寄存器，用于<strong>暂时存放 ALU 的运算结果</strong>，可以作为加法运算的一个输入端。</li>
<li><strong>通用寄存器组</strong>：如<code>AX</code>、<code>BX</code>、<code>CX</code>、<code>DX</code>、<code>SP</code>等，用于<strong>存放操作数（包括源操作数，目的操作数及中间结果）和各种地址信息</strong>。注意<code>SP</code>是堆栈指针，用于指示栈顶地址。</li>
<li><strong>程序状态字寄存器</strong>：保留<strong>由算数逻辑运算指令或测试指令的结果而建立的各种状态信息</strong>，如溢出标志（<code>OF</code>）、符号标志（<code>SF</code>）、零标志（<code>ZF</code>），进行标志（<code>CF</code>）等。PSW 中的这些位参与并决定<strong>微操作</strong>的形成。</li>
<li><strong>移位器</strong>：对操作数或运算结果进行<strong>移位运算。</strong></li>
<li><strong>计数器</strong>：控制<strong>乘除运算</strong>的操作步数。</li>
</ul>
<h3 id="1-2-2-两种数据通路设计方式"><a href="#1-2-2-两种数据通路设计方式" class="headerlink" title="1.2.2.两种数据通路设计方式"></a>1.2.2.两种数据通路设计方式</h3><ul>
<li><p>接下来介绍两种数据通路设计方式，来详细探讨这些寄存器的作用。</p>
</li>
<li><p>注意下面的叙述仅仅是了解，不知道没有关系，后面会具体学习的。</p>
</li>
</ul>
<p><strong>数据通路：是指执行部件之间传送信息的路径，由控制信号控制。</strong></p>
<h4 id="1-2-2-1-专用数据通路"><a href="#1-2-2-1-专用数据通路" class="headerlink" title="1.2.2.1.专用数据通路"></a>1.2.2.1.专用数据通路</h4><p><strong>专用数据通路：根据指令执行过程中的数据和地址的流动方向安排连接线路。例如下图中每个寄存器与 ALU 都有专门的数据连线</strong>。</p>
<ul>
<li><p>任何一个通用寄存器中保存的数据都有可能作为 ALU 的输入，因此需要<strong>提供两组连线分别将通用寄存器两端连接至 ALU 两端</strong>（注意连线并不是只有一根，而是要视具体的数据传输情况而定）  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532930.png" alt="image-20230416153257853" loading="lazy"></p>
</li>
</ul>
<p><strong>专用数据通路方式下，有可能多个寄存器会同时向 ALU 传输数据，这显然是不合理的，主要有以下两种解决方案</strong>：</p>
<ul>
<li><p><strong>多路选择器（MUX)<strong>：根据控制信号选择一路输出，</strong>每个多路选择器都可以决定要把哪一个信号输出</strong>。比如下图左侧的多路选择器信号为 00，就表示让 $R_{0} $通过，右侧的多路选择器信号为 01，就表示让$R_{1} $通过  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161533771.png" alt="image-20230416153317677" loading="lazy"></p>
</li>
<li><p><strong>三态门</strong>：控制<strong>每一路是否可以输出</strong>。比如下图， $R_0out  $为 1 时表示 $R_{0} $的数据可以输出到 A 端， $R_0out  $为 0 时表示 $R_{0} $的数据无法输出到 B 端。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161534435.png" alt="image-20230416153447350" loading="lazy"></p>
</li>
</ul>
<p><strong>专用数据通路方式优缺点如下</strong>：</p>
<ul>
<li><strong>优点</strong>：基本不存在数据冲突的现象。</li>
<li><strong>缺点</strong>：结构复杂，流量大，不易实现，只在特殊场合、需求中使用。</li>
</ul>
<h4 id="1-2-2-2-CPU-内部单总线（主要使用）"><a href="#1-2-2-2-CPU-内部单总线（主要使用）" class="headerlink" title="1.2.2.2.CPU 内部单总线（主要使用）"></a>1.2.2.2.CPU 内部单总线（主要使用）</h4><p><strong>CPU 内部单总线：此种方式会将所有寄存器的输入和输出端都连接到一条公共的通路上。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124924.png" alt="image-20230416153521914" loading="lazy"></p>
<ul>
<li>$R_{x}out $ 表示寄存器的输出控制信号， $ R_{x}in$ 表示寄存器的输入控制信号。</li>
</ul>
<p>ALU 接受数据时也是通过总线接受，但这种方式会导致 <strong>ALU 无法分清这是哪一个操作数</strong>，所以我们可以在其中设置一个<strong>暂存寄存器</strong>。例如，<strong>下图中 $R_{0} $的数据会被先送到暂存寄存器上，然后使 $R_{0}out $ 失效，再导通 $R_{1}out $，最后将$R_{1} $数据输出到 B 端，这样的话就可以保证操作数的次序正确</strong>。</p>
<p>同时，<strong>暂存寄存器也可以避免破坏寄存器原有的内容</strong>。例如，某次运算两个操作数分别来自主存和 $R_{0} $，那么来自主存的操作数就可以直接放入暂存寄存器，而不用先放入 A，<strong>这样就避免了因 A 原本有内容而由于主存操作数的读入破坏了其内容的情况发生</strong>。  </p>
<p>ALU 在计算完成之后仍然会将计算结果放回内部总线，不过这样做容易产生一个问题，<strong>一旦输入端发送的信号还没有稳定前，ALU 就产生了计算结果，并通过内部总线送回了寄存器，这样会导致运算错误</strong>。所以我们可以在 ALU 的输出端再加一个暂存寄存器，同时在暂存寄存器上方加一个三态门，等 ALU 输出结果稳定之后，让三态门导通，然后给寄存器加上电信号让输出结果送回寄存器即可。</p>
<h2 id="1-3-控制器基本结构"><a href="#1-3-控制器基本结构" class="headerlink" title="1.3.控制器基本结构"></a>1.3.控制器基本结构</h2><h3 id="1-3-1-控制器概述"><a href="#1-3-1-控制器概述" class="headerlink" title="1.3.1.控制器概述"></a>1.3.1.控制器概述</h3><p><strong>控制器主要作用是取指令，分析指令和执行指令，主要涉及以下寄存器</strong>：</p>
<ul>
<li><strong>程序计数器 PC</strong>：用于指出<strong>下一条指令在主存中的存放地址</strong>。</li>
<li><strong>指令寄存器 IR</strong>：用于保存<strong>当前正在执行的那条指令。</strong></li>
<li><strong>指令译码器</strong>：仅对操作码字段进行<strong>译码</strong>，向控制器提供特定的操作信号。</li>
<li><strong>存储器地址寄存器</strong>：用于存放要<strong>访问的主存单元的地址</strong>。</li>
<li><strong>存储器数据寄存器</strong>：用于存放向<strong>主存写入的信息或从主存读出的信息。</strong></li>
<li><strong>时序系统</strong>：用于产生各种<strong>时序信号</strong>，它们都是由统一时钟（CLOCK）分频得到。</li>
<li><strong>微操作信号发生器</strong>：根据 IR 的内（指令）、PSW 的内容及时序信号，<strong>产生控制计算机系统的所需要的各种控制信号</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161540190.png" loading="lazy"></p>
<h3 id="1-3-2-控制器控制过程概述"><a href="#1-3-2-控制器控制过程概述" class="headerlink" title="1.3.2.控制器控制过程概述"></a>1.3.2.控制器控制过程概述</h3><p><strong>控制器控制过程概述：大致逻辑过程描述如下</strong>：</p>
<ul>
<li><p><strong>程序计数器 PC</strong> 会指明下一条指令的地址，当取出该指令后会将其放到<strong>指令寄存器</strong> IR 当中。指令的地址码指明了操作数的地址信息，所以<strong>地址码的信息需要输出到内部总线上，而操作码部分会送给控制单元 CU</strong>。</p>
</li>
<li><p><strong>具体来说，操作码会送给指令译码器</strong> ，译码器的对应端会被选通，了解当前的指令类型后，就明白了下次执行的微操作是什么，所以<strong>译码器的输出信号会作为微操作信号发生器</strong>的输入信号，用于产生该指令的<strong>微操作序列</strong>。</p>
</li>
<li><p>微操作序列需要受到时序系统的控制。<strong>时序系统</strong>产生时序信号，微操作发生器每接受到一次信号，就会产生一个微操作（注意此时会受到 PSW 标志位的影响，有可能改变微操作的类型）。</p>
</li>
<li><p>最后还需要 <strong>MAR 和 MDR</strong>，MAR 连接地址总线，MDR 连接数据总线，用于和存储器进行交互。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161541097.png" alt="image-20230416154119009" loading="lazy"></p>
<h2 id="1-4-CPU-的本质——寄存器的集合体"><a href="#1-4-CPU-的本质——寄存器的集合体" class="headerlink" title="1.4.CPU 的本质——寄存器的集合体"></a>1.4.CPU 的本质——寄存器的集合体</h2><p><strong>CPU 的本质就是寄存器的集合体，所以这也是 CPU 很贵的原因。</strong></p>
<ul>
<li><strong>用户可见的寄存器</strong>：通用寄存器组、程序状态字寄存器 PSW，程序计数器 PC。</li>
<li><strong>用户不可见的寄存器</strong>：MAR、MDR、IR 和暂存寄存器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161544495.png" alt="image-20230416154413382" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161550448.png" alt="image-20230416155037353" loading="lazy"></p>
<h1 id="2-指令执行过程"><a href="#2-指令执行过程" class="headerlink" title="2.指令执行过程"></a><a name="2.指令执行过程">2.指令执行过程</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161611723.png" alt="image-20230416161109612" loading="lazy"></p>
<h2 id="2-1-指令周期是什么"><a href="#2-1-指令周期是什么" class="headerlink" title="2.1.指令周期是什么"></a>2.1.指令周期是什么</h2><p><strong>指令周期：是指 CPU 从主存中取出并执行一条指令所需要的全部时间，不同指令的指令周期可能不同。指令周期常用若干机器周期（又叫 CPU 周期）来表示，一个机器周期又包含若干时钟周期（也称为节拍或 T 周期，T 是 CPU 操作的最基本单位）</strong>。</p>
<ul>
<li><strong>每个指令周期内的机器周期数可以不等。</strong></li>
<li><strong>每个机器周期内的时钟周期数可以不等。</strong></li>
</ul>
<p><strong>机器周期指的是完成一个子过程所花费的时间，下图中的方波表示若干时钟周期。例如 CPU 取指令，它是一个程序化、步骤化的过程，所以需要花费多个时钟周期（对应多个操作）来完成</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161554507.png" alt="image-20230416155450425" loading="lazy"></p>
<p><strong>不同指令的指令周期可能不同，例如</strong>：</p>
<ul>
<li><strong>空指令 NOP</strong>：空指令的意思就是什么也不做，因此其指令周期就是取指周期。</li>
<li><strong>加法指令 ADD</strong>：指令周期包括取指和执行两个部分，且这个两个部分长度差不多。</li>
<li><strong>乘法指令 MUL</strong>：相较于加法指令，由于乘法较为复杂，所以它的执行周期可能会更长。</li>
<li><strong>具有间接寻址的指令</strong>：间接寻址需要多次访问主存才能取到真实的地址，因此它会多一个<strong>间址周期</strong>。</li>
<li><strong>带有中断周期的指令</strong>：这种类型的指令会专门留出时间用于检测是否有中断信号，所以又会多一个中断周期。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161555299.png" alt="image-20230416155525209" loading="lazy"></p>
<h2 id="2-2-指令周期流程"><a href="#2-2-指令周期流程" class="headerlink" title="2.2.指令周期流程"></a>2.2.指令周期流程</h2><p><strong>不同指令的指令周期可能不同，自然也会有不一样的执行流程。某个指令在执行过程中是否要经过某个周期需要进行判断。且这四个工作周期都会涉及到 CPU 的访存操作，只是访存的目的不同。</strong></p>
<ul>
<li><p><strong>取指周期 (FE)：为了取出指令</strong>。</p>
</li>
<li><p><strong>间址周期 (IND)（可能有）：为了得到有效地址。</strong></p>
</li>
<li><p><strong>执行周期 (EX)：为了取得操作数。</strong></p>
</li>
<li><p><strong>中断周期 (INT)（可能有）：为了保存程序断点</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556575.png" alt="image-20230416155606476" loading="lazy"></p>
</li>
<li><p>具体实现时可借助<strong>触发器</strong>完成，通过二进制位是否有效进行控制  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556914.png" alt="image-20230416155634819" loading="lazy"></p>
</li>
</ul>
<h3 id="2-2-1-取指周期"><a href="#2-2-1-取指周期" class="headerlink" title="2.2.1.取指周期"></a>2.2.1.取指周期</h3><ul>
<li><p>首先 PC 指明了<strong>当前要执行的指令在主存的存放地址</strong>，所以需要先把 PC 中的内容（指令地址）送入 MAR中，<strong>也即<code>(PC)-&gt;MAR</code></strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557655.png" alt="image-20230416155752570" loading="lazy"></p>
</li>
<li><p>因为取指令需要访问主存，所以 CU 通过<strong>控制总线</strong>向主存发出<strong>读信号</strong>， <strong>也即<code>1-&gt;R</code></strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557897.png" alt="image-20230416155721809" loading="lazy"></p>
</li>
<li><p>MAR 中的地址信息会通过<strong>地址总线送给主存</strong>，读出相应数据后，该指令会通过<strong>数据总线送到 MDR 当中</strong>，<strong>也即<code>M(MAR)-&gt;MDR</code></strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558392.png" alt="image-20230416155819305" loading="lazy"></p>
</li>
<li><p>然后把 MDR 中的内容送入 <strong>IR</strong> 当中，<strong>也即<code>(MDR)-&gt;IR</code></strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161559158.png" alt="image-20230416155939043" loading="lazy"></p>
</li>
<li><p>最后 <strong>CU 发出控制信号</strong>，让 PC+“1”，形成下一条地址，<strong>也即<code>PC=PC+1</code></strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558096.png" loading="lazy"></p>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li><code>(PC)-&gt;MAR</code>。</li>
<li><code>1-&gt;R</code>。</li>
<li><code>M(MAR)-&gt;MDR</code>。</li>
<li><code>(MDR)-&gt;IR</code>。</li>
<li><code>PC+1</code>。</li>
</ul>
<h3 id="2-2-2-间址周期"><a href="#2-2-2-间址周期" class="headerlink" title="2.2.2.间址周期"></a>2.2.2.间址周期</h3><p><strong>一旦指令采用间接寻址，就需要进入间址周期。</strong></p>
<ul>
<li><p>首先将指令的<strong>地址码送入 MAR</strong>，<strong>也即 Ad(IR)-&gt;MAR</strong>（注意也可以<code>Ad(MDR)-&gt;MAR</code>）  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161601516.png" alt="image-20230416160146430" loading="lazy"></p>
</li>
<li><p>CU 发出<strong>读控制信号</strong>，**也即<code>1-&gt;R</code>**。</p>
</li>
<li><p>将 MAR 所指主存中的内容通过数据总线送入 MDR，<strong>也即<code>M(MAR)-&gt;MDR</code></strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161602831.png" alt="image-20230416160207749" loading="lazy"></p>
</li>
<li><p>此时 MDR 保存的是操作数的<strong>有效地址</strong>。接下来 <strong>MDR 中的内容可以直接放入 MAR，也可以放入 IR 与原来的指令进行拼接</strong>（因为原来的地址只是形式地址）形成一个新的指令。</p>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li><code>Ad(IR)-&gt;MAR</code>（也可以是 <code>Ad(MDR)-&gt;MAR</code>）。</li>
<li><code>1-&gt;R</code>。</li>
<li><code>M(MAR)-&gt;MDR</code>。</li>
</ul>
<h3 id="2-2-3-执行周期"><a href="#2-2-3-执行周期" class="headerlink" title="2.2.3.执行周期"></a>2.2.3.执行周期</h3><p>执行周期的任务就是<strong>根据 IR 中指令字的操作码和操作数通过 ALU</strong> 产生执行结果，由于不同指令的执行周期操作不同，<strong>所以没有统一的数据流向</strong>。</p>
<h3 id="2-2-4-中断周期"><a href="#2-2-4-中断周期" class="headerlink" title="2.2.4.中断周期"></a>2.2.4.中断周期</h3><h4 id="2-2-4-1-中断"><a href="#2-2-4-1-中断" class="headerlink" title="2.2.4.1.中断"></a>2.2.4.1.中断</h4><p><strong>中断：通俗理解就是暂停当前任务去完成其他任务，完成后返回。</strong></p>
<p>例如，当前执行的程序由一些指令组成，现在执行到了指令 2，那么此时 PC 应该指向指令 3  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171116631.png" alt="image-20230417111622548" loading="lazy"></p>
<p>指令 2 结束之后会进行<strong>中断检查</strong>，如果此时有中断信号过来，那么在指令 2 执行完毕之后，就要<strong>暂停当前程序，转而执行中断信号所对应的程序指令</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161604726.png" loading="lazy">  </p>
<p>执行完毕之后，再返回原来程序继续执行  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161605611.png" loading="lazy"></p>
<h4 id="2-2-4-2-中断周期"><a href="#2-2-4-2-中断周期" class="headerlink" title="2.2.4.2.中断周期"></a>2.2.4.2.中断周期</h4><p><strong>为了能够找到 “回家的路”，所以需要保存程序断点，其实也就是 PC 的值。一般使用堆栈来保存断点。下图 SP 表示栈顶指针，假设 SP 此时指向栈顶元素，进栈操作是先修改指针，后保存数据</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161606339.png" loading="lazy"></p>
<ul>
<li><p>首先 CU 控制 SP，让其减 1，新指向的位置需要放入 PC。需要注意 <strong>SP 是堆栈指针，但其本质指向的是某个主存地址，所以它的意思就是现在需要把 PC 内的值放入 SP 所指向的某个主存单元保存起来</strong>，也即 <strong><code>(SP-1)-&gt;SP</code>，<code>(SP)-&gt;MAR</code></strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608679.png" alt="image-20230416160834593" loading="lazy"></p>
</li>
<li><p>CU 通过控制总线向主存发出<strong>写信号</strong>，**也即<code>1-&gt;W</code>**。</p>
</li>
<li><p><strong>向 MAR 所指地址处写入 PC（断点）</strong>。一个数据想要写入主存，首先得放入 MDR。因此 <strong>(PC)-&gt;MDR</strong>，至此<strong>断点信息被保存</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608595.png" alt="image-20230416160857514" loading="lazy"></p>
</li>
<li><p>接下来就需要<strong>执行新的程序指令了</strong>，因此 CU 控制<strong>将中断服务程序的入口地址送入 PC</strong>，也就是把最上面示例图的 PC 指向改为指向 “X”，**也即<code>向量地址-&gt;PC</code>**。</p>
</li>
<li><p>最后新的程序指令执行完成之后，<strong>依靠堆栈返回到之前的位置继续执行</strong>。</p>
</li>
</ul>
<p><strong>总之</strong>：</p>
<ul>
<li><code>(SP-1)-&gt;SP</code></li>
<li><code>SP-&gt;MAR</code></li>
<li><code>1-&gt;W</code></li>
<li><code>(PC)-&gt;MDR</code></li>
<li><code>MDR-&gt;M(MAR)</code></li>
<li><code>向量地址 -&gt;PC</code></li>
</ul>
<h2 id="2-3-指令执行方案"><a href="#2-3-指令执行方案" class="headerlink" title="2.3.指令执行方案"></a>2.3.指令执行方案</h2><p><strong>指令执行方案：一个指令周期通常要包括几个执行步骤，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。出于性能和硬件成本的考虑，可以选用如下三种不同的方案来安排指令的执行步骤</strong>：</p>
<ul>
<li>单指令周期。</li>
<li>多指令周期。</li>
<li>流水线方案。</li>
</ul>
<h3 id="2-3-1-单指令周期"><a href="#2-3-1-单指令周期" class="headerlink" title="2.3.1.单指令周期"></a>2.3.1.单指令周期</h3><p><strong>单指令周期：对所有指令都选用相同的执行时间来完成，称为单指令周期方案。</strong></p>
<p>此时每条指令都在固定的时钟周期内完成，指令之间 <strong>串行执行</strong>，即下一条指令只能在前一条指令执行结束之后启动。<strong>因此指令周期取决于最长的指令的执行时间，对于那些本来可以在更短时间内完成的指令，也要使用这个较长的执行周期，会降低整个系统的运行速度。</strong></p>
<h3 id="2-3-2-多指令周期"><a href="#2-3-2-多指令周期" class="headerlink" title="2.3.2.多指令周期"></a>2.3.2.多指令周期</h3><p><strong>多指令周期：对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案</strong>。</p>
<p>指令之间 <strong>串行执行</strong>，即下一条指令只能在前一条指令执行结束后启动。但是可以选用<strong>不同个数的时钟周期来完成不同指令的执行过程</strong>，<strong>指令需要几个周期就分配几个周期，而不再强求所有指令占用相同的执行时间。</strong></p>
<h3 id="2-3-3-流水线方案"><a href="#2-3-3-流水线方案" class="headerlink" title="2.3.3.流水线方案"></a>2.3.3.流水线方案</h3><p><strong>流水线方案：指令之间可以并行执行的方案，称为流水线方案。</strong></p>
<p>流水线方案力争 <strong>在每个时钟周期完成一条指令的执行过程</strong>（当然这只有在理想情况下才能达到）。<strong>这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自在不同的执行步骤</strong>。</p>
<h1 id="3-数据通路单总线结构"><a href="#3-数据通路单总线结构" class="headerlink" title="3.数据通路单总线结构"></a>3.数据通路单总线结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640918.png" alt="image-20230416164054829" loading="lazy"></p>
<h2 id="3-1-有关概念"><a href="#3-1-有关概念" class="headerlink" title="3.1.有关概念"></a>3.1.有关概念</h2><h3 id="3-1-1-CPU-中数据的流动方式"><a href="#3-1-1-CPU-中数据的流动方式" class="headerlink" title="3.1.1.CPU 中数据的流动方式"></a>3.1.1.CPU 中数据的流动方式</h3><p><strong>一条指令的指令周期是会被划分为不同阶段，而不同阶段的数据流向也会不同，主要有以下三种</strong>：</p>
<ul>
<li>寄存器和寄存器之间。</li>
<li>寄存器与主存之间。</li>
<li>寄存器与 ALU 之间。</li>
</ul>
<h3 id="3-1-2-数据通路和控制信号"><a href="#3-1-2-数据通路和控制信号" class="headerlink" title="3.1.2.数据通路和控制信号"></a>3.1.2.数据通路和控制信号</h3><p><strong>数据通路：描述了数据在各个功能部件之间传送的路径。我们需要确定信息从哪里开始，中间经过哪些部件，最后又传至哪里。因此只要确定了数据的流向，我们就可以发出不一样的控制信号，来控制这些数据的流动。</strong></p>
<p><strong>控制信号是由控制部件产生的，虽然寄存器种类繁杂，但它们只会发出如下两类控制信号：</strong></p>
<ul>
<li><strong><code>in</code>：也即输入路径。</strong></li>
<li><strong><code>out</code>：也即输出路径</strong>。</li>
</ul>
<p><strong>这些信号都是由控制器发出的，所以下图中的 $ACC_{in} $、$ACC_{out} $、 $R0_{in} $和 $R0_{out} $​等控制信号事实上和微操作发生器（CU）有着线路连接，微操作发生器发出不一样的信号就会使这些寄存器之间产生多种多样的联系</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161614739.png" alt="image-20230416161446625" loading="lazy"></p>
<h3 id="3-1-3-数据通路种类"><a href="#3-1-3-数据通路种类" class="headerlink" title="3.1.3.数据通路种类"></a>3.1.3.数据通路种类</h3><ul>
<li><p><strong>CPU 内部单总线（上图）</strong>：该方式<strong>将所有寄存器的输入端和输出端都连接到同一条公共的通路上</strong>，这意味着<strong>同一时刻只允许两个部进行数据交换</strong>，它们对总线的使用是独占的。<strong>本小节探讨的内容所用的数据通路方式便是这种</strong>。</p>
</li>
<li><p><strong>CPU 内部多总线方式</strong>：将所有寄存器的输入和输出端都连接到<strong>多条公共通路上</strong>。采用多总线方式，可以同时在多个总线上<strong>传送不同的数据。</strong></p>
</li>
<li><p><strong>专用数据通路方式</strong>：根据指令执行过程中的数据和地址的流动方向安排连接线路，<strong>避免使用共享的总线</strong>，性能高，但是硬件消耗量大。</p>
</li>
</ul>
<h3 id="3-1-4-内部总线与系统总线"><a href="#3-1-4-内部总线与系统总线" class="headerlink" title="3.1.4.内部总线与系统总线"></a>3.1.4.内部总线与系统总线</h3><ul>
<li><strong>内部总线</strong>：<strong>同一部件</strong>，如 CPU 内部连接各寄存器及运算部件之间的总线。</li>
<li><strong>系统总线</strong>：<strong>同一台计算机系统的各部件</strong>，如 CPU、内存、通道和各类 I&#x2F;O 接口间相互连接的总线。</li>
</ul>
<p>以下的讲解中会使用这张图  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161616080.png" alt="image-20230416161620990" loading="lazy"></p>
<h2 id="3-2-寄存器之间的数据流动"><a href="#3-2-寄存器之间的数据流动" class="headerlink" title="3.2.寄存器之间的数据流动"></a>3.2.寄存器之间的数据流动</h2><p><strong>例子：现在要把 PC 的内容送至 MAR，那么传送操作流程如下</strong>：</p>
<ul>
<li><p>首先 $ PCout $有效（CU 发出信号），让其和总线导通  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161617187.png" alt="image-20230416161715097" loading="lazy"></p>
</li>
<li><p>然后把 $PC$ 的内容（其实就是电信号）送至 $BUS$（总线），也即 ( $PC$)-&gt; $BUS$ 。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618824.png" loading="lazy"></p>
<ul>
<li><p>最后使 $MAR_{in}$​有效， $BUS$ 内容再送至 $MAR$ 即可，也即 $BUS$-&gt; $MAR$  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618616.png" loading="lazy"></p>
</li>
</ul>
</li>
</ul>
<p>在答题时一定要写清楚数据流向，最规范的模板为  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618459.png" loading="lazy"></p>
<h2 id="3-3-主存与-CPU-之间的数据流动"><a href="#3-3-主存与-CPU-之间的数据流动" class="headerlink" title="3.3.主存与 CPU 之间的数据流动"></a>3.3.主存与 CPU 之间的数据流动</h2><p><strong>例子：现在 CPU 要从主存中读取指令，那么传送操作流程如下</strong>：</p>
<ul>
<li><p>首先，程序计数器 $PC$ 指明了我们要读取的指令存放在什么地址，所以要把 $PC$ 的内容放入 $MAR$ 当中，即$ (PC)-&gt;Bus-&gt;MAR $（这一步其实也就是上面寄存器与寄存器之间的数据流动）  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161619583.png" loading="lazy"></p>
</li>
<li><p>刚才，为了实现 PC 到 MAR 而使得 $PC_{out} $​和 $PC_{in} $​有效了，现在<strong>应该撤销这两个控制信号</strong>，让总线空闲。接下来要进行读操作，所以 CU 要向主存发出读信号，即 $1-&gt; R$（注意该信号是通过控制总线发出的）。</p>
</li>
<li><p>然后使 $MDR_{in}$ 有效（**注意区分图中的 $MDR_{in} $​， $MDR_{in} $​是控制数据是否可以从内部总线流入 $MDR$**），主存中对应地址信息的内容通过外部数据总线送入 $MDR$ 当中，即 $MEM(MAR)$-&gt; $MDR$  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161628556.png" alt="1" loading="lazy"></p>
</li>
<li><p>最后需要把该指令放入$IR$ 当中， $MDR-&gt;Bus-&gt;IR$  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161629503.png" alt="image-20230416162948426" loading="lazy"></p>
</li>
</ul>
<p>较为规范的模板为：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161630911.png" loading="lazy"></p>
<h2 id="3-4-寄存器与-ALU-之间的数据流动"><a href="#3-4-寄存器与-ALU-之间的数据流动" class="headerlink" title="3.4.寄存器与 ALU 之间的数据流动"></a>3.4.寄存器与 ALU 之间的数据流动</h2><p><strong>执行算数或逻辑运算时数据可能会流向 ALU，比如现在要执行一条加法指令，加法运算的其中一个操作数已经被存放在 $ACC$ 中了，另一个操作数地址会由加法指令直接指明</strong>。</p>
<ul>
<li><p>首先需要根据该指令的地址码部分读取出参与加法的另一个操作数，即 $ Ad(IR) -&gt;Bus-&gt; MAR$，此时 $MDR_{out} $和 $MAR_{in}$​有效。</p>
</li>
<li><p>当然还可以采用另外一种方式。之前就说过，取指令的时候是把指令先取到了 $MDR$ 中然后再拷贝至$IR$ 中，所以取指结束后， $MDR$ 中也存放了这条指令的完整信息，因此可以直接把 $MDR$ 中指令的地址码传送到 $MAR$ 中，此时 $MDR_{out} $​和 $MAR_{in}$​有效。  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161634185.png" alt="image-20230416163418087" loading="lazy"></p>
</li>
<li><p>CU 向主存发出读控制信号，即 $1-&gt; R $</p>
</li>
<li><p>主存中相应信息通过外部数据总线送至 $MDR$ 当中， $MDR_{in}$ 有效，即 $MEM(MAR)$-&gt; 数据总线 -&gt; $MDR$  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161635806.png" alt="image-20230416163548712" loading="lazy"></p>
</li>
<li><p>接下来把操作数放到暂存寄存器 $Y$ 中，此时 $MDR_{out} $​和 $ Y_{in} $有效，即 MDR-&gt;bus-&gt; $Y$。<strong>之所以这样做是因为 ALU 必须同时接受到两个信号才可以运作，但是内部总线同一时刻只能传送一个输入信号，因此不得不把其中的一个操作放到暂存寄存器中，该寄存器与 ALU 是有一个专门的数据通路的，他们的传送不会占用内部总线</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161636910.png" alt="image-20230416163629820" loading="lazy"></p>
</li>
<li><p>CU 向 ALU 发送加命令，然后 $ACC_{out}$和 $ALU_{in} $有效，执行加法操作，即 ( $ACC$)+( $Y$)-&gt;$ Z  $。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637327.png" alt="image-20230416163713240" loading="lazy"></p>
</li>
<li><p>当输出数据稳定之后，撤销 $ACC_{out}$和 $ALU_{in} $​。最后将结果存回 $ACC$ 中，即 $ Z-&gt; ACC$  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637988.png" alt="image-20230416163739894" loading="lazy"></p>
</li>
</ul>
<p>较为规范的模板为  ：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161638315.png" loading="lazy"></p>
<p><strong>可以看出，通过发出不一样的控制信号，就能使微操作一步接着一步进行下去，每个微操作至少需要消耗一个时钟周期，每一个时钟周期内，CU 都会发出一组相应的控制信号来完成其中的某一个微操作</strong>。</p>
<h2 id="3-5-有关-CPU-内部单总线经典例题"><a href="#3-5-有关-CPU-内部单总线经典例题" class="headerlink" title="3.5.有关 CPU 内部单总线经典例题"></a>3.5.有关 CPU 内部单总线经典例题</h2><p>设有如下所示的单总线结构，请分支指令<code>ADD (R0),R1</code>的指令流程和控制信号。</p>
<ul>
<li>$R  _{1} $表示源操作数（没有括号表示直接存放在寄存器中），$(R  _{0} )$ 表示目的操作数（带有括号表示存储的操作数的地址，同时这两个操作数的运算的结果又会放回 $R _{0} $所指向主存单元）。也即$ ((R _{0} ))+(R <em>{1} )-&gt;(R 0</em>{0} )$。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639870.png" alt="image-20230416163921777" loading="lazy"></p>
<p>各个阶段的指令流程如下  ：</p>
<p><strong>1：取指周期</strong>：公共操作，都一样。</p>
<table><thead><tr><th>时序</th><th>微操作</th><th>有效控制信号</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>(PC)-&gt;MAR</td><td>PCout,MARin</td><td>PC 所指指令地址送至 MAR</td></tr><tr><td>2</td><td>M(MAR)-&gt;MDR</td><td>MemR，MARout，MDRinE</td><td>把指令送到 MDR 中</td></tr><tr><td>3</td><td>(MDR)-&gt;IR</td><td>MDRout,IRin</td><td>把指令由 MDR 送到 IR</td></tr><tr><td>4</td><td>指令译码</td><td>-</td><td>进行译码操作</td></tr><tr><td>5</td><td>(PC)+1-&gt;PC</td><td>-</td><td>PC+1 操作</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>

<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639924.png" alt="image-20230416163938826" loading="lazy"></p>
<p><strong>2：间指周期</strong>：完成取数操作，被加数在主存中，加数已经存放在寄存器 $R _{1}$中了。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424883.png" alt="image-20230416142413792" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640100.png" alt="image-20230416164011484" loading="lazy"></p>
<p><strong>3：执行周期</strong>：此时加数在 R1 中，被加数在 Y 中。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424547.png" alt="image-20230416142439466" loading="lazy"></p>
<p><strong>注意：本节内容是计组考试中的高频考点，注意考察指令的执行过程。</strong></p>
<h1 id="4-数据通路专用通路结构"><a href="#4-数据通路专用通路结构" class="headerlink" title="4.数据通路专用通路结构"></a>4.数据通路专用通路结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161649331.png" alt="image-20230416164908239" loading="lazy"></p>
<h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1.概述"></a>4.1.概述</h2><p>如果数据通路采用 CPU 内部单总线，那么就意味着同一时间只允许两个部件进行数据交互。<strong>实际上，如果能使多个部件同时进行数据交互，那么指令的执行速度一定会的得到提升，实现这种需求一方面可以借助多总线的方式，另一方面还可以建立专用数据通路——在任何两个需要进行数据交互的部件之间建立数据通路</strong>。</p>
<p>如下：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647652.png" alt="image-20230416164703559" loading="lazy">  </p>
<p>取指周期如下：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161428320.png" alt="image-20230416142819239" loading="lazy"></p>
<h2 id="4-2-例题"><a href="#4-2-例题" class="headerlink" title="4.2.例题"></a>4.2.例题</h2><p>下图是一个简化了的 CPU 与主存连接结构示意图 (图中省略了所有的多路选择器)。其中有一个累加寄存器 (ACC)、一个状态数据寄存器和其他 4 个寄存器（MAR、MDR、PC 和 IR）。各部件及其之间的连线表示数据通路，箭头表示信息传递方向。  </p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647475.png" alt="image-20230416164757386" loading="lazy"></p>
<p>完成以下问题：</p>
<ul>
<li><strong>请写出图中 a、b、C、d 4 个寄存器的名称</strong>。</li>
<li><strong>简述图中取指令的数据通路</strong>。</li>
<li><strong>简述数据在运算器和主存之间进行存 &#x2F; 取访问的数据通路。</strong></li>
<li><strong>简述完成指令 LDA X 的数据通路 (X 为主存地址，LDA 的功能为 (X)→ACC)。</strong></li>
<li><strong>简述完成指令 ADD Y 的数据通路 (Y 为主存地址，ADD 的功能为 (ACC)+ (Y)→ACC)。</strong></li>
<li>**简述完成指令 STA Z 的数据通路 (Z 为主存地址，STA 的功能为 (ACC)→Z)**。</li>
</ul>
<p><strong>（1）请写出图中 a、b、C、d 4 个寄存器的名称。</strong></p>
<p>首先 d 可以自动 “+1”，因此是 PC；PC 的内容是地址，送入 MAR，故 c 是 MAR；b 与微操作信号发生器相连，因此是 IR；相应的 a 就是 MDR。</p>
<ul>
<li>a：MDR</li>
<li>b：IR</li>
<li>c：MAR</li>
<li>d：PC</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161648003.png" alt="image-20230416164825907" loading="lazy"></p>
<p><strong>（2）简述图中取指令的数据通路。</strong></p>
<ul>
<li>(PC)-&gt;MAR</li>
<li>M(MAR)-&gt;MDR</li>
<li>MDR-&gt;IR</li>
</ul>
<p><strong>（3）简述数据在运算器和主存之间进行存 &#x2F; 取访问的数据通路</strong>。</p>
<p>假设存 &#x2F; 取的数据放到 ACC 中，并且数据地址已经放入 MAR 中。</p>
<p><strong>取过程</strong></p>
<ul>
<li>M(MAR)-&gt;MDR</li>
<li>(MDR)-&gt;ALU-&gt;ACC</li>
</ul>
<p><strong>存过程</strong></p>
<ul>
<li>(ACC)-&gt;MDR</li>
<li>(MDR)-&gt;M(MAR)</li>
</ul>
<p><strong>（4）简述完成指令 LDA X 的数据通路 (X 为主存地址，LDA 的功能为 (X)→ACC)。</strong></p>
<ul>
<li>X-&gt;MAR</li>
<li>M(MAR)-&gt;MDR</li>
<li>(MDR)-&gt;ALU-&gt;ACC</li>
</ul>
<p><strong>（5）简述完成指令 ADD Y 的数据通路 (Y 为主存地址，ADD 的功能为 (ACC)+ (Y)→ACC)。</strong></p>
<ul>
<li>Y-&gt;MAR</li>
<li>M(MAR)-&gt;MDR</li>
<li>(MDR)-&gt;ALU，(ACC)-&gt;ALU</li>
<li>ALU-&gt;ACC</li>
</ul>
<p>**（6）简述完成指令 STA Z 的数据通路 (Z 为主存地址，STA 的功能为 (ACC)→Z)**。</p>
<ul>
<li>Z-&gt;MAR</li>
<li>(ACC)-&gt;MDR</li>
<li>(MDR)-&gt;M(MAR)</li>
</ul>
<h1 id="5-硬布线控制器"><a href="#5-硬布线控制器" class="headerlink" title="5.硬布线控制器"></a><a name="5.硬布线控制器">5.硬布线控制器</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161713047.png" loading="lazy"></p>
<h2 id="5-1-内容回顾和一些概念"><a href="#5-1-内容回顾和一些概念" class="headerlink" title="5.1.内容回顾和一些概念"></a>5.1.内容回顾和一些概念</h2><p>高级语言编写的程序会被翻译为与之等价指令序列，每条指令的执行，有可能会涉及如下四个周期：</p>
<ul>
<li><strong>取指周期</strong>：完成取指令。</li>
<li><strong>间指周期</strong>：如果采用间接寻址，需要将形式地址转变为真实地址。</li>
<li><strong>执行周期</strong>：执行指令。</li>
<li><strong>中断周期</strong>：处理中断信号。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652162.png" alt="image-20230416165212046" loading="lazy"></p>
<p>下图中<code>FE</code>、<code>IND</code>、<code>EX</code>和<code>INT</code>分别是上面四个周期的缩写，<strong>各自对应了如下四个触发器，如果某个触发器为 1 就表示指令处于某个周期内。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652735.png" alt="image-20230416165227648" loading="lazy"></p>
<p>一个指令周期内又需要若干<strong>微操作序列</strong>来完成该指令周期的工作，每个指令周期又由若干<strong>时钟周期</strong>组成（节拍），CU 会在每一个节拍内发出一个<strong>微命令</strong>，生成对应的微操作。</p>
<ul>
<li><strong>微命令和微操作是一一对应的</strong>：比如微命令 1 使得$ PC _{out}$ 、$MAR _{in}$ ​有效，完成对应的微操作 (PC)-&gt;MAR。</li>
</ul>
<p><strong>每个节拍内可以并行地完成互不冲突的微操作，而且同一个微操作也可能在不同指令的不同阶段被使用</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161653434.png" alt="image-20230416165312336" loading="lazy"></p>
<ul>
<li>上图采用的是<strong>定长周期</strong>的策略（即便执行周期和中断周期可以在两个节拍内完成，但是我们还是让其耗时三个节拍）。</li>
</ul>
<p>实际上，不同指令的执行周期所需要的节拍数是各不相同的，因此为了简化设计，选择定长的机器周期，<strong>以可能出现的最大节拍数为准</strong>（通常以访存所需要节拍数作为参考），若实际所需要节拍数较少，<strong>可以将微操作安排在机器周期末尾几个节拍上进行。</strong></p>
<h2 id="5-2-硬布线控制"><a href="#5-2-硬布线控制" class="headerlink" title="5.2.硬布线控制"></a>5.2.硬布线控制</h2><p><strong>硬布线控制：使用控制单元 CU 进行逻辑控制。</strong></p>
<h3 id="5-2-1-CU-如何发出微命令"><a href="#5-2-1-CU-如何发出微命令" class="headerlink" title="5.2.1.CU 如何发出微命令"></a>5.2.1.CU 如何发出微命令</h3><p><strong>可以看出，指令间区别最大的地方在于执行周期，像取指周期、间指周期和中断周期都是差不多的。所以，我们只要根据指令操作码、目前的指令周期、节拍信号以及机器状态条件就可以确定现在这个节拍下应该发出哪些微命令。具体来说</strong>：</p>
<ul>
<li><p><strong>STEP1：得让 CU 知道现在执行的是什么命令</strong>：首先需要把 IR 的 $n$位操作码送给<strong>操作码译码器</strong>（ $n$位操作码意味着有 $2 ^{n}$ 种不一样的指令，经过操作码译码器译码后对应的地址选择线就会被选通），<strong>CU 通过判断对应哪一个输入信号有效，来判断当前执行的是哪一条指令</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655637.png" alt="image-20230416165504542" loading="lazy"></p>
</li>
<li><p><strong>STEP2：得让 CU 知道当前执行到了该指令的哪一个机器周期</strong>：所以需要把<code>FE</code>、<code>IND</code>、<code>EX</code>和<code>INT</code>这四个触发器的二进制信息送给 CU，<strong>CU 通过判断对应的值是否为 1 来判断目前处于哪一个机器周期</strong>（需要注意这四个触发器实际上已经被集成在了 CPU 中）  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655839.png" alt="image-20230416165540748" loading="lazy"></p>
</li>
<li><p><strong>STEP3：得让 CU 知道当前处在该机器周期的哪一个节拍</strong>：因此需要给 CU 输入一个节拍信号，节拍信号是通过<strong>节拍发生器</strong>给出的，时钟部件会有规律的发出脉冲信号，每个脉冲信号就是一个时钟周期。<strong>节拍发生器在接受到时钟部件发出的信号后，就会让其中的某个输出线导通</strong>、节拍信号是循环发出的，当$ T _{m} $结束后，就会回到 $T _{0}$，此时表示进入了新的机器周期  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124920.png" alt="image-20230416201559822" loading="lazy"></p>
</li>
<li><p><strong>STEP4：最后需要给 CU 提供机器状态条件</strong>：<strong>状态条件统称为标志，它们来自于执行单元的返回信息</strong>。比如前面说过的来自于运算器的 PSW（溢出判断就在这里）、来自于 ACC 的符号位等，也有可能来自于 I&#x2F;O 设备、主存等  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657694.png" alt="image-20230416165702583" loading="lazy"></p>
</li>
</ul>
<p><strong>这四组信息齐全后，CU 就可以给出当前节拍下应该发出的微命令</strong>：<strong>每个输出的控制信号对应一个微命令，也就是对应一个微操作</strong>。例如，如果$ C _{1} $对应微操作为 $(PC) $-&gt;MAR，那么只需让其接到 $PC  _{out}$​和 $MAR _{in} $​即可  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657883.png" alt="image-20230416165727760" loading="lazy"></p>
<h3 id="5-2-2-逻辑化表达式"><a href="#5-2-2-逻辑化表达式" class="headerlink" title="5.2.2.逻辑化表达式"></a>5.2.2.逻辑化表达式</h3><p>现在最困难的问题在于：<strong>CU 如何能知道现在应该发出哪条命令？</strong>。比如上面的例子中，$C _{1}$​被接通后就执行了 (PC)-&gt;MAR。</p>
<ul>
<li><p>$C _{1}$的比较好解释：因为所有指令在取指周期内，第一步需要做的事情就是 (PC)-&gt;MAR。于是硬件工程师规定：<strong>无论是哪一种指令，只要处于取指周期（FE&#x3D;1），同时还处于第一阶段（$T <em>{0} $）的话，就要完成 (PC)-&gt;MAR 这样的操作，也即是 $C <em>{1}$对应的操作，其对应的逻辑化表达式为 $C</em>{1} $&#x3D; $FE·T</em>{0} $</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657606.png" loading="lazy"></p>
</li>
</ul>
<p>说到这里大家可能就已经明白了，只要能写出某一个微命令对应的<strong>逻辑化表达式</strong>，然后设计相应的<strong>逻辑电路</strong>即可，但理想很美好，现实很骨感。上面那个例子的逻辑电路设计起来是非常简单的，而且最重要的是该微操作仅出现在取指周期的第一阶段；<strong>但有的微操作，例如 M(MAR)-&gt;MDR 它们使用的就非常频繁，那么他们应该怎么设计呢？这就是本节内容的核心</strong>。在学习硬件时大家要牢牢把握 “<strong>逻辑化表达式是电路的数学化描述</strong>” 这句话的深刻含义。</p>
<p>$M(MAR)-&gt;MDR$ 的逻辑化表达式和电路如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161658376.png" alt="image-20230416165850266" loading="lazy"><br>逻辑化表达式为：  $FE· T_{1} +IND· T_{1} (  ADD+ STA+  LDA+  JMP+ BAN)+ EX· T_{1}(ADD+LDA) $</p>
<ul>
<li><p>$ FE· T_{1} $：与运算，如果结果为 1，就表示需要进行 M(MAR)-&gt;MDR 微操作  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017310.png" alt="image-20230416201715192" loading="lazy"></p>
</li>
<li><p>$EX· T_{1}(ADD+LDA) $：如果处在 ADD 加法命令或 LDA 命令的执行周期的 $T_{1}$​阶段也表示需要进行 M(MAR)-&gt;MDR 微操作  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161659864.png" alt="image-20230416165902772" loading="lazy"></p>
</li>
</ul>
<h2 id="5-3-硬布线控制器设计"><a href="#5-3-硬布线控制器设计" class="headerlink" title="5.3.硬布线控制器设计"></a>5.3.硬布线控制器设计</h2><ul>
<li><strong>注意</strong>：此部分内容在考试中基本不会涉及，但是对于理解硬布线控制却很有帮助。</li>
</ul>
<h3 id="5-3-1-硬布线控制器设计步骤"><a href="#5-3-1-硬布线控制器设计步骤" class="headerlink" title="5.3.1.硬布线控制器设计步骤"></a>5.3.1.硬布线控制器设计步骤</h3><p><strong>硬布线控制器设计步骤如下</strong>：</p>
<p><strong>①：分析各个阶段的微操作序列（取指，间指，执行、中断）</strong></p>
<ul>
<li>确定哪些指令在什么阶段、在什么条件下会使用到的微操作。</li>
</ul>
<p><strong>②：选择 CPU 的控制方式</strong></p>
<ul>
<li>采用定长机器周期还是不定长机器周期？每个机器周期安排几个节拍？</li>
<li>注意：后面讲解采用同步控制方式（定长机器周期），一个机器周期内安排 3 个节拍。</li>
</ul>
<p><strong>③：安排微操作时序</strong></p>
<ul>
<li>如何用 3 个节拍完成整个机器周期内的所有微操作。</li>
</ul>
<p><strong>④：电路设计</strong></p>
<ul>
<li>确定微操作命令的逻辑表达式，并用电路实现。</li>
</ul>
<h3 id="5-3-2-步骤一：分析各个阶段的微操作序列"><a href="#5-3-2-步骤一：分析各个阶段的微操作序列" class="headerlink" title="5.3.2.步骤一：分析各个阶段的微操作序列"></a>5.3.2.步骤一：分析各个阶段的微操作序列</h3><p><strong>如果我们能罗列出某个系统在各个阶段的微操作序列，就可以知道在什么情况下需要使用到这个微操作</strong>。</p>
<p><strong>取指周期</strong>（所有指令都一样）。</p>
<ul>
<li>PC-&gt;MAR</li>
<li>1-&gt;R</li>
<li>M(MAR)-&gt;MDR</li>
<li>MDR-&gt;IR</li>
<li>OP(IR)-&gt;ID（ID 是指令译码器）</li>
<li>(PC)+1-&gt;PC</li>
</ul>
<p><strong>间址周期</strong>（所有指令都一样）。</p>
<ul>
<li>Ad(IR)-&gt;MAR（找寻真正地址）</li>
<li>1-&gt;R</li>
<li>M(MAR)-&gt;MDR</li>
<li>MDR-&gt;Ad(IR)</li>
</ul>
<p><strong>执行周期</strong>（各不相同），例如：</p>
<p><strong>CLA</strong>：clear ACC 指令、ACC 清零。</p>
<ul>
<li>0-&gt;ACC</li>
</ul>
<p><strong>LDA X</strong>：取数指令，把 X 所指内容取到 ACC。</p>
<ul>
<li>Ad(IR)-&gt;MAR</li>
<li>1-&gt;R</li>
<li>M(MAR)-&gt;MDR</li>
<li>MDR-&gt;ACC</li>
</ul>
<p><strong>JMP X</strong>：无条件转移。</p>
<ul>
<li>Ad(IR)-&gt;PC</li>
</ul>
<p><strong>BAN X</strong>：条件转移，当 ACC 为负时转移（属于机器状态条件）。</p>
<ul>
<li>$A_{0}⋅Ad(IR)+ \overline A_{0}⋅(PC)-&gt;CP$</li>
</ul>
<h3 id="5-3-3-步骤三：安排微操作时序"><a href="#5-3-3-步骤三：安排微操作时序" class="headerlink" title="5.3.3.步骤三：安排微操作时序"></a>5.3.3.步骤三：安排微操作时序</h3><ul>
<li><strong>注意</strong>：第二步已经完成，我们会采用定长机器周期，并且每个机器周期内安排三个节拍。</li>
</ul>
<p><strong>安排微操作时序有如下原则</strong>：</p>
<ul>
<li><strong>原则一</strong>：微操作的先后顺序不得随意更改（比如 PC-&gt;MAR 一定在 M(MAR)-&gt;MDR 之前完成）。</li>
<li><strong>原则二</strong>：被控对象不同的微操作尽量安排在一个节拍内完成（比如 PC-&gt;MAR 控制对象为寄存器，1-&gt;R 控制对象为主存，因此尽量安排在同一个节拍内完成）。</li>
<li><strong>原则三</strong>：占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序（比如寄存器之间的交互快于寄存器与主存的交互，因此如果可以的话尽量将其放在一个节拍完成）。</li>
</ul>
<p>比如<strong>取指周期</strong>，上面得到的微操作序列，在这种原则下是不合适的，因此更改如下：</p>
<ul>
<li>PC-&gt;MAR 和 1-&gt;R 由于被控对象不同的，所以放在一个节拍内。</li>
<li>(PC+1)-&gt;PC 位置随意，只要在 PC-&gt;MAR 之后即可，所以搭配一个 M(MAR)-&gt;MDR 让其在一个节拍内进行。<strong>不把 M(MAR)-&gt;MDR 放在后面的原因是因为这是从主存取数据，时间较长，起码得保证一个时钟周期</strong>。</li>
<li>后面两个是 CPU 内部寄存器的数据传送，<strong>因此速度很快，在一个时钟周期内是可以一次同时发出两个微命令的</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161700481.png" alt="image-20230416170059393" loading="lazy"></p>
<p><strong>间址周期安排如下</strong>：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161701021.png" alt="image-20230416170115936" loading="lazy"></p>
<p><strong>执行周期的设计可以说是整个设计的核心所在</strong>，不同指令的执行周期千差万别，具体如何设计是硬件工程师的任务，在这里我们只是简单了解即可。主要是想让大家明白一点，<strong>指令的设计是一个非常严谨的事情，它有哪几个周期，一个周期内有几个节拍，一个节拍要完成哪些微操作，这些都是必须要考虑到的事情</strong>。</p>
<ul>
<li>设计时会将指令分为<strong>非访存，访存和转移指令</strong>等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161705356.png" alt="image-20230416170547257" loading="lazy"></p>
<h3 id="5-3-4-步骤四：组合逻辑设计（电路设计）"><a href="#5-3-4-步骤四：组合逻辑设计（电路设计）" class="headerlink" title="5.3.4.步骤四：组合逻辑设计（电路设计）"></a>5.3.4.步骤四：组合逻辑设计（电路设计）</h3><p><strong>①：列出操作时间表：也即列出在取指、间址、执行和中断周期， $T_{0}$​、 $T_{1}$​和 $T_{2}$节拍内有可能用到的所有微操作</strong></p>
<p><strong>对于取指周期：</strong></p>
<ul>
<li><strong>需要用到该微操作的填 “1”，否则空</strong></li>
<li>注意表格中的<strong>状态条件栏</strong>：如果填 “ $ I$”，表示该指令采用间接寻址，需要将间址特征送入，即 1-&gt;IND；如果填 “ $\overline I $”，表示该指令将直接进入执行周期，即<code> 1-&gt;EX</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708366.png" alt="image-20230416170802261" loading="lazy"></p>
<p><strong>对于间址周期</strong>：</p>
<ul>
<li><p>注意<strong>状态条件栏</strong>：如果填 “ $ \overline I \overline N \overline D $”，表示该指令采用多级间接寻址，直到该状态栏不填任何信息时，才表示结束了间接寻址，可以进入执行周期  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708736.png" alt="image-20230416170816638" loading="lazy"></p>
</li>
</ul>
<p>③对于执行周期：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709818.png" alt="image-20230416170923708" loading="lazy"></p>
<p><strong>②：写出微操作命令的最简表达式</strong>。</p>
<p><strong>从上面的表格中我们可以看到 M(MAR)-&gt;MDR 操作的使用频次。</strong></p>
<ul>
<li>对于<strong>取指周期</strong>，只要处在 $T_{1}$​，无论哪一个指令都要用到 M(MAR)-&gt;MDR，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li>
<li>对于<strong>间址周期</strong>，只要处在 $T_{1}$​，并且是 $ADD$、 $STA$、 $LDA$、 $JMP$ 。<br>、 $BAN $ 指令的话，就要用到 M(MAR)-&gt;MDR，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li>
<li>对于<strong>执行周期</strong>，只要处在 $T_{1}$​，并且是 $ADD$ 或 $LDA$ 的话，就要用到 <code>M(MAR)-&gt;MDR</code>，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162018083.png" alt="image-20230416201850969" loading="lazy"></p>
<p><strong>综上，当逻辑表达式：“ $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$” 为 1 时，就要执行<code> M(MAR)-&gt;MDR</code> 微操作</strong>。</p>
<p><strong>③：设计出逻辑表达式对应的电路图</strong>：</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709168.png" alt="image-20230416170959038" loading="lazy"></p>
<h2 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4.总结"></a>5.4.总结</h2><p><strong>硬布线控制器的设计步骤如下</strong>：</p>
<p>1：分析每个阶段的微操作序列  。<br>2：选择 CPU 的控制方式  。<br>3：安排微操作时序  。<br>4：电路设计。</p>
<ul>
<li>列出操作时间表。</li>
<li>写出微操作命令的最简表达式。</li>
<li>画出逻辑图。</li>
</ul>
<p><strong>硬布线控制器的特点：</strong></p>
<ul>
<li>指令越多，设计和实现就越复杂，<strong>因此一般用于 RISC（精简指令集系统）</strong>。</li>
<li>如果扩充一条新的指令，则控制器的设计就需要大改，因此<strong>扩充指令困难。</strong></li>
<li>由于使用纯硬件实现控制，因此<strong>执行速度很快</strong>（微操作控制信号由组合逻辑电路即时产生）。</li>
</ul>
<h1 id="6-微程序控制器的基本原理"><a href="#6-微程序控制器的基本原理" class="headerlink" title="6.微程序控制器的基本原理"></a>6.微程序控制器的基本原理</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161719373.png" alt="image-20230416171943251" loading="lazy"></p>
<p>硬布线控制器，就是用纯硬件实现的控制器，电路非常复杂，也是整个计组中的难点之一，好在考试基本不考，而本节需要学习的<strong>微程序控制器倒是在大题中常有出现</strong>。</p>
<h2 id="6-1-微程序控制器的设计思路"><a href="#6-1-微程序控制器的设计思路" class="headerlink" title="6.1.微程序控制器的设计思路"></a>6.1.微程序控制器的设计思路</h2><ul>
<li>程序会被翻译为对等的机器指令。</li>
<li>机器指令又会被分为一个个的微操作序列。</li>
</ul>
<p><strong>微程序控制器的设计思路：把每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。所以微指令之于指令就等价于指令之于程序</strong>。</p>
<ul>
<li><strong>指令</strong>是对程序执行步骤的描述。</li>
<li><strong>微指令</strong>是对指令执行步骤的描述。</li>
<li><strong>微命令与微操作一一对应</strong>。</li>
<li><strong>微指令</strong>可能包含多个<strong>微命令（微操作）</strong>。</li>
</ul>
<p><strong>比如下图中的微指令 d，它指明了 “完成微操作 5、2”。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161714659.png" alt="image-20230416171442530" loading="lazy"><br><strong>每条指令对应一个微程序，这些微程序可以存到一个控制存储器中，用程序机器指令的办法来寻址每个微程序中的微指令。目前，大多计算机都采用微程序设计技术。</strong></p>
<p><strong>其中，存放微指令的控制存储器的单元地址称为微地址，一条微指令通常包含</strong>：</p>
<ul>
<li><strong>操作控制字段</strong>：又称操作码字段，用于产生某一步操作所需要的各种操作控制信号。</li>
<li><strong>顺序控制字段</strong>：又称微地址码字段，用于控制产生下一条要执行的微指令地址。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161715734.png" alt="image-20230416171506645" loading="lazy"></p>
<h2 id="6-2-微程序控制器的基本结构"><a href="#6-2-微程序控制器的基本结构" class="headerlink" title="6.2.微程序控制器的基本结构"></a>6.2.微程序控制器的基本结构</h2><h3 id="6-2-1-微程序控制器基本组成"><a href="#6-2-1-微程序控制器基本组成" class="headerlink" title="6.2.1.微程序控制器基本组成"></a>6.2.1.微程序控制器基本组成</h3><p><strong>微程序控制器基本组成:</strong></p>
<ul>
<li><p><strong>控制存储器 CM：</strong> 它是微程序控制器的核心部件，<strong>用于存放各指令对应的微程序，使用只读存储器 ROM 构成</strong>。每一条机器指令对应的微指令序列，由 CPU 厂商负责设计，并且在 CPU 出厂之前就已经把 ROM 里面的微程序数据全部写好了。</p>
</li>
<li><p><strong>微地址形成部件：</strong> 由于不同指令对应的微程序是不同的，<strong>因此需要根据该指令的操作码来确定它所对应的微程序的起始地址</strong>，以保证微指令的连续进行。</p>
</li>
<li><p><strong>微地址寄存器 CMAR：</strong> 有 MAR 就有 CMAR，和 MAR 一样，<strong>它用于接收微地址形成部件送来的微地址</strong>；同时 CMAR 还有一个别名，叫做 u u uPC，其实就是把 PC 和 MAR 整合到了一起。</p>
</li>
<li><p><strong>地址译码器：</strong> 有了地址就需要地址译码器，<strong>地址译码器会把地址码转换为存储单元控制信号。</strong></p>
</li>
<li><p><strong>微指令寄存器 CMDR：</strong> 有 MDR 就有 CMDR，它是微指令寄存器，别名叫做 u u uIR，<strong>用于存放从 CM 中取出的微指令，它的位数同微指令的字长。</strong></p>
</li>
<li><p><strong>顺序逻辑控制单元</strong>。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161716475.png" alt="image-20230416171648365" loading="lazy"></p>
<h3 id="6-2-1-微程序控制器工作过程"><a href="#6-2-1-微程序控制器工作过程" class="headerlink" title="6.2.1.微程序控制器工作过程"></a>6.2.1.微程序控制器工作过程</h3><p><strong>微程序控制器基本组成：当 CPU 取到一条指令之后，流程如下</strong>：</p>
<ol>
<li>把指令的<strong>操作码</strong>送给<strong>微地址形成部件</strong>，以确定<strong>微指令序列的起始地址</strong>。</li>
<li>根据<strong>顺序逻辑</strong>及其他标志信息等来确定<strong>接下来要执行的微指令的地址。</strong></li>
<li>将微指令地址<strong>放入到 CMAR</strong> 中。</li>
<li>经过地址译码器译码后就可以<strong>选中 CMAR 所指向的微指令</strong>。</li>
<li>取出该微指令，<strong>存放到 CMDR 中。</strong></li>
<li>(执行完该微指令后需要把微指令 “下地址” 信息送给顺序逻辑，结合其他信息用于判断下一个微指令)。</li>
<li>硬件电路需要根据该微指令的<strong>控制码部分</strong>，向 <strong>CPU 内部其他部件或系统总线</strong>发出控制信号（$PC_{out} ,MAR _{in}$，$1-&gt;R$ 等等）。</li>
</ol>
<h2 id="6-3-微程序控制器的工作原理"><a href="#6-3-微程序控制器的工作原理" class="headerlink" title="6.3.微程序控制器的工作原理"></a>6.3.微程序控制器的工作原理</h2><ul>
<li><p><strong>所有指令的取指周期、间址周期和中断周期几乎是一样的，所以这几个周期所对应的微指令序列也是可以共享的，因此在 CM 中只会存储一份</strong>。</p>
</li>
<li><p>取指周期的微程序段通常是公用的，所以 <strong>如果某指令系统中有 n 条机器指令，则 CM 中微程序段的个数至少是 n+1 个</strong>，而对于一些早期的 CPU，物联网设备的 CPU 由于其 CPU 可以不包含间址周期和中断周期，所以不包含进去。</p>
</li>
<li><p><strong>需要注意</strong>：物理上取指周期、执行周期看起来像两个微程序，但逻辑上应该将其看作一个整体。因此，“<strong>一条指令对应一个微程序</strong>” 的说法是正确的。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161718354.png" alt="image-20230416171824240" loading="lazy"></p>
<h1 id="7-微指令的设计"><a href="#7-微指令的设计" class="headerlink" title="7.微指令的设计"></a><a name="7.微指令的设计">7.微指令的设计</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161725625.png" alt="image-20230416172512509" loading="lazy"></p>
<h2 id="7-1-微指令的格式"><a href="#7-1-微指令的格式" class="headerlink" title="7.1.微指令的格式"></a>7.1.微指令的格式</h2><h3 id="7-1-1-水平型微指令"><a href="#7-1-1-水平型微指令" class="headerlink" title="7.1.1.水平型微指令"></a>7.1.1.水平型微指令</h3><p><strong>水平型微指令：是指一条微指令可以定义多个可并行执行的微命令</strong>。</p>
<ul>
<li><strong>优点：</strong> 微程序短，执行速度快。</li>
<li><strong>缺点：</strong> 微指令长，编写微程序较为麻烦。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721386.png" loading="lazy"></p>
<p><strong>水平型微指令其操作控制码部分较长，如果采用水平型微指令，那么指令的条数较少（一条微指令可以完成多个微操作或微命令），所以指令体积就会感觉很 “胖”</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721563.png" loading="lazy"></p>
<h3 id="7-1-2-垂直型微指令"><a href="#7-1-2-垂直型微指令" class="headerlink" title="7.1.2.垂直型微指令"></a>7.1.2.垂直型微指令</h3><p><strong>垂直型微指令：是指一条微指令只能定义一个微命令，由微操作码字段规定具体功能</strong>。</p>
<ul>
<li><strong>优点</strong>：微指令短、简单、规整、便于编写微程序。</li>
<li><strong>缺点</strong>：微程序长，执行速度慢，工作效率低。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721619.png" loading="lazy"></p>
<p><strong>垂直型微指令其操作控制码部分短，如果采用垂直型微指令，那么指令的条数较多（一条微指令只能定义一个微操作或微命令），所以指令体积就会感觉很 “瘦”。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722551.png" alt="image-20230416172209461" loading="lazy"></p>
<h3 id="7-1-3-混合型微指令"><a href="#7-1-3-混合型微指令" class="headerlink" title="7.1.3.混合型微指令"></a>7.1.3.混合型微指令</h3><p><strong>混合型微指令：在垂直型的基础上增加一些不复杂的并行操作。微指令较短，仍便于编写，形成的微程序也不长，执行速度加快。</strong></p>
<h2 id="7-2-微指令的编码方式"><a href="#7-2-微指令的编码方式" class="headerlink" title="7.2.微指令的编码方式"></a>7.2.微指令的编码方式</h2><p><strong>微指令的编码方式：又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目的是在保证速度的情况下，尽量缩短微指令字长。</strong></p>
<h3 id="7-2-1-直接编码（直接控制）"><a href="#7-2-1-直接编码（直接控制）" class="headerlink" title="7.2.1.直接编码（直接控制）"></a>7.2.1.直接编码（直接控制）</h3><p><strong>直接编码：直接编码无需译码，在微指令的操作控制字段中，每一位代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置为 1 或 0 即可，每个微命令对应并控制数据通路中的一个微操作。</strong></p>
<ul>
<li><strong>优点</strong>：简单、直观、执行速度快、操作并行性好。</li>
<li><strong>缺点</strong>：微指令字长过长，n 个微指令就要求微指令的操作字段有 n 位，造成控制存储器容量变得很大。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722368.png" alt="image-20230416172236277" loading="lazy"></p>
<ul>
<li>上图表示发出 (PC)-&gt;MAR 和 1-&gt;R 信号。</li>
</ul>
<h3 id="7-2-2-字段直接编码"><a href="#7-2-2-字段直接编码" class="headerlink" title="7.2.2.字段直接编码"></a>7.2.2.字段直接编码</h3><p><strong>字段直接编码：将微指令的微命令字段分成若干小字段，然后把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中</strong>。</p>
<ul>
<li><strong>互斥性微命令</strong>：不能并发执行（比如 PC-&gt;MAR 和 PC+1-&gt;PC）。</li>
<li><strong>相容性微命令</strong>：可以并发执行（比如 PC-&gt;MAR 和 1-&gt;R）。</li>
</ul>
<p><strong>每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关</strong>  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723579.png" alt="image-20230416172300488" loading="lazy"></p>
<p><strong>微命令字段分段的原则为</strong>：</p>
<ul>
<li><strong>互斥性微命令分在同一段内，相容性微命令分在不同段内</strong>。</li>
<li>每个小段中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和移码时间。</li>
<li><strong>一般每个小段还要留出一个状态，表示本字段不发出任何微命令</strong>。因此当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，通常 000 表示不操作。</li>
</ul>
<p><strong>字段直接编码优缺点如下</strong></p>
<ul>
<li><strong>优点</strong>：可以缩短微指令字长。</li>
<li><strong>缺点</strong>：由于要通过译码电路后再发出微命令，因此比直接编码要慢。</li>
</ul>
<h3 id="7-2-3-字段间接编码"><a href="#7-2-3-字段间接编码" class="headerlink" title="7.2.3.字段间接编码"></a>7.2.3.字段间接编码</h3><p><strong>字段间接编码：一个字段的某些微命令需要用另一个字段中的某些微命令解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐编码。</strong></p>
<ul>
<li><strong>优点</strong>：可以进一步缩短微指令字长。</li>
<li><strong>缺点</strong>：削弱了微指令的并行控制能力，所以通常作为字段直接编码的一种辅助手段。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723204.png" alt="image-20230416172318107" loading="lazy"></p>
<h2 id="7-3-微指令的地址形成方式"><a href="#7-3-微指令的地址形成方式" class="headerlink" title="7.3.微指令的地址形成方式"></a>7.3.微指令的地址形成方式</h2><h3 id="7-3-1-下地址给出"><a href="#7-3-1-下地址给出" class="headerlink" title="7.3.1.下地址给出"></a>7.3.1.下地址给出</h3><p><strong>下地址给出：下一个微指令的地址直接由当前微指令的下地址字段指出。</strong></p>
<h3 id="7-3-2-操作码形成"><a href="#7-3-2-操作码形成" class="headerlink" title="7.3.2.操作码形成"></a>7.3.2.操作码形成</h3><p><strong>操作码形成：当机器指令取至指令寄存器之后，微指令的地址由操作码经微地址形成部件形成</strong>。</p>
<h3 id="7-3-3-增量计数法"><a href="#7-3-3-增量计数法" class="headerlink" title="7.3.3.增量计数法"></a>7.3.3.增量计数法</h3><p><strong>增量计数法：类似于 (PC+1)-&gt;PC，有 (CMAR+1)-&gt;CMAR。</strong></p>
<h3 id="7-3-4-分支转移"><a href="#7-3-4-分支转移" class="headerlink" title="7.3.4.分支转移"></a>7.3.4.分支转移</h3><p>有些微指令是转移指令，类似于 JMP。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723517.png" loading="lazy"></p>
<h3 id="7-3-5-通过测试网络"><a href="#7-3-5-通过测试网络" class="headerlink" title="7.3.5.通过测试网络"></a>7.3.5.通过测试网络</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161724375.png" alt="image-20230416172418278" loading="lazy"></p>
<h3 id="7-3-6-由硬件产生微程序入口地址"><a href="#7-3-6-由硬件产生微程序入口地址" class="headerlink" title="7.3.6.由硬件产生微程序入口地址"></a>7.3.6.由硬件产生微程序入口地址</h3><ul>
<li><strong>第一条微指令地址</strong>：由专门硬件产生（用专门的硬件记录取指周期微程序首地址）。</li>
<li><strong>中断周期</strong>：由硬件产生中断周期微程序首地址（用专门的硬件记录）。</li>
</ul>
<h1 id="8-微程序控制单元的设计"><a href="#8-微程序控制单元的设计" class="headerlink" title="8.微程序控制单元的设计"></a>8.微程序控制单元的设计</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161750234.png" alt="image-20230416175020091" loading="lazy"></p>
<h2 id="8-1-微程序控制单元设计步骤"><a href="#8-1-微程序控制单元设计步骤" class="headerlink" title="8.1.微程序控制单元设计步骤"></a>8.1.微程序控制单元设计步骤</h2><h3 id="8-1-1-第一步：分析每个阶段的微操作序列"><a href="#8-1-1-第一步：分析每个阶段的微操作序列" class="headerlink" title="8.1.1.第一步：分析每个阶段的微操作序列"></a>8.1.1.第一步：分析每个阶段的微操作序列</h3><p><strong>无论是组合逻辑设计还是微程序设计，对于相同的 CPU 结构，两种控制单元的位操作码和节拍安排都是极其相似的</strong>。以微程序控制单元在取指阶段发出的微操作命令及节拍安排如下：</p>
<ul>
<li>$T_{0}$​：PC-&gt;MAR，1-&gt;R（对应微指令 a）。</li>
<li>$T_{1}$​：M(MAR)-&gt;MDR，PC+1-&gt;PC（对应微指令 b）。</li>
<li>$T_{2}$：MDR-&gt;IR,OP(IR)-&gt; 微地址形成部件（对应微指令 c）。</li>
</ul>
<p>相比于硬布线控制，只是在 $T_{2}$节拍内的微操作命令有所不同：<strong>微程序控制单元在 $T_{2}$节拍内要将指令的操作码送至微地址形成部件（OP(IR)-&gt; 微地址形成部件），以形成该条机器指令的微程序首地址。而硬布线控制单元在 $T_{2}$节拍内要将指令的操作码送至指令译码器，以控制 CU 发出相应的微命令（OP(IR)-&gt;ID）</strong>。</p>
<p>若把一个节拍 $t$ 内的微操作安排在一条微指令中完成，上述微操作就对应了 3 条微指令。<strong>但是由于微程序控制的所有控制信号都来自于微命令，而微命令又存在于控制存储器中，因此欲完成这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。</strong></p>
<ul>
<li>在取指微程序中，除第一条微指令外，<strong>其余微指令的地址均由上一条微指令的下地址字段直接给出</strong>，因此上述每条微指令都需要增加一个<strong>将微指令下地址字段送至 CMAR</strong> 的微操作，也即 <strong>Ad(CMDR)-&gt;CMAR。</strong></li>
<li>取指微程序的最后一条微指令，<strong>其后继微指令的地址是由微地址形成部件形成的</strong>，即微地址形成部件 -&gt;CMAR。为了反映该地址与操作码有关，因此记为 <strong>OP(IR)-&gt; 微地址形成部件 -&gt;CMAR</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161738357.png" alt="image-20230416173804248" loading="lazy"></p>
<p><strong>总之，考虑到需要形成后继的微指令地址，上述取指操作应需要 6 条微指令</strong>：</p>
<ul>
<li>$T_{0}$​：<strong>PC-&gt;MAR，1-&gt;R</strong></li>
<li>$T_{1}$​：Ad(CMDR)-&gt;CMAR</li>
<li>$T_{2}$：<strong>M(MAR)-&gt;MDR,(PC+1)-&gt;PC</strong></li>
<li>$T_{3} $：Ad(CMDR)-&gt;CMAR</li>
<li>$T_{4} $：<strong>MDR-&gt;IR</strong></li>
<li>$T_{5} $​：<strong>OP(IR)-&gt; 微地址形成部件 -&gt;CMAR</strong></li>
</ul>
<h3 id="8-1-2-第二步：写出对应机器指令的微操作命令及节拍安排"><a href="#8-1-2-第二步：写出对应机器指令的微操作命令及节拍安排" class="headerlink" title="8.1.2.第二步：写出对应机器指令的微操作命令及节拍安排"></a>8.1.2.第二步：写出对应机器指令的微操作命令及节拍安排</h3><p><strong>首先写出每个周期所需要的微操作，也就是把可以并行的微操作安排在同一时序进行，这一点请参照：</strong><a href=""><a href="#5.硬布线控制器">5.硬布线控制器</a></a>。</p>
<p>安排微操作时序有如下原则：</p>
<ul>
<li>原则一：微操作的<font color='red'>先后顺序</font>不得随意更改（比如PC-&gt;MAR一定在M（MAR）-&gt;MDR之前完成）</li>
<li>原则二：<font color='red'>被控对象不同的微操作</font>尽量安排在<font color='red'>一个节拍内</font>完成（比如PC-&gt;MAR控制对象为寄存器，1&gt;R控制对象为主存，因此尽量安排在同一个节拍内完成）</li>
<li>原则三：<font color='red'>占用时间较短</font>的微操作尽量安排在<font color='red'>一个节拍内完成，并允许有先后顺序</font>（比如寄存器之间的交互快于寄存器与主存的交互，因此如果可以的话尽量将其放在一个节拍完成）</li>
</ul>
<p>比如取指周期，上面我们所列的微操作序列，在这种原则下是不合适的，因此更改如下：</p>
<p><strong>另外还要加入一些特有的操作</strong>：</p>
<ul>
<li><p>取指周期内，除了最后一条微指令，<strong>每一条微指令结束后都要根据当前微指令的下地址字段指出下一条微指令的地址</strong>，即 Ad(CMDR)-&gt;CMAR；取指周期的最后一条微指令执行完成之后，<strong>要根据指令操作码确定其执行周期的微程序首地址</strong>，即 OP(IR)-&gt; 微地址形成部件 -&gt;CMAR。</p>
</li>
<li><p>执行周期内，<strong>每一条微指令结束后都要根据当前微指令的下地址字段指出下一条微指令的地址</strong>，即 Ad(CMDR)-&gt;CMAR；<strong>执行周期最后一条微指令其下地址是 0，又会指向取指周期第一条微指令</strong>  。</p>
<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161747220.png" style="zoom: 50%;" / loading="lazy"></li>
</ul>
<h3 id="8-1-3-第三步：确定微指令格式"><a href="#8-1-3-第三步：确定微指令格式" class="headerlink" title="8.1.3.第三步：确定微指令格式"></a>8.1.3.第三步：确定微指令格式</h3><ul>
<li><strong>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数</strong>。</li>
<li><strong>根据 CM 中存储的微指令总数，确定微指令的顺序控制字段的位数。</strong></li>
<li><strong>最后按操作控制字段位数和顺序控制字段位数就可以确定微指令字长</strong>。</li>
</ul>
<p>更多细节请看<a href="#7.微指令的设计">7.微指令的设计</a>。</p>
<h3 id="8-1-4-第四步：编写微指令码点"><a href="#8-1-4-第四步：编写微指令码点" class="headerlink" title="8.1.4.第四步：编写微指令码点"></a>8.1.4.第四步：编写微指令码点</h3><p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</p>
<h2 id="8-2-微程序设计分类"><a href="#8-2-微程序设计分类" class="headerlink" title="8.2.微程序设计分类"></a>8.2.微程序设计分类</h2><h3 id="8-2-1-静态微程序设计和动态微程序设计"><a href="#8-2-1-静态微程序设计和动态微程序设计" class="headerlink" title="8.2.1.静态微程序设计和动态微程序设计"></a>8.2.1.静态微程序设计和动态微程序设计</h3><ul>
<li><strong>静态</strong>：微程序无需改变，采用 ROM。</li>
<li><strong>动态</strong>：通过改变微指令和微程序改变机器指令，有利于仿真，采用 DPROM。</li>
</ul>
<h3 id="8-2-2-毫微程序设计"><a href="#8-2-2-毫微程序设计" class="headerlink" title="8.2.2.毫微程序设计"></a>8.2.2.毫微程序设计</h3><ul>
<li><strong>微程序设计</strong>：使用微程序解释机器指令。</li>
<li><strong>毫微程序设计</strong>：使用毫微程序解释微程序。</li>
</ul>
<h2 id="8-3-硬布线控制器和微程序控制器比较"><a href="#8-3-硬布线控制器和微程序控制器比较" class="headerlink" title="8.3.硬布线控制器和微程序控制器比较"></a>8.3.硬布线控制器和微程序控制器比较</h2><table><thead><tr><th></th><th><strong>微程序控制器</strong></th><th><strong>硬布线控制器</strong></th></tr></thead><tbody><tr><td><strong>工作原理</strong></td><td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td><td>微操作控制信号由组合逻辑电路根据当前的指令码，状态和时序即时产生</td></tr><tr><td><strong>执行速度</strong></td><td>慢</td><td>快</td></tr><tr><td><strong>是否规整</strong></td><td>是</td><td>否</td></tr><tr><td><strong>应用场合</strong></td><td>CISC 和 CPU</td><td>RISC 和 CPU</td></tr><tr><td><strong>易扩充性</strong></td><td>易于扩充</td><td>很难扩充</td></tr></tbody></table>



<h1 id="9-中断和异常"><a href="#9-中断和异常" class="headerlink" title="9.中断和异常"></a>9.中断和异常</h1><h2 id="9-1-中断的作用"><a href="#9-1-中断的作用" class="headerlink" title="9.1.中断的作用"></a>9.1.中断的作用</h2><p><strong>在操作系统引入核心态和用户态这两种工作状态后，就需要考虑它们之间的切换问题了。具体来讲，操作系统内核工作在核心态，用户程序工作在用户态，系统不允许用户程序使用核心态的功能，但是用户程序为了完成某些操作又必须使用这些功能。</strong></p>
<ul>
<li>比如 C 语言中的<code>printf</code>可以向屏幕打印一些内容。在屏幕上显示内容，这本就是操作系统才能做到的事情，所以你编写的程序在运行必须使用相关功能。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>因此，需要在核心态建立一些 “门”，以便实现从用户态进入核心态。而中断就是 CPU 运行上层程序时唯一能进入这些 “门” 的途径，同时中断也是让操作系统内核夺回 CPU 使用权的唯一途径。发生中断时，用户态会立即进入核心态，这是通过硬件实现的</strong>。</p>
<h2 id="9-2-中断的类型"><a href="#9-2-中断的类型" class="headerlink" title="9.2.中断的类型"></a>9.2.中断的类型</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752409.png" alt="image-20230416175223296" loading="lazy"></p>
<h3 id="9-2-1-外中断（中断）"><a href="#9-2-1-外中断（中断）" class="headerlink" title="9.2.1.外中断（中断）"></a>9.2.1.外中断（中断）</h3><p><strong>中断：也称为外中断，指中断信号来自于 CPU 外部，也即与当前执行的指令无关，例如</strong>：</p>
<ul>
<li><p><strong>时钟部件</strong>会每隔一个时间片给 CPU 发送一个<strong>时钟中断</strong>信号，防止某些程序长时间抢占 CPU。</p>
</li>
<li><p><strong>输入 &#x2F; 输出处理完成后，相关设备也会发送一个中断信号</strong>，希望处理机能够向设备发下一个输入 &#x2F; 输出请求，同时让完成输入 &#x2F; 输出后的程序继续运行  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752751.png" alt="image-20230416175236635" loading="lazy"></p>
</li>
</ul>
<h3 id="9-2-2-内中断（异常）"><a href="#9-2-2-内中断（异常）" class="headerlink" title="9.2.2.内中断（异常）"></a>9.2.2.内中断（异常）</h3><p><strong>内中断：也称为异常 (trap)，指中断信号来自于 CPU 内部，也即与当前执行的指令有关，例如</strong>：</p>
<ul>
<li>试图在用户态下执行特权指令。</li>
<li>执行除法指令时发现除数为 0。</li>
<li>应用程序想要请求操作系统内核为其提供服务，此时会执行一条特殊的指令——<strong>陷入指令（<code>trap</code>）</strong>，该指令会引发一个内中断信号（比如 C 语言中的<code>printf</code>）。</li>
</ul>
<p><strong>对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现异常应立即处理</strong>。</p>
<h2 id="9-3-中断的处理过程"><a href="#9-3-中断的处理过程" class="headerlink" title="9.3.中断的处理过程"></a>9.3.中断的处理过程</h2><p>此部分内容需要用到大量计组的知识，不是三言两语就能说清楚的，这里只是简单谈及，读者可以查阅文章最开始的链接进行学习  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161757080.png" loading="lazy"></p>
<ul>
<li><p><strong>关中断</strong>：在中断服务程序中，为了<strong>保护中断现场</strong> (即 CPU 主要寄存器中的内容) 期间不被新的中断所打断，必须关中断，从而<strong>保证被中断的程序在中断服务程序执行完毕后能接着正确地执行</strong>。</p>
</li>
<li><p><strong>保存断点</strong>：为保证在中断服务程序执行那个完毕后能<strong>正确地返回原来的程序</strong>，必须将原来程序的断点（即 PC 的内容）<strong>保存</strong>起来。这一点我们在<a href="#2.指令执行过程">2.指令执行过程</a>中有过详细介绍。</p>
</li>
<li><p><strong>引出中断服务程序</strong>：<strong>其实质是取出中断服务程序的入口地址并传送给程序计数器 PC。</strong></p>
</li>
<li><p><strong>保护现场：</strong> 保存<strong>通用寄存器和状态寄存器</strong>的内容（即保存 ACC 寄存器的值），以便返回原程序后可以<strong>恢复 CPU 环境</strong>，可以使用堆栈，也可以使用特定存储单元。</p>
</li>
<li><p><strong>中断服务：</strong> 主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲寄存器 （中断服务的过程中有可能会修改 ACC 寄存器的值）。</p>
</li>
<li><p><strong>恢复现场：</strong> 通过<strong>出栈指令或取数指令</strong>把之前保存的信息送回寄存器中（把原程序算到一般的 ACC 值恢复原样）。</p>
</li>
<li><p><strong>中断返回：通过中断返回指令回到</strong>原程序断点<strong>处。</strong></p>
</li>
</ul>
<h1 id="10-指令流水线基本概念性能指标"><a href="#10-指令流水线基本概念性能指标" class="headerlink" title="10.指令流水线基本概念性能指标"></a><a name="10.指令流水线基本概念性能指标">10.指令流水线基本概念性能指标</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161945862.png" alt="image-20230416194547727" loading="lazy"></p>
<h2 id="10-1-指令流水的定义"><a href="#10-1-指令流水的定义" class="headerlink" title="10.1.指令流水的定义"></a>10.1.指令流水的定义</h2><p><strong>前面说过，一条指令的执行过程可以分成多个阶段，不同的计算机有不同的分法，其中比较通用的划分方法就是划分为取指，分析和执行三个阶段</strong>。</p>
<ul>
<li><p><strong>取指</strong>：根据 PC 内容访问主存储器，取出一条指令送到 IR 中。</p>
</li>
<li><p><strong>分析</strong>：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址 EA，并存有效地址 EA 中取出操作数。</p>
</li>
<li><p><strong>执行</strong>：根据操作码字段完成指令规定的功能，即把运算结果写入到通用寄存器或主存中  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758588.png" loading="lazy"></p>
</li>
</ul>
<p>当多条指令在处理器中执行时，会有如下三种执行方式，称之为指令流水：</p>
<ul>
<li>顺序执行</li>
<li>一次重叠</li>
<li>二次重叠</li>
</ul>
<h3 id="10-1-1-顺序执行方式"><a href="#10-1-1-顺序执行方式" class="headerlink" title="10.1.1.顺序执行方式"></a>10.1.1.顺序执行方式</h3><p><strong>顺序执行方式：指令会按顺序执行，前一条指令执行完之后，才启动下一条指令。传统的冯诺依曼机便采用此种方式，又称其为串行执行方式</strong>。</p>
<ul>
<li><strong>优点</strong>：控制<strong>简单</strong>，硬件<strong>代价小。</strong></li>
<li><strong>缺点</strong>：执行指令的<strong>速度较慢</strong>，任何时刻，处理机中<strong>只有一条指令</strong>在执行，各功能部件<strong>利用率很低。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758581.png" loading="lazy"></p>
<p>**设取指、分析、执行 3 个阶段的时间都相等，用 $t$ 表示，那么顺序执行 $n$条指令所用时间为 $T&#x3D;3nt $**。</p>
<h3 id="10-1-2-一次重叠方式"><a href="#10-1-2-一次重叠方式" class="headerlink" title="10.1.2.一次重叠方式"></a>10.1.2.一次重叠方式</h3><p><strong>一次重叠方式：同时进行第 k 条指令的 “执行阶段” 和第 k+1 条指令的 “取指阶段”。</strong></p>
<ul>
<li><strong>优点</strong>：程序的执行时间<strong>缩短了 $ \frac{1}{3} $​</strong>，各功能部件的<strong>利用率明显提高</strong>。</li>
<li><strong>缺点</strong>：需要付出较大的<strong>硬件代价</strong>，控制过程也比顺序执行<strong>复杂。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758172.png" loading="lazy">  </p>
<p><strong>采用此种方式时，执行 $n$条指令所用时间为</strong>：</p>
<p>$T&#x3D;3t+(n-1)×2t&#x3D;(1+2n)t $</p>
<h3 id="10-1-3-二次重叠执行方式"><a href="#10-1-3-二次重叠执行方式" class="headerlink" title="10.1.3.二次重叠执行方式"></a>10.1.3.二次重叠执行方式</h3><p><strong>二次重叠方式：为了进一步提高指令的执行速度，可以把 “取 $K$+1 条指令” 提前到 “分析第 $K$ 条指令”的期间完成，使 “分析第 k+1 条指令” 与“执行第 k 条指令”同时进行</strong>。</p>
<ul>
<li><strong>优点</strong>：使指令的执行时间缩短了近 2&#x2F;3。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017986.png" loading="lazy"></p>
<p><strong>采用此种方式，执行 $n$条指令所用时间为</strong>：</p>
<p>$T&#x3D;3t+(n-1)×t&#x3D;(2+n)t $</p>
<p><strong>这是一种理想的指令执行方式，在正常情况下，处理机中同时有 3 条指令在执行. 若每条指令需要通过 4 个或 5 个执行步骤完成，则可以采取 3 次或 4 次重叠执行方式（考试常考 5 次）</strong>。</p>
<h2 id="10-2-流水线的表示方法"><a href="#10-2-流水线的表示方法" class="headerlink" title="10.2.流水线的表示方法"></a>10.2.流水线的表示方法</h2><h3 id="10-2-1-指令执行过程图"><a href="#10-2-1-指令执行过程图" class="headerlink" title="10.2.1.指令执行过程图"></a>10.2.1.指令执行过程图</h3><p><strong>指令执行过程图：该图用于描述指令的执行过程以及影响流水线的因素，横坐标表示时间、纵坐标表示指令序列。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161759655.png" alt="image-20230416175911550" loading="lazy"></p>
<h3 id="10-2-2-时空图"><a href="#10-2-2-时空图" class="headerlink" title="10.2.2.时空图"></a>10.2.2.时空图</h3><p><strong>指令执行过程图：在时空图中，横坐标表示时间（输入流水线中的各个任务在流水线中所经过的时间）；纵坐标表示空间，即流水线的每个流水段（对应各个执行部件）。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171125130.png" alt="image-20230416175942607" loading="lazy"></p>
<ul>
<li>从上图中可以看出，第一条指令 $I_{1}$在时刻 $t_{0}$​进入流水线，在时刻$ t_{4}$​流出流水线。</li>
<li>第二条指令$I_{2} $在时刻 $T_{1}$进入流水线，在时刻 $t_{5}$流出流水线。</li>
<li>以此类推，每经过一个Δt 时间，便有一条指令进入流水线，从时刻$ t_{4}$开始有一条指令流出流水线。</li>
</ul>
<h2 id="10-3-流水线性能指标"><a href="#10-3-流水线性能指标" class="headerlink" title="10.3.流水线性能指标"></a>10.3.流水线性能指标</h2><h3 id="10-3-1-吞吐率"><a href="#10-3-1-吞吐率" class="headerlink" title="10.3.1.吞吐率"></a>10.3.1.吞吐率</h3><p><strong>吞吐率：是指在单位时间内流水线所完成的任务数量，或是输出结果的数量</strong>。</p>
<p><strong>假设任务数为 n n n，处理完这 $n$个任务所用时间为 $ T_{k}$​，则计算流水线吞吐率（ $ TP$）的最基本公式为</strong></p>
<p>$ TP&#x3D;\frac{n}{T_{k}} $</p>
<p><strong>对应时空图如下</strong>：</p>
<ul>
<li><p>一条指令的执行分为 $K$ 个阶段，每个阶段耗时Δt，一般取Δt &#x3D; 一个时钟周期  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png" alt="image-20230416180116454" loading="lazy"></p>
</li>
</ul>
<p><strong>则流水线的实际吞吐率为</strong>：</p>
<p>$TP&#x3D;\frac{n}{(k+n-1)\Delta t} $</p>
<p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p>
<p>$ \lim\limits_{n \to \infty}TP&#x3D;\frac{n}{(k+n-1)\Delta t} $</p>
<p><strong>故</strong>：</p>
<p>$ TP_{max}&#x3D;\frac{1}{\Delta t} $</p>
<h3 id="10-3-2-加速比"><a href="#10-3-2-加速比" class="headerlink" title="10.3.2.加速比"></a>10.3.2.加速比</h3><p><strong>加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</strong></p>
<p><strong>设 $T_{0}$​表示不使用流水线时的执行时间，即顺序执行所有指令花费的时长； $ T_{k}$​表示使用流水线的执行时间，则计算流水线加速比 $S $ 的基本公式为</strong></p>
<p>$S&#x3D;\frac{T_{0}}{T_{k}} $</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png" loading="lazy"></p>
<p><strong>单独完成一个任务耗时为 $ k\Delta t$，则顺序完成 $n$个任务耗时为 $ T_{0}&#x3D;nk\Delta $，且 $ T_{k}&#x3D;(k+n-1)\Delta $，故实际加速比为</strong>：</p>
<p>$ S&#x3D;\frac{nk\Delta}{(k+n-1)\Delta}&#x3D;\frac{kn}{k+n-1} $</p>
<p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p>
<p>$ \lim\limits_{n \to \infty}S&#x3D;\frac{kn}{k+n-1} $</p>
<p><strong>故</strong>：</p>
<p>$ S_{max}&#x3D;k $</p>
<h3 id="10-3-3-效率"><a href="#10-3-3-效率" class="headerlink" title="10.3.3.效率"></a>10.3.3.效率</h3><p><strong>加速比：流水线的设备利用率称为流水线的效率。在时空图上，流水线的效率定义为： $n$个任务占用的时空区有效面积与 $n$个任务所用的时间与 $K$ 个流水段所围成的时空区域总面积之比</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161802331.png" alt="image-20230416180206228" loading="lazy"></p>
<p><strong>则流水线效率 ( $E$) 的一般公式为</strong>：</p>
<p>$ E&#x3D;\frac{n 个任务占用的时空区有效面积}{n 个任务所用的时间与 k 个流水段所围成的时空区域总面积}&#x3D;\frac{T_{0}}{kT_{k}} $</p>
<p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p>
<p>$ \lim\limits_{n \to \infty}E&#x3D;\frac{T_{0}}{kT_{k}} $</p>
<p><strong>故</strong>：</p>
<p>$ E_{max}&#x3D;1 $</p>
<h1 id="11-指令流水线影响因素分类"><a href="#11-指令流水线影响因素分类" class="headerlink" title="11.指令流水线影响因素分类"></a>11.指令流水线影响因素分类</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810973.png" alt="image-20230416181019839" loading="lazy"></p>
<h2 id="11-1-影响指令流水线的因素"><a href="#11-1-影响指令流水线的因素" class="headerlink" title="11.1.影响指令流水线的因素"></a>11.1.影响指令流水线的因素</h2><p><a href="#10.指令流水线基本概念性能指标">10.指令流水线基本概念性能指标</a>中所讲到的流水线都是理想情况，但在实际情况中流水线的衔接似乎不那么完美，那么这当中的影响因素都有哪些呢？</p>
<h3 id="11-1-1-结构相关（资源冲突）"><a href="#11-1-1-结构相关（资源冲突）" class="headerlink" title="11.1.1.结构相关（资源冲突）"></a>11.1.1.结构相关（资源冲突）</h3><h4 id="11-1-1-1-概述"><a href="#11-1-1-1-概述" class="headerlink" title="11.1.1.1.概述"></a>11.1.1.1.概述</h4><p><strong>结构相关（资源冲突）：由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关</strong>。</p>
<p>如下图所示，<code>Load</code>指令在进入<code>Mem</code>阶段时，<code>Instr3</code>指令才刚进入取指阶段，两者都会访问主存所以可能导致资源上的冲突。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161806136.png" alt="image-20230416180647002" loading="lazy"></p>
<h4 id="11-1-1-2-解决方法"><a href="#11-1-1-2-解决方法" class="headerlink" title="11.1.1.2.解决方法"></a>11.1.1.2.解决方法</h4><p><strong>结构相关（资源冲突）解决方法</strong>：</p>
<ul>
<li><p><strong>第一种解决方法</strong>：后一相关指令<strong>暂停一周期</strong>。</p>
</li>
<li><p><strong>第二种解决方法</strong>：进行资源重复配置，<strong>专门设立数据存储器和指令存储器</strong>，使访问数据和访问指令<strong>专属于不同的存储块</strong>，互不干扰  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161805535.png" loading="lazy"></p>
</li>
</ul>
<h3 id="11-1-2-数据相关（数据冲突）"><a href="#11-1-2-数据相关（数据冲突）" class="headerlink" title="11.1.2.数据相关（数据冲突）"></a>11.1.2.数据相关（数据冲突）</h3><h4 id="11-1-2-1-概述"><a href="#11-1-2-1-概述" class="headerlink" title="11.1.2.1.概述"></a>11.1.2.1.概述</h4><p><strong>数据相关（数据冲突）：在一个程序中，如果存在必须等前一条指令执行完才能执行后一条指令的情形，则这两条指令为数据相关</strong>。</p>
<p>如下图所示，众多指令在依次执行。<code>sub</code>、<code>and</code>、<code>or</code>和<code>xor</code>这些指令都会用到<code>r1</code>这个操作数。其中<code>add</code>指令会把<code>r2</code>和<code>r3</code>相加的结果放入<code>r1</code>，在这个过程中，如果<code>and</code>后面的指令在<code>and</code>指令还没有把<code>r1</code>放入内存时就访问了<code>r1</code>，那么就会导致<code>sub</code>、<code>and</code>和<code>or</code>这三个指令拿到错误的<code>r1</code>，而只有<code>xor</code>拿到了正确的<code>r1</code>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807614.png" alt="image-20230416180729500" loading="lazy"></p>
<h4 id="11-1-2-2-解决方法"><a href="#11-1-2-2-解决方法" class="headerlink" title="11.1.2.2.解决方法"></a>11.1.2.2.解决方法</h4><p><strong>数据相关（数据冲突）解决方法</strong>。</p>
<ul>
<li><p><strong>第一种解决方法</strong>：把遇到数据相关的指令及其后续指令<strong>都暂停一至几个时钟周期</strong>，直至数据相关问题消失后再继续进行，可以分为 <strong>硬件阻塞 (stall)</strong> 和 <strong>软件插入 “NOP</strong>“ 两种方法  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809003.png" alt="image-20230416180919877" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161808032.png" alt="image-20230416180835875" loading="lazy"></p>
<p><strong>第二种解决方法</strong>：使用<strong>数据旁路技术</strong>，仔细观察，<code>r1</code>的正确结果其实已经在执行阶段结束之后就生成了，因此<strong>可以把该指令的计算结果作为 ALU 的一个输入来源</strong>，直接开始计算过程  。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807591.png" alt="image-20230416180754468" loading="lazy"></p>
</li>
<li><p><strong>第三种解决方法</strong>：使用<strong>编译优化</strong>，通过编译器<strong>调整指令顺序</strong>，使得一些不需要该数据的后续指令先于这些指令执行。</p>
</li>
</ul>
<h3 id="11-1-3-控制相关（控制冲突）"><a href="#11-1-3-控制相关（控制冲突）" class="headerlink" title="11.1.3.控制相关（控制冲突）"></a>11.1.3.控制相关（控制冲突）</h3><h4 id="11-1-3-1-概述"><a href="#11-1-3-1-概述" class="headerlink" title="11.1.3.1.概述"></a>11.1.3.1.概述</h4><p><strong>控制相关（控制冲突）：当流水线遇到转移指令和其他改变 PC 值的指令而造成断流时，会引起控制相关、</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809667.png" alt="image-20230416180943551" loading="lazy"></p>
<h4 id="11-1-3-2-解决方法"><a href="#11-1-3-2-解决方法" class="headerlink" title="11.1.3.2.解决方法"></a>11.1.3.2.解决方法</h4><p><strong>控制相关（控制冲突）解决方法</strong>：</p>
<ul>
<li><strong>转移指令分支预测</strong>：简单预测（永久 true 或者 false）、动态预测（根据历史情况）动态调整。</li>
<li><strong>预期转移成功和不成功两个控制流方向上的目标指令。</strong></li>
<li><strong>加快和提前形成条件码。</strong></li>
<li><strong>提高转移方向的猜准率。</strong></li>
</ul>
<h2 id="11-2-流水线的分类"><a href="#11-2-流水线的分类" class="headerlink" title="11.2.流水线的分类"></a>11.2.流水线的分类</h2><h3 id="11-2-1-根据流水线使用的级别不同分类"><a href="#11-2-1-根据流水线使用的级别不同分类" class="headerlink" title="11.2.1.根据流水线使用的级别不同分类"></a>11.2.1.根据流水线使用的级别不同分类</h3><ul>
<li><p><strong>部件功能级流水</strong>：就是<strong>把复杂的算数逻辑运算组成流水线工作方式</strong>。例如可以把浮点加法操作分为求阶、对阶、尾数相加以及规格化 4 个子过程。</p>
</li>
<li><p><strong>处理机级流水</strong>：就是<strong>把一条指令解释过程分为多个子过程</strong>。例如我们经常提到的取指、译码、执行和访存及写回 5 个子过程。</p>
</li>
<li><p><strong>处理间流水</strong>：就<strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需要存放在与下一个处理器所共享的存储器中。</strong></p>
</li>
</ul>
<h3 id="11-2-2-根据流水线可以完成的功能分类"><a href="#11-2-2-根据流水线可以完成的功能分类" class="headerlink" title="11.2.2.根据流水线可以完成的功能分类"></a>11.2.2.根据流水线可以完成的功能分类</h3><ul>
<li><p><strong>单功能流水线</strong>：只能实现<strong>一种固定的专门功能</strong>的流水线。</p>
</li>
<li><p><strong>多功能流水线</strong>：通过<strong>各段间的不同连接方式可以同时或不同时地</strong>实现多种功能的流水线。</p>
</li>
</ul>
<h3 id="11-2-3-根据同一时间内各段之间的连接方式"><a href="#11-2-3-根据同一时间内各段之间的连接方式" class="headerlink" title="11.2.3.根据同一时间内各段之间的连接方式"></a>11.2.3.根据同一时间内各段之间的连接方式</h3><ul>
<li><p><strong>静态流水线</strong>：在同一时间内，流水线的各段<strong>只能按同一种功能</strong>的连接方式工作。</p>
</li>
<li><p><strong>动态流水线</strong>：在同一时间内，<strong>当某些段正在实现某种运算时，另一些段正在进行另一种运算</strong>。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</p>
</li>
</ul>
<h3 id="11-2-4-根据流水线的各个功能段之间是否有反馈信号"><a href="#11-2-4-根据流水线的各个功能段之间是否有反馈信号" class="headerlink" title="11.2.4.根据流水线的各个功能段之间是否有反馈信号"></a>11.2.4.根据流水线的各个功能段之间是否有反馈信号</h3><ul>
<li><p><strong>线性流水线</strong>：从输入到输出，<strong>每个功能段只允许经过一次</strong>，不存在反馈回路。</p>
</li>
<li><p><strong>非线性流水线</strong>：存在反馈回路，<strong>从输入到输出过程中，某些功能段将数次通过流水</strong>线，这种流水线适合进行线性递归的运算。</p>
</li>
</ul>
<h2 id="11-3-流水线多发技术"><a href="#11-3-流水线多发技术" class="headerlink" title="11.3.流水线多发技术"></a>11.3.流水线多发技术</h2><h3 id="11-3-1-超标量技术"><a href="#11-3-1-超标量技术" class="headerlink" title="11.3.1.超标量技术"></a>11.3.1.超标量技术</h3><p><strong>超标量技术：每个时钟周期内可以<font color='orange'>并发执行多条独立指令</font>，即以并行操作方式将两条或多条指令编译并执行，为此需要配置多个功能部件。超标量计算机<font color='orange'>不能调整指令的执行顺序</font>，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810398.png" alt="image-20230416181059298" loading="lazy"></p>
<h3 id="11-3-2-超流水技术"><a href="#11-3-2-超流水技术" class="headerlink" title="11.3.2.超流水技术"></a>11.3.2.超流水技术</h3><p>超流水技术：在<font color='yellow'>一个时钟周期</font>内<font color='yellow'>再分段</font>，在一个时钟周期内<font color='yellow'>一个功能部件使用多次</font>。<font color='yellow'>不能调整</font>指令的<font color='yellow'>执行顺序</font>，靠编译程序解决优化问题。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161811432.png" alt="image-20230416181152329" loading="lazy"></p>
<h3 id="11-3-3-超长指令字"><a href="#11-3-3-超长指令字" class="headerlink" title="11.3.3.超长指令字"></a>11.3.3.超长指令字</h3><p><strong>超流水技术：由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可以达到上百位），为此需要采用多个处理部件。</strong></p>
<h1 id="12-五段式指令流水线"><a href="#12-五段式指令流水线" class="headerlink" title="12.五段式指令流水线"></a>12.五段式指令流水线</h1><p><strong>本节会介绍如下 5 类指令的执行过程，它们在考试中经常出现</strong>：</p>
<ul>
<li>运算类指令</li>
<li>LOAD 指令</li>
<li>STORE 指令</li>
<li>条件转移指令</li>
<li>无条件转移指令</li>
</ul>
<p><strong>指令在执行过程中会涉及如下过程</strong>：</p>
<ul>
<li><code>IF</code>：取指</li>
<li><code>ID</code>译码 &amp; 取数</li>
<li><code>EX</code>执行</li>
<li><del><code>M</code>：访存</del></li>
<li><code>WB</code>：写回寄存器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161947573.png" alt="image-20230416194733427" loading="lazy"></p>
<p><strong>注意</strong>：</p>
<ul>
<li>在 RISC 处理器中只有 LOAD 和 STORE 才能访问主存。</li>
<li>转移类指令通常采用相对寻址（相对于 PC）。</li>
</ul>
<h2 id="12-1-运算类指令的执行过程"><a href="#12-1-运算类指令的执行过程" class="headerlink" title="12.1.运算类指令的执行过程"></a>12.1.运算类指令的执行过程</h2><p><strong>下表展示了 2 个较为典型的运算类指令:</strong></p>
<table><thead><tr></th></tr></thead><tbody><tr><td>加法指令（另个寄存器相加）</td><td>ADD R<sub>s</sub>,R<sub>d</sub></td><td>(R<sub>s</sub>)+(R<sub>d</sub>)-&gt; R<sub>d</sub></td></tr><tr><td>加法指令（寄存器与立即数相加）</td><td>ADD #996,R<sub>d</sub></td><td>996+(R<sub>d</sub>)-&gt; R<sub>d</sub></td></tr><tr><td>算数左移指令</td><td>SHL R<sub>d</sub></td><td>(R<sub>d</sub>)&lt;&lt;&lt;2-&gt; R<sub>d</sub></td></tr></tbody></table>

<p><strong>运算类指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p>
<p><strong>运算类指令步骤二（<code>ID</code>）：取出操作数到 ID 段的锁存器。</strong></p>
<ul>
<li>ADD Rs,Rd：Rs 放到 $A$中、Rd 放到 $B$ 中。</li>
<li>ADD #996,Rd：Rd 放到 $A$中，966 放到 $Imm$ 中。</li>
<li>SHL Rd：Rd 放到 $A$中。</li>
</ul>
<p><strong>运算类指令步骤三（<code>EX</code>）：进行运算，将结果存入 EX 段锁存器</strong>。</p>
<p><strong>运算类指令步骤四（<code>M</code>） ：对于 RISC 系统，计算结果会直接放入寄存器，所以是空段，什么事情都不用做，但要消耗相应的时间</strong>。</p>
<p><strong>运算类指令步骤五（<code>WB</code>）：运算结果写回指定寄存器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161948409.png" loading="lazy"></p>
<h2 id="12-2-LOAD-指令执行过程"><a href="#12-2-LOAD-指令执行过程" class="headerlink" title="12.2.LOAD 指令执行过程"></a>12.2.LOAD 指令执行过程</h2><p><strong>LOAD 指令的功能是取数，会把主存或寄存器中的内容取至寄存器中，有如下两种描述方式</strong>：</p>
<table><thead><tr></tr></thead><tbody><tr><td>LOAD R<sub>d</sub>, 996(R<sub>s</sub>)</td><td>(996+(R<sub>s</sub>)) -&gt;R<sub>d</sub></td></tr><tr><td>LOAD R<sub>d</sub>, mem</td><td>(mem)-&gt;R<sub>d</sub></td></tr></tbody></table>

<p><strong>LOAD 指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p>
<p>**LOAD 指令步骤二（<code>ID</code>）：将基址寄存器的值放到锁存器 A A A、将偏移量放到 $Imm$**。</p>
<p><strong>LOAD 指令步骤三（<code>EX</code>）：进行运算，得到有效地址。</strong></p>
<p><strong>LOAD 指令步骤四（<code>M</code>） ：从数据 Cache 中取数并放入锁存器。</strong></p>
<p><strong>LOAD 指令步骤五（<code>WB</code>）：将取出的数写回寄存器。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161950321.png" loading="lazy"></p>
<h2 id="12-3-STORE-指令执行过程"><a href="#12-3-STORE-指令执行过程" class="headerlink" title="12.3.STORE 指令执行过程"></a>12.3.STORE 指令执行过程</h2><p><strong>STORE 指令的功能是存数，有如下两种描述方式</strong>：</p>
<table><thead><tr></tr></thead><tbody><tr><td>STORE R<sub>s</sub>, 996(R<sub>d</sub>)</td><td>R<sub>s</sub>-&gt;996+(R<sub>d</sub>))</td></tr><tr><td>STORE R<sub>s</sub>, mem</td><td>R<sub>s</sub>-&gt;(mem)</td></tr></tbody></table>

<p><strong>Store 指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p>
<p>**Store 指令步骤二（<code>ID</code>）：将基址寄存器的值放到锁存器 A A A、将偏移量放到 $Imm$、将要存的数放到 $B$**。</p>
<p><strong>Store 指令步骤三（<code>EX</code>）：进行运算，得到有效地址，并将锁存器 $B$ 的内容放到锁存器 Store。</strong></p>
<p><strong>Store 指令步骤四（<code>M</code>） ：写入数据 Cache</strong>。</p>
<p><strong>Store 指令步骤五（<code>WB</code>） ：空段。</strong></p>
<h2 id="12-4-条件转移指令执行过程"><a href="#12-4-条件转移指令执行过程" class="headerlink" title="12.4.条件转移指令执行过程"></a>12.4.条件转移指令执行过程</h2><p><strong>如下</strong>：</p>
<ul>
<li><strong>beq Rs,Rt, #偏移量</strong>：若 (Rs)&#x3D;&#x3D;(Rt)，则 (PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC，否则有 (PC)+ 指令字长 -&gt;PC。</li>
<li><strong>bne Rs,Rt, #偏移量</strong>：若 (Rs)!&#x3D;(Rt)，则 (PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC，否则有 (PC)+ 指令字长 -&gt;PC。</li>
</ul>
<p><strong>条件转移指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器。</strong></p>
<p>**条件转移指令步骤二（<code>ID</code>）：进行比较的两个数放入锁存器 $A$和 $B$、偏移量放入 $Imm$**。</p>
<p><strong>条件转移指令步骤三（<code>EX</code>）：进行运算，比较两个数。</strong></p>
<p><strong>条件转移指令步骤四（<code>M</code>） ：将目标 PC 值写回 PC。</strong></p>
<p><strong><del>条件转移指令步骤五</del>（<code>WB</code>） ：空段</strong>。</p>
<h2 id="12-5-无条件转移指令执行过程"><a href="#12-5-无条件转移指令执行过程" class="headerlink" title="12.5.无条件转移指令执行过程"></a>12.5.无条件转移指令执行过程</h2><p><strong>如下</strong>：</p>
<ul>
<li><strong>jmp #偏移量</strong>：(PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC。</li>
</ul>
<p><strong>无条件转移指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p>
<p>**无条件转移指令步骤二（<code>ID</code>）：偏移量放入 $Imm$**。</p>
<p><strong>无条件转移指令步骤三（<code>EX</code>）：将目标 PC 值写回 PC。</strong></p>
<p><strong>无条件转移指令步骤四（<code>M</code>） ：空段。</strong></p>
<p><strong>无条件转移指令步骤五（<code>WB</code>） ：空段</strong>。</p>
<h1 id="13-多处理器基本概念"><a href="#13-多处理器基本概念" class="headerlink" title="13.多处理器基本概念"></a>13.多处理器基本概念</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162004915.jpg" alt="第5章 中央处理器" loading="lazy"></p>
<h2 id="13-1-SISD、SIMD、MIMD-基本概念"><a href="#13-1-SISD、SIMD、MIMD-基本概念" class="headerlink" title="13.1.SISD、SIMD、MIMD 基本概念"></a>13.1.SISD、SIMD、MIMD 基本概念</h2><p><strong>计算机体系结构分类：基于指令流的数量和数据流的数量，可以将计算机体系结构分为如下 4 类</strong>：</p>
<ul>
<li><strong>单指令单数据流 SISD</strong></li>
<li><strong>单指令多数据流 SIMD</strong></li>
<li><strong>多指令单数据流 MISD</strong></li>
<li><strong>多指令多数据流 MIMD</strong></li>
</ul>
<h3 id="13-1-1-单指令单数据流-SISD"><a href="#13-1-1-单指令单数据流-SISD" class="headerlink" title="13.1.1.单指令单数据流 SISD"></a>13.1.1.单指令单数据流 SISD</h3><p><strong>单指令单数据流 SISD：常规的单处理器便是 SISD，其特性和硬件组成如下</strong>：</p>
<ul>
<li><strong>特性</strong>：①各指令序列<strong>只能并发而不能并行</strong>；②每条指令<strong>处理一两个数据</strong>；③不是<strong>数据级并行技术</strong>。</li>
<li><strong>硬件组成</strong>：①一个<strong>处理器</strong> + 一个<strong>主存储器</strong>；②若采用指令流水线，则<strong>需要设置多个功能部件，采用多模块交叉存储器</strong>。</li>
</ul>
<p>《<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86&spm=1001.2101.3001.7020">计算机组成原理</a>》这门课程一直研究的便是 SISD。如下，<strong>此 CPU 在同一时间段内仅能处理一个进程或线程的一个指令序列，每条指令只能处理一两个数据。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955615.png" alt="image-20230416195506504" loading="lazy"></p>
<h3 id="13-1-2-单指令多数据流-SIMD"><a href="#13-1-2-单指令多数据流-SIMD" class="headerlink" title="13.1.2.单指令多数据流 SIMD"></a>13.1.2.单指令多数据流 SIMD</h3><p><strong>单指令多数据流 SIMD：其特性和硬件组成如下</strong>：</p>
<ul>
<li><strong>特性</strong>：①各指令序列<strong>只能并发而不能并行</strong>；②每条指令<strong>可以同时处理多个具有相同特征的数据</strong>；③是<strong>数据级并行技术</strong>。</li>
<li><strong>硬件组成</strong>：①一个<strong>指令控制部件</strong> + 多个<strong>处理单元 &#x2F; 执行单元</strong> + 一个<strong>主存储器</strong>；②每个执行单元有<strong>各自的寄存器组、局部存储器、地址寄存器</strong>；③不同执行单元<strong>执行同一条指令、处理不同的数据。</strong></li>
</ul>
<p>如下，在 SIMD 系统中，<strong>CU 每次会取出一条指令，根据此指令发出控制信号给各个执行部件（如 ALU），每个执行部件都有各自的寄存器（组）。</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955174.png" alt="image-20230416195538067" loading="lazy"></p>
<p><strong>SIMD 系统善于对结构类似的大量数据做相同处理，例如</strong>：</p>
<ul>
<li>图像处理时，对每个像素点作 “高斯模糊”。</li>
<li>可用于优化 for 循环中对数组元素的重复处理。</li>
</ul>
<h3 id="13-1-3-多指令单数据流-MISD"><a href="#13-1-3-多指令单数据流-MISD" class="headerlink" title="13.1.3.多指令单数据流 MISD"></a>13.1.3.多指令单数据流 MISD</h3><p><strong>多指令单数据流 MISD：多条指令并行执行，处理同一个数据。现实中并不存在这种计算机。</strong></p>
<h3 id="13-1-4-多指令多数据流-MIMD"><a href="#13-1-4-多指令多数据流-MIMD" class="headerlink" title="13.1.4.多指令多数据流 MIMD"></a>13.1.4.<strong>多指令多数据流 MIMD</strong></h3><p><strong>多指令多数据流 MIMD：常规的多处理器便是 MIMD，其特性如下</strong>：</p>
<ul>
<li>各指令序列<strong>并行执行，分别处理多个不同的数据</strong>。</li>
<li>是一种<strong>线程级并行技术</strong>（甚至是线程级以上）。</li>
</ul>
<p><strong>MIMD 可以进一步分为：</strong></p>
<ul>
<li>多处理器系统</li>
<li>多计算机系统</li>
</ul>
<h4 id="13-1-4-1-多处理器系统"><a href="#13-1-4-1-多处理器系统" class="headerlink" title="13.1.4.1.多处理器系统"></a>13.1.4.1.多处理器系统</h4><p><strong>多处理器系统：是共享内存多处理器（SMP）的简称。其特性和硬件组成如下</strong>：</p>
<ul>
<li><strong>特性</strong>：各处理器之间，可以通过 LOAD&#x2F;STORE 指令访问<strong>同一个主存储器</strong>，可以通过<strong>主存相互传送数据</strong>。</li>
<li><strong>硬件组成</strong>：①一台计算机内，有多个<strong>处理器</strong> + 一个<strong>主存储器</strong>；②多个处理器<strong>共享单一的物理地址空间。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161956973.png" alt="image-20230416195608820" loading="lazy"></p>
<h4 id="13-1-4-2-多计算机系统"><a href="#13-1-4-2-多计算机系统" class="headerlink" title="13.1.4.2.多计算机系统"></a>13.1.4.2.多计算机系统</h4><p><strong>多计算机系统：其特性和硬件组成如下</strong>：</p>
<ul>
<li><strong>特性</strong>：各计算机之间，<strong>不可以通过 LOAD&#x2F;STORE 指令直接访问对方的存储器</strong>，只能通过<strong>消息传递相互传送数据</strong>。</li>
<li><strong>硬件组成</strong>：①由多台计算机组成，所以有多个<strong>处理器</strong> + 多个<strong>主存储器</strong>；②每台计算机拥有<strong>各自的私有存储器</strong>，物理地址空间<strong>相互独立。</strong></li>
</ul>
<p>实际应用中，可以把单个任务拆分为多个任务，分别指派给不同的计算机执行。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161957622.png" alt="image-20230416195712433" loading="lazy"></p>
<h2 id="13-2-向量处理器"><a href="#13-2-向量处理器" class="headerlink" title="13.2.向量处理器"></a>13.2.向量处理器</h2><p>向量处理机的LOAD指令，可以将一个向量取到向量寄存器中；加法指令，可以实现两个向量相加应用于：向量计算、大量浮点数计算，空气动力学、核物理学、巨型矩阵计算问题很多超级计算机如中国的“银河”就是向量处理器。</p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161959391.png" alt="image-20230416195929243" loading="lazy"></p>
<h1 id="14-硬件多线程的基本概念"><a href="#14-硬件多线程的基本概念" class="headerlink" title="14.硬件多线程的基本概念"></a>14.硬件多线程的基本概念</h1><p><strong>硬件多线程：在 <a href="">(王道 408 考研操作系统) 第二章进程管理 - 线程概念和多线程模型</a>这一节中我们说到了线程的一些缺点。线程粒度较进程来讲更细，而且线程切换包含很多开销，频繁切换线程必然会影响系统性能，所以为了减少开销便诞生了硬件多线程。在支持硬件多线程的 CPU 中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。共有如下 3 种实现方式</strong></p>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162011405.png" alt="image-20230416201131263" loading="lazy"></p>
<p><strong>如下</strong>：</p>
<ul>
<li>对于<strong>不支持硬件多线程的 CPU</strong>：同一时刻只能有一个线程运行，线程切换时需要保护现场，产生额外开销。</li>
<li>对于<strong>支持硬件多线程的 CPU</strong>：不同线程运行在不同环境中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012378.png" alt="image-20230416201232259" loading="lazy"></p>
<h2 id="14-1-细粒度多线程"><a href="#14-1-细粒度多线程" class="headerlink" title="14.1.细粒度多线程"></a>14.1.细粒度多线程</h2><p><strong>细粒度多线程：关键特征如下</strong>：</p>
<ul>
<li><strong>指令发射：轮流发射各线程的指令（每个时钟周期发射一个线程）</strong>。</li>
<li><strong>线程切换频率：每个时钟周期切换一次线程。</strong></li>
<li><strong>线程切换代价：低。</strong></li>
<li><strong>并行性：指令级并行、线程间不并行</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012684.png" alt="image-20230416201249567" loading="lazy"></p>
<h2 id="14-2-粗粒度多线程"><a href="#14-2-粗粒度多线程" class="headerlink" title="14.2.粗粒度多线程"></a>14.2.粗粒度多线程</h2><p><strong>粗粒度多线程：关键特征如下</strong>：</p>
<ul>
<li><strong>指令发射：连续几个时钟周期，都发射同一线程的指令序列。流水线阻塞时，才切换另一个线程</strong>。</li>
<li><strong>线程切换频率：只有流水线阻塞时才切换另一个线程。</strong></li>
<li><strong>线程切换代价：高（需要重载流水线）。</strong></li>
<li><strong>并行性：指令级并行、线程间不并行。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013395.png" alt="image-20230416201302277" loading="lazy"></p>
<h2 id="14-3-同时多线程"><a href="#14-3-同时多线程" class="headerlink" title="14.3.同时多线程"></a>14.3.同时多线程</h2><p><strong>同时多线程：关键特征如下</strong>：</p>
<ul>
<li><strong>指令发射：一个时钟周期内同时发射多个线程的指令</strong>。</li>
<li><strong>线程切换频率：NULL。</strong></li>
<li><strong>线程切换代价：NULL</strong>。</li>
<li><strong>并行性：指令级并行、线程级并行。</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013448.png" alt="image-20230416201314329" loading="lazy"></p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay-qrcode.jpg"><img loading="lazy" src="/images/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/qqpay-qrcode.jpg"><img loading="lazy" src="/images/qqpay-qrcode.jpg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay-qrcode.jpg"><img loading="lazy" src="/images/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Explorer</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://ccsu.top/posts/ea8ec112/" title="机组-第五章 中央处理器">http://ccsu.top/posts/ea8ec112/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/c0af4cb/" rel="prev" title="机组-第六章 总线"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">机组-第六章 总线</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/de459af/" rel="next" title="机组-第四章 指令系统"><span class="post-nav-text">机组-第四章 指令系统</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div id="waline"></div><script src="/js/comments/waline.js" type="module" defer></script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">皖ICP备20002891号-2</a></div><div class="copyright"><span>&copy; 2016 – 2023 </span><span class="with-love" id="animate" title="赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Explorer</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.0.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.8</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-02-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} Days ${passHour} Hours ${passMinute} Minutes ${passSecond} Seconds`;
}
blog_live_time();
</script></div><div id="busuanzi"><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":350,"hOffset":null,"vOffset":null},"mobile":{"show":true},"log":false});</script></body></html>