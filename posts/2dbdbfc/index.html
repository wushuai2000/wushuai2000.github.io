<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="Explorer"><meta name="copyright" content="Explorer"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>计组-第三章 存储系统 | explorerの博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" type="image/png" href="/./favicon.ico"><link rel="mask-icon" href="/./favicon.ico" color="#6200ee"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"ccsu.top","root":"/","title":["Wu","Shuai","の","Blog"],"version":"1.8.8","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"waline":{"config":{"enable":true,"serverURL":"https://blog-api-seven-vert.vercel.app/","comment":false,"visitor":false,"emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://cdn.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"2506812280@qq.com"},"requiredMeta":["nick"],"el":"#waline","lang":"en","path":"/posts/2dbdbfc/"},"cdn":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","dark":"html.dark"},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="explorerの博客" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-BMBD00SVV4"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BMBD00SVV4');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="1.存储器概述   image-20230414135654630  1.1.存储器分类 1.1.1.按在计算机中的作用（层次）分类  主存储器：简称主存，又称内存；用来存放计算机运行期间所需的大量程序和数据；CPU 可以直接对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据；特点是容量较小，存储速度较快，造价高。 辅助存储器：简称辅存，又称外存；是主存储器">
<meta property="og:type" content="article">
<meta property="og:title" content="计组-第三章 存储系统">
<meta property="og:url" content="http://ccsu.top/posts/2dbdbfc/index.html">
<meta property="og:site_name" content="explorerの博客">
<meta property="og:description" content="1.存储器概述   image-20230414135654630  1.1.存储器分类 1.1.1.按在计算机中的作用（层次）分类  主存储器：简称主存，又称内存；用来存放计算机运行期间所需的大量程序和数据；CPU 可以直接对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据；特点是容量较小，存储速度较快，造价高。 辅助存储器：简称辅存，又称外存；是主存储器">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-04-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-05T16:00:00.000Z">
<meta property="article:author" content="Explorer">
<meta property="article:tag" content="计算机组成原理">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Explorer"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Explorer"><span class="site-author-status" title="努力学习">😄</span></a><div class="site-author-name"><a href="/about/">Explorer</a></div><span class="site-name">explorerの博客</span><sub class="site-subtitle"></sub><div class="site-desciption">前路漫漫，当克己，当慎独!</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">74</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">64</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/wushuai2000" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=549838440" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/huan-ji-91-3/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/345844264" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2506812280@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.存储器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.存储器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1.按在计算机中的作用（层次）分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2.按照存储介质分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3.按存储方式分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%AF%E4%BF%9D%E5%AD%98%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.2.4.按信息的可保存性分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.多级存储系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.存储器性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1.存储容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E6%88%90%E6%9C%AC"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2.单位成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%80%9F%E5%BA%A6"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3.存储速度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">2.主存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%85%83%E4%BB%B6%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.基本的半导体元件及原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.存储器芯片的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80"><span class="toc-number">2.3.</span> <span class="toc-text">2.3.寻址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sram%E8%8A%AF%E7%89%87%E5%92%8Cdram%E8%8A%AF%E7%89%87"><span class="toc-number">3.</span> <span class="toc-text">3.SRAM芯片和DRAM芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%85%83%E4%BB%B6%E4%B8%8D%E5%90%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%89%B9%E6%80%A7%E5%B7%AE%E5%BC%82"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.存储器元件不同导致的特性差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%85%E6%9E%81%E7%94%B5%E5%AE%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1.栅极电容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%A8%B3%E6%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2.双稳态触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sram-%E5%92%8C-dram-%E5%AF%B9%E6%AF%94"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3.SRAM 和 DRAM 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dram-%E7%9A%84%E5%88%B7%E6%96%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.DRAM 的刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E5%99%A8%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E8%A1%8C%E5%88%97%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1.译码器需要使用行列地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2.分散刷新、集中刷新和异步刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dram-%E5%88%B7%E6%96%B0"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">3.2.2.1.DRAM 刷新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">3.2.2.2.分散刷新、集中刷新和异步刷新特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">3.2.2.3.分散刷新、集中刷新和异步刷新优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dram-%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BA%BF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.DRAM 的地址线复用技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">4.只读存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8rom%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.只读存储器（ROM）特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rom-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2.ROM 的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E7%9A%84%E9%87%8D%E8%A6%81-bios"><span class="toc-number">4.3.</span> <span class="toc-text">4.3.计算机内的重要 BIOS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8Ccpu%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">5.主存储器和CPU的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%9D%97%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E4%B8%8E-cpu-%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.单块存储芯片与 CPU 的连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%9D%97%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E4%B8%8E-cpu-%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.多块存储芯片与 CPU 的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1.位扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">5.2.1.1.单个连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">5.2.1.2.多个连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%89%A9%E5%B1%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2.字扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E9%80%89%E6%B3%95"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">5.2.2.1.线选法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E7%89%87%E9%80%89%E6%B3%95"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">5.2.2.2.译码片选法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">5.2.2.3.字位同时扩展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E5%99%A8%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">5.3.译码器(补充知识点)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E5%8F%A3ram%E5%92%8C%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">6.双端口RAM和多模块存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80"><span class="toc-number">6.1.</span> <span class="toc-text">6.1.高位交叉编址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80"><span class="toc-number">6.2.</span> <span class="toc-text">6.2.低位交叉编址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%A3%81%E7%9B%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">7.磁盘存储器（磁盘的基本结构，磁盘阵列）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">7.1.磁盘存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87%E7%BB%84%E6%88%90"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1.磁盘设备组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">7.1.1.1.存储区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">7.1.1.2.硬盘存储器的构成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2.磁盘性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3.平均存取时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80"><span class="toc-number">7.1.4.</span> <span class="toc-text">7.1.4.磁盘地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.5.</span> <span class="toc-text">7.1.5.磁盘工作过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97"><span class="toc-number">7.2.</span> <span class="toc-text">7.2.磁盘阵列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">7.3.光存储器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">8.</span> <span class="toc-text">8.固态硬盘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98ssd%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">8.1.固态硬盘（SSD）概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98ssd%E7%BB%84%E6%88%90"><span class="toc-number">8.2.</span> <span class="toc-text">8.2.固态硬盘（SSD）组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AA%E5%AD%98%E7%BF%BB%E8%AF%91%E5%B1%82"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1.闪存翻译层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2.存储介质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98ssd%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">8.3.</span> <span class="toc-text">8.3.固态硬盘（SSD）的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">8.4.</span> <span class="toc-text">8.4.磨损均衡技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8cache"><span class="toc-number">9.</span> <span class="toc-text">9.高速缓冲存储器Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cache-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">9.1.Cache 基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">9.2.程序访问的局部性原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%9D%97"><span class="toc-number">9.3.</span> <span class="toc-text">9.3.主存块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E7%8E%87%E5%92%8C%E7%BC%BA%E5%A4%B1%E7%8E%87"><span class="toc-number">9.4.</span> <span class="toc-text">9.4.命中率和缺失率</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">10.Cache和主存的映射方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">10.1.</span> <span class="toc-text">10.1.全相联映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84"><span class="toc-number">10.1.1.</span> <span class="toc-text">10.1.1.如何映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E5%AD%98"><span class="toc-number">10.1.2.</span> <span class="toc-text">10.1.2.如何访存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="toc-number">10.2.</span> <span class="toc-text">10.2.直接映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">10.2.1.如何映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E5%AD%98-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">10.2.2.如何访存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-number">10.3.</span> <span class="toc-text">10.3.组相联映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84-2"><span class="toc-number">10.3.1.</span> <span class="toc-text">10.3.1.如何映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BF%E5%AD%98-2"><span class="toc-number">10.3.2.</span> <span class="toc-text">10.3.2.如何访存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">10.4.</span> <span class="toc-text">10.4.三种方式各自优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">11.Cache替换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95rand"><span class="toc-number">11.1.</span> <span class="toc-text">11.1.随机算法（RAND）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95fifo"><span class="toc-number">11.2.</span> <span class="toc-text">11.2.先进先出算法（FIFO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%91%E6%9C%9F%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95lru%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98"><span class="toc-number">11.3.</span> <span class="toc-text">11.3.近期最少使用算法（LRU）——效率最高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95lfu"><span class="toc-number">11.4.</span> <span class="toc-text">11.4.最不经常使用算法（LFU）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5"><span class="toc-number">12.</span> <span class="toc-text">12.Cache的写策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%91%BD%E4%B8%AD"><span class="toc-number">12.1.</span> <span class="toc-text">12.1.写命中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9B%9E%E6%B3%95-write-back"><span class="toc-number">12.2.</span> <span class="toc-text">12.1.1.写回法 (write-back)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%86%99%E6%B3%95-write-through"><span class="toc-number">12.3.</span> <span class="toc-text">12.1.2.全写法 (write-through)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%8D%E5%91%BD%E4%B8%AD"><span class="toc-number">12.4.</span> <span class="toc-text">12.2.写不命中</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%88%86%E9%85%8D%E6%B3%95-write-allocate"><span class="toc-number">12.4.1.</span> <span class="toc-text">12.2.1.写分配法 (write-allocate)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%86%99%E5%88%86%E9%85%8D%E6%B3%95not-write-allocate"><span class="toc-number">12.4.2.</span> <span class="toc-text">12.2.2.非写分配法（not-write-allocate）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7-cache"><span class="toc-number">13.</span> <span class="toc-text">13.多级 Cache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">14.虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">14.1.</span> <span class="toc-text">14.1.页式存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">14.2.</span> <span class="toc-text">14.2.逻辑地址和物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">14.3.</span> <span class="toc-text">14.3.页表和地址变换过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">14.3.1.</span> <span class="toc-text">14.3.1.页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">14.3.2.</span> <span class="toc-text">14.3.2.快表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">14.4.</span> <span class="toc-text">14.4.页式虚拟存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">14.5.</span> <span class="toc-text">14.5.段式虚拟存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">14.6.</span> <span class="toc-text">14.6.段页式虚拟存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8E-cache-%E6%AF%94%E8%BE%83"><span class="toc-number">14.7.</span> <span class="toc-text">14.7.虚拟存储器与 Cache 比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C"><span class="toc-number">14.7.1.</span> <span class="toc-text">14.7.1.相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C"><span class="toc-number">14.7.2.</span> <span class="toc-text">14.7.2.不同</span></a></li></ol></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/57%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/" style="font-size: 12px; color: #999">57步进电机</a> <a href="/tags/AT9SPro/" style="font-size: 12px; color: #999">AT9SPro</a> <a href="/tags/Anaconda/" style="font-size: 12px; color: #999">Anaconda</a> <a href="/tags/Arduino/" style="font-size: 24px; color: #3383cd">Arduino</a> <a href="/tags/CUDA/" style="font-size: 18px; color: #668eb3">CUDA</a> <a href="/tags/CUDNN/" style="font-size: 12px; color: #999">CUDNN</a> <a href="/tags/Conda/" style="font-size: 12px; color: #999">Conda</a> <a href="/tags/DHT11/" style="font-size: 12px; color: #999">DHT11</a> <a href="/tags/Docker/" style="font-size: 18px; color: #668eb3">Docker</a> <a href="/tags/ESP8266/" style="font-size: 12px; color: #999">ESP8266</a> <a href="/tags/GPIO/" style="font-size: 30px; color: #0078e7">GPIO</a> <a href="/tags/GPS/" style="font-size: 12px; color: #999">GPS</a> <a href="/tags/GPU/" style="font-size: 24px; color: #3383cd">GPU</a> <a href="/tags/HC-05/" style="font-size: 12px; color: #999">HC-05</a> <a href="/tags/HTML/" style="font-size: 18px; color: #668eb3">HTML</a> <a href="/tags/Hexo/" style="font-size: 18px; color: #668eb3">Hexo</a> <a href="/tags/Hexo%E5%AE%89%E8%A3%85/" style="font-size: 24px; color: #3383cd">Hexo安装</a> <a href="/tags/IAR%E8%BD%AF%E4%BB%B6/" style="font-size: 12px; color: #999">IAR软件</a> <a href="/tags/JavaScript/" style="font-size: 18px; color: #668eb3">JavaScript</a> <a href="/tags/Json/" style="font-size: 12px; color: #999">Json</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#6200ee;"><link itemprop="mainEntityOfPage" href="http://ccsu.top/posts/2dbdbfc/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Explorer"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="explorerの博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">计组-第三章 存储系统</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <span class="post-meta-icon-text">Posted on</span> <time title="Created: 2023-04-06 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-06T00:00:00+08:00">2023-04-06</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">24.4k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">91m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%80%83%E7%A0%94408/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">考研408</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">计算机组成原理</span></a><a class="tag-item" href="/tags/%E8%80%83%E7%A0%94/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">考研</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="存储器概述">1.存储器概述</h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141356715.png"
alt="image-20230414135654630" />
<figcaption aria-hidden="true">image-20230414135654630</figcaption>
</figure>
<h2 id="存储器分类"><a name="存储器分类">1.1.存储器分类</a></h2>
<h3
id="按在计算机中的作用层次分类">1.1.1.按在计算机中的作用（层次）分类</h3>
<ul>
<li><strong>主存储器</strong>：简称<strong>主存</strong>，又称<strong>内存</strong>；用来存放计算机运行期间所需的大量程序和数据；CPU
可以<strong>直接对其进行访问</strong>，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据；特点是<strong>容量较小，存储速度较快，造价高</strong>。</li>
<li><strong>辅助存储器</strong>：简称<strong>辅存</strong>，又称<strong>外存</strong>；是主存储器的后援存储器，用来存放<strong>当前暂时不用的程序和数据，以及一些需要永久性保存</strong>的信息，它不能与
CPU
直接交换信息；特点是<strong>容量极大，存储速度较慢，造价低。</strong></li>
<li><strong>高速缓冲存储器</strong>：简称
<strong>Cache</strong>；它位于主存和 CPU
之间，用来存放<strong>正在执行的程序段和数据</strong>，以便 CPU
能够高速地使用它们；Cache 的读取速度可以和 CPU
相匹配，但<strong>存储容量小，价格高，目前会被集成在 CPU
当中</strong>。</li>
</ul>
<h3 id="按照存储介质分类">1.1.2.按照存储介质分类</h3>
<ul>
<li><strong>磁表面存储器</strong>：如磁盘、磁带等。</li>
<li><strong>磁心存储器半导体存储器</strong>：如 MOS
型存储器、双极型存储器。</li>
<li><strong>光存储器</strong>：如光盘。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355109.png" /></p>
<h3 id="按存储方式分类">1.1.3.按存储方式分类</h3>
<ul>
<li><strong>随机存储器（RAM）</strong>：存储器的任何一个存储单元的内容都可以<strong>随机存取</strong>，而且<strong>存取时间与存储单元的物理位置无关</strong>；其优点是<strong>读写方便，使用灵活，主要用作主存或高速缓冲存储器</strong>；RAM
又分为<strong>静态 RAM</strong>（以触发器原理寄存信息）和<strong>动态
RAM</strong>（以电容充电原理寄存信息）。</li>
<li><strong>只读存储器（ROM）</strong>：存储器的内容<strong>只能随机读出而不能写入</strong>；<strong>信息一旦写入存储器就固定不变，即使断电内容也不会丢失</strong>。因此通常用它存放固定不变的程序，常数和汉字字库，甚至用于操作系统的固化。<strong>它与随机存储器可以共同作为主存的一部分，统一构成主存的地址域。</strong></li>
<li><strong>串行访问存储器</strong>：对存储单元进行 I/O
操作时，<strong>需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）</strong>。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>顺序存储寄存器</strong>的内容<strong>只能按照某种顺序存取</strong>，存取时间的长短与信息在存储体的<strong>物理位置</strong>有关，其特点是<strong>存储速度慢，例如：磁带；</strong></li>
<li><strong>直接存取存储器</strong>既不像 RAM
那样随机访问任何一个存储单元，又不像顺序存取存储器那样完全按照顺序存取，而是介于两者之间，存取信息是<strong>通常先寻找整个存储器中的某个小区域，再在小区域内顺序查找，例如：机械硬盘</strong>。</li>
</ul>
<h3 id="按信息的可保存性分类">1.2.4.按信息的可保存性分类</h3>
<ul>
<li><strong>易失性存储器</strong>：断电后，存储的信息<strong>会消失</strong>，如
RAM；</li>
<li><strong>非易失性存储器</strong>：断电后，存储的信息<strong>仍然会保持</strong>，如
ROM。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><strong>破坏性读出</strong>：某个存储单元所存储的信息被读出时，原存储信息被破坏；具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个<strong>再生</strong>操作，以便恢复被破坏的信息，例如：DRAM（栅极电容）。</li>
<li><strong>非破坏性读出</strong>某个存储单元所存储的信息被读出时，原存储信息不被破坏，例如：SRAM（双稳态触发器）。</li>
</ul>
<h2 id="多级存储系统">1.2.多级存储系统</h2>
<p><strong>多级存储系统：为了缓解存储系统容量、速度和成本这三者之间的矛盾。在计算机系统中，存储器系统通常会采用多级结构，如下图所示，从上至下</strong>：</p>
<ul>
<li><strong>价格</strong>越来越低。</li>
<li><strong>速度</strong>越来越慢。</li>
<li><strong>容量</strong>越来越大。</li>
<li><strong>CPU 访问的频度</strong>越来越低。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355824.png" /></p>
<p><strong>实际上，存储系统的层次结构主要体现在 “Cache - 主存” 和 “主存
- 辅存” 这两层</strong>：</p>
<ul>
<li><strong>“Cache - 主存”</strong>：主要解决 <strong>CPU
和主存速度</strong>不匹配的问题。</li>
<li><strong>“主存 -
辅存”</strong>：主要解决<strong>存储系统的容量</strong>问题。</li>
</ul>
<p><strong>在多级存储系统中</strong>：</p>
<ul>
<li>Cache、主存可以和 CPU 直接交换信息。</li>
<li>辅存则要通过主存和 CPU 交换信息。</li>
<li>主存与 CPU、Cache、辅存都能交换信息。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355061.png" /></p>
<p><strong>多级存储系统的核心思想是：让上一层的存储器作为下一层存储器的高速缓存</strong>。</p>
<ul>
<li>“<strong>Cache - 主存</strong>” 层速度接近于
Cache，容量和价位却接近于主存。</li>
<li>“<strong>主存 - 辅存</strong>”
层速度接近于主存，容量和价位却接近于辅存。</li>
</ul>
<p><strong>另外注意</strong>：</p>
<ul>
<li>主存和 Cache
之间的数据调动是由<strong>硬件自动完成的</strong>，对所有程序员透明。</li>
<li>主存和辅存之间的数据调动则是<strong>由硬件和操作系统共同完成的</strong>，对应用程序员是透明。</li>
</ul>
<h2 id="存储器性能指标">1.3.存储器性能指标</h2>
<p><strong>存储器有以下三个性能指标（相互制约），通过协调这三个指标，设计者尽可能地设计大容量、低成本和高速度的存储器系统</strong>。</p>
<ul>
<li>存储容量。</li>
<li>单位成本。</li>
<li>存储速度。</li>
</ul>
<h3 id="存储容量">1.3.1.存储容量</h3>
<p><strong>存储容量 = 存储字数 × 字长（如 1M×8 位）。</strong></p>
<ul>
<li>单位换算：<strong>1B(Byte，字节)=8b(bit，位)。</strong></li>
<li>存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。</li>
</ul>
<h3 id="单位成本">1.3.2.单位成本</h3>
<p><strong>每位价格 = 总成本 ÷ 总容量</strong>。</p>
<h3 id="存储速度">1.3.3.存储速度</h3>
<p><strong>数据传输率 = 数据的宽度 ÷ 存储周期</strong>。</p>
<ul>
<li><strong>存取时间（ $T_{a}
$​）</strong>：是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li>
<li><strong>存取周期 ( $ T_{m}
$​)</strong>：<strong>存取周期</strong>又称<strong>读写周期</strong>或<strong>访问周期</strong>。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储操作（读或写操作）之间所需的最小时间间隔。</li>
<li><strong>主存带宽（ $ B_{M} $）</strong>:
主存宽度又称为数据传输率，表示每秒从主存进出信息的最大容量，单位为字 /
秒，字节 / 秒 (B/s) 或位 / 秒(b/s)。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355072.png" /></p>
<h1 id="主存储器">2.主存储器</h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408552.png"
alt="image-20230414140744990" />
<figcaption aria-hidden="true">image-20230414140744990</figcaption>
</figure>
<h2
id="基本的半导体元件及原理"><a name="锚点名称">2.1.基本的半导体元件及原理</a></h2>
<p>在 <a href="">(计算机组成原理) 第一章计算机系统概述 - 计算机硬件组成
(存储器、运算器和控制器概述及计算机工作过程详解)</a>
这篇文章中说到：<strong>一个存储器由存储体、MAR（地址寄存器）和
MDR（数据寄存器） 构成，这三部分会在时序逻辑电路
的控制下相互配合进行工作</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408302.png" /></p>
<p><strong>存储体是用来存放二进制数据的，它由多个存储单元构成，而存储单元又有存储元构成，下图就是一个存储元，由
MOS 管和电容实现</strong>。</p>
<ul>
<li><strong>MOS 管</strong>：可以理解为一种电控开关，输入电压达到 **
某个阈值时，**MOS 管就可以接通。</li>
<li><strong>电容</strong>：当产生电压差时就会充电，可以<strong>保存一定电荷</strong>。<strong>电容带电和不带电分别对应两种状态</strong>，也即二进制中的
0 和 1。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359286.png" /></p>
<p><strong>利用 MOS 管和电容可以进行如下操作</strong>：</p>
<ul>
<li><p><strong>读出二进制</strong>：假如电容有电，此时当 MOS
管接通时，<strong>电荷就可以顺着导线向 MOS
管右侧流动</strong>，当在该侧检测到电流时相当于输出了 1，反之则输出了 0
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408799.png" /></p></li>
<li><p><strong>写入二进制</strong>：在 MOS 管右侧接入电压，然后导通 MOS
管，<strong>这样电流就会从右向左流动</strong>，此时电容一端接地，于是两块板子上有电压差，<strong>电荷就会被
“装载” 进去</strong>，接着再把 MOS 管断开，这样电荷就跑不出去了 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359707.png" /></p></li>
</ul>
<p><strong>上述仅仅是一个存储元，如果把多个存储元按照一定方式连接，那么就能一次性读出或者写入多位数据，比如下图</strong>：</p>
<ul>
<li><p>下图中<strong>红色导线连接了每个存储元的 MOS
管</strong>，因此如果给其加上电压，就意味着所有存储元的 MOS
管都可以被导通。</p></li>
<li><p>当 MOS
管导通后，<strong>电容里存储的电荷就可以顺着绿色的线导出</strong> 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408417.png" /></p></li>
</ul>
<p><strong>于是按照上述方式就可以读出一整行存储元所存储的数据信息，而这一行其实就是存储单元（也即一个存储字），多个存储单元组合便构成了存储体</strong>。</p>
<ul>
<li>为什么存储器每次读写操作的单位是一个存储字：<strong>因为同属于一个存储字的存储元它们的
MOS 管一端接的都是同一根线。</strong></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359359.png" /></p>
<h2 id="存储器芯片的基本原理">2.2.存储器芯片的基本原理</h2>
<ul>
<li>读出和写入的功能有了，那么下一个问题就是<strong>如何决定我们要读或者写的具体是哪一个存储字呢</strong>，这就要涉及到<strong>译码器</strong>的概念了。</li>
</ul>
<p><strong>译码器</strong>：当给出 <span
class="math inline">\(n\)</span> 位地址时，<strong>这 <span
class="math inline">\(n\)</span> 位地址就会对应 $2^{n} $
个存储单元（因为是地址是二进制）</strong>，所以<strong>译码器会根据
MAR</strong>（它和 CPU
连接）里面给出的这几位地址，<strong>将其转化为某一条字选线的高电平信号。</strong></p>
<ul>
<li>例如：MAR 送过来的地址是<code>000</code>，对应十进制的
0，所以译码器会给第 0
根字选线一个高电平，<strong>此时第一个存储字对应的存储元件都会被选通</strong>。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408186.png" /></p>
<p>如下，<strong>当第 0
根字选线被接通后，就可以通过数据线（也叫位线，绿色），把每一位的二进制信息传送到
MDR 当中</strong>，然后 <strong>CPU 会通过数据总线（宽度等于存储字长）从
MDR 当中取走这一存储字的数据。</strong></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631446.png" /></p>
<p><strong>为此，我们需要新增一个控制电路来控制 MAR、MDR
和译码器</strong>：</p>
<ul>
<li><strong>控制 MAR</strong>：当 CPU 通过地址总线把地址送入 MAR
时，由于使用的是电信号，而电信号<strong>容易紊乱</strong>，因此<strong>在
MAR 中电信号稳定之前，该地址不能被送入译码器当中</strong>。</li>
<li><strong>控制 MDR</strong>：和 MAR 相同，稳定时才能输出。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408664.png" /></p>
<p><strong>另外，存储芯片还需要向外提供片选线，用 $ C $ $ S
$（芯片选择信号）或 $ C $ $E
$（芯片使能信号）表示（横线表示低电平有效）</strong>。</p>
<p><strong>当然，控制电路还需要提供读控制线和写控制线</strong>：</p>
<ul>
<li><p>$ W $$ E
$：低电平时，表示正在进行<strong>写操作</strong>，也就是要把 MDR
里保存的数据把它输入到电容中。</p></li>
<li><p>$ O $$ E$：低电平时，进行<strong>读操作。</strong></p></li>
<li><p>下图中读写控制线分为两根，也可以整合为一根， $ W $ $E
$就表示<strong>低电平写，高电平读</strong>。</p></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141403668.png" /></p>
<p><strong>最后屏蔽内部实现细节后，存储器芯片会这样表示</strong> ：</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141403640.png" /></p>
<p><strong>最后再次说明一下片选线的作用</strong>：下图是内存条，一个内存条由很多存储芯片组成（如果是
8G，那么每个存储芯片大概就是
1G），<strong>因此片选线就是为了操作指定的存储芯片</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141407141.png"
alt="image-20230414140709086" />
<figcaption aria-hidden="true">image-20230414140709086</figcaption>
</figure>
<p>同时上面原理图中讲到的每一根线其实就是对应了芯片的<strong>引脚</strong>。</p>
<ul>
<li><p><span class="math inline">\(n\)</span> 位地址就对应了 $2^{n} $
个存储单元，因此总容量 = 存储单元个数 × 存储字长</p></li>
<li><p>有时我们会见到这样的描述，<strong>8×8 位的存储单元</strong>，比如
8K×8 位，就是 $2^{13}×8bit $</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408214.png" /></p></li>
</ul>
<h2 id="寻址">2.3.寻址</h2>
<p>如下矩阵方格中每一个方格表示 8bit
的信息，<strong>每一行表示一个存储字</strong>，为 4B 大小，该矩阵共有
256 行，大小为 1KB</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141405823.png" /></p>
<p>现代计算机通常是<strong>按照字节寻址</strong>的，因此 1
个小方格就对应 1 个地址，这里有 1K 个字节那么就有 1K 个地址。既然有 1K
个地址，那么根据之前叙述，应该就有 10 根地址线（ $2^{10} $）。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408887.png" /></p>
<p>虽然是按照字节编址的，但还可以按照字、半字、双字等方式寻址：</p>
<ul>
<li><strong>按字节寻址</strong>：1K 个单元，每个单元 1B。</li>
<li><strong>按字寻址</strong>：256 个单元，每个单元 4B。</li>
<li><strong>按半字寻址</strong>：512 个单元，每个单元 2B。</li>
<li><strong>按双字寻址</strong>：128 个单元，每个单元 8B。</li>
</ul>
<blockquote>
<ul>
<li><strong>位（bite）</strong>:
音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。</li>
<li><strong>字节（byte）</strong>：一个字节等于8位，即1Byte=8bit。</li>
<li><strong>字</strong>：一串数码作为一个整体来处理运算，被称为一个字，字的位数称为字长，一个字通常有若干个字节，例如286微机的字由2个字节组成，它的字长为16；486微机的字由4个字节组成，它的字长为32位机。
计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。</li>
</ul>
</blockquote>
<h1 id="sram芯片和dram芯片">3.SRAM芯片和DRAM芯片</h1>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141618171.png" /></p>
<p><strong>本节会在上节的基础上，介绍两种重要的存储器芯片：DRAM 和
SRAM</strong>。</p>
<ul>
<li><strong>DRAM(Dynamic-Random- Access -Memory)：动态
DRAM，主要用于主存。</strong></li>
<li><strong>SRAM(Static- Random -Access -Memory)：静态 RAM，主要用于
Cache</strong>。</li>
</ul>
<p><strong>注意</strong>：DRAM 芯片已经过时了，现在主存通常采用
SDRAM（如 DDR3 和 DDR4）。</p>
<h2
id="存储器元件不同导致的特性差异">3.1.存储器元件不同导致的特性差异</h2>
<p>上一节介绍的芯片实则就是 <strong>DRAM
芯片</strong>，主要被用于制作主存。<strong>其实 DRAM 芯片和 SRAM
芯片的核心区别点就在于他们的存储元制作材料不一样。</strong></p>
<ul>
<li><p><strong>DRAM</strong>：使用<strong>栅极电容</strong>。</p></li>
<li><p><strong>SRAM</strong>：使用<strong>双稳态触发器</strong> 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619753.png" /></p></li>
</ul>
<h3 id="栅极电容">3.1.1.栅极电容</h3>
<p><strong>栅极电容：当给字选择线一高电平时，MOS
管会接通，然后给数据线一高电平，由于电容一端接地，因此电容板之间产生电压差，于是电荷被
“写入” 电容</strong>。</p>
<ul>
<li><strong>1</strong>：表示电容内<strong>存储</strong>了电荷。</li>
<li><strong>0</strong>：表示电容内<strong>未存储</strong>电荷。</li>
</ul>
<p><strong>在读出时，如果电容里面有电荷，那么当 MOS
管接通后，一定会在数据线位置检测到电流信号，反之则不会，分别对应数据 1
和数据 0。</strong></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619128.png" /></p>
<h3 id="双稳态触发器">3.1.2.双稳态触发器</h3>
<ul>
<li><strong>关于双稳态触发器具体原理请点击链接跳转</strong>：<a
target="_blank" rel="noopener" href="http://www.360doc.com/content/19/0827/18/2289804_857407763.shtml">双稳态触发器</a>。</li>
</ul>
<p><strong>双稳态触发器：是一种具有记忆功能的逻辑单元电路，它能储存一位二进制码。它有两个稳定的工作状态，在外加信号触发下电路可从一种稳定的工作状态转换到另一种稳定的工作状态</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619373.png" /></p>
<p><strong>相比栅极电容，双稳态触发器有两根数据线。当给字选择线一高电平信号后</strong>：</p>
<ul>
<li><strong>如果里面存储的是 1</strong>，那么将会在 BLX
这条线上输出低电平信号（左边没有）。</li>
<li><strong>如果存储的是 0</strong>，那么将会在 BL
这条线上输出低电平信号（右边没有）。</li>
</ul>
<p><strong>同时在写入时</strong>：</p>
<ul>
<li><strong>如果要写入数据 0</strong>：那么只需要给 BL
一<strong>低电平信号</strong>，同时给 BLX
一<strong>高电平信号</strong>。</li>
<li><strong>如果要写入数据 1</strong>，那么只需要给 BL
一<strong>高电平信号</strong>，同时给 BLX
一<strong>低电平信号。</strong></li>
</ul>
<h3 id="sram-和-dram-对比">3.1.3.SRAM 和 DRAM 对比</h3>
<p><strong>关于读写速度</strong>：</p>
<ul>
<li><strong>DRAM
使用栅极电容的充放电来完成读写操作</strong>：电容的物理特性就决定了其充放电是一种<strong>破坏性读出</strong>，读出后应该<strong>有重写操</strong>作，也就是需要重新充电，也称之为<strong>再生</strong>，读写<strong>速度较慢</strong>。</li>
<li><strong>SRAM
使用双稳态触发器</strong>：在读写数据时，触发器的状态是<strong>保持稳定的</strong>，因此属于<strong>非破坏性读出</strong>，无需进行<strong>重写操作</strong>，读写速度<strong>也就更快。</strong></li>
</ul>
<p><strong>2：关于成本和功耗</strong></p>
<ul>
<li><strong>DRAM</strong>：单个存储元制造成本<strong>低</strong>，集成度<strong>高</strong>，功耗<strong>低。</strong></li>
<li><strong>SRAM</strong>：单个存储元制造成本更<strong>高</strong>，集成度<strong>低</strong>，功耗<strong>大</strong>。</li>
</ul>
<p><strong>3：其它区别</strong></p>
<table>
<thead>
<tr>
<th>
类型 / 特点
</th>
<th>
SRAM（静态 RAM）
</th>
<th>
DRAM（动态 RAM）
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>存储原理</strong>
</td>
<td>
触发器
</td>
<td>
电容
</td>
</tr>
<tr>
<td>
<strong>是否是破坏性读出</strong>
</td>
<td>
否
</td>
<td>
是
</td>
</tr>
<tr>
<td>
<strong>是否需要重写</strong>
</td>
<td>
否
</td>
<td>
是
</td>
</tr>
<tr>
<td>
<strong>运行速度</strong>
</td>
<td>
快
</td>
<td>
慢
</td>
</tr>
<tr>
<td>
<strong>集成度</strong>
</td>
<td>
低
</td>
<td>
高
</td>
</tr>
<tr>
<td>
<strong>发热量</strong>
</td>
<td>
大
</td>
<td>
小
</td>
</tr>
<tr>
<td>
<strong>成本</strong>
</td>
<td>
高
</td>
<td>
低
</td>
</tr>
<tr>
<td>
<strong>是否是易失性存储器</strong>
</td>
<td>
是
</td>
<td>
是
</td>
</tr>
<tr>
<td>
<strong>是否需要 “刷新”</strong>
</td>
<td>
否
</td>
<td>
是
</td>
</tr>
<tr>
<td>
<strong>送行列地址</strong>
</td>
<td>
同时送
</td>
<td>
分两次
</td>
</tr>
<tr>
<td>
<strong>用途</strong>
</td>
<td>
Cache
</td>
<td>
主存
</td>
</tr>
</tbody>
</table>
<ul>
<li>刷新：<strong>电容里面的电荷不能永久存在</strong>，一般只能维持
2ms，因此即使不断电，2ms 后信息也会丢失，因此对于 DRAM 需要
“刷新”，也就是再充电；而 SRAM 只要不断电，触发器的状态就不会改变。</li>
</ul>
<h2 id="dram-的刷新">3.2.DRAM 的刷新</h2>
<h3 id="译码器需要使用行列地址">3.2.1.译码器需要使用行列地址</h3>
<p>上一节说到了译码器的作用：<strong>把某一位的地址，转化为相应的选通线的高电平信号，
<span class="math inline">\(n\)</span>位地址就对应 $2^{n} $
个选通线。</strong></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622269.png" /></p>
<p><strong>当地址数变多时，选通线数量级将会非常大</strong>，例如仅 20
个地址就需要 $ 2^{20}=1 048 576 $ 根选通线，这已接近百万了。</p>
<p><strong>解决方法就是：将原来的单纯的一维的地址，改变为行列地址，也就是一个矩阵，分别交给行地址译码器和列地址译码器管理，这样的话每个译码器只需处理一半的地址信息，也就是
1024 根选通线</strong> 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622248.png" /></p>
<p>例如地址<code>0000</code>
<code>0000</code>，如果采用之前的方案，那么经过译码器译码后，第 0
根选通线会被选中 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622141.png" /></p>
<p>而如果采用行列译码器的方案，<strong>地址<code>0000</code>
<code>0000</code>的低四位将会交给列地址译码器，高四位将会交给行地址译码，每个存储单元只有列选通线和行选通线同时被选中时才能被选中</strong>，因此<code>(1,1)</code>位置的存储单元此时会被选中。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622038.png" /></p>
<p><strong>对于八位地址，原本需要使用 $2^{8}=256 $
根选通线，而现在只需要<span
class="math inline">\(2^{4}+2^{4}=16+16=32\)</span>根选通线，所以使用行列地址的本质就是要减少选通线数量</strong>。</p>
<h3
id="分散刷新集中刷新和异步刷新">3.2.2.分散刷新、集中刷新和异步刷新</h3>
<h4 id="dram-刷新">3.2.2.1.DRAM 刷新</h4>
<p><strong>关于 DRAM 的刷新，这里有 4 个问题需要回答</strong>：</p>
<ul>
<li><strong>多久刷新一次</strong>：一般为 2ms。</li>
<li><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元。</li>
<li><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用
1 个读写周期。</li>
<li><strong>什么时候刷新</strong>：分散刷新、集中刷新和异步刷新（接下来介绍）。</li>
</ul>
<h4
id="分散刷新集中刷新和异步刷新特点">3.2.2.2.分散刷新、集中刷新和异步刷新特点</h4>
<p>假设 DRAM 内部结构排列形式为 128×128，存储周期为 0.5 $us
$，电容最多坚持 2ms，因此对应 2ms/0.5 $us $=4000 个周期，有 128
行，刷新每一行都需要 0.5 $us $，同时注意以下内容：</p>
<ul>
<li>刷新对 CPU
是透明的，也即<strong>刷新不依赖于外部的访问</strong>。</li>
<li>DRAM
刷新单位是行，因此<strong>刷新操作时仅需要行地址。</strong></li>
<li>刷新操作类似于读操作，但又有所不同：<strong>刷新操作仅给栅极电容补充电荷，不需要信息输出，另外刷新时不需要进行选片，即整个存储器中的所有芯片同时被刷新。</strong></li>
</ul>
<p>一共有<strong>分散刷新、集中刷新和异步刷新</strong>这三种方式：</p>
<ul>
<li><p><strong>分散刷新</strong>：把对每行的刷新分散到各个工作周期当中，这样，一个存储器的系统工作周期就分为了两个部分，<strong>前半部分用于正常读写或保持；后半部分用于刷新某一行</strong>。这种刷新方式增加了系统的存取周期，增加为
1 $us $。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622334.png" /></p></li>
<li><p><strong>集中刷新</strong>：<strong>是指利用一段固定的时间，依次对存储器的所有行进行逐一再生，存储周期不变</strong>，在刷新期间内会停止对存储器的访问，因此称之为
“死时间”，又称访存 “死区” 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141623410.png" /></p></li>
<li><p><strong>异步刷新</strong>：它是前两种刷新方式的结合。<strong>具体做法是用刷新周期除以行数，得到两次刷新操作之间的时间间隔
t（2ms/128=15.6 $us $）</strong>，接着利用逻辑电路每隔该时间间隔 t(15.6
$us $) 产生一次刷新请求，因此每 15.6 $us $ 内会有 0.5 $us $
的死时间。所以死时间会分散在整个过程中，而且可以在译码阶段刷新 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632079.png" /></p></li>
</ul>
<h4
id="分散刷新集中刷新和异步刷新优缺点">3.2.2.3.分散刷新、集中刷新和异步刷新优缺点</h4>
<p><strong>集中刷新</strong>：</p>
<ul>
<li><strong>优点</strong>：读写操作不受刷新工作的影响，因此系统的<strong>存取速度较高</strong>。</li>
<li><strong>缺点</strong>：是在集中刷新期间（死区）不能访问存储器。</li>
</ul>
<p><strong>分散刷新</strong>：</p>
<ul>
<li><strong>优点</strong>：是<strong>没有死区。</strong></li>
<li><strong>缺点</strong>：是加长了系统的存取周期<strong>降低了整体速度。</strong></li>
</ul>
<p><strong>异步刷新</strong>：综合最优。</p>
<ul>
<li>可以避免使 CPU
连续等待过长的时间，而且减少了刷新次数，从根本上<strong>提高了整机的工作效率</strong>；</li>
<li>同时如果将刷新安排在不需要访问存储器的译码阶段，则<strong>既不会加长存取周期，又不会产生
“死时间”</strong>，这是分散刷新的方式的发展，也称之为
“<strong>透明刷新</strong>”。</li>
</ul>
<h2 id="dram-的地址线复用技术">3.3.DRAM 的地址线复用技术</h2>
<ul>
<li>前面说过 SRAM
需要同时送行列地址，也即<strong>行列地址信息会同时丢给行译码器和列译码器。</strong></li>
</ul>
<p>而 DRAM
由于用于主存，所以容量可能较大，因此地址线可能也会更多，<strong>所以为了使地址线电路变得更简单，会采用一种地址线的复用技术，也就是分两次送。</strong></p>
<p><strong>这种技术可以使行列地址分两次前后进行传送，传送时只需要一半地址，先传送至缓冲区，再传送给译码器即可，这样会使地址线更少</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703887.png" /></p>
<h1 id="只读存储器">4.只读存储器</h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141625901.png"
alt="image-20230414162516788" />
<figcaption aria-hidden="true">image-20230414162516788</figcaption>
</figure>
<h2 id="只读存储器rom特点">4.1.只读存储器（ROM）特点</h2>
<p><strong>只读存储器（ROM）：前文说到的 SRAM 和 DRAM 都属于 RAM
芯片，RAM
芯片属于数据易失性芯片，断电后数据将会消失。但很多情况下需要对数据进行长期保存，所以就要使用到
ROM 芯片。它有两个显著的特点</strong>：</p>
<ul>
<li>结构简单，所以位密度比可读存储器的高。</li>
<li>具有非易失性，可靠性高。</li>
</ul>
<h2 id="rom-的类型">4.2.ROM 的类型</h2>
<ul>
<li><strong>掩模式只读存储器（MROM）</strong>：MROM
的内容由<strong>半导体制造厂家按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人无法改变其内容</strong>。优点是<strong>可靠性高、集成度高、价格便宜</strong>；缺点则是灵活性差。</li>
<li><strong>一次可编程只读存储器（PROM）</strong>：PROM
是可以实现一次性编程的只读存储器，允许用户<strong>利用专门的设备写入自己的程序</strong>，一旦写入，内容无法改变。</li>
<li><strong>可擦除可编程只读存储器（EPROM）</strong>：EPROM
<strong>可以让用户利用编程器写入信息，而且内容也可以进行多次改写</strong>。如果需要修改
EPROM 内容，则先将其全部内容擦除，然后再编程。EPROM
又可以分为<strong>紫外线擦除（UVEPROM）</strong>和电擦除<strong>（<span
class="math inline">\(E ^{2} PROM\)</span>）</strong>。EPROM
虽然既可以读又可以写，但是它不能取代 RAM，因为 EPROM
的编程次数有限，且写入时间过长。</li>
<li><strong>闪存存储器（Flash Memory）</strong>：Flash Memory 是在 EPROM
与 <span class="math inline">\(E ^{2} PROM\)</span>
的基础上发展起来的，其主要特点是<strong>即可以在不加电的情况下长期保存信息，又能在线进行快速擦除和重写</strong>。需要注意的是<strong>闪存需要先擦除再写入，因此闪存的写速度要比读速度更慢</strong>。</li>
<li><strong>固态硬盘（SSD）</strong>：基于闪存，<strong>由控制单元和存储单元组成</strong>。保留了闪存长期保存信息，快速擦除与重写的特性。对比传统的硬盘也具有读写速度快，功耗低，其缺点就是价格高。</li>
</ul>
<h2 id="计算机内的重要-bios">4.3.计算机内的重要 BIOS</h2>
<p><strong>BIOS：是计算机主板一个非常重要的 ROM 芯片，它存储了
“自举装入程序”，负责引导装入操作系统，进行开机操作。</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141633488.png"
alt="如何在BIOS中设置USB第一启动项_AwardBIOS" />
<figcaption
aria-hidden="true">如何在BIOS中设置USB第一启动项_AwardBIOS</figcaption>
</figure>
<h1 id="主存储器和cpu的连接">5.主存储器和CPU的连接</h1>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141634276.png" /></p>
<p><strong>现代计算机中，MAR 和 MDR 通常集成在 CPU
的内部，而存储芯片内的仅是一个普通的寄存器。主存储器与 CPU
的连接示意图如下</strong>：</p>
<ul>
<li>主存储器通过<strong>数据总线、地址总线和控制总线</strong>与 CPU
连接。</li>
<li>数据总线的位数与工作频率的乘积正比于<strong>数据传输率。</strong></li>
<li><strong>地址总线的位数</strong>决定了可寻址的最大内存空间。</li>
<li><strong>控制总线</strong>（读或写）指出总线周期的类型和本次输入输出操作完成的时刻。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703006.png" /></p>
<h2 id="单块存储芯片与-cpu-的连接">5.1.单块存储芯片与 CPU 的连接</h2>
<p>下图是前文中讲到过的一<strong>单个存储芯片的内部构造</strong>（<a href="#锚点名称">2.1.基本的半导体元件及原理</a>），它和
CPU 通过以下总线连接（<strong>具体过程会在 “二：多块存储芯片与 CPU
的连接 -（1）位扩展 -①：单个连接” 中进行描述</strong>）。</p>
<ul>
<li><strong>数据总线（绿色线）</strong>：用于传送数据。</li>
<li><strong>地址总线（红色线）</strong>：用于传送地址。</li>
<li><strong>控制总线（橙色线）</strong>：用于发出控制信号。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703643.png" /></p>
<h2 id="多块存储芯片与-cpu-的连接">5.2.多块存储芯片与 CPU 的连接</h2>
<p><strong>上图展示的只是一个 8×8 位的存储芯片，仅能存储 8B
的数据，所以会存在以下问题</strong>：</p>
<ul>
<li>问题一：存储字长为 8 位，也即 CPU 一次只能读或写 8
位，而现代计算机数据总线宽度至少是 64
位，严重不匹配。因此问题在于如何<strong>增加存储字长，使 CPU
一次能读或写多位数据</strong> （对应<strong>位扩展</strong>）。</li>
<li>问题二：只有 8
个地址，地址数目太少。因此问题在于如何<strong>扩展地址空间，使地址数目变多</strong>（对应<strong>字扩展</strong>）。</li>
</ul>
<p><strong>这里，为了后续描述方便，为一块存储芯片的输入输出信号进行命名</strong>：</p>
<ul>
<li><strong>地址线</strong>：有可能输入多位的地址，因此地址用$A_{n}
$表示， <span class="math inline">\(n\)</span>从 0
开始，表示从地址低位到地址高位</li>
<li><strong>数据线</strong>：用 $ D_{n} $表示， <span
class="math inline">\(n\)</span>从 0
开始，表示从数据低位到数据高位。</li>
<li><strong>片选线</strong>：片选信号通常用 $CS $ 或 $ CE $
表示，其中的横线表示低电平有效，高电平无效。</li>
<li><strong>读写控制线</strong>：该信号用 $WE $ 或 $ WR $
表示，其中的横线表示低电平写，高电平读。（注意有些地方也可能将读写分开，分别为
$OE $ 或 $ WE $，低电平表示有效，高电平无效）。</li>
</ul>
<h3 id="位扩展">5.2.1.位扩展</h3>
<h4 id="单个连接"><a name="5.2.1.1.单个连接">5.2.1.1.单个连接</a></h4>
<p>下图是买来的一块 8K×1 位的存储芯片。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703104.png" /></p>
<p>该存储芯片有 8K 个存储单元，由于 $ 2^{13}=8192 $，这意味着至少需要
<strong>13
根地址线</strong>才能表示这么多地址，<strong>因此该存储芯片要向外暴露出
13 个地址引脚</strong>，然后 CPU
会把它想要访问的地址通过<strong>地址总线</strong>送过来。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703711.png" /></p>
<p>左下角的 “ $W E $” 表示<code>Write
Enable</code>，上方没有横线，那么就表示<strong>低电平读、高电平写</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703778.png" /></p>
<p>上图显示 CPU 一次是可以读写 8
位数据的，<strong>但是由于存储芯片字长的限制，所以一次最多只能进行一位</strong>，这导致数据总线没有被充分利用。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703722.png" /></p>
<p>还有一个片选线 <span class="math inline">\(C S\)</span>
，表示高电平有效，这里暂时先给一个高电平，具体作用后面会说。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703968.png" /></p>
<p>至此，单个芯片的连接已经完成了。<strong>但是由于存储字长为
1，一次只能读写一位数据，所以数据总线利用率很差</strong>，因此在这种情况下可以进行<strong>位扩展</strong>。</p>
<h4 id="多个连接">5.2.1.2.多个连接</h4>
<p>接着又买到了一个和上面相同规格的存储芯片。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703307.png" /></p>
<p>对于地址线，<strong>我们从刚才连接的每一个地址线分别分流出一根线连接到该存储芯片的引脚上，这意味着一个地址可以同时选中两个存储单元。</strong></p>
<p>对于读写控制线也是这样连接，这意味着它们是<strong>同时读或者同时写</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703345.png" /></p>
<p>对于数据线，<strong>该存储芯片的引脚可以连接在 CPU 的$D_{1}
$位置</strong>。</p>
<p>最后，也给片选$CS $ 线给一高电平。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703536.png" /></p>
<p>至此，两块芯片连接完成。现在，<strong>从整体上看存储字长被扩展为了 2
位，也即可以同时读或写两位的信息了</strong>。</p>
<p>最后，再买来 6 块芯片，连接好即可。</p>
<ul>
<li><p>每块芯片都有 8 个存储单元，CPU 发出的 <span
class="math inline">\(A_{0}\)</span>$A_{12} $的这 13
位的地址信息会同时送给 8 片存储芯片 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703902.png" /></p></li>
</ul>
<h3 id="字扩展">5.2.2.字扩展</h3>
<h4 id="线选法">5.2.2.1.线选法</h4>
<p>如下是买来的一块 8K×8 位的存储芯片 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703763.png" /></p>
<p>单个芯片的连接过程同
“<a href="#5.2.1.1.单个连接">5.2.1.1.单个连接</a>”，可自行研究。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703177.png" /></p>
<p>这个芯片明显不需要进行位扩展。但其问题在于：<strong>此 CPU
的寻址能力很大，可以达到$ 2^{16} $，但却只利用了其中一部分，有 3
位没有被利用，所以在这情况下就要采用字扩展的方式来解决问题。</strong></p>
<p>再买来一块相同规格的存储芯片，先采用之前的位扩展的规则进行连接，如下图：</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703432.png" /></p>
<p>可以发现采用这种方式连接将会产生很大的问题：<strong>两块芯片会被同时选中，比如读数据时，两块存储芯片的
8 位数据会同时传给 CPU，因此存在数据冲突</strong>。</p>
<p><strong>解决方法就在于片选信号$CS $。现在，将 $ A_{13}<span
class="math inline">\(​连接到左边存储芯片的片选信号\)</span>CS $ 上，将 $
A_{14}<span
class="math inline">\(连接到右边存储芯片的片选信号\)</span>CS $
上。由于是高电平有效，因此当地址位为 1
时表示该存储芯片工作。</strong></p>
<p><strong>$ A_{13}$​和 $
A_{14}$只有两位，故取值只会有四种情况：01、10、11、00</strong>。</p>
<ul>
<li><p><strong>如果是 01（注意 $ A_{14}$是 0 $ A_{13}$​是 1， $
A_{14}$是地址高位）</strong>：此时左边芯片工作，右边片不工作。因此现在
<strong>CPU 提供的这 13 位的地址只会读取左边存储芯片对应的 8
位的数据</strong> 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703773.png" /></p></li>
<li><p><strong>如果是
10</strong>：此时右边芯片工作，左边芯片不工作；因此现在 <strong>CPU
提供的这 13 位的地址只会读取右边存储芯片对应的 8 位的数据</strong>
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703922.png" /></p></li>
<li><p><strong>如果是 11 或
00</strong>：这种情况又会出现刚才的矛盾，因此<strong>不能出现</strong>
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703111.png" /></p></li>
</ul>
<p><strong>这样操作后，芯片所表示的地址范围会发生改变</strong>：</p>
<ul>
<li><strong>左边芯片</strong>：010 0000 0000 0000~011 1111 1111
1111。</li>
<li><strong>右边芯片</strong>：100 0000 0000 0000~101 1111 1111
1111。</li>
</ul>
<p><strong>这种连接方法称之为 “线选法”，其缺点在于以 00 和 11
开头的地址是不能用的。</strong></p>
<ul>
<li>注意：不是仅有两个地址，是以 00 和 11
开头的所有地址均不可用，其数量是相当多的。</li>
</ul>
<h4 id="译码片选法">5.2.2.2.译码片选法</h4>
<ul>
<li><strong>译码片选法会在线选法的基础上做一定改进，只需要加入一个非门。</strong></li>
</ul>
<p><strong>以 $ A_{13}<span
class="math inline">\(​为例，让它分别连接左边芯片和右边芯片的片选信号\)</span>CS
$ 上，但是在第二个线路中加入一个非门，这样当 $ A_{13}$​为 1
时，左边会被选中，右边由于非门的取反作用会变为不工作</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703041.png" /></p>
<p>这样的话，<strong>左边芯片的地址范围就为：10 0000 0000 0000~11 1111
1111 1111；右边的则为：00 0000 0000 0000 ~01 1111 1111
1111，整个主存地址空间是连续的。</strong></p>
<p>上面用到的非门叫做 “<strong>1-2
译码器</strong>”，这种方法叫做<strong>译码片选法</strong>，<strong>如果
CPU 有 n 条多余的片选线，那么他可以对应 $2^{n} $
个片选信号。</strong></p>
<ul>
<li>译码器编号：1-2 译码器是输入 1 个对应 2 个，2-4 译码器是输入两个对应
4 个，以此类推。</li>
</ul>
<p>讲完上面的操作，现在可以使用真正使用字扩展了。<strong>这里采用一个
2,4 译码器，也就是输入两个信号，输出 4 个信号，接着加入 4 个 8×8
位的存储芯片，每块存储芯片都会接受 CPU 发过来的低 13
位的地址信息</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703842.png" /></p>
<ul>
<li>注意上方图片中，每个存储芯片所有的地址信息都是直接来自于 CPU
的，不是从左边相邻的芯片传递过来的，这里是这样画只是为了整洁。</li>
<li>在电路图中，当需要表示低电平有效时，通常会在上面画一个 “小圆”。</li>
</ul>
<p>当 $ A_{13}$​， $ A_{14}$为均为 0 时，就表示第一根线为 1，剩余为
0，但是经过译码器后，由于是取反，所以第一根为 0，其余为 1，而正好 0
表示存储芯片工作，所以这种情况第一个存储芯片工作，其余不工作 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703002.png" /></p>
<p>类似的，当 $ A_{13}$​为 1， $ A_{14}$为 0 时，就表示第二根线为
1，剩余为 0，但是经过译码器后，由于是取反，所以第二根为 0，其余为
1，而正好 0
表示存储芯片工作，所以这种情况就表示第二个存储芯片工作，其余不工作
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703889.png" /></p>
<p>因此：</p>
<p><strong>要访问第一块存储芯片，就要保证 $ A_{13}$​为 0， $ A_{14}$为
0，此时地址范围为：<code>000 0000 0000 0000 到 001 1111 1111
1111</code><br />
要访问第二块存储芯片，就要保证 $ A_{13}$​为 1， $ A_{14}$为
0，此时地址范围为：<code>010 0000 0000 0000 到 011 1111 1111
1111</code><br />
要访问第三块存储芯片，就要保证 $ A_{13}$​为 0， $ A_{14}$为
1，此时地址范围为：<code>100 0000 0000 0000 到 101 1111 1111
1111</code><br />
要访问第四块存储芯片，就要保证 $ A_{13}$​为 1， $ A_{14}$为
1，此时地址范围为：<code>110 0000 0000 0000 到 111 1111 1111
1111</code></strong></p>
<p><strong>所以这样的操作就能保证主存地址范围从全 0 到全
1，而且是连续的</strong>。</p>
<p>另外还需要注意的是，考试时可能不会是连续的 $ A_{13}$​和 $
A_{14}$，有可能是 $ A_{13}$​和 $
A_{15}$，<strong>但是无论怎么样，只要不选中，就不影响选片操作，是 0 是 1
不用管，只看选中的那几位</strong> 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703422.png" /></p>
<p>最后，这里的 $ A_{15}$没有被启用，如果要使用的话那么就需要一个 3-8
译码器，然后再增加 4 个相同规格的存储芯片即可。</p>
<h4 id="字位同时扩展">5.2.2.3.字位同时扩展</h4>
<p>位扩展可以使得存储芯片的字长变得更长，从而更好的发挥<strong>数据总线的传输能力</strong>；字扩展可以增加存储器的存储字数，从而更好利用
<strong>CPU
的寻址能力</strong>。既然二者都有的优点，那么就可以将它们综合起来，这种方法就是<strong>字位同时扩展。</strong></p>
<p>如下图有 8 块芯片，共有 4 组，每组两块，每组芯片实现了位扩展。</p>
<ul>
<li>前面的可以连接 $D_{0}-D_{3} <span class="math inline">\(​,
后面的可以连接前面的可以连接\)</span>D_{4}-D_{7}$。</li>
</ul>
<p>这是一个 16K 的存储芯片，因此将 $A_{0}-A_{13} $作为片内地址， $
A_{14}-A_{15} $介入 2,4 译码器（因为有 4 组）。<strong>一个芯片是 16K×4
位，一组就是 16K×8 位，整体就是 64×8 位。</strong></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703507.png" /></p>
<h2 id="译码器补充知识点">5.3.译码器(补充知识点)</h2>
<p>1：需要注意的是片选信号和译码器要配合使用，一定要注意是高电平有效还是低电平有效
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702454.png" /></p>
<p>2：译码器往往还有一个 (还有可能是多个) 和$CS $
类似功能的控制端，叫做使能端，即$EN $。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702965.png" /></p>
<ul>
<li>下面两个必须是低电平，上面必须是高电平才能工作。如果是其他非法状态，译码器右侧输出将会是全
1。</li>
</ul>
<p>3：在实际场景中，CPU 上还会有一个 MREQ（访问存储器的控制信号），CPU
会通过它来控制访问存储器。如下，只有当 MREQ
发出高电平时，经过非门，变为低电平后，译码器使能端变为低电平，此时译码器工作，地址才会被映射。</p>
<ul>
<li>之所以 CPU
需要控制，是因为这些地址信息都是电信号，开始时电信号是不稳定的，因此需要等稳定后才能
“打开” 译码器。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702120.png" /></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702333.png" /></p>
<p>4：注意 74ls138</p>
<h1 id="双端口ram和多模块存储器">6.双端口RAM和多模块存储器</h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141716857.png"
alt="image-20230414171604726" />
<figcaption aria-hidden="true">image-20230414171604726</figcaption>
</figure>
<p>之前在<a href="">存储器分类、多级存储系统和存储器性能指标</a>
这篇文章中讲到了存取周期的概念：：<strong>存取周期又称读写周期或访问周期，它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储操作（读或写操作）之间所需的最小时间间隔</strong>。对于
DRAM芯片，它的恢复时间是比较长的，有时有可能会到达存取周期的几倍，而现代计算机
CPU 通常都是多核的，<strong>那么这么多 CPU
核心究竟应该怎样访问主存才能解决恢复时间过长带来的问题呢</strong>？主要有两种思路：</p>
<ul>
<li>双端口 RAM。</li>
<li>多模块存储器。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702109.png" /></p>
<p><strong>双端口
RAM：是指同一个存储器有左右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。该项技术可以优化多核
CPU 访问一根内存条的速度</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702087.png" /></p>
<p><strong>两个端口对同一主存操作时无外乎有以下四种情况</strong>：</p>
<ul>
<li><strong>两个端口不同时对同一地址单元读出数据</strong>：没有错误。</li>
<li><strong>两个端口同时对同一地址单元读出数据</strong>：没有错误。</li>
<li><strong>两个端口同时对同一地址单元写入数据</strong>：发生写入错误。</li>
<li><strong>两个端口同时对同一地址单元操作，一个写入，一个读出</strong>：发生读出错误。</li>
</ul>
<p>其解决方法为：<strong>置 “忙” 信号 $ BUSY $为
0</strong>，由判断逻辑决定暂时关闭一个端口（延时）。<strong>未被关闭的端口正常访问，被关闭的延长一个很短的时间段后再访问。</strong></p>
<p><strong>多模块存储器：多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。有两种编址方式</strong>：</p>
<ul>
<li><strong>高位交叉编址</strong>。</li>
<li><strong>低位交叉编址。</strong></li>
</ul>
<h2 id="高位交叉编址">6.1.高位交叉编址</h2>
<p><strong>高位交叉编址：高位地址表示体号，低位地址为体内地址。在这种编址方式下，总是把低的体内地址送到由高位体号所确定的模块内进行译码。访问一个连续的主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU
总是按顺序访问存储模块，存储模块不能并行访问，因此不能提高存储器的吞吐率。</strong></p>
<p>如下图，存储器共有 4 个模块 $ M_{0}-M_{3} $（可以将其理解为 “4
根内存条”），按照这种方式编址后，<strong>地址前两位（高位）表示的是某根内存条，后面部分（低位）表示的是该内存条中的具体地址</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702942.png" /></p>
<p>假设每个存储体的存取周期为 <span
class="math inline">\(T\)</span>，存取时间为 <span
class="math inline">\(r\)</span>，且
T=4r。如果多体存储器采用高位交叉编址，那么 CPU
真正花在读数据上的时间只有 <span
class="math inline">\(r\)</span>，但却要再花费 3r
的时间用来等待，效率不高。<strong>也就是说连续读取 <span
class="math inline">\(n\)</span>个存储字，就要耗时 $ nT $</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702048.png"
alt="image-20230414170230959" />
<figcaption aria-hidden="true">image-20230414170230959</figcaption>
</figure>
<h2 id="低位交叉编址">6.2.低位交叉编址</h2>
<p><strong>低位交叉编址：低位地址表示体号，高位地址为体内地址。在这种编址方式下，总是把高位的体内地址送到由低位体号所确定的模块内进行译码。程序连续存放在相邻的模块中，将采用此编址方式的存储器称为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器带宽</strong>。</p>
<p>如下图，存储器共有 4 个模块$ M_{0}-M_{3}$（可以将其理解为 “4
根内存条”），<strong>每个模块的模块号 = 单元地址 %4</strong> 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632277.png" /></p>
<p><strong>采用低位交叉编址的存储器连续读取 <span
class="math inline">\(n\)</span>个存储字，耗时为 $ T+(n-1)r
$</strong>。CPU 每经过时间 <span class="math inline">\(r\)</span>
后会启动下一模块，**因此交叉存储器要求其模块数必须大于等于 $ <span
class="math inline">\(**，以保证某模块后经过\)</span> T $
时间后再次启动该模块时，其上次的存取周期已到（也就是已经恢复） 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632248.png" /></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632896.png" /></p>
<h1
id="磁盘存储器磁盘的基本结构磁盘阵列">7.磁盘存储器（磁盘的基本结构，磁盘阵列）</h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141717032.png"
alt="image-20230414171734928" />
<figcaption aria-hidden="true">image-20230414171734928</figcaption>
</figure>
<h2 id="磁盘存储器">7.1.磁盘存储器</h2>
<p><strong>计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。所谓
“磁表面存储”，是把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。</strong></p>
<p><strong>磁表面存储器有以下优点</strong>：</p>
<ul>
<li>存储容量大，价位低。</li>
<li>记录介质可以重复使用。</li>
<li>记录信息可以长期保存而不丢失，甚至可以脱机存档。</li>
<li>非破坏读出，读出时不需要再生。</li>
</ul>
<p><strong>磁表面存储器有以下缺点</strong>：</p>
<ul>
<li>存取速度慢。</li>
<li>机械结构复杂。</li>
<li>对环境要求较高。</li>
</ul>
<h3 id="磁盘设备组成">7.1.1.磁盘设备组成</h3>
<h4 id="存储区域">7.1.1.1.存储区域</h4>
<p><strong>存储区域：一块硬盘含有若干记录面，每个记录面划分为若干条磁道，每条磁道又划分为若干扇区，扇区（也称之为块）是磁盘读写的最小单位，也就是磁盘是按块存取。</strong></p>
<ul>
<li><p><strong>磁头数：也即记录面数，表示硬盘总共有多个磁头，磁头分为读磁头和写磁头，每个磁头对应一个记录面。</strong></p></li>
<li><p><strong>柱面数：表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面</strong>。</p></li>
<li><p><strong>扇区数：表示每一条磁道上有多少个扇区。</strong></p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141709066.png"
alt="22cc501b8cef4462a2a98f52726b64d7" />
<figcaption
aria-hidden="true">22cc501b8cef4462a2a98f52726b64d7</figcaption>
</figure>
<h4 id="硬盘存储器的构成">7.1.1.2.硬盘存储器的构成</h4>
<p><strong>硬盘存储器的构成：由磁盘驱动器，磁盘控制器和盘片组成。</strong></p>
<ul>
<li><p><strong>磁盘驱动器：核心部件是磁头组件和硬件组件，温彻斯特是一种可移动磁头固定盘片的硬盘存储器</strong>
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141710265.png" /></p></li>
<li><p><strong>磁盘控制器：硬盘存储器和主机的接口，主流的标准有
IDE,SCSI,SATA 等</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141711584.png"
alt="1" />
<figcaption aria-hidden="true">1</figcaption>
</figure></li>
</ul>
<h3 id="磁盘性能指标">7.1.2.磁盘性能指标</h3>
<p><strong>①：磁盘容量：一个磁盘所能存储的字节总数。磁盘容量有格式化容量和非格式化容量之分</strong>。</p>
<ul>
<li><strong>非格式化容量</strong>：磁记录表面可以利用的磁化单元总数。</li>
<li><strong>格式化容量</strong>：是指按照某种特定的记录格式所能存储信息的总量。</li>
</ul>
<p><strong>②：记录密度：是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。</strong></p>
<ul>
<li><p><strong>道密度</strong>：沿磁盘半径方向单位长度上的磁道数。</p></li>
<li><p><strong>位密度</strong>：是磁道单位长度上所能记录的二进制代码的位数。</p></li>
<li><p><strong>面密度</strong>：是道密度和位密度的乘积 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141712979.png"
alt="1" />
<figcaption aria-hidden="true">1</figcaption>
</figure></li>
</ul>
<p><strong>磁盘所有磁道记录的信息量一定是相等的，并不是说圆越大记录的信息就越多，因此越靠近里面的磁道位密度就越大。</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141716338.png"
alt="image-20230414171641252" />
<figcaption aria-hidden="true">image-20230414171641252</figcaption>
</figure>
<h3 id="平均存取时间">7.1.3.平均存取时间</h3>
<p><strong>平均存取时间：一次磁盘读写花费的时间由以下三种时间决定</strong>：</p>
<p><strong>①：寻道时间 $ T_{S} $：在读 /
写数据前，将磁头移动到指定磁道所花费时间</strong>。</p>
<ul>
<li><strong>启动磁头臂花费时间</strong>：$ s $（约为 2ms）。</li>
<li><strong>移动磁头花费时间：</strong>
假设磁头匀速移动，每跨越一个磁道耗时为 $ m$（约为 0.2ms），总共需要跨越
<span class="math inline">\(n\)</span>条磁道。</li>
<li><strong>总花费时间： $ T_{S} $​= $ s$+ $ m$× $ n$。</strong></li>
</ul>
<p><strong>②：延迟时间 T R T_{R}
TR​：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</strong></p>
<ul>
<li><strong>磁盘转速为</strong> <span
class="math inline">\(r\)</span>(单位为 “转 / 秒” 或“转 /
分”，典型转速为 5400r/min 或 7200r/min)。</li>
<li><strong>转一圈所需要时间</strong>： $ $。</li>
<li><strong>目标扇区平均需要转半圈</strong>： $ $。​</li>
<li><strong>总花费时间： $ T_{R} $= $ $​× $ $​= $r $</strong>。</li>
</ul>
<p><strong>③：传输时间 $T_{t}
$：从磁盘读出或向磁盘写入数据所经历的时间</strong>。</p>
<ul>
<li><strong>每个磁道可以存储 <span
class="math inline">\(n\)</span>字节的数据，因此对于$ b
$字节的数据需要的磁道数为</strong>： $ $。</li>
<li><strong>读写一个磁道所需要的时间刚好又是转一圈所需要的时间</strong>：
$ $。</li>
<li><strong>总花费时间：$ T_{t} $= $ $× $ $= $ $。</strong></li>
</ul>
<p><strong>因此：总的平均存储时间 $T_{a} $= 寻道时间 + 延迟时间 +
传输时间 = $ T_{s} $​+ $ $+ $ $​</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141714919.png"
alt="0" />
<figcaption aria-hidden="true">0</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632827.png" /></p>
<ul>
<li>寻道时间为 6ms。</li>
<li>10000r/min，所以 166r/s，因此转一圈大约 6ms，所以半圈
3ms，所以延迟时间为 3ms。</li>
<li>传输时间为 4(KB)/20(MB)=0.2ms。</li>
<li>其他时间为 0.2ms。</li>
<li>所以平均时间为 9.4ms。</li>
</ul>
<h3 id="磁盘地址">7.1.4.磁盘地址</h3>
<p><strong>主机会向磁盘发送地址信息，格式如下</strong>：</p>
<table>
<thead>
<tr>
<th>
驱动器号
</th>
<th>
柱面（磁道）号
</th>
<th>
盘面号
</th>
<th>
扇区号
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
确定是哪一个硬盘
</td>
<td>
用于移动寻道
</td>
<td>
激活某个磁头
</td>
<td>
旋转扇区划过磁头
</td>
</tr>
</tbody>
</table>
<p>如果系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256
个磁道，16 个盘面，每个盘面划分为 16 个扇区，则每个扇区地址要 18
位二进制代码，分布如下：</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632236.png" /></p>
<h3 id="磁盘工作过程">7.1.5.磁盘工作过程</h3>
<p><strong>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151633673.gif" /></p>
<p>需要注意的是硬盘属于机械式部件，其读写操作是并行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。所以是需要串
- 并变换电路的 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630537.png"
alt="image-20230415163009440" />
<figcaption aria-hidden="true">image-20230415163009440</figcaption>
</figure>
<h2 id="磁盘阵列">7.2.磁盘阵列</h2>
<p><strong>磁盘阵列：RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储，并行访问，具有更好的存储性能，可靠性和安全性</strong>。</p>
<p><strong>RAID 的分级如下。在 RAID1~RAID5
几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。</strong></p>
<ul>
<li><p><strong>RAID0</strong>：无冗余和无校验的磁盘阵列（逻辑上相邻的两个扇区在物理上存到两个磁盘）。</p></li>
<li><p><strong>RAID1</strong>：镜像磁盘阵列（直接存两份数据）。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630116.png"
alt="image-20230415163024022" />
<figcaption aria-hidden="true">image-20230415163024022</figcaption>
</figure></li>
<li><p><strong>RAID2</strong>：逻辑上连续的几个 bit
物理上分散存储在各个盘中，4bit 信息为 + 3bit 海明校验位，可纠正一位错误
。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630970.png"
alt="image-20230415163045848" />
<figcaption aria-hidden="true">image-20230415163045848</figcaption>
</figure></li>
<li><p><strong>RAID3</strong>：位交叉奇偶校验码的磁盘阵列。</p></li>
<li><p><strong>RAID4</strong>：块交叉奇偶校验的磁盘阵列。</p></li>
<li><p><strong>RAID5</strong>：无独立校验的奇偶校验磁盘阵列。</p></li>
</ul>
<p><strong>总之，RAID
通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量了通过镜像功能，提高安全可靠性；通过数据校验，提高容错能力</strong>。</p>
<h2 id="光存储器">7.3.光存储器</h2>
<p><strong>光盘存储器是利用光学原理读 /
写信息的存储装置，它采用聚集激光束对盘式介质以非接触的方式记录信息</strong>
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631878.png" /></p>
<h1 id="固态硬盘">8.固态硬盘</h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141718909.png"
alt="image-20230414171800773" />
<figcaption aria-hidden="true">image-20230414171800773</figcaption>
</figure>
<p><strong>在微小型高档笔记本电脑中，采用高性能 Flash Memory
作为硬盘记录数据——固态硬盘</strong> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151623950.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="固态硬盘ssd概述">8.1.固态硬盘（SSD）概述</h2>
<p><strong>固态硬盘（SSD）：它是一种基于闪存技术的存储器，与 U
盘并无本质区别，属于电可擦除 ROM，也即
EEPROM。传统机械硬盘与固态硬盘内部构造如下图所示</strong>：</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151624494.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>SSD 有以下特点</strong>：</p>
<ul>
<li><strong>SSD
读写速度较快，随机访问性能高，用电路控制访问位置</strong>（机械硬盘则是通过移动磁臂旋转磁盘控制访问位置）。</li>
<li><strong>SSD 安静无噪音、耐摔抗震、能耗低、造价更高</strong>。</li>
<li><strong>SSD 容易出现坏块（读写次数过多可能会导致）。</strong></li>
</ul>
<h2 id="固态硬盘ssd组成">8.2.固态硬盘（SSD）组成</h2>
<h3 id="闪存翻译层">8.2.1.闪存翻译层</h3>
<p><strong>闪存翻译层：主要作用是负责翻译逻辑块号，找到对应页。具体来说，I/O
总线会给出系统所要读 /
写的逻辑块号，然后闪存翻译层会把逻辑块号映射为对应的物理地址。</strong></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151627038.png" /></p>
<h3 id="存储介质">8.2.2.存储介质</h3>
<p><strong>存储介质：上面 SSD
构造图中的黑色块状部分为闪存芯片，多个闪存芯片构成 SSD
的闪存芯片组。每个闪存芯片内由多个数据块组成（每个数据块大小为
16KB~512KB）、每个数据块又有多个页组成（每个页大小为
512B~4KB）。这里特别注意 “逻辑块”
在不同的存储器下有不同的含义：</strong></p>
<ul>
<li><strong>如果是磁盘</strong>：逻辑块指的就是磁盘的块或扇区。</li>
<li><strong>如果是 SSD</strong>：逻辑块指的就是 SSD 的页。</li>
<li><strong>所以，SSD 的一个页相当于磁盘的一个扇区、SSD
的一个块相当于磁盘的一个磁道。</strong></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151627683.png" /></p>
<h2 id="固态硬盘ssd的读写">8.3.固态硬盘（SSD）的读写</h2>
<p><strong>固态硬盘（SSD）的读写：主要由以下特点</strong>：</p>
<ul>
<li><strong>以页为单位进行读写</strong>。</li>
<li><strong>以块为单位进行擦除，擦干净的块，其中的每页都可以写一次，读无限次。</strong></li>
<li><strong>支持随机访问，也即系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址。</strong></li>
<li><strong>SSD
读速度要快于写速度，这是因为要写的页如果有数据则需要先将块内其他页全部复制到一个新的块中，再写入新的页</strong>。</li>
</ul>
<h2 id="磨损均衡技术">8.4.磨损均衡技术</h2>
<p><strong>磨损均衡技术：由于反复写会导致闪存快磨损，所以引入磨损均衡技术，闪存翻译层有一个平均磨损逻辑试图通过将擦除平均分布在所有块上来最大化每个块的寿命。有如下两种方式</strong>：</p>
<ul>
<li><p><strong>动态磨损均衡</strong>：写入数据时，优先选择<strong>累计擦除次数少</strong>的新闪存块。</p></li>
<li><p><strong>静态磨损均衡</strong>：SSD
监测并自动进行数据分配、迁移。让<strong>老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务。</strong></p></li>
</ul>
<h1 id="高速缓冲存储器cache">9.高速缓冲存储器Cache</h1>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142146250.png" /></p>
<p><strong>由于程序的转移概率和数据分布的离散性很大，所以想要仅仅通过提高主存系统的并行性以此来提升存储器带宽的想法是不现实的。因此这就我们必须从系统结构上加以改进，也即采用<a href="#存储器分类">1.1存储器分类</a>中讲到的多级存储体系</strong>。</p>
<ul>
<li>Cache - 主存层次。</li>
<li>主存 - 辅存层次。</li>
</ul>
<h2 id="cache-基本原理">9.1.Cache 基本原理</h2>
<p>以微信为例，当你打开微信时，与微信有关的数据和代码将会被加载进主存，比如文字数据、支付数据、运动数据等等。这些数据很多，涉及各个功能，但有的人使用微信可能只偏好于某些方面（比如视频聊天）。所以在这样的情况下，CPU
在较长时间内使用到的只是微信的部分程序和数据 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142139806.png"
alt="image-20230414213910707" />
<figcaption aria-hidden="true">image-20230414213910707</figcaption>
</figure>
<p><strong>所以可以把把这一部分的数据复制一份给 Cache，由于 Cache
的速度和 CPU 十分接近，这样的话 CPU 会直接和 Cache
交流，整机性能会有明显提升</strong> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142139431.png"
alt="image-20230414213956332" />
<figcaption aria-hidden="true">image-20230414213956332</figcaption>
</figure>
<h2 id="程序访问的局部性原理">9.2.程序访问的局部性原理</h2>
<p>如下是一段简单的 C 语言程序：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> M <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>j<span class="token operator">++</span>
			sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该程序在运行后会被加载进内存，程序的本质就是<strong>指令和数据</strong>，所以这段程序在主存中分布情况可能是下面这样：</p>
<ul>
<li><p>假定 M、N 为 2048，按字节编址，int 占用 4 个字节。</p></li>
<li><p>这个二维数组看似是二维的，实则在主存中是一维的，相当于把第二行接到了第一行的尾巴后面。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142142096.png"
alt="image-20230414214251984" />
<figcaption aria-hidden="true">image-20230414214251984</figcaption>
</figure></li>
</ul>
<p><strong>程序访问的局部性原理包括空间局部性和时间局部性</strong>：</p>
<p><strong>空间局部性</strong>：<strong>是指最近未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的</strong>。例如上例中形参是一个数组，在一个元素访问完毕之后，下一个元素的物理位置和它其实是相邻的。</p>
<p><strong>时间局部性</strong>：<strong>是指最近未来要用到的信息，很可能就是现在正在使用的信息</strong>。比如上例中
for
循环内的<code>sum+=a[i][j]</code>，这一条语句明显会被重复使用多次。</p>
<p><strong>Cache + 局部性原理：可以把 CPU
目前正在访问的元素的邻近数据放到 Cache 中，之后 CPU
的访存操作大多数就会针对 Cache
进行，程序的执行速度的也会得到提升。</strong></p>
<p>下面是一个空间局部性很差的程序，它只是在上面程序的基础上把
“<strong>一行一行的访问” 变为了
“一列一列的访问</strong>”。之前，访问完<code>a[0][0]</code>，下一个访问的就是<code>a[0][1]</code>，而现在下一个却变成了<code>a[1][0]</code>了。因为每次访问都要跳过
2048 个数组元素，也就是 8192 字节，假如主存与 Cache
的交换单位较小，<strong>那么每访问一个数组元素都需要装入一个主存块到
Cache 中</strong>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> M<span class="token punctuation">;</span>j<span class="token operator">++</span>
			sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="主存块">9.3.主存块</h2>
<p><strong>主存块：这是主存与 Cache
之间交换数据的最小单位。也即将主存的存储空间分块，比如每 1KB
为一块，主存与 Cache 之间就会以块为单位进行数据交换。</strong></p>
<p>例如下图数组，对于<code>a[0][0]</code>我们先判断它属于哪一块，确定好之后再将它所在的块复制到
Cache 中去。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142144189.png"
alt="image-20230414214417102" />
<figcaption aria-hidden="true">image-20230414214417102</figcaption>
</figure>
<p><strong>假设主存大小为 4M，每 1KB 为一块，由于
4M=4096KB，因此会被分为 4096 块，然后对其编号（0-4095）</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142145548.png"
alt="image-20230414214502471" />
<figcaption aria-hidden="true">image-20230414214502471</figcaption>
</figure>
<p><strong>由于 $2^{22}=4 194 $，所以这些地址至少需要 22
位才能全部表示，我们将 22 位地址拆分为两个部分，前 12 位表示块号（ $
2^{12}=4096 $），后 10 位表示块内地址（ $ 2^{10}=1024 $)</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142145283.png"
alt="image-20230414214539186" />
<figcaption aria-hidden="true">image-20230414214539186</figcaption>
</figure>
<h2 id="命中率和缺失率">9.4.命中率和缺失率</h2>
<p><strong>命中率 <span class="math inline">\(H\)</span>： CPU
欲访问的信息已经在 Cache 中的比率</strong>。</p>
<p><strong>缺失率： CPU 欲访问的信息未经在 Cache 中的比率，为 <span
class="math inline">\(1-H\)</span>。</strong></p>
<ul>
<li><p>假设某程序执行期间，Cache 的的总命中次数为 $ N_{c}
$，访问主存的总次数为 $ N_{M} $，<strong>那么 <span
class="math inline">\(H\)</span>= $ $。​​</strong></p></li>
<li><p><strong>命中率 <span class="math inline">\(H\)</span> 越接近 1
越好</strong>。</p></li>
<li><p>设 $ t_{c} $为命中时的 Cache 访问时间， $ t_{m}
$为未命中时的访问时间, 则 <strong>Cache - 主存系统的平均访问时间 $
T_{a}=Ht_{c}+(1-H)t_{m} $。​</strong></p></li>
</ul>
<h1
id="cache和主存的映射方式"><a name="10.Cache和主存的映射方式">10.Cache和主存的映射方式</a></h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142201730.png"
alt="image-20230414220104642" />
<figcaption aria-hidden="true">image-20230414220104642</figcaption>
</figure>
<p>前面说过，Cache
中保存的实际是主存中的数据副本，所以这里就会涉及一个很重要的问题：<strong>主存内容和
Cache 中的内容是如何对应，也即是如何映射的？</strong>
地址映射的方法有以下三种：</p>
<ul>
<li><strong>全相联映射</strong>：主存块可以放在 Cache
的<strong>任何位置</strong>。</li>
<li><strong>直接映射</strong>：每个主存块<strong>只能放到一个特定的位置</strong>，由<strong>主存块号
%Cache 总块数</strong>来确定。</li>
<li><strong>组相联映射</strong>：将 Cache
块分为<strong>若干组</strong>，每个主存块可以放到<strong>特定分组中的任意一个位置</strong>，其中<strong>组号
= 主存块号 % 分组数。</strong></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142149568.png"
alt="image-20230414214921473" />
<figcaption aria-hidden="true">image-20230414214921473</figcaption>
</figure>
<p>把主存块放到 Cache 中后：</p>
<ul>
<li><p><strong>要给每个 Cache 块增加一个
“标记位”</strong>，记录<strong>对应的主存块号</strong>。</p></li>
<li><p><strong>再给每个 Cache 块增加一个
“有效位”</strong>，用于<strong>控制其是否生效</strong>，以免产生冲突
。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142150662.png"
alt="image-20230414215019584" />
<figcaption aria-hidden="true">image-20230414215019584</figcaption>
</figure></li>
</ul>
<p><strong>分块后需要对主存进行编号，假设某个计算机的主存地址空间大小为
256MB，按字节编址，Cache 有 8 个 Cache 行（也即 Cache
块），行长（也即块大小）为 64B。</strong></p>
<ul>
<li><strong>主存块号编号</strong>：块大小为 <span
class="math inline">\(64B=2^6B\)</span>、主存大小为 <span
class="math inline">\(256MB=2^28B\)</span>，那么就有 <span
class="math inline">\(2^{28}/2^6\)</span> 个主存块，所以主存编号为从 0
到 <span class="math inline">\(2^{22}-1\)</span>。</li>
<li><strong>块内地址</strong>：这 22 位是用于区分主存块的，所以剩下的
28-22=6 位则为每个主存块的地址范围（或空间）。也即先利用高 22
位确定是哪一块，然后在该块中用低 6 位确定地址。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142153801.png"
alt="image-20230414215317711" />
<figcaption aria-hidden="true">image-20230414215317711</figcaption>
</figure>
<h2 id="全相联映射">10.1.全相联映射</h2>
<h3 id="如何映射">10.1.1.如何映射</h3>
<p><strong>全相联映射：主存块可以放在 Cache 的任何位置。</strong></p>
<p>例如下图中的 0 号主存块，它就可以放置到 Cache 的 3
号位置，每行的标记号用于指出该行取自主存的哪一块，同时将对应的有效位置为
1。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142153856.png"
alt="image-20230414215356771" />
<figcaption aria-hidden="true">image-20230414215356771</figcaption>
</figure>
<h3 id="如何访存">10.1.2.如何访存</h3>
<p><strong>以上图紫色主存块为例，其地址为
1…1101001110，在全相联映射下，CPU 访存时首先会取该地址的前 22
位，也即主存块号，来和 Cache 中每一行的标记进行对比</strong>。</p>
<ul>
<li><strong>若标记号 = 块号且有效位为 1</strong>：说明 <strong>Cache
命中</strong>，也就是说此时访问的数据在 Cache
中是有副本的，接着<strong>只需在 Cache 中访问后 6
位地址所定位的单元</strong>即可。</li>
<li><strong>若标记号不匹配或匹配但有效位为 0</strong>：此时说明
<strong>Cache
未命中</strong>，则正常访问主存，也即要从主存中取数据。</li>
</ul>
<h2 id="直接映射">10.2.直接映射</h2>
<h3 id="如何映射-1">10.2.1.如何映射</h3>
<p><strong>直接映射：每个主存块只能放到一个特定的位置，由主存块号 %Cache
总块数来确定</strong>。</p>
<p>例如下图中的 0 号主存块，由于 0%8=0，因此它<strong>只能放到 Cache 的
0 号位置</strong>；对于 8 号主存块，由于 8%8=0，所以它也要放到 0
号位置，<strong>而且需要把之前的 0
号主存块给腾空</strong>，相应的标记位也要修改 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142155753.png"
alt="image-20230414215559659" />
<figcaption aria-hidden="true">image-20230414215559659</figcaption>
</figure>
<p><strong>“%” 运算具有一些特性，这里 Cache 块数 = 8=<span
class="math inline">\(2^3\)</span>，其指数部分为
3，这意味着主存块号中的后 3 位直接反映了该主存块在 Cache
中的位置。例如上图中的 0 号和 8 号，其主存块号的后三位均为
000，这正好对应了它们在 Cache 的第 0 行</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142157753.png"
alt="image-20230414215737664" />
<figcaption aria-hidden="true">image-20230414215737664</figcaption>
</figure>
<p><strong>因此标记可以直接取主存块号的前 19
位，相应地址形式会变化为下面这样</strong> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142158500.png"
alt="image-20230414215838387" />
<figcaption aria-hidden="true">image-20230414215838387</figcaption>
</figure>
<h3 id="如何访存-1">10.2.2.如何访存</h3>
<p><strong>以上图橙色主存块为例，其地址为
0…01000001110。在直接映射下，CPU 访存时首先会根据主存块号的后三位确定
Cache 行（而不用挨个比较），接着会判断前 19
位和标记号是否匹配并同时判断有效位是否为 1</strong>。</p>
<h2 id="组相联映射">10.3.组相联映射</h2>
<h3 id="如何映射-2">10.3.1.如何映射</h3>
<p><strong>组相联映射：将 Cache
块分为若干组，每个主存块可以放到特定分组中的任意一个位置，其中组号 =
主存块号 % 分组数。</strong></p>
<p>以 2 路组相联为例（2 块为一组，分为四组）。对于下图中 1
号主存块，由于
1%4=1，因此它会被放入<strong>第一组的任意位置</strong>；对于 222-3
号主存块也会放入第一组，它会放到该组另一个空闲位置 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142159993.png"
alt="image-20230414215932900" />
<figcaption aria-hidden="true">image-20230414215932900</figcaption>
</figure>
<p><strong>和直接映射一样，由于 “%” 的运算特性，这里分组数 =
4=22，这意味着主存块号中的后 2
位反映了该主存块在哪一个组。所以标记号只需取前 20
位，相应地址形式会变化为下面这样</strong> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142200971.png"
alt="image-20230414220008881" />
<figcaption aria-hidden="true">image-20230414220008881</figcaption>
</figure>
<h3 id="如何访存-2">10.3.2.如何访存</h3>
<p><strong>以上图橙色主存块为例，其地址为
1…0100001110。在组相联映射下，CPU
访存时首先会根据主存块号的后两位确定所属分组号，接着会判断主存块号的前
20 位与分组内的某个标记号是否匹配同时判断有效位是否为 1</strong>。</p>
<h2 id="三种方式各自优缺点">10.4.三种方式各自优缺点</h2>
<p><strong>全相联映射</strong>：</p>
<ul>
<li><strong>优点</strong>：Cache 存储空间利用充分，命中率高。</li>
<li><strong>缺点</strong>：查找慢，有时可能要比对所有行的标记。</li>
</ul>
<p><strong>直接映射</strong>：</p>
<ul>
<li><strong>优点</strong>：对于任意一个位置，只需对比一个标记，速度最快。</li>
<li><strong>缺点</strong>：缺点就是 Cache
存储空间利用不充分，命中率低。</li>
</ul>
<p><strong>组相联映射</strong>：<strong>综合效果较好。</strong></p>
<h1
id="cache替换算法"><a name="11.Cache替换算法">11.Cache替换算法</a></h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151527611.png"
alt="image-20230415152732490" />
<figcaption aria-hidden="true">image-20230415152732490</figcaption>
</figure>
<p>在<a href="#10.Cache和主存的映射方式"><strong>10.Cache和主存的映射方式</strong></a>中我们讲到了
Cache
和主存之间的映射关系，细致分析了三种映射方式各自的特点。那么下一个亟待解决的问题就是：<strong>Cache
是很小的，主存却很大，如果 Cache 满了应该怎么办？</strong>
这就是本节的主题——<strong>Cache
的替换算法</strong>。当然，不同的映射方式其替换机制也会有所不同。</p>
<ul>
<li><strong>全相联映射：Cache
完全满了才需要替换，需要在全局中选择替换哪一块</strong>。</li>
<li><strong>直接映射：如果对应位置为空则直接替换，无需考虑替换算法。</strong></li>
<li><strong>组相联映射：分组内满了才需要替换，需要在分组内选择替换哪一块。</strong></li>
</ul>
<p><strong>本节以全相联映射为例，介绍以下四种替换算法</strong>：</p>
<ul>
<li><strong>随机算法（RAND）</strong>。</li>
<li><strong>先进先出算法（FIFO）。</strong></li>
<li><strong>近期最少使用算法（LRU）。</strong></li>
<li><strong>最不频繁使用算法（LFU）</strong>。</li>
</ul>
<p><strong>在讲解之前大家一定明白一点，CPU
每访问一个内存块，都会立即把该内存块调入 Cache 中</strong>。</p>
<h2 id="随机算法rand">11.1.随机算法（RAND）</h2>
<p><strong>随机算法（RAND）：若 Cache
已满，则随机选择一块进行替换。</strong></p>
<ul>
<li><strong>通过以下叙述可知：随机算法十分简单，但是它完全没有考虑到局部性原理，命中率很低，实际效果很不稳定。</strong></li>
</ul>
<p>如下有 4 个 Cache 块，初始状态下 4 个 Cache
块均为空，采用<strong>全相连映射</strong>，CPU
访问主存块的顺序为：{1,2,3,4,1,2,5,1,2,3,4,5}，CPU
<strong>每访问一个内存块，都会立即把该内存块调入 Cache
中</strong>，前四次调入时由于都有空闲 Cahce 块，所以不会发生替换。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,<strong>1,2</strong>,5,1,2,3,4,5}。由于 1,2
主存块已经被调入了 Cache，所以<strong>直接命中。</strong></p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。对于 5
号主存块，它并没有调入 Cache
中，因此需要立即被调入，<strong>但此时已经没有空闲 Cache
块了，所以需要使用替换算法选择一块换出，然后再把 5
号主存块调入。这里采用的是随机算法，所以我们可以任意挑选一块调入，比如把
3 号主存块给替换出去</strong>。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,5,<strong>1,2</strong>,3,4,5}。直接命中。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。和上面一样，随机挑选一块换出。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="red">
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。和上面一样，随机挑选一块换出。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="red">
4
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>访存结束，{1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。直接命中。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h2 id="先进先出算法fifo">11.2.先进先出算法（FIFO）</h2>
<p><strong>先进先出算法（FIFO）：若 Cache 已满，则替换最先被调入 Cache
的块</strong>。</p>
<ul>
<li><strong>通过以下叙述可知：先进先出算法实现也很简单，但该算法依然没有考虑到局部性原理，因为最先被调入的
Cache
块也有可能是会频繁访问到的。而且此算法容易产生抖动现象（—刚换上去的块又立马被换下）。</strong></li>
</ul>
<p>仍然采用之前的例子，直接进行到这一步。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。对于 5
号主存块，它并没有调入 Cache 中，因此需要立即被调入，但此时已经没有空闲
Cache 块了，所以需要使用替换算法选择一块换出，然后再把 5
号主存块调入。<strong>这里采用的是 FIFO
算法，根据先进先出原则，最先被调入 Cache 的最先被替换，因此 1
号被替换</strong>。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td bgcolor="red">
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,5,<strong>1</strong>,2,3,4,5}。此时应该替换 2
号。</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td bgcolor="red">
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>后续步骤不再详细演示，最终结束状态如下：</p>
<table>
<thead>
<tr>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="red">
5
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
</tr>
<tr>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
是
</td>
<td>
是
</td>
<td>
是</font>
</td>
<td>
是
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h2
id="近期最少使用算法lru效率最高">11.3.近期最少使用算法（LRU）——效率最高</h2>
<p><strong>近期最少使用算法（LRU）：该算法会为每一个 Cache
块设置一个计数器，用于记录每个 Cache
块究竟有多长时间没有被访问了。在替换时直接选取计数器最大的替换即可。</strong></p>
<ul>
<li><strong>通过以下叙述可知：LRU
算法是基于局部性原理的，近期访问过的主存块，在不久的将来很有可能会被再次访问到，因此这种淘汰机制是合理的。LRU
算法的实际运行效果也很优秀，Cache 命中率也高</strong>。</li>
</ul>
<p><strong>计数器的变化规则如下</strong>：</p>
<ul>
<li><strong>命中时：所命中的块的计数器清零，计数器比其低的块的计数器 +
1，其余不变</strong>。</li>
<li><strong>未命中且还有空闲块时：新装入的块的计数器置为
0，其余非空闲块的计数器全 + 1。</strong></li>
<li><strong>未命中且没有空闲块时：计数器最大的块被淘汰，新装入块的计数器置为
0，其余块的计数器 + 1。</strong></li>
</ul>
<p>如下表格表示初始状态：</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
<strong>Cache #0</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{<strong>1</strong>,2,3,4,1,2,5,1,2,3,4,5}。由于 1
装入了第一个 Cache
块，属于<strong>未命中且还有空闲块</strong>，因此该块计数器置为
0，其余非空闲块计数器全 + 1。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,<strong>2</strong>,3,4,1,2,5,1,2,3,4,5}。情况同上。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>第三、四个主存块亦是如此。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
3
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,<strong>1</strong>,2,5,1,2,3,4,5}。<strong>此时
Cache 命中，因此需要将所命中块的计数器清零，比其低的块的计数器 +
1，其余不变。</strong></p>
<ul>
<li>这一点其实就体现了 LRU
算法的核心，它能保证最近访问的块的计数器一定很低。</li>
</ul>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,<strong>2</strong>,5,1,2,3,4,5}，情况同上。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即 {1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。此时属于
<strong>“未命中且没有空闲行”，所以计数器最大的块会被淘汰（淘汰 3
号主存块），新装入块的计数器置为 0，其余块计数器全 + 1。</strong></p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
2
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,5,<strong>1</strong>,2,3,4,5}。直接命中。</p>
<ul>
<li><strong>注意</strong>：只需要将 “比该块计数器值小的块的计数器 + 1”
即可，大的不变，因此上面表格中的 3 号 Cache
的计时器就不用动了，这里很容易犯错。</li>
</ul>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
4
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,5,1,<strong>2</strong>,3,4,5}。直接命中。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
5
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，{1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。未命中，且没有空行。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
2
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="red">
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。未命中，且没有空行。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
3
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td bgcolor="red">
4
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。未命中，且没有空行。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="red">
5
</td>
<td>
</td>
</tr>
<tr>
<td>
3
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
5
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h2 id="最不经常使用算法lfu">11.4.最不经常使用算法（LFU）</h2>
<p><strong>最不经常使用算法（LFU）：该算法会为每一个 Cache
块设置一个计数器，用于记录每个 Cache
块被访问过几次。在替换时直接选取计数器最小的替换即可。</strong></p>
<ul>
<li><strong>通过以下叙述可知：LFU
算法并没有很好地遵循局部性原理，比如微信聊天相关的块，在某个时间段内使用率会很高，但是一段时间后使用率会很低，并不科学。</strong></li>
</ul>
<p><strong>计数器的变化规则为：</strong></p>
<ul>
<li><strong>新调入的块计数器为 0，之后每访问一次计数器就 +
1。需要替换时，选择计数器最小的一行替换。</strong></li>
<li><strong>若有多个计数器最小的行，可以按照行号递增或 FIFO
策略进行选择。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
<strong>Cache #0</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即 {<strong>1,2,3,4</strong>,1,2,5,1,2,3,4,5}。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,<strong>1,2,</strong>5,1,2,3,4,5}。发生命中，计数器 + 1。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。<strong>选择计数器最小的那一行，但是这里有两行相同（都是
0），所以再按照 FIFO 策略选择 3 号主存块淘汰。</strong></p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即 {1,2,3,4,1,2,5,<strong>1,2</strong>,3,4,5}。1,2
命中，计数器 + 1。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
2
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。需要进行替换，<strong>这里我们再采用行号递增的规则淘汰
5 号主存块。</strong></p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
2
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td bgcolor="red">
3
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。命中，计时器 + 1。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
2
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="green">
4
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>继续访存，也即
{1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。需要替换，只剩一个最小的了，替换
3 号主存块即可。</p>
<table>
<thead>
<tr>
<th>
计时器
</th>
<th>
访问主存块
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
1
</th>
<th>
2
</th>
<th>
5
</th>
<th>
1
</th>
<th>
2
</th>
<th>
3
</th>
<th>
4
</th>
<th>
5
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
2
</td>
<td>
<strong>Cache #0</strong>
</td>
<td bgcolor="red">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td bgcolor="green">
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
<td>
</td>
</tr>
<tr>
<td>
2
</td>
<td>
<strong>Cache #1</strong>
</td>
<td>
</td>
<td bgcolor="red">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td bgcolor="green">
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
</td>
</tr>
<tr>
<td>
0
</td>
<td>
<strong>Cache #2</strong>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td>
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
5
</td>
<td>
5
</td>
<td bgcolor="red">
3
</td>
<td>
3
</td>
<td bgcolor="red">
5
</td>
<td>
</td>
</tr>
<tr>
<td>
1
</td>
<td>
<strong>Cache #3</strong>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td bgcolor="red">
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td>
4
</td>
<td bgcolor="green">
4
</td>
<td>
4
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否命中？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
<strong>是否替换？</strong>
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
否
</td>
<td>
是
</td>
<td>
否
</td>
<td>
是
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h1 id="cache的写策略">12.Cache的写策略</h1>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151543520.png"
alt="image-20230415154310416" />
<figcaption aria-hidden="true">image-20230415154310416</figcaption>
</figure>
<p>在<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39183034/article/details/119967515?spm=1001.2014.3001.5501"><a href="#10.Cache和主存的映射方式">10.Cache和主存的映射方式</a></a>和<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39183034/article/details/120016603?spm=1001.2014.3001.5501"><a href="#11.Cache替换算法">11.Cache替换算法</a></a>这两篇文章中分别探讨了主存、Cache
之间的映射关系以及 Cache 的替换算法。关于
Cache，最后需要解决的一个问题就是：<strong>如何保持 Cache
与数据母体的一致性</strong>？因为我们知道，Cache
中保存的只是<strong>主存数据的副本</strong>，一旦对 Cache
进行写操作就一定会导致两部分数据出现不一致，而对于读操作则不关心。这就是
Cache 写策略所要探讨的问题。</p>
<p><strong>Cache 写策略分写命中和写不命中两种情况</strong>：</p>
<ul>
<li><strong>写命中</strong>：有全写法和写回法。</li>
<li><strong>写不命中</strong>：有写分配法和非写分配法两种。</li>
</ul>
<h2 id="写命中">12.1.写命中</h2>
<p><strong>写命中：写命中时主存块被调入 Cache 中，也即要被修改的单元在
Cache 中。此时有两种方法</strong>：</p>
<ul>
<li>写回法。</li>
<li>全写法。</li>
</ul>
<h2 id="写回法-write-back">12.1.1.写回法 (write-back)</h2>
<p><strong>写回法 (write-back)：是指当 CPU 写命中时，只修改 Cache
中的内容，而不立即写入主存，只有当此块被换出时才写回主存。如下图，绿色主存块写命中，修改时只在
Cache
上修改，而不立即写入主存，只有当绿色块被替换时才会写回主存</strong>。</p>
<ul>
<li><strong>优点</strong>：减少了访存次数。</li>
<li><strong>缺点</strong>：存在数据不一致的隐患。</li>
</ul>
<p><strong>这种方法需要判断 Cache 是否被修改过，因此在对应 Cache
块还会增加一个 “脏位”，用于标识是否修改过，如果对应位为 1
表示修改过，那么在被替换时该 Cache
块中的内容会被写回至标记位所定位的主存块上</strong> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151537514.png"
alt="image-20230415153708377" />
<figcaption aria-hidden="true">image-20230415153708377</figcaption>
</figure>
<h2 id="全写法-write-through">12.1.2.全写法 (write-through)</h2>
<p><strong>全写法 (write-through)：是指当 CPU
写命中时，必须把数据同时写入 Cache
和主存。当某一块需要替换时，不必把这一块写回主存，新调入的块直接覆盖即可</strong>。</p>
<ul>
<li><strong>优点</strong>：实现简单，更能保持数据的一致性。</li>
<li><strong>缺点</strong>：增加了访存次数，降低了 Cache 的效率。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151538715.png"
alt="image-20230415153819596" />
<figcaption aria-hidden="true">image-20230415153819596</figcaption>
</figure>
<p><strong>为了减少全写法直接写入主存时所产生时间损耗，通常会在 Cache
和主存之间加入写缓冲（Write Buffer）。CPU 同时写数据到 Cache
和写缓冲中，写缓冲再控制将内容写入主存，写缓冲是一个 FIFO
队列，可以解决速度不匹配的问题。</strong></p>
<ul>
<li><p>注意频繁写会导致缓冲区溢出 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631121.png" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151539724.png"
alt="image-20230415153919610" />
<figcaption aria-hidden="true">image-20230415153919610</figcaption>
</figure></li>
</ul>
<h2 id="写不命中">12.2.写不命中</h2>
<p><strong>写不命中：写不命中时被修改的单元不在 Cache
中。此时有两种方法</strong>：</p>
<ul>
<li>写分配法。</li>
<li>非写分配法。</li>
</ul>
<h3 id="写分配法-write-allocate">12.2.1.写分配法 (write-allocate)</h3>
<p><strong>写分配法：是指当写不命中时，会把主存的块加载到 Cache
中，然后更新此 Cache 块，通常会结合写回法使用。</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151540924.png"
alt="image-20230415154008820" />
<figcaption aria-hidden="true">image-20230415154008820</figcaption>
</figure>
<h3
id="非写分配法not-write-allocate">12.2.2.非写分配法（not-write-allocate）</h3>
<p><strong>非写分配法：是指当写不命中时，CPU
直接对主存的块进行修改，而不调入 Cache 中（注意只有读操作才将主存块调入
Cache 中），通常会结合全写法使用</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151541097.png"
alt="image-20230415154128984" />
<figcaption aria-hidden="true">image-20230415154128984</figcaption>
</figure>
<h1 id="多级-cache">13.多级 Cache</h1>
<p>现代计算机的 Cache 一般是多级的（通常三级）。对于三级
Cache，<strong>按离 CPU 的远近可命名为 L1 Cache、 L2 Cache、 L3Cache，离
CPU 越远，访问速度就越慢，容量也越大，反之相反。</strong> 其中指令 Cache
与数据 Cache 分离一般在 L1
级，此时通常<strong>为写分配法和写回法</strong>合用。</p>
<p>下图是一个含有两级的 Cache 系统，<strong>L1 对 L2 使用全写法，L2
对主存使用写回法</strong>，由于 L2
的存在，其访问速度远大于主存，因此避免了因频繁写时导致的缓冲区溢出
。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151541752.png" /></p>
<p>如下图是资源管理器中显示的 Cache 信息。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151542250.png"
alt="image-20230415154239158" />
<figcaption aria-hidden="true">image-20230415154239158</figcaption>
</figure>
<h1 id="虚拟存储器">14.虚拟存储器</h1>
<h2 id="页式存储器">14.1.页式存储器</h2>
<p>前面说过主存和 Cache 之间是以块作为数据的传输单位的。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151551467.png"
alt="image-20230415155133378" />
<figcaption aria-hidden="true">image-20230415155133378</figcaption>
</figure>
<p>我们知道，应用程序运行时需要加载进主存。比如说微信，假如它有 1GB
大小，那么想要在主存中找到连续的 1GB
空间是很困难的，并且就算加载进去了，也会极大的破坏主存的利用率，产生很多碎片。</p>
<p><strong>因此为了提高主存利用率，可以将程序（所谓程序就是数据、指令的集合体）分为一个个大小相同的
“页”，每个页面的大小和“物理块”
的大小是相同的。给每个页面编号后，就可以分散在主存中</strong> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151552958.png"
alt="image-20230415155241848" />
<figcaption aria-hidden="true">image-20230415155241848</figcaption>
</figure>
<p>所以页式存储系统是这样的：<strong>一个程序（操作系统中称为进程)在逻辑上被分为若干大小相同的
“页面”，“页面” 大小与 “块”
大小相同，每个页面可以离散地放入不同的主存块</strong>。</p>
<ul>
<li>页面的划分属于逻辑角度，主存和 Cache 块的划分属于物理角度。</li>
</ul>
<h2 id="逻辑地址和物理地址">14.2.逻辑地址和物理地址</h2>
<ul>
<li><strong>逻辑地址</strong>：程序员视角中看到的地址。</li>
<li><strong>物理地址</strong>：数据在主存中真实的地址。</li>
</ul>
<p>我们编写程序时，所操作的数据其显示的地址均为虚拟地址，真实的地址需要操作系统进行映射。那么为什么需要虚拟地址呢？</p>
<p>早期的计算机启动进程时，会将进程或程序所包含的东西全部加载进内存，而且访问的就是真实的物理内存。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151556888.png" /></p>
<p><strong>但是这种粗暴的操作有很大弊端</strong>，比如说经典的<strong>野指针</strong>问题在这种情况下就很容易产生，而且进程在运行中会产生大量数据，这些数据一旦不能连续存放，就会另外开辟空间，这无疑增加了异常访问的情况。</p>
<p>所以计算机设计者意识到了这种模式缺陷，想到了一种方法：增加一个中间层，利用中间层映射物理内存。程序访问内存时不直接访问物理内存，先访问中间层，如果中间层访问没有问题，那么操作系统就会将中间层映射到物理层，完成正常执行。</p>
<p><strong>一个进程创建之后，操作系统会为这个进程分配一个专属于它的大小为
4GB 的虚拟进程地址空间（4GB 是因为 32 位系统中，指针是 4
个字节），与它相对的是一片真实的物理地址空间，操作系统在映射虚拟内存时只会映射到那一片物理空间，而且需要特别注意这个虚拟空间并不是真的有
4GB，它只是虚拟的
。由于每一个进程都有自己的虚拟的进程地址空间，所以它只能访问自己的进程的数据，这样做实现了隔离，也就是进程之间的相互独立。并且把虚拟地址空间划分为这样、那样的区，也能实现数据的连续存放。</strong></p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151557336.png" /></p>
<p>操作系统负责分页操作，该过程对程序员是不可见的。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151604882.png"
alt="image-20230415160453779" />
<figcaption aria-hidden="true">image-20230415160453779</figcaption>
</figure>
<p>站在程序员的视角上，对于一个打包好的 4KB
程序，<strong>我们肯定是知道它的大小的，由于 4KB=$ 2^{12}B
$，因此可以编址，其范围为：000000000000~111111111111</strong> 。
<strong>假设该程序中有一个变量 <span class="math inline">\(x\)</span>
的逻辑地址为：001000000011，另外一个变量 y
的逻辑地址为：110000001010</strong> 。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151605640.png" /></p>
<p>在学习第一章时，我们知道取变量 <span class="math inline">\(x\)</span>
到 $ ACC $ 寄存器的操作对应的机器指令是：<strong>000001
001000000011，分别对应操作码和地址码（逻辑地址)</strong>，我们指明的仅仅是一个相对的地址，并不是说
<span class="math inline">\(x\)</span> 的地址真的就在那里。</p>
<p><strong>每个页的大小是 1KB。也就是 $2 ^{10} $B，因此可以将变量 <span
class="math inline">\(x\)</span>
的逻辑地址分为两个部分：一个表示页号，一个表示页内地址，其中页内地址的大小取决于每个页面的大小，如果是
1KB，那么就需要 10 个比特位</strong>。</p>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151605544.png" /></p>
<p>因此 <span class="math inline">\(x\)</span> 的逻辑地址：001000000011
就表示它在第 0 页，<strong>而 <span class="math inline">\(x\)</span>
的真实的物理地址可以用该页所在的主存的块号（12 位）+
页内地址表示</strong> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151606954.png"
alt="image-20230415160639824" />
<figcaption aria-hidden="true">image-20230415160639824</figcaption>
</figure>
<ul>
<li>此例中，第 0 页放在了主存的第 2 块，因此 <span
class="math inline">\(x\)</span>
的真实地址为：0000000000101000000011。</li>
</ul>
<h2 id="页表和地址变换过程">14.3.页表和地址变换过程</h2>
<h3 id="页表">14.3.1.页表</h3>
<p>所以我们见到的地址均为虚拟的地址，给出逻辑地址后，操作系统必须将其转化为真实的物理地址再进行访存，<strong>其中最基本的一个操作就是把页号映射为块号</strong>，所以为了记录这样的映射关系，操作系统会建立一张页表
。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151607454.png"
alt="image-20230415160728373" />
<figcaption aria-hidden="true">image-20230415160728373</figcaption>
</figure>
<p><strong>值得注意的是，页表中存放的数据是保存在主存中的，因此进行地址转换时还要要进行访存操作</strong>。</p>
<p>地址的变化过程大致如下：</p>
<ul>
<li><strong>拆分逻辑地址为页号和页内地址</strong>。</li>
<li><strong>CPU
中的页表基址寄存器指明了页表在主存中的存放位置</strong>（以地址为 1058
为例，就表示当前运行的程序其所对应的页表是从 1058
后的存储单元开始存储的，由于每个页表项的大小相同，所以只需顺次读取即可）。</li>
<li><strong>查询页表找到逻辑页面对应的主存块。</strong></li>
<li><strong>块号 + 页内地址 = 物理地址</strong>。</li>
<li><strong>进行访存操作</strong>（Cache 未命中时进入主存）。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151609908.png"
alt="image-20230415160914781" />
<figcaption aria-hidden="true">image-20230415160914781</figcaption>
</figure>
<h3 id="快表">14.3.2.快表</h3>
<p><strong>依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项放在一个高速缓冲器中，称之为页表（TLB）中，则明显可以提高效率，相应地把放在主存中的页表称为慢表（Page）。</strong></p>
<p><strong>相应地在进行地址转换时，首先查快表，若命中，则无需访问主存中的页表；否则查询主存中完整的页表，查询之后为了以后便于访问将其加入到快表中</strong>
。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151610663.png"
alt="image-20230415161038540" />
<figcaption aria-hidden="true">image-20230415161038540</figcaption>
</figure>
<p>结合之前的 Cache，整个访存操作可以是如下流程 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151612532.png"
alt="image-20230415161248408" />
<figcaption aria-hidden="true">image-20230415161248408</figcaption>
</figure>
<h2 id="页式虚拟存储器">14.4.页式虚拟存储器</h2>
<p>我们知道，运行一个程序时，需要将该程序调入主存，然后根据局部性原理，主存中的部分相关数据会调入
Cache
以提高性能。那么现在的问题是，<strong>一个程序调入主存时需要全部调入吗，还是只需要调入一部分就可以了呢？答案是部分即可</strong>。这一点大家可以联系我们日常使用的手机就能明白，手机内存有限，但是可以同时运行多个大体积程序。<strong>这就是虚拟存储系统：实际物理内存很有限，但是运行时似乎很大很大</strong>。</p>
<ul>
<li>Tips：游戏开局（比如英雄联盟）前面，会有一段加载资源的过程，也就是
“loading”，其实其中绝大部分的工作就是将相关数据从辅存调入主存。</li>
</ul>
<p>这一点其实与前面讲过的主存和 Cache
之间的关系比较相似，<strong>操作系统仍然会将程序分页，程序加载进主存时，会加载一部分，也就是说有的页已经加载进了主存，有的页还留在辅存中</strong>
。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151614663.png"
alt="image-20230415161451555" />
<figcaption aria-hidden="true">image-20230415161451555</figcaption>
</figure>
<p>有分页自然也有负责映射的页表，只不过这里的页表和前面所讲的页表稍有不同，除了完成最基本的映射工作外，这里的页表还会增加以下选项：</p>
<ul>
<li><strong>有效位</strong>：该有效位如果为 1
表示该页已经被加载进了主存，如果为 0 表示仍然留在辅存中。</li>
<li><strong>外存块号</strong>：为了方便以后快速找到需要加载的页的位置，所以也会将辅存进行分块，并且记录其块号。这样以后程序在运行时，如果需要该数据就会能快速找到并加载进主存。</li>
<li><strong>访问位</strong>：前面说过 Cache 被填满后就要执行 Cache
替换算法。而访问位涉及到的就是<strong>页面置换算法</strong>，主存相较于辅存很小，注定只能保存一部分辅存的副本，所以主存很容易会被填满，当其填满时就要进行替换。访问位可以记录最近一段时间内，该页被访问了多少次，因此淘汰页面时可以优先淘汰次数最少的页面。</li>
<li><strong>脏位</strong>：如果脏位为 1
表示进行了更改，如果淘汰页面时则需要写回主存。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151615172.png"
alt="image-20230415161547083" />
<figcaption aria-hidden="true">image-20230415161547083</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151616896.png" /></p>
<p>置于主存和辅存更详细的过程就需要在操作系统这么课中深究了。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151617181.png"
alt="image-20230415161744067" />
<figcaption aria-hidden="true">image-20230415161744067</figcaption>
</figure>
<h2 id="段式虚拟存储器">14.5.段式虚拟存储器</h2>
<p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两个部分：<strong>段号和段内地址</strong>。虚拟地址到实地址之间的变换是由段表实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变所以段表中要给出各段的起始地址和段的长度。</p>
<p>CPU
根据虚拟地址访存时，首先根据段号与该段基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存。已调入主存时，从段表读出该段在主存中的起始地址与段内地址（偏移量）相加，得到对应的主存实地址
。</p>
<figure>
<img
src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151618608.png"
alt="image-20230415161833520" />
<figcaption aria-hidden="true">image-20230415161833520</figcaption>
</figure>
<p>段式虚拟存储器的<strong>优点</strong>是：段的分界与程序的自然分界对应，因为具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享
。
<strong>缺点</strong>则是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p>
<h2 id="段页式虚拟存储器">14.6.段页式虚拟存储器</h2>
<p><strong>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器</strong>。在段页式虚拟存储器中，每个程序对应一个段表，
每段对应一个页表，
段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</p>
<p>虚地址分为<strong>段号、段内页号、页内地址</strong>三部分。CPU
根据虚地址访存时，首先根据段号得到段表地址;
然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址;
最后从页表中取出实页号，与页内地址拼接形成主存实地址。</p>
<p>段页式虚拟存储器的<strong>优点</strong>是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。<strong>缺点</strong>是在地址变换过程中需要两次查表，系统开销较大。</p>
<h2 id="虚拟存储器与-cache-比较">14.7.虚拟存储器与 Cache 比较</h2>
<h3 id="相同">14.7.1.相同</h3>
<ol type="1">
<li>最终目的都是为了<strong>提高系统性能</strong>，两者都有<strong>容量、速度和价格</strong>的梯度。</li>
<li>都把数据分为<strong>小的信息块，并作为基本的传递单位</strong>，虚拟存储器系统的信息块更大。</li>
<li>都有地址的<strong>映射、替换算法和更新</strong>策略等问题。</li>
<li>依据程序的局部性原理应用
“<strong>快速缓存的思想</strong>”，将活跃的数据放在相对高速的部件中。</li>
</ol>
<h3 id="不同">14.7.2.不同</h3>
<ol type="1">
<li>Cache
主要为了解决<strong>系统的速度</strong>，而虚拟存储器则为了解决<strong>主存容量。</strong></li>
<li><strong>Cache
全由硬件实现</strong>，是硬件存储器，对程序员透明；<strong>而虚拟存储器由
OS
和硬件共同实现</strong>，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</li>
<li>由于 CPU 的速度约为 Cache 的 10 倍，主存的速度约为硬盘的 100
倍以上，<strong>因此虚拟存储器系统不命中时对系统的性能影响很大。</strong></li>
<li><strong>CPU 与 Cache 和主存都建立了直接访问的通路，而辅存与 CPU
没有直接通路</strong>。也就是说在 Cache 不命中时主存能和 CPU
直接通信，同时将数据调入
Cache；而虚拟存储器系统不命中时，只能先由硬盘调入内存，而不能直接和 CPU
通信。</li>
</ol>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/alipay-qrcode.jpg"><img loading="lazy" src="/images/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/qqpay-qrcode.jpg"><img loading="lazy" src="/images/qqpay-qrcode.jpg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/images/wechatpay-qrcode.jpg"><img loading="lazy" src="/images/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Explorer</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://ccsu.top/posts/2dbdbfc/" title="计组-第三章 存储系统">http://ccsu.top/posts/2dbdbfc/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/posts/de459af/" rel="prev" title="计组-第四章 指令系统"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">计组-第四章 指令系统</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/posts/189f252b/" rel="next" title="计组-第二章 数据的表示和运算"><span class="post-nav-text">计组-第二章 数据的表示和运算</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div id="waline"></div><script src="/js/comments/waline.js" type="module" defer></script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">皖ICP备20002891号-2</a></div><div class="copyright"><span>&copy; 2016 – 2024 </span><span class="with-love" id="animate" title="赞助者们"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Explorer</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.0.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.8</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-02-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} Days ${passHour} Hours ${passMinute} Minutes ${passSecond} Seconds`;
}
blog_live_time();
</script></div><div id="busuanzi"><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":350,"hOffset":null,"vOffset":null},"mobile":{"show":true},"log":false});</script></body></html>