<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>katex测试</title>
      <link href="/posts/c441e7e0/"/>
      <url>/posts/c441e7e0/</url>
      
        <content type="html"><![CDATA[<p>$$<br>A &#x3D; \begin{bmatrix}<br>        a_{11}    &amp; a_{12}    &amp; …    &amp; a_{1n}\<br>        a_{21}    &amp; a_{22}    &amp; …    &amp; a_{2n}\<br>        a_{31}    &amp; a_{22}    &amp; …    &amp; a_{3n}\<br>        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\<br>        a_{n1}    &amp; a_{n2}    &amp; … &amp; a_{nn}\<br>    \end{bmatrix} , b &#x3D; \begin{bmatrix}<br>        b_{1}  \<br>        b_{2}  \<br>        b_{3}  \<br>        \vdots \<br>        b_{n}  \<br>    \end{bmatrix}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组-第七章 输入输出系统</title>
      <link href="/posts/24f1e69a/"/>
      <url>/posts/24f1e69a/</url>
      
        <content type="html"><![CDATA[<h1 id="1-输入-x2F-输出系统基本概念"><a href="#1-输入-x2F-输出系统基本概念" class="headerlink" title="1.输入&#x2F;输出系统基本概念"></a>1.输入&#x2F;输出系统基本概念</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1.概述"></a>1.1.概述</h2><p><strong>现代计算机结构大体由主机和 I&#x2F;O 设备（外设）。I&#x2F;O 的意思就是 Input&#x2F;Output，意为输入和输出。I&#x2F;O 设备就是指可以将数据输入到计算机，或者可以接受计算机输出数据的外部设备</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170807128.png" alt="image-20230417080703038" loading="lazy"></p><p><strong>常见的 I&#x2F;O 设备如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170807266.png" alt="image-20230417080719167" loading="lazy"></p><p><strong>主机是通过 I&#x2F;O 接口（又称为 I&#x2F;O 控制器或设备控制器）来协调它和外部设备之间的数据传输的</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170807454.png" alt="image-20230417080738398" loading="lazy"></p><ul><li>I&#x2F;O 控制器多种多样，也会制定相应的标准，比如下面用于控制 USB 设备的 I&#x2F;O 接口。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170808431.png" alt="image-20230417080809367" loading="lazy"></p><p><strong>I&#x2F;O 控制器本质就是一块芯片，会被集成在主板上</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170808242.png" alt="image-20230417080833164" loading="lazy"></p><h2 id="1-2-I-x2F-O-系统的基本组成"><a href="#1-2-I-x2F-O-系统的基本组成" class="headerlink" title="1.2.I&#x2F;O 系统的基本组成"></a>1.2.I&#x2F;O 系统的基本组成</h2><h3 id="1-2-1-I-x2F-O-硬件和-I-x2F-O-软件"><a href="#1-2-1-I-x2F-O-硬件和-I-x2F-O-软件" class="headerlink" title="1.2.1.I&#x2F;O 硬件和 I&#x2F;O 软件"></a>1.2.1.I&#x2F;O 硬件和 I&#x2F;O 软件</h3><ul><li><p><strong>I&#x2F;O 硬件：包括外部设备，I&#x2F;O 接口，I&#x2F;O 总线。</strong></p></li><li><p><strong>I&#x2F;O 软件：包括驱动程序、用户程序、管理程序、升级补丁等等，通常采用 I&#x2F;O 指令和通道指令实现主机和 I&#x2F;O 设备的信息交换。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170809209.png" alt="image-20230417080938149" loading="lazy"></p><h3 id="1-2-2-I-x2F-O-指令和通道指令"><a href="#1-2-2-I-x2F-O-指令和通道指令" class="headerlink" title="1.2.2.I&#x2F;O 指令和通道指令"></a>1.2.2.I&#x2F;O 指令和通道指令</h3><ul><li><p><strong>I&#x2F;O 指令：是 CPU 指令的一部分。其格式与普通指令格式稍有区别，操作码指明了 CPU 要对 I&#x2F;O 接口做什么，命令码指明了 I&#x2F;O 接口要对设备做什么</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170819122.png" alt="image-20230417081928042" loading="lazy"></p></li><li><p><strong>通道指令：是指<font color='orange'>通道能识别的指令</font>。<font color='red'>通道程序</font>提前编制好<font color='red'>放在主存中</font>，在含有通道的计算机中，CPU 执行 I&#x2F;O 指令对通道发出命令，由通道执行一系列<font color='red'>通道指令</font>，代替 CPU 对 I&#x2F;O 设备进行管理</strong>。</p></li></ul><p>注：I&#x2F;O 指令与普通指令格式略有不同，操作码指明了CPU要对I&#x2F;O 接口做什么，命令码指明了I&#x2F;O 接口要对设备做什么。</p><h2 id="1-3-I-x2F-O-控制方式概述"><a href="#1-3-I-x2F-O-控制方式概述" class="headerlink" title="1.3.I&#x2F;O 控制方式概述"></a>1.3.I&#x2F;O 控制方式概述</h2><p>下面是一段简单的 C 语言代码，在其运行过程中会涉及 <strong>CPU 和 I&#x2F;O 设备之间的交互。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> i<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待输入</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i=%c\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当程序执行到<code>scanf(&quot;%c&quot;,&amp;i)</code>时，屏幕会不断闪烁，此时 CPU 正在等待键盘输入数据。它们会通过 I&#x2F;O 接口进行数据交互，所依靠的是如下三个重要的寄存器。</strong></p><ul><li><strong>数据寄存器</strong>：存放主机要输出到外设或外设要输入到主机的数据。</li><li><strong>控制寄存器</strong>：反映了某个外设所要执行的动作。</li><li><strong>状态寄存器</strong>：反映了当前外设的状态（比如打印机是否就绪，是否忙碌等等）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170810648.png" alt="image-20230417081042591" loading="lazy"></p><p><strong>当输入完数据之后，CPU 是如何确定此时可以被取走数据了呢？共有三种 I&#x2F;O 控制方式</strong>：</p><ul><li><strong>程序查询方式</strong>：CPU 不断轮询检查 I&#x2F;O 控制器中的 “状态寄存器”，检测到状态为“已完成” 之后，再从数据寄存器中取出输入数据。</li><li><strong>程序中断方式</strong>：等待键盘 I&#x2F;O 时 CPU 可以先去执行其他程序，键盘 I&#x2F;O 完成之后 I&#x2F;O 控制器向 CPU 发出中断请求，CPU 响应中断请求，并取走数据。</li><li><strong>DMA控制方式：</strong>主存与高速&#x2F;O设备之间有一条直接数据通路（DMA总线）。CPU向DMA接口发出“读&#x2F;写”命令，并指明主存地址、磁盘地址、读写数据量等参数。DMA控制器自动控制磁盘与主存的数据读写，每完成一整块数据读写（如1KB为一整块），才向CPU发出一次中断请求。DMA控制器与主存每次传送1个字当传送完一整块数据后才向CPU发出中断请求。</li></ul><p><strong>这三种方式具体的控制过程是本章的核心，所以这里就不多解释了，否则非但解释不清，而且大家还会感觉很乱</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170812468.png" alt="image-20230417081254404" loading="lazy"></p><p><strong>思考：</strong>对于快速&#x2F;O设备，如“磁盘”，每准备好一个字就给CPU发送一次中断请求，会导致什么问题？<br><strong>答：</strong>CPU需要花大量的时间来处理中断服务程序，CPU利用率严重下降。</p><h2 id="1-4-通道控制方式了解"><a href="#1-4-通道控制方式了解" class="headerlink" title="1.4.通道控制方式了解"></a>1.4.通道控制方式了解</h2><ul><li>我们的个人电脑的 I&#x2F;O 设备是有限的，所以 CPU 管理起来绰绰有余，但是像大型商业机或服务器的 I&#x2F;O 设备数目是相当多的，如果还用 CPU 来管理，那显然不合理。</li><li>通道是具有特殊功能的处理器能对&#x2F;o设备进行统一管理。</li></ul><p><strong>通道控制方式：除了上述三种控制方式外，在通道控制方式中，通道是一种具有特殊功能的处理器，可以对 I&#x2F;O 设备进行统一管理。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170815386.png" alt="image-20230417081546329" loading="lazy"></p><p>**通道可以理解为 <font color='red'>“弱鸡版” 的 CPU</font>，通道可以识别并执行一系列的<font color='red'>通道指令</font>**。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170817135.png" alt="image-20230417081712075" loading="lazy"></p><h1 id="2-外部设备之输入和输出设备"><a href="#2-外部设备之输入和输出设备" class="headerlink" title="2.外部设备之输入和输出设备"></a>2.外部设备之输入和输出设备</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170852912.png" loading="lazy"></p><p><strong>外部设备又称为外围设备，是除了主机以外的，能直接或间接与计算机交换信息的装置，分为</strong>：</p><ul><li><strong>输入设备</strong>：用于向计算机系统输入命令和文本、数据等信息的部件。<strong>键盘和鼠标</strong>是最基本的输入设备。</li><li><strong>输出设备</strong>：用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。<strong>显示器和打印机</strong>是最基本的输出设备。</li><li><strong>外存设备</strong>：是指除计算机内存及 CPU 缓存以外的存储器。<strong>硬磁盘、光盘</strong>等是最基本的外存设备。</li></ul><h2 id="2-1-输入设备"><a href="#2-1-输入设备" class="headerlink" title="2.1.输入设备"></a>2.1.输入设备</h2><h3 id="2-1-1-键盘"><a href="#2-1-1-键盘" class="headerlink" title="2.1.1.键盘"></a>2.1.1.键盘</h3><p><strong>键盘：键盘是最常用的输入设备，通过它可以发出命令或输入数据。每个键相当于一个开关，当按下键时，电信号连通；当松开键时，弹簧把键弹起，电信号断开。键盘输入信息可以分为如下三个步骤</strong>：</p><ul><li>查出按下的是哪个键。</li><li>将该键翻译成能被主机接受的<strong>编码</strong>，比如 ASCII 码。</li><li>将编码传送给主机。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170823939.png" alt="image-20230417082331851" loading="lazy"></p><h3 id="2-1-2-鼠标"><a href="#2-1-2-鼠标" class="headerlink" title="2.1.2.鼠标"></a>2.1.2.鼠标</h3><p><strong>鼠标：鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系，常用的有机械式和光电式两种</strong>：</p><ul><li><p>光电式：光电式鼠标使用一个小型的光学传感器来检测桌面上的纹理和移动。当鼠标移动时，传感器通过检测纹理的变化来传输信号给计算机。光电式鼠标通常使用发光二极管和光敏二极管来检测鼠标的移动。</p></li><li><p>机械式：采用机械开关来检测鼠标的移动。在每个开关下方有一个小电机，当鼠标移动时，电机会转动，触发开关，传输信号给计算机。机械式鼠标通常使用滚轮和光学传感器来跟踪鼠标的移动。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170823615.png" alt="image-20230417082350539" loading="lazy"></p></li></ul><h2 id="2-2-输出设备"><a href="#2-2-输出设备" class="headerlink" title="2.2.输出设备"></a>2.2.输出设备</h2><h3 id="2-2-1-显示器"><a href="#2-2-1-显示器" class="headerlink" title="2.2.1.显示器"></a>2.2.1.显示器</h3><h4 id="2-2-1-1-分类"><a href="#2-2-1-1-分类" class="headerlink" title="2.2.1.1.分类"></a>2.2.1.1.分类</h4><p><strong>按显示设备所用的显示器件分类</strong>：</p><ul><li><p><strong>阴极射线管（CRT）显示器：</strong>CRT显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极和荧光粉涂层及玻璃外壳5部分组成。具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短<del>等目前前LCD难以超过的优点</del>。</p></li><li><p><strong>液晶显示器（LCD）</strong></p><ul><li><p>原理：利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。</p></li><li><p>特点：体积小、重量轻、省电、无辐射、绿色环保、画面柔、不伤眼等。</p></li></ul></li><li><p><strong>LED（发光二极管） 显示器</strong></p><ul><li>原理：通过控制半导体发光二极管进行显示，用来显示文字、图形、图像等各种信息。</li></ul></li><li><p>…….</p></li></ul><p>注：LCD与LED是两种不同的显示技术，LCD是由液态晶体组成的显示屏，而LED则是由发光二极管组成的显示屏。与LCD相比，LED显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。</p><p><strong>按所显示的信息分类</strong></p><ul><li><strong>字符显示器：</strong>显示字符的方法以点阵为基础。<font color='orange'>点阵是指由m×n个点组成的阵列</font>。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔将<font color='orange'>点阵存入由ROM构成的字符发生器</font>中，在CRT进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中0和1代码不同控制扫描电子束的开或关，从而在屏幕上显示出字符。对应于每个字符窗口，所需显示<font color='orange'>字符的ASCII代码被存放在视频存储器VRAM中</font>，以备刷新。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170841117.png" alt="image-20230417084123043" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170843984.png" alt="image-20230417084314904" loading="lazy"></p><ul><li><p><strong>图形显示器</strong>：将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为了在屏幕上保留持久稳定的图像，需要按定的频率对屏幕进行反复刷新。这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。</p><ul><li><strong>按扫描方式不同可分为：</strong><ul><li>光栅扫描显示器</li><li>随机扫描显示器</li></ul></li></ul></li><li><p><strong>图像显示器</strong></p></li></ul><h4 id="2-2-1-2-参数信息"><a href="#2-2-1-2-参数信息" class="headerlink" title="2.2.1.2.参数信息"></a>2.2.1.2.参数信息</h4><p><strong>①：屏幕大小</strong></p><ul><li>以<strong>对角线长度</strong>表示，常用的有 12~29 英寸。</li></ul><p><strong>②：分辨率</strong></p><ul><li>所能表示的<strong>像素个数</strong>，屏幕上的每个光点就是一个像素，以宽、高的像素乘积表示。例如：800×600、1024×768 和 1280×1024 等等。</li></ul><p><strong>③：灰度级</strong></p><ul><li>是指黑白显示器中所显示的像素点的<strong>亮暗差别</strong>，在彩色显示器中则表现为<strong>颜色的不同</strong>。灰度级越多，<strong>图像层次就越清晰逼真</strong>。典型的有 8 位（256 级）、16 位等。<font color='cornflowerblue'>n位可以表示2^n^种不同的亮度或颜色</font>。</li></ul><p><strong>④：刷新率</strong></p><ul><li><strong>光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称之为刷新</strong>。刷新率是<strong>指单位时间内扫描整个屏幕内容的次数</strong>，按照人的视觉生理，刷新频率大于 30Hz 时才不会感到闪烁，通常显示器<font color='green'>刷新频率</font>在 60Hz~120Hz。</li></ul><p><strong>⑤：VRAM（显存）</strong></p><ul><li><p>也称为**<font color='yellow'>刷新存储器</font><strong>，为了不断提高刷新图像的信号，</strong>必须把每一帧的图像信息存储在刷新存储器中**。其存储内容由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量就越大。</p></li><li><p><strong><font color='cornflowerblue'>VRAM 容量 &#x3D; 分辨率 × 灰度级位数</font></strong></p></li><li><p><strong><font color='cyan'>VRAM 带宽 &#x3D; 分辨率 × 灰度级位数 × 帧频</font></strong>  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170825589.png" alt="image-20230417082500517" loading="lazy"></p><p>$1440*<em>900</em>3B≈3.7MB$（一帧的大小即为显存的理论最小值）</p><p>如果显示器刷新率&#x3D;60Hz，则显存带宽至少要$3.7*60&#x3D;222MB&#x2F;S$</p></li></ul><p>注：现代计算机中，显存除了作为当前显示帧的缓存，还会用于保存即将渲染的图像数据。集成显卡计算机中，通常分配一片内存作为显存。</p><h3 id="2-2-2-打印机"><a href="#2-2-2-打印机" class="headerlink" title="2.2.2.打印机"></a>2.2.2.打印机</h3><h4 id="2-2-2-1-按印字原理不同分类"><a href="#2-2-2-1-按印字原理不同分类" class="headerlink" title="2.2.2.1.按印字原理不同分类"></a>2.2.2.1.按印字原理不同分类</h4><ul><li><p><strong>击打式打印机</strong>：利用机械动作<strong>使印字机与色带或纸相撞</strong>而打印字符。如：机打发票银行回执单（防伪性好）。</p><ul><li><p>优点：设备成本低印字质量好。</p></li><li><p>缺点：噪声大速度慢。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170847073.png" alt="image-20230417084743014" loading="lazy"></p><ul><li><p><strong>非击打式打印机</strong>：采用<strong>电、磁、光、喷墨等物理或化学方法</strong>印刷字符。</p><ul><li>优点：速度快噪声小。</li><li>缺点：成本高。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170848667.png" alt="image-20230417084805581" loading="lazy"></p><h4 id="2-2-2-2-按打印机工作方式不同分类"><a href="#2-2-2-2-按打印机工作方式不同分类" class="headerlink" title="2.2.2.2.按打印机工作方式不同分类"></a>2.2.2.2.按打印机工作方式不同分类</h4><ul><li><p><strong>串行打印机：</strong> <strong>逐字</strong>打印，速度慢。</p></li><li><p><strong>行式打印机：</strong> <strong>逐行</strong>打印，速度快。</p></li></ul><h4 id="2-2-2-3-按工作方式不同分类"><a href="#2-2-2-3-按工作方式不同分类" class="headerlink" title="2.2.2.3.按工作方式不同分类"></a>2.2.2.3.按工作方式不同分类</h4><p><strong>针式打印机</strong>：</p><ul><li><strong>原理</strong>：在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需内容。</li><li><strong>特点</strong>：针式打印机擅长 “多层复写打印”，实现各种票据或蜡纸等的打印。它工作原理简单，造价低廉，耗材(色带) 便宜，但打印分辨率和打印速度不够高。</li></ul><p><strong>喷墨打印机</strong>：</p><ul><li><strong>原理</strong>：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色墨滴，按一定的比例混合出所要求的颜色。</li><li><strong>特点</strong>：打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快; 但防水性差，高质量打印需要专用打印纸。</li></ul><p><strong>激光打印机</strong>：</p><ul><li><p><strong>原理</strong>：计算机输出的二进制信息，经过调制后的<a href="https://so.csdn.net/so/search?q=%E6%BF%80%E5%85%89&spm=1001.2101.3001.7020">激光</a>束扫描，在感光鼓上形成潜像，再经过显影、车印和定影，便在纸上得到所需的字符或图像。</p></li><li><p><strong>特点</strong>：打印质量高、速度快、噪声小、处理能力强; 但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓 (也称为硒鼓) 是激光打印机的核心部件。</p></li></ul><h1 id="3-I-x2F-O接口"><a href="#3-I-x2F-O接口" class="headerlink" title="3.I&#x2F;O接口"></a>3.I&#x2F;O接口</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170919346.png" alt="image-20230417091913236" loading="lazy"></p><h2 id="3-1-I-x2F-O-接口（I-x2F-O-控制器）"><a href="#3-1-I-x2F-O-接口（I-x2F-O-控制器）" class="headerlink" title="3.1.I&#x2F;O 接口（I&#x2F;O 控制器）"></a>3.1.I&#x2F;O 接口（I&#x2F;O 控制器）</h2><p><strong>I&#x2F;O 接口（I&#x2F;O 控制器）：是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上有很大的差异，接口正是为了解决这些差异而设置的</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170855108.png" alt="image-20230417085504048" loading="lazy"></p><h2 id="3-2-I-x2F-O-接口的功能"><a href="#3-2-I-x2F-O-接口的功能" class="headerlink" title="3.2.I&#x2F;O 接口的功能"></a>3.2.I&#x2F;O 接口的功能</h2><p><strong>I&#x2F;O 接口的主要功能：</strong></p><ul><li><strong>实现主机和外设的通信联络控制</strong>：解决主机与外设<strong>时序配合问题</strong>，协调<strong>不同工作速度的外设和主机之间的信息交换</strong>，以保证整个计算机系统能<strong>统一，协调地工作</strong>。</li><li><strong>进行地址译码和设备选择</strong>：CPU 送来外设的地址码后，<strong>接口必须对地址进行译码以产生设备选择信</strong>息，使主机能和指定外设交换信息。</li><li><strong>实现数据缓冲</strong>：CPU 与外设之间的速度往往不匹配，为了<strong>消除速度差异</strong>，接口必须设置<strong>数据缓冲寄存器</strong>，用于数据的暂存，以避免速度不一致而丢失数据。</li><li><strong>信号格式的转换</strong>：外设与主机两者的电平，数据格式都可能存在差异，<strong>接口应提供计算机与外设的信号格式的转换功能</strong>，如电平转换，并 &#x2F; 串或串 &#x2F; 并转换，模 &#x2F; 数或数 &#x2F; 模转换等等。</li><li><strong>传送控制命令和状态信息</strong>：CPU 要启动某一外设时，<strong>通过接口中的命令寄存器向外设发出启动命令</strong>；外设准备就绪时，则<strong>将 “准备好” 状态信息送回接口中的状态寄存器</strong>，并反馈给 CPU。外设向 CPU 提出中断请求，CPU 也有相应的<strong>响应信号</strong>反馈给外设。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170855622.png" alt="image-20230417085539566" loading="lazy"></p><h2 id="3-3-I-x2F-O-接口基本结构"><a href="#3-3-I-x2F-O-接口基本结构" class="headerlink" title="3.3.I&#x2F;O 接口基本结构"></a>3.3.I&#x2F;O 接口基本结构</h2><p><strong>I&#x2F;O 接口基本结构：</strong></p><ul><li><strong>内部接口</strong>：与<strong>系统总线相连</strong>，实质上是与<strong>内存、CPU</strong> 相连。<del>数据的传输只能是并行传输</del> （注意这句话要辩证的看待，早期计算机的确是靠并行，但现在趋势是<strong>从并行转向串行</strong>）。</li><li><strong>外部接口</strong>：通过接口电缆<strong>与外设相连</strong>，外部接口的数据传输可能是串行方式，因此 I&#x2F;O 接口需要具有<strong>串 &#x2F; 并转换功能。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170856406.png" alt="image-20230417085618338" loading="lazy"></p><p><strong>实际图：</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170856050.png" alt="image-20230417085634957" loading="lazy"></p><h2 id="3-4-I-x2F-O-接口的工作原理"><a href="#3-4-I-x2F-O-接口的工作原理" class="headerlink" title="3.4.I&#x2F;O 接口的工作原理"></a>3.4.I&#x2F;O 接口的工作原理</h2><p><strong>I&#x2F;O 接口的工作原理：</strong></p><ul><li><strong>发命令</strong>：CPU 发送<font color='red'>命令字</font>（控制字）到 <strong>I&#x2F;O 控制寄存器</strong>中，向设备发送命令（此过程需要驱动程序的协助），然后在 I&#x2F;O 控制逻辑的控制下对设备发出相应命令。</li><li><strong>读状态</strong>：CPU 从状态寄存器中<strong>读取<font color='red'>状态字</font><strong>，获得设备或 I&#x2F;O 控制器的</strong>状态信息。</strong></li><li><strong>读写数据</strong>：从<strong>数据缓冲寄存器</strong>发送或读取数据，完成主机与外设的数据交换。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170857829.png" alt="image-20230417085756756" loading="lazy"></p><p><strong>注意</strong>：</p><ul><li>控制寄存器、状态寄存器在使用时间上是错开的，因此可以将其合二为一，使用一个寄存器完成两项功能。</li><li>上图中的各种寄存器称为 <strong>I&#x2F;O 端口</strong>（数据端口，状态端口，控制端口）。</li><li>CPU 通过<strong>地址线</strong>指明它要读写数据的端口。</li><li>CPU 通过<strong>控制线</strong>发出读写 I&#x2F;O 端口的信号、中断请求信号等。</li><li>CPU 通过<strong>数据线</strong>读写数据，读取状态和中断类型号等等。</li><li><strong>每个设备对应一组寄存器</strong>，操作不同的寄存器就是在操作不同的设备。</li></ul><h2 id="3-5-I-x2F-O-端口及其编址"><a href="#3-5-I-x2F-O-端口及其编址" class="headerlink" title="3.5.I&#x2F;O 端口及其编址"></a>3.5.I&#x2F;O 端口及其编址</h2><p>I&#x2F;O 端口是指接口电路中可被 CPU 直接访问的寄存器，主要有<strong>数据端口，状态端口和控制端口</strong>，若干端口加上相应的控制逻辑电路组成接口。通常，<strong>CPU 能对数据端口进行读写操作，但对状态端口只能进行读操作，对控制端口只能进行写操作</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170859575.png" alt="image-20230417085906494" loading="lazy"></p><p><strong>I&#x2F;O 端口及其编址：I&#x2F;O 端口要想能够被 CPU 访问，就必须要对各个端口进行编号，每个端口对应一个端口地址，编址方式有统一编址和独立编址两种</strong>。</p><h3 id="3-5-1-统一编址"><a href="#3-5-1-统一编址" class="headerlink" title="3.5.1.统一编址"></a>3.5.1.统一编址</h3><p><strong>统一编址：又称存储器映射方式，是把 I&#x2F;O 端口当作存储器的单元进行地址分配，这种方式 CPU 不需要设置专门的 I&#x2F;O 指令，用统一的<font color='cyan'>访存指令</font>就可以访问 I&#x2F;O 端口。</strong>靠不同的地址码区分内存和I&#x2F;O设备。访存类的指令都可以访问I&#x2F;O端口<br>（RISC机器常用）。</p><ul><li><strong>优点</strong>：不需要<strong>专门的输入&#x2F;输出指令</strong>，所有访存指令都可直接访问端口，程序设计灵活性高；端口有较大的编址空间读写控制逻辑电路简单。</li><li><strong>缺点</strong>：端口占用了主存地址空间，使主存地址空间变小外设寻址时间长（地址位数多，地址译码速度慢）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170859867.png" alt="image-20230417085942810" loading="lazy"></p><p>例如：系统总线中地址线共10根，则可以访问的存储单元个数为2^10^&#x3D;1024个，假设要给10个I&#x2F;O端口编址：</p><ol><li>0~9表示I&#x2F;O地址，10~1023为主存单元地址。</li><li>0~1013表示主存单元地址，1014~1023为10地址。</li><li>10~19表示I&#x2F;O地址，0~9、20~1023为主存单元地址。</li></ol><h3 id="3-5-2-独立编址"><a href="#3-5-2-独立编址" class="headerlink" title="3.5.2.独立编址"></a>3.5.2.独立编址</h3><p><strong>独立编址：又称 I&#x2F;O 映射方式，I&#x2F;O 端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的 I&#x2F;O 指令来访问 I&#x2F;O 端口。</strong></p><p>靠<font color='cyan'>不同的指令</font>区分内存和I&#x2F;O设备。只能用专门的<font color='cyan'>I&#x2F;O指令</font>访问<font color='cyan'>I&#x2F;O端口</font>（Intel处理器常用，IN、OUT就是IO指令）。</p><ul><li><strong>优点</strong>：使用专用I&#x2F;O指令，程序编制清晰；I&#x2F;O端口地址位数少，地址译码速度快；I&#x2F;O端口的地址不占用主存地址空间。</li><li><strong>缺点</strong>：I&#x2F;O<strong>指令少</strong>，一般<strong>只能对端口进行传送操作</strong>，程序设计灵活性差；尤其需要 CPU 提供存储器读写、I&#x2F;O设备读&#x2F;写两组控制信号，增加了控制逻辑电路的复杂性。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170901911.png" alt="image-20230417090130856" loading="lazy"></p><h2 id="3-6-I-x2F-O-接口的类型"><a href="#3-6-I-x2F-O-接口的类型" class="headerlink" title="3.6.I&#x2F;O 接口的类型"></a>3.6.I&#x2F;O 接口的类型</h2><p><strong>按数据传送方式分类：</strong></p><ul><li><p>并行接口：一个字节或一个字所有位同时传送。</p></li><li><p>串行接口：一位一位的传送。</p></li></ul><p>注：这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，<del>数据总是并行传送的</del>。接口要完成数据格式转换。</p><p><strong>按主机访问 I&#x2F;O 设备的控制方式分类：</strong></p><ul><li>程序查询接口</li><li>中断接口</li><li>DMA 接口</li></ul><p><strong>按功能选择的灵活性分类：</strong></p><ul><li>可编程接口</li><li>不可编程接口</li></ul><h2 id="3-7-I-x2F-O接口的连接电路"><a href="#3-7-I-x2F-O接口的连接电路" class="headerlink" title="3.7.I&#x2F;O接口的连接电路"></a>3.7.I&#x2F;O接口的连接电路</h2><p><strong>唐版教材示意图：</strong></p><ul><li><p>数据线&#x3D;数据总线</p></li><li><p>设备选择线&#x3D;地址总线</p></li><li><p>状态线、命令线&#x3D;控制总线</p></li></ul><p><strong>I&#x2F;O接口的功能（具体操作）</strong>：</p><ul><li>设备选址</li><li>传送命令</li><li>传送数据</li><li>反映I&#x2F;O设备的工作状态</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170928668.png" alt="image-20230417092857613" loading="lazy"></p><h2 id="3-8-I-x2F-O接口的基本结构"><a href="#3-8-I-x2F-O接口的基本结构" class="headerlink" title="3.8.I&#x2F;O接口的基本结构"></a>3.8.I&#x2F;O接口的基本结构</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170932534.png" alt="image-20230417093245453" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170933514.png" alt="image-20230417093333441" loading="lazy"></p><h1 id="4-I-x2F-O方式之程序查询方式"><a href="#4-I-x2F-O方式之程序查询方式" class="headerlink" title="4.I&#x2F;O方式之程序查询方式"></a>4.I&#x2F;O方式之程序查询方式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171031360.png" alt="image-20230417103139282" loading="lazy"></p><h2 id="4-1-I-x2F-O-控制方式"><a href="#4-1-I-x2F-O-控制方式" class="headerlink" title="4.1.I&#x2F;O 控制方式"></a>4.1.I&#x2F;O 控制方式</h2><p><strong>I&#x2F;O 控制方式：I&#x2F;O 系统实现主机与 I&#x2F;O 设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的 I&#x2F;O 方式有程序查询，程序中断，DMA 和通道等等，其中前两种方式更依赖于 CPU 中程序指令的执行</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170937416.png" alt="image-20230417093715340" loading="lazy"></p><h2 id="4-2-程序查询方式"><a href="#4-2-程序查询方式" class="headerlink" title="4.2.程序查询方式"></a>4.2.程序查询方式</h2><p><strong>程序查询方式：信息交换的控制完全由主机程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行 I&#x2F;O 操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</strong></p><ul><li><p><strong>特点</strong>： CPU 一旦启动 I&#x2F;O，必须停止现行程序的运行，并在现行程序中插入一段程序。<strong>因此有 “踏步” 等待现象，CPU 与 I&#x2F;O 串行工作。</strong></p></li><li><p><strong>优点</strong> ：接口设计<strong>简单</strong>，设备量少。</p></li><li><p><strong>缺点</strong>：CPU 在信息传送过程中要花费很多时间用于查询和等待，而且在一段时间年内只能和一台外设交换信息，<strong>效率大大降低。</strong></p></li></ul><p><strong>大致流程如下</strong>：</p><ol><li>CPU 执行初始化程序，并预置传送参数。</li><li>向 I&#x2F;O 接口发出命令字，启动 I&#x2F;O 设备。</li><li>从外设接口读取状态信息。</li><li>CPU 不断查询 I&#x2F;O 设备状态，直到外设准备就绪。</li><li>传送一次数据。</li><li>修改地址和计数器参数。</li><li>判断传送是否结束，若未结束转至第 3 步，直到计数器为 0。</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170938678.png" alt="image-20230417093850598" loading="lazy"></p><h2 id="4-3-相关例题"><a href="#4-3-相关例题" class="headerlink" title="4.3.相关例题"></a>4.3.相关例题</h2><p>在程序查询方式的输入 &#x2F; 输出系统中，假设不考虑处理时间，每一个查询操作需要 100 个时钟周期，CPU 的时钟频率为 50MHz。现有鼠标和硬盘两个设备，而且 CPU 必须每秒对鼠标进行 30 次查询，硬盘以 32 位字长为单位传输数据，即每 32 位被 CPU 查询一次，传输率为 $2 X 2 ^{20} B&#x2F;s$。求 CPU 对这两个设备查询所花费的时间比率，由此可得出什么结论?</p><p><strong>从时间的角度理解：</strong></p><p>一个时钟周期为： $ \frac{1}{50MHz} &#x3D;  20ns$。</p><p>一个查询操作耗时：$100×20 ns&#x3D;2000ns$。</p><p><strong>①对于鼠标</strong>  </p><p>每秒查询鼠标耗时：$30×2000ns&#x3D;60000 ns  $</p><p>查询鼠标所花费的时间比率：$\frac{60000ns}{1s}&#x3D;0.006 % $ </p><p><strong>②对于硬盘</strong>  </p><p>每 32 位需要查询一次，每秒传送 $2× 2^{20}B  $</p><p>每秒需要查询 $ \frac{2×2^{20}B}{4B}&#x3D;2^{19} $ 次  。</p><p>查询硬盘耗时： $2^{19} ×2000ns&#x3D;512×1024×2000 n  \approx 1.05× 10^{9} ns  $</p><p>查询硬盘所花费的时间比率： $\frac{1.05×10^{9}ns}{1s}  &#x3D; 105 % $</p><p>可见，即使 CPU 将全部时间都用于对硬盘的查询，也不能满足磁盘传输的要求，因此CPU 一般不采用程序查询方式与磁盘交换信息。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170948022.png" alt="image-20230417094802946" loading="lazy"></p><h1 id="5-I-x2F-O方式之程序中断方式"><a href="#5-I-x2F-O方式之程序中断方式" class="headerlink" title="5.I&#x2F;O方式之程序中断方式"></a>5.I&#x2F;O方式之程序中断方式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171009439.png" alt="image-20230417100951303" loading="lazy"></p><h2 id="5-1-中断的基本概念"><a href="#5-1-中断的基本概念" class="headerlink" title="5.1.中断的基本概念"></a>5.1.中断的基本概念</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170954542.png" alt="image-20230417095413455" loading="lazy"></p><p><strong>中断：中断是指在计算机执行现行程序的过程中，出现某些急需要处理的异常情况或特殊请求，CPU 暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕之后 CPU 又自动返回现行程序的断点处，继续执行原程序。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170951948.png" alt="image-20230417095131882" loading="lazy"></p><p><strong>CPU 在程序中安排好于某个时刻启动某台外设，然后 CPU 继续执行原来的程序，不需要像查询方式那样一直等待设备就绪。在可以响应中断的条件下，CPU 暂时中止现在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成之后，CPU 返回原来的程序。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170954995.png" alt="image-20230417095443930" loading="lazy"></p><p>中断时 CPU 会离开原来的程序而跑去执行其他程序，那么原来的程序是如何保证执行完成的确定性？也就是说不能出现 CPU 回来时还有 “_<strong>这些程序究竟有没有执行过？</strong>_” 这样的疑问，这一点和操作系统中锁的含义类似。<strong>因此为了实现操作的原子性，我们也需要这样一把锁，保证 CPU 在执行一段程序时不会受到中断的干扰，或者说在这个确定的周期内 CPU 必须保证确确实实执行完了原来的程序，然后才能响应中断，我们把这样的锁称之为 CPU 的关中断和开中断。</strong></p><ul><li><p><strong>关中断</strong>：不会响应中断信号</p></li><li><p><strong>开中断</strong>：响应中断信号  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170952865.png" alt="image-20230417095214801" loading="lazy"></p></li></ul><p>如何实现呢？还记得 PSW标志位吗？<strong>其中的 IF(Interrupt Flag) 如果为 1 表示开中断（允许中断），如果为 0 表示关中断（不允许中断）。</strong></p><ul><li><strong>注意</strong>：IF&#x3D;0 屏蔽的是<strong>普通中断</strong>，但是像掉电，关机这种中断是无法被屏蔽的，也是必须被响应的。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170952060.png" alt="image-20230417095257001" loading="lazy"></p><h2 id="5-2-中断执行流程"><a href="#5-2-中断执行流程" class="headerlink" title="5.2.中断执行流程"></a>5.2.中断执行流程</h2><p><strong>中断执行流程</strong></p><ul><li><strong>中断请求： 中断源向 CPU 发送中断请求信号。</strong></li><li><strong>中断响应：响应中断的条件。</strong></li><li><strong>中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。</strong></li><li><strong>中断处理：中断隐指令和中断服务程序。</strong></li></ul><h3 id="5-2-1-中断请求"><a href="#5-2-1-中断请求" class="headerlink" title="5.2.1.中断请求"></a>5.2.1.中断请求</h3><p><strong>中断请求：每个中断源向 CPU 发出中断请求的时间是随机的，因此为了记录中断时间并区分不同的中断源，中断系统需要对每个中断源设置中断请求触发器<code>INTR</code>，当其状态为 “1” 时，表示中断源有请求，这些触发器可组成中断请求标记寄存器，该寄存器可以集成在 CPU 中，也可以分散在各个中断源中。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170955438.png" alt="image-20230417095518380" loading="lazy"></p><h4 id="5-2-1-1-内中断和外中断"><a href="#5-2-1-1-内中断和外中断" class="headerlink" title="5.2.1.1.内中断和外中断"></a>5.2.1.1.内中断和外中断</h4><ul><li><p><strong>外中断</strong>：是指来自<strong>处理器和内存以外的部件</strong>引起的中断，包括 <strong>I&#x2F;O 设备发出的 I&#x2F;O 中断、外部信号中断 (如用户按 Esc 键)，以及各种定时器引起的时钟中断</strong>等。外中断在狭义上一般称为中断 (后文若未说明，一般是指外中断)。</p></li><li><p><strong>内中断</strong>：是指在<strong>处理器和内存内部产生的中断</strong>，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断及用户态到核心态的切换等。</p></li></ul><h4 id="5-2-1-2-硬件中断和软件中断"><a href="#5-2-1-2-硬件中断和软件中断" class="headerlink" title="5.2.1.2.硬件中断和软件中断"></a>5.2.1.2.硬件中断和软件中断</h4><ul><li><p><strong>硬件中断</strong>：通过<strong>外部的硬件</strong>产生的中断。属于<strong>外中断。</strong></p></li><li><p><strong>软件中断</strong>：通过<strong>某条指令</strong>产生的中断，这种中断是可以通过编程实现的。属于<strong>内中断。</strong></p></li></ul><h4 id="5-2-1-3-非屏蔽中断和可屏蔽中断"><a href="#5-2-1-3-非屏蔽中断和可屏蔽中断" class="headerlink" title="5.2.1.3.非屏蔽中断和可屏蔽中断"></a>5.2.1.3.非屏蔽中断和可屏蔽中断</h4><ul><li><p><strong>非屏蔽中断</strong>：是一种<strong>硬件中断</strong>，此种中断通过不可屏蔽中断请求<code>NMI</code>控制，<strong>不受中断标志位<code>IF</code>的影响</strong>，即使在关中断 (IF&#x3D;0) 的情况下也会被响应。</p></li><li><p><strong>可屏蔽中断</strong>：也是一种<strong>硬件中断</strong>，此种中断通过中断请求标记触发器<code>INTR</code>控制，<strong>且受中断标志位<code>IF</code>的影响</strong>，在关中断情况下不接受中断请求。</p></li></ul><h3 id="5-2-2-中断判优"><a href="#5-2-2-中断判优" class="headerlink" title="5.2.2.中断判优"></a>5.2.2.中断判优</h3><p><strong>中断判优：由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需要通过中断判优逻辑确定响应哪一个中断源的请求，中断系统在任一瞬间只能响应一个中断源的请求。</strong></p><p><strong>用硬件实现中断判优依靠硬件排队器</strong></p><ul><li>中断会按照优先级排布，当较高优先级发出中断时通过逻辑与非结果会使较低优先级的中断请求信号输出为 0，以此完成判优。</li><li>计算机大多采用硬件判优。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170955713.png" alt="image-20230417095532647" loading="lazy"></p><p><strong>用软件实现中断判优依靠查询程序</strong></p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170955658.png" alt="image-20230417095545595" style="zoom:150%;" / loading="lazy"><p><strong>不同中断有不同的优先级，这些优先级是规定好的</strong>。</p><ul><li><strong>硬件中断</strong>属于最高级，其次是软件中断。</li><li><strong>非屏蔽中断优于可屏蔽中断。</strong></li><li><strong>DMA 请求优于 I&#x2F;O 设备传送的中断请求。</strong></li><li>高速设备优于低速设备。</li><li>输入设备优于输出设备。</li><li>实时设备优于普通设备。</li></ul><h3 id="5-2-3-中断响应"><a href="#5-2-3-中断响应" class="headerlink" title="5.2.3.中断响应"></a>5.2.3.中断响应</h3><p><strong>中断响应：CPU 响应中断满足的三个条件</strong>：</p><ul><li>中断源有<strong>中断请求</strong>。</li><li>CPU 允许中断及<strong>开中断。</strong></li><li>一条指令执行完毕，且<strong>没有更紧迫的任务。</strong></li></ul><h3 id="5-2-4-中断隐指令"><a href="#5-2-4-中断隐指令" class="headerlink" title="5.2.4.中断隐指令"></a>5.2.4.中断隐指令</h3><h4 id="5-2-4-1-中断隐指令概念"><a href="#5-2-4-1-中断隐指令概念" class="headerlink" title="5.2.4.1.中断隐指令概念"></a>5.2.4.1.中断隐指令概念</h4><p><strong>中断隐指令：CPU 响应中断后，经过某些操作，就会转去执行中断服务程序，这些操作是由硬件直接实现的，称其为中断隐指令。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170956770.png" alt="image-20230417095620686" loading="lazy"></p><p><strong>中断隐指令并不是指令系统中的一条真正的指令，而是cPU在检测到中断请求时自动完成的一系列动作，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令，其完成的操作如下</strong>：</p><ul><li><strong>关中断</strong>：在中断服务程序中，为了<strong>保护中断现场</strong> (即 CPU 主要寄存器中的内容) 不被新的中断所打断，必须关中断，以此<strong>保证被中断的程序在中断服务程序执行完毕后能继续正确地执行</strong>。</li><li><strong>保存断点</strong>：为保证在中断服务程序执行完毕后能<strong>正确地返回原来的程序</strong>，必须将原来程序的断点（即 PC 的内容）<strong>保存</strong>起来。这一点在 <a href="">(计算机组成原理) 第五章中央处理器 - 指令执行过程（取指周期、间址周期、执行周期和中断周期）</a>中有过详细介绍。</li><li><strong>引出中断服务程序</strong>：其实质是<strong>取出中断服务程序的入口地址并传送给程序计数器 PC。</strong></li></ul><h4 id="5-2-4-2-确定中断服务程序的入口地址的方法"><a href="#5-2-4-2-确定中断服务程序的入口地址的方法" class="headerlink" title="5.2.4.2.确定中断服务程序的入口地址的方法"></a>5.2.4.2.确定中断服务程序的入口地址的方法</h4><p><strong>其中，确定中断服务程序的入口地址共有如下两种方法</strong>：</p><ul><li><strong>软件查询法</strong></li><li><strong>硬件向量法</strong></li></ul><p><strong>软件查询法</strong>：CPU 必须找到中断服务程序的入口地址，称之为<strong>中断向量</strong>。系统中的全部中断向量会集中存放到存储器的某个区域内，这个存放中断向量的存储器称之为<strong>中断向量表</strong>，也即服务程序入口地址表。</p><ul><li><p><strong>中断向量</strong>可以理解为函数的指针。</p></li><li><p><strong>中断向量地址</strong>就是指向函数指针的指针  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304170958274.png" alt="image-20230417095815193" loading="lazy"></p></li></ul><p><strong>硬件向量法</strong>：依靠<strong>排队器</strong>，每一个中断服务被响应后会有其对应的输入，<strong>由中断向量地址形成部件映射后便会形成独特的向量</strong>，最终会由向量地址找到对应的入口地址  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171001666.png" alt="image-20230417100132593" loading="lazy"></p><h3 id="5-2-5-中断处理"><a href="#5-2-5-中断处理" class="headerlink" title="5.2.5.中断处理"></a>5.2.5.中断处理</h3><p><strong>中断服务程序的主要任务如下【此部分可结合 <a href="">(计算机组成原理) 第五章中央处理器 - 第二节：指令执行过程（取指周期、间址周期、执行周期和中断周期）</a>理解】。</strong></p><ul><li><p><strong>保护现场：</strong> 保存<strong>通用寄存器和状态寄存器</strong>的内容（即保存 ACC 寄存器的值），以便返回原程序后可以<strong>恢复 CPU 环境</strong>，可以使用堆栈，也可以使用特定存储单元。</p></li><li><p><strong>中断服务：</strong> 主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲寄存器 （中断服务的过程中有可能会修改 ACC 寄存器的值）。</p></li><li><p><strong>恢复现场：</strong> 通过<strong>出栈指令或取数指令</strong>把之前保存的信息送回寄存器中。</p></li><li><p><strong>中断返回：</strong> 通过<strong>中断返回指令回到原程序断点处。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171002103.png" loading="lazy"></p><h2 id="5-3-多重中断和中断屏蔽技术"><a href="#5-3-多重中断和中断屏蔽技术" class="headerlink" title="5.3.多重中断和中断屏蔽技术"></a>5.3.多重中断和中断屏蔽技术</h2><h3 id="5-3-1-单重中断和多重中断"><a href="#5-3-1-单重中断和多重中断" class="headerlink" title="5.3.1.单重中断和多重中断"></a>5.3.1.单重中断和多重中断</h3><ul><li><p><strong>单重中断：CPU 在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而 CPU 对新的中断请求不予响应。</strong></p></li><li><p><strong>多重中断：CPU 在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，若 CPU 暂停现行的中断服务程序，转去执行新的中断请求。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171004775.png" alt="image-20230417100419711" loading="lazy"></p><p>实现多重中断需要格外注意关中断和开中断的时机，以及屏蔽字（中断屏蔽技术）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171004764.png" alt="image-20230417100436704" loading="lazy"></p><h3 id="5-3-2-中断屏蔽技术"><a href="#5-3-2-中断屏蔽技术" class="headerlink" title="5.3.2.中断屏蔽技术"></a>5.3.2.中断屏蔽技术</h3><p><strong>中断屏蔽技术：多重中断虽然支持暂停一个中断服务程序然后再响应另一个中断，但不是所有中断都会响应，像键盘这些低速设备优先级并不高，所以就需要一个屏蔽字，指明接下来哪些中断信号应该被忽视</strong>。</p><p><strong>中断屏蔽技术主要用于多重中断，CPU 要具备多重中断的功能，需要满足下列条件</strong>：</p><ul><li>在中断服务程序中提前设置<strong>开中断</strong>指令。</li><li><strong>优先级别高的中断源有权中断优先级低的中断源。</strong></li><li>每个中断源都有一个<strong>屏蔽触发</strong>器，1 表示屏蔽该中断源的请求，0 表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个<strong>屏蔽字寄存器</strong>，屏蔽字寄存器的内容称为<strong>屏蔽字。</strong></li></ul><p><strong>具体来说</strong>：</p><ul><li>一般用 <strong><code>1</code>表示屏蔽 <strong>，</strong>0 表示正常申请。</strong></li><li><strong>每个中断源对应一个屏蔽字</strong>（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）。</li><li>屏蔽字中<code>1</code>越多，优先级越高。每个屏蔽字中至少有一个<code>1</code>（<strong>至少要能够屏蔽自身的中断</strong>）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171005835.png" alt="image-20230417100528747" loading="lazy"></p><p>设某机有 4 个中断源 A、B、C、D,其硬件排队优先次序为 A&gt;B&gt;C&gt;D, 现要求将中断处理次序改为 D&gt;A&gt;C&gt;B。  </p><ol><li>写出每个中断源对应的屏蔽字。 </li><li>按下图所示的时间轴给出的 4 个中断源的请求时刻，画出 CPU 执行程序的轨迹。设每个中断源的中断服务程序时间均为 20us。</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171007168.png" alt="image-20230417100749101" loading="lazy"></p><h2 id="5-4-程序中断方式"><a href="#5-4-程序中断方式" class="headerlink" title="5.4.程序中断方式"></a>5.4.程序中断方式</h2><ul><li>讲完了前面那么多关于中断的预备知识后，现在回归主题——<strong>引入中断系统后如何控制 I&#x2F;O 系统的数据读写工作</strong>。</li></ul><p><strong>程序中断方式：在正常情况下，CPU 正在运行某段程序，该程序有可能使用到外部设备。比如从该外部设备输入一个字符</strong>。</p><ul><li>首先会向该 I&#x2F;O 设备发出 I&#x2F;O 指令，启动该设备，接着外部设备就会去工作，<strong>准备 CPU 想要的数据和信息。</strong></li><li>在外部工作的过程中，<strong>CPU 可以继续运行。</strong></li><li>当 I&#x2F;O 设备完成工作后，会给 CPU 发送一个<strong>中断请求信号</strong>。</li><li>如下图，CPU 在 K 处检测到了信号，于是对其进行处理，处理完成之后返回 K+1 位置，继续运行。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171015519.png" alt="image-20230417101523445" loading="lazy"></p><p>假定 CPU 主频为 50MHz，CPI 为 4。设备 D 采用异步串行通信方式向主机传送 7 位 ASCII 字符，通信规程中有 1 位奇校验位和 1 位停止位，从 D 接收启动命令到字符送入 I&#x2F;0 端口需要 0.5ms。</p><p>1）每传送一个字符，在异步串行通信线上共需传输多少位？在设备D持续工作过程中，每秒钟最多可向I&#x2F;O端口送入多少个字符？</p><p>2）设备 D 采用中断方式进行输入 &#x2F; 输出，示意图如下: </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171015809.png" alt="image-20230417101536740" loading="lazy"></p><p>I&#x2F;O 端口每收到一个字符申请一次中断，中断响应需 10 个时钟周期，中断服务程序共有 20 条指令，其中第 15 条指令启动D工作。若 CPU 需从 D 读取 1000 个字符，则完成这一任务所需时间大约是多少个时钟周期? CPU 用于完成这一任务的时间大约是多少个时钟周期? 在中断响应阶段 CPU 进行了哪些操作?  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171020088.png" loading="lazy"></p><h1 id="5-5-拓展"><a href="#5-5-拓展" class="headerlink" title="5.5.拓展"></a>5.5.拓展</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171014321.png" alt="无标题" loading="lazy"></p><h1 id="6-I-x2F-O方式之DMA方式"><a href="#6-I-x2F-O方式之DMA方式" class="headerlink" title="6.I&#x2F;O方式之DMA方式"></a>6.I&#x2F;O方式之DMA方式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171030615.png" alt="image-20230417103011520" loading="lazy"></p><h2 id="6-1-什么是-DMA-方式"><a href="#6-1-什么是-DMA-方式" class="headerlink" title="6.1.什么是 DMA 方式"></a>6.1.什么是 DMA 方式</h2><p><strong>DMA 方式：DMA 方式是一种完全由硬件进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU 与外设并行工作。DMA 方式在外设与内存之间开辟一条 “直接数据通道”，信息传送不再经过 CPU，降低了 CPU 在传送数据时的开销，因此称为直接存储器存取方式。由于数据传送不需要经过 CPU，也就不需要保护，恢复 CPU 现场等繁琐操作。此种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销较大。</strong></p><p><strong>如下图，CPU 向 DMA 控制器指明要输入还是输出、要传送多少个数据、以及数据在主存、外设中的地址</strong>：</p><ul><li><strong>传送前</strong>：接受外设发出的 DMA 请求（外设传送一个字的请求），并向 CPU 发出总线请求。</li><li><strong>传送前</strong>：CPU 响应总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。</li><li><strong>传送时</strong>：确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数。</li><li><strong>传送时</strong>：规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</li><li><strong>传送后</strong>：向 CPU 报告 DMA 操作的结束。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171021304.png" alt="image-20230417102151241" loading="lazy"></p><h2 id="6-2-DMA-控制器组成"><a href="#6-2-DMA-控制器组成" class="headerlink" title="6.2.DMA 控制器组成"></a>6.2.DMA 控制器组成</h2><p><strong>DMA 控制器组成：</strong></p><ul><li><strong>主存地址寄存器</strong>：简称 AR，存放<strong>要交换数据的主存地址。</strong></li><li><strong>传送长度计数器</strong>：简称 WC，记录传送<strong>数据的长度</strong>，计数溢出时，数据即传送完毕，自动发中断请求信号。</li><li><strong>数据缓冲寄存器</strong>：暂存<strong>每次传送的数据。</strong></li><li><strong>DMA 请求触发器</strong>：每当 I&#x2F;O 设备准备好数据，给出一个控制信号，<strong>使 DMA 请求触发器置位。</strong></li><li><strong>控制 &#x2F; 状态逻辑</strong>：由控制和时序电路及状态标志组成，用于<strong>指定传送方向，修改传送参数</strong>，并对 DMA 请求信号和 CPU 相应信号进行协调和同步。</li><li><strong>中断机构</strong>：当一个数据块传送完毕之后触发中断机构，向 CPU 提出中断请求。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171023251.png" alt="image-20230417102322168" loading="lazy"></p><p><strong>注意</strong>：在 DMA 传送过程中，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用，而当 DMA 传送结束之后，将恢复 CPU 的一切权利并开始执行其操作，由此可见，DMA 控制器必须具有控制系统总线的能力。</p><h1 id="6-3-DMA-传送过程"><a href="#6-3-DMA-传送过程" class="headerlink" title="6.3.DMA 传送过程"></a>6.3.DMA 传送过程</h1><h3 id="6-3-1-预处理"><a href="#6-3-1-预处理" class="headerlink" title="6.3.1.预处理"></a>6.3.1.预处理</h3><p><strong>DMA 控制器组成：由 CPU 完成一些必要的准备工作。首先, CPU 执行几条 I&#x2F;O 指令，用以测试 I&#x2F;O 设备状态，再向 DMA 控制器的有关寄存器置初值、设置传送方向，启动该设备等等。然后 CPU 继续执行原来的程序，直到 I&#x2F;O 设备准备好发送的数据（输入情况）或接受的数据（输出情况）时，I&#x2F;O 设备向 DMA 控制器发送 DMA 请求，再由 DMA 控制器向 CPU 发送总线请求，用以传输数据。</strong></p><ul><li>主存起始地址 -&gt;AR</li><li>I&#x2F;O 设备地址 -&gt;DAR</li><li>传送数据个数 -&gt;WC</li><li>启动 I&#x2F;O 设备</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171024204.png" alt="image-20230417102412120" loading="lazy"></p><h3 id="6-3-2-数据传送"><a href="#6-3-2-数据传送" class="headerlink" title="6.3.2.数据传送"></a>6.3.2.数据传送</h3><p><strong>数据传送：DMA 的数据传输可以单字节（或字）为基本单位，也可以数据块为基本单位。对于以数据块为单位的传送（如硬盘），DMA 占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器而非通过 CPU 执行程序实现的，即数据传送阶段完全由 DMA（硬件）控制。</strong></p><ul><li>设备将输入写入 DR，发出 DMA 请求。</li><li>控制逻辑检测到一个数据后，向 CPU 发出总线请求，CPU 给予反馈信号。</li><li>DMA 控制器接管总线，进行数据传送。</li><li>主存地址计数器 + 1，长度计数器 + 1。</li><li>传输完多个字后，长度计数器溢出，溢出信号传送给中断机构，向 CPU 发出中断请求。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171024947.png" alt="image-20230417102425860" loading="lazy"></p><h3 id="6-3-3-后处理"><a href="#6-3-3-后处理" class="headerlink" title="6.3.3.后处理"></a>6.3.3.后处理</h3><p><strong>后处理：DMA 控制器向 CPU 发出中断请求：CPU 执行中断服务程序做 DMA 结束处理，包括校验送入主存的数据是否正确，测试传送过程中是否出错（如果出错则转入诊断程序）以及决定是否继续使用 DMA 传送其他数据块等等。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171025960.png" alt="image-20230417102527875" loading="lazy"></p><p><strong>接着，CPU 继续执行主程序</strong></p><h2 id="6-4-DMA-方式的特点"><a href="#6-4-DMA-方式的特点" class="headerlink" title="6.4.DMA 方式的特点"></a>6.4.DMA 方式的特点</h2><p>主存和 DMA 接口之间有一条 “直接数据通路”，由于 DMA 方式传送数据不需要经过 CPU，因此不必中断线性程序，<strong>I&#x2F;O 主机并行工作，程序和传送并行工作。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171030189.png" loading="lazy"></p><p><strong>DMA 方式特点：</strong></p><ul><li>它使主存与 CPU 的固定联系脱钩，<strong>主存既可以被 CPU 访问，又可以被外设访问。</strong></li><li>在数据块传送时，主存地址的确定、传送数据的计数都有<strong>硬件电路直接实现。</strong></li><li>主存开辟专门的<strong>数据缓冲区</strong>，及时供给和接受外设的数据。</li><li>DMA 传送速度快，CPU 和外设并行工作，<strong>提高了系统效率。</strong></li><li><strong>DMA 在传送开始前要通过程序进行预处理，结束之后要通过中断方式进行后处理。</strong></li></ul><h2 id="6-5-DMA-传送方式"><a href="#6-5-DMA-传送方式" class="headerlink" title="6.5.DMA 传送方式"></a>6.5.DMA 传送方式</h2><p><strong>DMA 传送方式：主存和 DMA 控制器之间有一条数据通路，因此主存和 I&#x2F;O 设备之间交换信息时，不通过 CPU。但是当 I&#x2F;O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器和 CPU 通常采用以下三种方法使用主存</strong>  。</p><h3 id="6-5-1-停止-CPU-访问主存"><a href="#6-5-1-停止-CPU-访问主存" class="headerlink" title="6.5.1.停止 CPU 访问主存"></a>6.5.1.停止 CPU 访问主存</h3><p><strong>停止 CPU 访问主存</strong>：这种方式是当外设需要传送成组数据时，<strong>由 DMA 接口向 CPU 发送一个信号，要求 CPU 放弃地址线、数据线和有关控制线的使用权</strong>，DMA 接口获得总线控制权后，开始进行数据传送。数据传送结束后，DMA 接口通知 CPU 可以使用主存, 并把总线控制权交还给 CPU。<strong>在这种传送过程中，CPU 基本处于不工作状态或保持原始状态。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171026941.png" loading="lazy"></p><h3 id="6-5-2-DMA-和-CPU-交替访问主存"><a href="#6-5-2-DMA-和-CPU-交替访问主存" class="headerlink" title="6.5.2.DMA 和 CPU 交替访问主存"></a>6.5.2.DMA 和 CPU 交替访问主存</h3><p><strong>DMA 和 CPU 交替访问主存</strong>：DMA 与 CPU 交替访存，这种方式适用于 <strong>CPU 的工作周期比主存存取周期长</strong>的情况。例如，若 CPU 的工作周期是 1.2μs，主存的存取周期小于 0.6μs，则可将一个 CPU 周期分为 C1 和 C2 两个周期, 其中 C1 专供 DMA 访存，C2 专供 CPU 访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过 C1 和 C2 <strong>分时控制的。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171027582.png" alt="image-20230417102741513" loading="lazy"></p><h3 id="6-5-3-周期挪用（周期窃取）"><a href="#6-5-3-周期挪用（周期窃取）" class="headerlink" title="6.5.3.周期挪用（周期窃取）"></a>6.5.3.周期挪用（周期窃取）</h3><p><strong>周期挪用（周期窃取）</strong>：这种方式是前面两种的折中操作。<strong>当 I&#x2F;O 设备没有 DMA 请求时，CPU 按程序的要求访问主存，一旦 I&#x2F;O 设备有了 DMA 请求，就会有以下三种情况</strong>：</p><ul><li>**<strong>CPU 不再访存</strong>：因此 I&#x2F;O 的访存请求与 CPU 未发生冲突。</li><li>CPU 正在访存 **：此时必须等待存取周期结束后，CPU 再将总线占有权让出。</li><li><strong>I&#x2F;O 和 CPU 同时请求访存，出现访存冲突</strong>：此时 CPU 要暂时让出总线占有权，由 I&#x2F;O 设备挪用一个或多个存取周期。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171028916.png" alt="image-20230417102829847" loading="lazy"></p><h2 id="6-6-DMA-和中断对比"><a href="#6-6-DMA-和中断对比" class="headerlink" title="6.6.DMA 和中断对比"></a>6.6.DMA 和中断对比</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171028630.png" alt="image-20230417102858560" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组-第六章 总线</title>
      <link href="/posts/c0af4cb/"/>
      <url>/posts/c0af4cb/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总线概述"><a href="#1-总线概述" class="headerlink" title="1.总线概述"></a>1.总线概述</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162137051.png" alt="image-20230416213738949" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171119701.png" loading="lazy"></p><h2 id="1-1-总线相关概念"><a href="#1-1-总线相关概念" class="headerlink" title="1.1.总线相关概念"></a>1.1.总线相关概念</h2><h3 id="1-1-1-总线的定义"><a href="#1-1-1-总线的定义" class="headerlink" title="1.1.1.总线的定义"></a>1.1.1.总线的定义</h3><p><strong>总线：总线是一组能为多个部件分时共享的公共信息传送线路。为什么要采用总线呢？这是因为早期计算机的外部设备非常少，所以大多采用分散连接方式（也就是建立专门的数据传送线路），但是随着时代的发展，外部设备的数量越来越多，因此如果每增加一个外部设备就增加一个线路的话，显然是不合理的。所以为了更好地解决 I&#x2F;O 设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为了总线连接</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162131599.png" alt="image-20230416213125511" loading="lazy"></p><h3 id="1-1-2-总线的特点"><a href="#1-1-2-总线的特点" class="headerlink" title="1.1.2.总线的特点"></a>1.1.2.总线的特点</h3><ul><li><p><strong>共享：是指总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享。</strong></p></li><li><p><strong>。分时：是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162132774.png" alt="image-20230416213238707" loading="lazy"></p><h3 id="1-1-3-总线的特性"><a href="#1-1-3-总线的特性" class="headerlink" title="1.1.3.总线的特性"></a>1.1.3.总线的特性</h3><p><strong>设计总线时要考虑以下特性</strong>：</p><ul><li><strong>机械特性</strong>：尺寸、形状、管脚数、排列顺序。</li><li><strong>电气特性</strong>：传输方向和有效地电平范围。</li><li><strong>功能特性</strong>：每根传输线的功能（地址、数据、控制）。</li><li><strong>时间特性</strong>：信号的时序关系。</li></ul><h2 id="1-2-总线的分类"><a href="#1-2-总线的分类" class="headerlink" title="1.2.总线的分类"></a>1.2.总线的分类</h2><h3 id="1-2-1-按数据的传输格式分类"><a href="#1-2-1-按数据的传输格式分类" class="headerlink" title="1.2.1.按数据的传输格式分类"></a>1.2.1.按数据的传输格式分类</h3><p><strong>串行总线：一次只能发送一个 bit 的数据。</strong></p><ul><li><strong>优点</strong>：只需要一条传输线，<strong>成本低廉</strong>，广泛应用于<strong>长距离传输</strong>；应用于计算机内部时，可以<strong>节省布线空间。</strong></li><li><strong>缺点</strong>：在数据发送和接受的时候，需要进<strong>行拆卸和装配</strong>，要考虑<strong>串行 - 并行转换</strong>的问题。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162131212.png" alt="image-20230416213145146" loading="lazy"></p><p><strong>并行总线：一次可以并行发送多个 bit 的数据</strong>。</p><ul><li><strong>优点</strong>：总线的逻辑<strong>时序比较简单</strong>，电路实<strong>现起来比较容易。</strong></li><li><strong>缺点</strong>：信号线<strong>数量多</strong>，占用<strong>更多布线空间</strong>；远距离传输<strong>成本高昂</strong>；另外，在工作频率较高时，<strong>并行的信号线之间会产生严重干扰</strong>，对每条线等长的要求也越高，所以无法持续提升工作频率。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162131449.png" alt="image-20230416213153373" loading="lazy"></p><h3 id="1-2-2-按总线功能（连接的部件）"><a href="#1-2-2-按总线功能（连接的部件）" class="headerlink" title="1.2.2.按总线功能（连接的部件）"></a>1.2.2.按总线功能（连接的部件）</h3><h4 id="1-2-2-1-片内总线"><a href="#1-2-2-1-片内总线" class="headerlink" title="1.2.2.1.片内总线"></a>1.2.2.1.片内总线</h4><p><strong>片内总线：是芯片内部的总线，它是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线。</strong></p><h4 id="1-2-2-2-系统总线"><a href="#1-2-2-2-系统总线" class="headerlink" title="1.2.2.2.系统总线"></a>1.2.2.2.系统总线</h4><p><strong>系统总线：是计算机系统内各功能部件（CPU、主存、I&#x2F;O 接口）之间的相互连接的总线。按系统总线传输信息内容的不同，又可以分为 3 类：数据总线、地址总线和控制总线。</strong></p><ul><li><p><strong>数据总线（DATA BUS）</strong>：传输功能部件之间的<strong>数据信息</strong>，包括指令和操作数；其<strong>位数（根数）与机器字长、存储字长</strong>有关；<strong>双向</strong>传输。</p></li><li><p><strong>地址总线（ADDRESS BUS）</strong>：用于<strong>指出数据总线上的源数据或目的数据所在的主存单元或 I&#x2F;O 端口的地址</strong>；它是<strong>单向</strong>传输总线；地址总线<strong>的位数与主存地址空间</strong>的大小有关。</p></li><li><p><strong>控制总线（CONTROL BUS）</strong>：传输<strong>控制信息</strong>；一根控制线传输一个信息；<strong>对于单个控制线它是单向的，但是对于整个控制总线来说它是 “双向” 的</strong>，也就是有出（指 CPU 发出的控制信号）和有入（主存或外设返回的反馈信号)。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162132373.png" alt="image-20230416213202302" loading="lazy"></p><p><strong>注意区分数据通路和数据总线</strong></p><ul><li><strong>数据通路</strong>：各个功能部件通过数据总线连接形成的<strong>数据传输路径</strong>，它表示的是数据流经的路径。</li><li><strong>数据总线</strong>：是承载数据流动的<strong>媒介。</strong></li></ul><h4 id="1-2-2-3-通信总线"><a href="#1-2-2-3-通信总线" class="headerlink" title="1.2.2.3.通信总线"></a>1.2.2.3.通信总线</h4><p><strong>通信总线：是在计算机系统之间或计算机系统与其他系统（比如远程设备，测试设备）之间传送信息的总线，也称为外部总线。</strong></p><h3 id="1-2-3-按时序控制方式分类"><a href="#1-2-3-按时序控制方式分类" class="headerlink" title="1.2.3.按时序控制方式分类"></a>1.2.3.按时序控制方式分类</h3><ul><li><strong>同步总线</strong></li><li><strong>异步总线</strong></li></ul><h2 id="1-3-系统总线的结构"><a href="#1-3-系统总线的结构" class="headerlink" title="1.3.系统总线的结构"></a>1.3.系统总线的结构</h2><h3 id="1-3-1-单总线结构"><a href="#1-3-1-单总线结构" class="headerlink" title="1.3.1.单总线结构"></a>1.3.1.单总线结构</h3><p><strong>单总线结构：CPU、主存、I&#x2F;O 设备都连接在一组总线上，允许 I&#x2F;O 设备之间、I&#x2F;O 设备和 CPU 之间或 I&#x2F;O 设备与主存之间直接交换信息。</strong></p><ul><li><strong>优点</strong>：<strong>结构简单</strong>、<strong>成本低</strong>、<strong>易于接入新的设备。</strong></li><li><strong>缺点</strong>：<strong>带宽低、负载重、多个部件只能争用唯一的总线</strong>，且<strong>不支持并行操作</strong>；另外像 CPU、主存它们的速度是很快的，但是像硬盘这些设备速度要很慢，所以这种方式也不科学。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162135431.png" alt="image-20230416213511363" loading="lazy"></p><h3 id="1-3-2-双总线结构"><a href="#1-3-2-双总线结构" class="headerlink" title="1.3.2.双总线结构"></a>1.3.2.双总线结构</h3><p><strong>双总线结构：具有两条总线，一条是主存总线，用于 CPU、主存和通道之间进行数据传送；另一条是 I&#x2F;O 总线，用于多个外部设备与通道之间进行数据传送。</strong></p><ul><li><strong>优点</strong>：将较<strong>低速的 I&#x2F;O 设备从单总线上分离出来</strong>，实现存储器总线和 I&#x2F;O 总线的分离。</li><li><strong>缺点</strong>：需要增加<strong>通道</strong>等硬件设备。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162134614.png" alt="image-20230416213455554" loading="lazy"></p><p><strong>其中通道是指具有特殊功能的处理器，能对 I&#x2F;O 设备进行统一管理。通道程序放在主存中；另外双总线结构还支持突发（猝发）传送（送出一个地址，收到多个地址连续的数据）。</strong></p><h3 id="1-3-3-三总线结构"><a href="#1-3-3-三总线结构" class="headerlink" title="1.3.3.三总线结构"></a>1.3.3.三总线结构</h3><p><strong>三总线结构：在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这三条总线分别为主存总线、I&#x2F;O 总线和 DMA（直接内存访问）总线</strong>。</p><ul><li><strong>优点</strong>：提高了 I&#x2F;O 设备的<strong>性能</strong>，使其能更快地响应命令，提高系统<strong>吞吐量</strong>。</li><li><strong>缺点</strong>：系统工作<strong>效率较低</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162135196.png" alt="image-20230416213524132" loading="lazy"></p><ul><li><strong>主存总线</strong>：用于 <strong>CPU 和内存之间</strong>传送地址、数据和控制信息。</li><li><strong>I&#x2F;O 总线</strong>：用于 C<strong>PU 和各类外设之间</strong>通信。</li><li><strong>DMA 总线</strong>：用于<strong>内存和高速外设之间</strong>直接传送数据。</li></ul><h3 id="1-2-4-四总线结构"><a href="#1-2-4-四总线结构" class="headerlink" title="1.2.4.四总线结构"></a>1.2.4.四总线结构</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162136468.png" alt="image-20230416213657373" loading="lazy"></p><h2 id="1-4-总线性能指标"><a href="#1-4-总线性能指标" class="headerlink" title="1.4.总线性能指标"></a>1.4.总线性能指标</h2><h3 id="1-4-1-串行总线"><a href="#1-4-1-串行总线" class="headerlink" title="1.4.1.串行总线"></a>1.4.1.串行总线</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162142566.png" alt="image-20230416214234513" loading="lazy"></p><ul><li><strong>优点：</strong>只需要一条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间。</li><li><strong>缺点：</strong>在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。</li></ul><h3 id="1-4-2-并行总线"><a href="#1-4-2-并行总线" class="headerlink" title="1.4.2.并行总线"></a>1.4.2.并行总线</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162143113.png" alt="image-20230416214329047" loading="lazy"></p><ul><li>优点：总线的逻辑时序比较简单，电路实现起来比较容易。</li><li>缺点：信号线数量多，占用更多的布线空间；远距离传输成本高昂；由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。</li></ul><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3.总结"></a>1.3.3.总结</h3><ul><li>工作频率相同时，串行总线传输速度比并行总线慢。</li><li>并行总线的工作频率无法持续提高，而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线。</li></ul><hr><p><strong>①：总线<font color='orange'>传输周期</font>（<font color='orange'>总线周期</font>）：<font color='orange'>一次总线操作所需要的时间</font>，通常由若干个总线时钟周期构成。经过一个总线传输周期后就可以完成一组数据的传送</strong></p><ul><li>申请阶段：例如总线仲裁。</li><li>寻址阶段</li><li>传输阶段</li><li>结束阶段：释放总线使用权。</li></ul><hr><p><strong>②：总线<font color='red'>时钟周期</font>：也即<font color='red'>机器的时钟周期</font>，我们知道计算机中会有一个统一的时钟，来控制整个计算机的各个部件，总线自然也要受到时钟的控制。</strong></p><p>需要注意的是，<strong>总线周期与总线时钟周期</strong>的关系有时比较复杂。</p><ul><li>大多数情况下，一个总线周期包含多个总线时钟周期。</li><li>有的时候，一个总线周期就是一个总线时钟周期。</li><li>还有的时候，一个总线时钟周期可以包含多个总线周期。</li></ul><p>关于第三点大家可能会感觉到奇怪，其实有的时候当检测到一个时钟周期的 “上升沿” 和“下降沿”时会分别发出数据  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162135085.png" alt="image-20230416213541016" loading="lazy"></p><hr><p><strong>③：总线<font color='yellow'>工作频率</font>：总线上各种操作的频率，它是<font color='yellow'>总线周期的倒数</font>。</strong></p><p>若总线周期 &#x3D; N 个时钟周期，则总线的工作频率为 &#x3D; 时钟频率 &#x2F; N，**<font color='yellow'>表示一秒内传送了几次数据</font>**。</p><hr><p>④：总线时钟频率：即机器的时钟频率，是<font color='green'>时钟周期的倒数</font>。</p><p>若时钟周期为 T，则时钟频率为 1&#x2F;T，**表示<font color='green'>一秒内有多少个时钟周期</font>**。</p><hr><p><strong>⑤：<font color='cornflowerblue'>总线宽度</font>：又称为总线位宽，它是总线上<font color='cornflowerblue'>同时能够传输的数据位数</font>，通常是指<font color='cornflowerblue'>数据总线的根数</font>。</strong> 比如 32 根就称为 32bit 总线。</p><hr><p><strong>⑥：<font color='cyan'>总线带宽</font>：可以理解为总线的<font color='cyan'>数据传输率</font>，也即<font color='cyan'>单位时间内总线上可以传输数据的位数</font>。</strong> 通常用每秒钟传送信息的字节数来衡量，单位可以用字节 &#x2F; 秒（B&#x2F;s）表示。</p><p>因此有如下公式：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171120264.png" loading="lazy"></p><hr><p><strong>⑦：总线复用：是指一种<font color='purple'>信号线在不同的时间传输不同的信息</font>，这样做可以使用<font color='purple'>较少的成本</font>来传输更多得到信息，节省了成本，但是会使传输效率下降</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162139477.png" alt="image-20230416213930407" loading="lazy"></p><hr><p><strong>⑧：信号线数：是指地址总线、数据总线、控制总线 3 种总线线的根数之和</strong>。</p><h2 id="1-5-相关计算"><a href="#1-5-相关计算" class="headerlink" title="1.5.相关计算"></a>1.5.相关计算</h2><p><strong>这一部分特别爱出有关总线性能的计算问题</strong>。</p><p><img src="https://img-blog.csdnimg.cn/115a4d8d587947e2a9ce3f7ef9229cac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/55141e348db342f3a14348b18bb89890.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/9fd080aa2cdd46e4ae52213adaa355f8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/086831d289054af2ac5cab5a33659dc8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/a223e738f45e4220a1f24af607c1a655.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/71039f7457474585a1a07898b9fd846e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/b83e88ff83cb42e1adbf0ad1d6821dc7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"><br><img src="https://img-blog.csdnimg.cn/4579d7032d314d0a81f950b262ef93d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16" loading="lazy"></p><h1 id="2-总线仲裁"><a href="#2-总线仲裁" class="headerlink" title="2.总线仲裁"></a>2.总线仲裁</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171121451.png" loading="lazy"></p><h2 id="2-1-总线仲裁基本概念"><a href="#2-1-总线仲裁基本概念" class="headerlink" title="2.1.总线仲裁基本概念"></a>2.1.总线仲裁基本概念</h2><h3 id="2-1-1-主设备和从设备"><a href="#2-1-1-主设备和从设备" class="headerlink" title="2.1.1.主设备和从设备"></a>2.1.1.主设备和从设备</h3><p><strong>前面说过，同一时刻只能有一个设备控制总线进行传输，但可以有一个或多个设备从总线接受数据。因此，可以将总线上所连接的各类设备按其对总线有无控制功能分为</strong>：</p><ul><li><strong>主设备</strong>：获得<strong>总线控制权</strong>的设备。</li><li><strong>从设备</strong>：被主设备访问的设备，<strong>只能响应</strong>从设备发来的各种总线命令。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162150422.png" alt="image-20230416215052357" loading="lazy"></p><h3 id="2-1-2-总线仲裁的定义"><a href="#2-1-2-总线仲裁的定义" class="headerlink" title="2.1.2.总线仲裁的定义"></a>2.1.2.总线仲裁的定义</h3><p><strong>总线仲裁：多个主设备同时竞争总线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁。</strong></p><h3 id="2-1-3-为什么要进行总线仲裁"><a href="#2-1-3-为什么要进行总线仲裁" class="headerlink" title="2.1.3.为什么要进行总线仲裁"></a>2.1.3.为什么要进行总线仲裁</h3><p>总线属于共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。为了解决这个问题，应当采用<strong>总线仲裁部件</strong>，<strong>以某种方式选择一个主设备优先获得总线控制权，只有获得了总线控制权的设备，才能传送数据。</strong></p><h3 id="2-1-4-总线仲裁分类"><a href="#2-1-4-总线仲裁分类" class="headerlink" title="2.1.4.总线仲裁分类"></a>2.1.4.总线仲裁分类</h3><p><strong>①：集中仲裁方式</strong></p><ul><li><strong>链式查询方式</strong></li><li><strong>计数器定时查询方式</strong></li><li><strong>独立请求方式</strong></li></ul><p><strong>②：分布仲裁方式</strong></p><h2 id="2-2-集中仲裁"><a href="#2-2-集中仲裁" class="headerlink" title="2.2.集中仲裁"></a>2.2.集中仲裁</h2><p><strong>集中仲裁的工作流程</strong>：</p><ul><li>主设备发出<strong>请求信号。</strong></li><li>。若多个主设备同时要求使用总线，则<strong>总线控制器判优</strong>，仲裁逻辑按照一定的<strong>优先级顺序</strong>确定哪个主设备能够使用总线</li><li><strong>获得总线使用权</strong>的主设备开始传送数据。</li></ul><h3 id="2-2-1-链式查询方式"><a href="#2-2-1-链式查询方式" class="headerlink" title="2.2.1.链式查询方式"></a>2.2.1.链式查询方式</h3><h4 id="2-2-1-1-概述"><a href="#2-2-1-1-概述" class="headerlink" title="2.2.1.1.概述"></a>2.2.1.1.概述</h4><p><strong>链式查询方式：总线上所有的部件共用一根总线请求线（BR），当有部件请求使用总线时，需要经过此线发总线请求信号到总线控制器，由总线控制器检查总线是否忙？若总线不忙，则立即发出总线响应信号，经总线响应线（BG）串行地从一个部件传送到下一个部件，依次查询。</strong></p><ul><li><p><strong>若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件</strong>。</p></li><li><p><strong>若响应信号到达的部件有总线请求，则信号被拦截，不再传下去</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162151041.png" alt="image-20230416215127964" loading="lazy"></p></li></ul><p><strong>注意：</strong></p><ul><li>“<strong>总线忙” 信号的建立者是获得总线控制权的设备。</strong></li><li><strong>离总线控制器越近的部件优先级就越高；离总线控制器越远的部件优先级就越低。</strong></li></ul><h4 id="2-2-1-2-例子"><a href="#2-2-1-2-例子" class="headerlink" title="2.2.1.2.例子"></a>2.2.1.2.例子</h4><ul><li>假设上图中的设备 1 和设备 n 同时想要使用总线，<strong>那么它们都会向 BR 发出总线请求信号。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162152632.png" alt="image-20230416215227562" loading="lazy"></p><ul><li>当总线控制部件检测到请求信号时，它明白其中有设备想要获得总线控制权。</li><li>接着，总线控制部件会通过 <strong>BG 发出总线允许信号</strong>。该信号第一次会通过设备 0，但此时设备 0 并不想要使用总线，因此会让此信号继续往后传递；来到设备 1 后，设备 1 是想要使用总线的，<strong>所以它会接受信号，这也意味着总线控制部件允许它控制总线。</strong></li><li>同时<strong>设备 1 会向 BS 发出总线忙信号，</strong>表明此时总线已经被自己占据。当控制部件检测到 BS 信号时，就明白了此时总线控制权已经分配给了某个设备，于是会<strong>撤销 BG 信号</strong>，看起来就好像 BG 信号被设备 1 截断了一样。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162153272.png" alt="image-20230416215305200" loading="lazy"></p><p>接下来设备 1 就可以使用总线与其他设备进行数据交互了。<strong>当设备 1 使用完总线时，它会撤销总线忙信号。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162153571.png" alt="image-20230416215342495" loading="lazy"></p><p>此时设备 n 还在请求总线，总线控制部件检测到请求信号之后，重复以上步骤即可  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162155512.png" alt="image-20230416215518446" loading="lazy"></p><h4 id="2-2-1-4-优缺点"><a href="#2-2-1-4-优缺点" class="headerlink" title="2.2.1.4.优缺点"></a>2.2.1.4.优缺点</h4><p><strong>其优缺点如下</strong>：</p><ul><li><strong>优点</strong>：链式查询方式<strong>优先级固定</strong>，只需要很少几根控制线就能按一定优先次序实现总线控制，<strong>结构简单，易于扩充。</strong></li><li><strong>缺点</strong>：对硬件电路的故障<strong>十分敏感</strong>，并且<strong>优先级不能更改</strong>。当优先级较高的部件频繁使用总线时，会使优先级较低的部件长期不能使用总线，<strong>产生 “饥饿” 现象。</strong></li></ul><h3 id="2-2-2-计数器查询方式"><a href="#2-2-2-计数器查询方式" class="headerlink" title="2.2.2.计数器查询方式"></a>2.2.2.计数器查询方式</h3><h4 id="2-2-2-1-概述"><a href="#2-2-2-1-概述" class="headerlink" title="2.2.2.1.概述"></a>2.2.2.1.概述</h4><p><strong>计数器查询方式：该方式采用了一个计数器来控制总线使用权，相比链式查询方式多了一组设备地址线，少了一根总线响应线 BG，仍共用一根总线请求线，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数。计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162156297.png" alt="image-20230416215647229" loading="lazy"></p><h4 id="2-2-2-2-例子"><a href="#2-2-2-2-例子" class="headerlink" title="2.2.2.2.例子"></a>2.2.2.2.例子</h4><p>假设上图中的设备 1 和设备 n 通过 BR 发出<strong>总线请求信号。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162200938.png" alt="image-20230416220054864" loading="lazy"></p><p>当总线控制部件检测到请求信号时，它明白其中有设备想要获得总线控制权，此时<strong>计数器开始计数</strong>。比如从 0 开始，这意味着设备地址线上传过来的地址是 0，<strong>表示正在询问设备 0 是否想要控制权，</strong> 由于 0 号设备不想要使用，所以此时计数器变为 1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162201512.png" alt="image-20230416220134432" loading="lazy"></p><p>接着设备 1 发现此时的地址信息是自己的编号，而它正好也想要控制权，<strong>因此它会发出总线忙信号，表示此时已经获得了总线控制权。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162202102.png" alt="image-20230416220235021" loading="lazy"></p><p><strong>当控制部件检测到总线忙信号时，结束仲裁，同时计数器暂停</strong>。接着设备 1 就可以使用总线进行数据交互了。</p><p>使用完成之后，设备 1 会撤销 BS 信号，<strong>如果此时还有请求信号，那么计数器就可以接着计时，然后询问下一个设备是否需要控制总线。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162202102.png" alt="image-20230416220235021" loading="lazy"></p><h4 id="2-2-2-3-优缺点"><a href="#2-2-2-3-优缺点" class="headerlink" title="2.2.2.3.优缺点"></a>2.2.2.3.优缺点</h4><p><strong>优点一：就是计数初始值可以改变优先次序。</strong></p><ul><li>如果计数每次从 0 开始，那么设备的优先级就按顺序排列，固定不变。</li><li>如果计数器从上一次终点开始接着计数，此时设备优先级平等。</li><li>计数器的初始值还可以使用程序控制。</li></ul><p><strong>优点二：就是对电路的故障没有敏感</strong></p><p><strong>缺点一：就是增加了控制总线。</strong></p><ul><li>若设备有 $n$ 个，则需要 $\lceil log_{2}n \rceil $ 条控制线。</li></ul><p><strong>缺点二：就是查询较链式查询复杂。</strong></p><h3 id="2-2-3-独立请求方式"><a href="#2-2-3-独立请求方式" class="headerlink" title="2.2.3.独立请求方式"></a>2.2.3.独立请求方式</h3><h4 id="2-2-3-1-概述"><a href="#2-2-3-1-概述" class="headerlink" title="2.2.3.1.概述"></a>2.2.3.1.概述</h4><p><strong>计数器查询方式：该方式中，每个设备均有一对总线请求线 B R i BR_{i} BRi​和总线允许线 B G i BG_{i} BGi​。当总线上的部件需要使用总线时，经各自的总线请求线发出总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准每个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162203989.png" alt="image-20230416220332923" loading="lazy"></p><h4 id="2-2-3-2-例子"><a href="#2-2-3-2-例子" class="headerlink" title="2.2.3.2.例子"></a>2.2.3.2.例子</h4><p>总线控制部件中有一个排队器，如下，当设备 n 需要使用总线时会发出总线请求信号，轮到该设备使用总线时，该设备再给控制部件发送 BS 信号，告诉控制部件仲裁已经结束，当该设备使用完总线后，会撤销 BS 信号，排队继续进行 。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162205341.png" alt="image-20230416220504255" loading="lazy"></p><h4 id="2-2-3-4-优缺点"><a href="#2-2-3-4-优缺点" class="headerlink" title="2.2.3.4.优缺点"></a>2.2.3.4.优缺点</h4><p><strong>优点</strong></p><ul><li>响应<strong>速度快</strong>，总线允许信号 BG 直接从控制器发送到有关设备，不必在设备之间传递或查询。</li><li>对优先次序的控制相当<strong>灵活。</strong></li></ul><p><strong>缺点一：控制线数量多</strong></p><ul><li>若设备有 n 个，则需要 2n+1 条控制线。其中 + 1 为 BS 线，用于设备向总线控制部件反馈已经是否正在使用总线。</li></ul><p><strong>缺点二：控制逻辑更加复杂。</strong></p><h3 id="2-2-4-三种仲裁方式对比"><a href="#2-2-4-三种仲裁方式对比" class="headerlink" title="2.2.4.三种仲裁方式对比"></a>2.2.4.三种仲裁方式对比</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162205354.png" alt="image-20230416220524283" loading="lazy"></p><h2 id="2-3-分布仲裁"><a href="#2-3-分布仲裁" class="headerlink" title="2.3.分布仲裁"></a>2.3.分布仲裁</h2><p><strong>分布仲裁：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。</strong></p><ul><li>当设备有总线请求时，它们就各自把唯一的仲裁号发送到共享的仲裁总线上。</li><li>每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较。</li><li>如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。</li><li>最后，获胜者的仲裁号保留在仲裁总线上。</li></ul><h1 id="3-总线操作和定时"><a href="#3-总线操作和定时" class="headerlink" title="3.总线操作和定时"></a>3.总线操作和定时</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162220391.png" alt="image-20230416222036296" loading="lazy"></p><h2 id="3-1-总线定时"><a href="#3-1-总线定时" class="headerlink" title="3.1.总线定时"></a>3.1.总线定时</h2><h3 id="3-1-1-总线周期"><a href="#3-1-1-总线周期" class="headerlink" title="3.1.1.总线周期"></a>3.1.1.总线周期</h3><p><strong>总线周期：一个总线周期通常会分为以下几个阶段</strong>：</p><ul><li><p><strong>申请分配阶段：</strong> 由需要使用总线的主模块（主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者，也可将此阶段细分为<strong>传输请求</strong>和<strong>总线仲裁</strong>两个阶段。</p></li><li><p><strong>寻址阶段：</strong> 获得使用权的主模块通过总线发出本次要访问的<strong>从模块的地址及有关命令</strong>，启动参与本次传输的从模块。</p></li><li><p><strong>传输阶段：</strong> 主模块和从模块进行<strong>数据交换</strong>，可单向或双向进行数据传送。</p></li><li><p><strong>结束阶段：</strong> 主模块的有关信息均从系统总线上<strong>撤除</strong>，让出总线使用权。</p></li></ul><h3 id="3-1-2-总线定时"><a href="#3-1-2-总线定时" class="headerlink" title="3.1.2.总线定时"></a>3.1.2.总线定时</h3><p><strong>总线定时：是指双方在总线上交换数据时对时间关系的一种控制。本质是一种协议或规则，主要有以下几种</strong>：</p><ul><li><strong>同步通信（同步定时方式）</strong>：由统一时钟控制数据传送。</li><li><strong>异步通信（异步定时方式）</strong>：采用应答方式，没有公共时钟标准。</li><li><strong>半同步通信</strong>：同步、异步的结合。</li><li><strong>分离式通信</strong>：充分挖掘系统总线每一瞬间的潜力。</li></ul><h2 id="3-2-同步定时方式"><a href="#3-2-同步定时方式" class="headerlink" title="3.2.同步定时方式"></a>3.2.同步定时方式</h2><h3 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1.概述"></a>3.2.1.概述</h3><p><strong>同步定时：总线控制器采用一个统一的时钟信号来协调发送和接受双方的传送定时关系，有如下特点</strong>：</p><ul><li>若干时钟周期产生<strong>相等的时间间隔，每个间隔构成一个总线周期。</strong></li><li>在一个总线周期中，发送方和接受方可以进行<strong>一次数据传送。</strong></li><li>采用统一的时钟，每个部件或设备发送或接受信息都在固定的传送周期中，<strong>一个总线的传送周期结束，下一个总线传送周期开始</strong>。</li></ul><p><strong>例如下图，假设 CPU 作为主设备，某个输入设备作为从设备，那么整个传送过程如下</strong>：</p><ul><li>CPU 在 $ T_{1} $时刻的<strong>上升沿</strong>给出<strong>地址信息</strong>。</li><li>在 $T_{2} $时刻的<strong>上升沿给出读命令</strong>（这里时低电平有效），与地址信息相符合的输入设备按命令进行一系列的内部操作，且<strong>必须在$ T_{3}$​的上升沿来临之前</strong>，将 CPU 所需要的数据送到数据总线上。</li><li>CPU 在 $T_{3} $​时钟周期内，将数据线上的信息传送到内部寄存器中。</li><li>CPU 在 $ T_{4} $​时刻的上升沿<strong>撤销读命令</strong>，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162207231.png" alt="image-20230416220728165" loading="lazy"></p><h3 id="3-2-2-优缺点"><a href="#3-2-2-优缺点" class="headerlink" title="3.2.2.优缺点"></a>3.2.2.优缺点</h3><p><strong>优点</strong></p><ul><li>传送<strong>速度快</strong>、传输<strong>速率高。</strong></li><li>总线控制逻辑<strong>简单。</strong></li></ul><p><strong>缺点</strong></p><ul><li>主从设备属于<strong>强制性同步。</strong></li><li>不能及时进行数据通信的有效性检验，<strong>可靠性较差。</strong></li></ul><p><strong>同步通信适用于总线长度较短以及总线所接部件的存取时间比较接近的系统，否则就会出现诸如 “主设备跟得上总线的速度，而从设备跟不上总线的速度” 这样的尴尬情况。</strong></p><h2 id="3-3-异步定时方式"><a href="#3-3-异步定时方式" class="headerlink" title="3.3.异步定时方式"></a>3.3.异步定时方式</h2><p><strong>异步定时：没有统一的时钟，也没有固定的时钟间隔，完全依靠传送双方相互制约的 “握手” 信号来实现定时控制。</strong></p><ul><li><strong>主设备提出交换信息的 “请求” 信号，经接口传送到从设备。</strong></li><li><strong>从设备接到主设备的请求后，通过接口向主设备发出 “回答” 信号。</strong></li></ul><h3 id="3-3-1-三种异步定时方式"><a href="#3-3-1-三种异步定时方式" class="headerlink" title="3.3.1.三种异步定时方式"></a>3.3.1.三种异步定时方式</h3><p><strong>由于没有统一的时钟信号，所以他们是根据 “请求” 和“回答”信号的撤销是否互锁，分为以下三种类型。可以结合网络中的三次握手理解。</strong></p><ul><li>不互锁方式</li><li>半互锁方式</li><li>全互锁方式</li></ul><h4 id="3-3-1-1-不互锁（速度最快但可靠性最差）"><a href="#3-3-1-1-不互锁（速度最快但可靠性最差）" class="headerlink" title="3.3.1.1.不互锁（速度最快但可靠性最差）"></a>3.3.1.1.不互锁（速度最快但可靠性最差）</h4><ul><li><p><strong>主设备发出 “<font color='red'>请求</font>” 信号后，不必等从设备的 “<font color='orange'>回答</font>” 信号，而是经过一段时间，便撤销 “<font color='red'>请求</font>” 信号，双方不存在互锁关系。</strong></p></li><li><p><strong>从设备接到 “<font color='red'>请求</font>” 信号后，发出 “<font color='orange'>回答</font>” 信号，并经过一段时间后，自动撤销 “<font color='orange'>回答</font>” 信号，双方不存在互锁关系。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162208316.png" alt="image-20230416220824949" loading="lazy"></p><h4 id="3-3-1-2-半互锁"><a href="#3-3-1-2-半互锁" class="headerlink" title="3.3.1.2.半互锁"></a>3.3.1.2.半互锁</h4><ul><li><p><strong>主设备发出 “<font color='red'>请求</font>” 信号后，必须等到从设备的 “<font color='orange'>回答</font>” 信号到来，才撤销 “<font color='red'>请求</font>” 信号，有互锁的关系。</strong></p></li><li><p><strong>从设备在接受到 “<font color='red'>请求</font>” 信号后，发出 “<font color='orange'>回答</font>” 信号，但不需要等到获知主设备的 “<font color='red'>请求</font>” 信号已经撤销，而是隔一段时间后自动撤销 “<font color='orange'>回答</font>” 信号，不存在依赖关系</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162208514.png" alt="image-20230416220834430" loading="lazy"></p><h4 id="3-3-1-3-全互锁（可靠性最强但速度最慢）"><a href="#3-3-1-3-全互锁（可靠性最强但速度最慢）" class="headerlink" title="3.3.1.3.全互锁（可靠性最强但速度最慢）"></a>3.3.1.3.全互锁（可靠性最强但速度最慢）</h4><ul><li><p><strong>主设备发出 “<font color='red'>请求</font>” 信号后，必须要等到从设备的 “<font color='orange'>回答</font>” 信号到来，才撤销 “<font color='red'>请求</font>” 信号，双方存在互锁的关系</strong></p></li><li><p><strong>从设备发出“<font color='orange'>回答</font>”信号，必须待获知主设备 “<font color='red'>请求</font>” 信号已经撤销后，再撤销其 “<font color='orange'>回答</font>” 信号，双方存在互锁关系</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162208187.png" alt="image-20230416220840118" loading="lazy"></p><h3 id="3-2-2优缺点"><a href="#3-2-2优缺点" class="headerlink" title="3.2.2优缺点"></a>3.2.2优缺点</h3><ul><li><strong>优点</strong>：总线周期<strong>长度可变</strong>，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，<strong>自动适应时间的配合</strong>。</li><li><strong>缺点</strong>：同步控制方式<strong>复杂</strong>，速度<strong>慢于</strong>同步定时方式。</li></ul><h2 id="3-4-半同步通信"><a href="#3-4-半同步通信" class="headerlink" title="3.4.半同步通信"></a>3.4.半同步通信</h2><p>半同步通信：统一时钟的基础上，增加一个“等待”响应信号<code>WATT</code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162215594.png" alt="image-20230416221516520" loading="lazy"></p><h2 id="3-5-半分离通信"><a href="#3-5-半分离通信" class="headerlink" title="3.5.半分离通信"></a>3.5.半分离通信</h2><p>上述三种通信的<strong>共同点</strong>一个总线传输周期（以输入数据为例）：</p><ul><li>主模块发地址、命令            <font color='green'>使用总线</font></li><li>从模块准备数据                   <font color='green'>不使用总线</font>         <font color='cornflowerblue'>总线空闲</font></li><li>从模块向主模块发数据        <font color='green'>使用总线</font></li></ul><p><strong>分离式通信的一个总线传输周期：</strong></p><ul><li>子周期1：<font color='cornflowerblue'>主模块</font>申请<font color='cornflowerblue'>占用总线</font>，使用完后放弃总线的使用权。</li><li>子周期2：<font color='cornflowerblue'>从模块</font>申请<font color='cornflowerblue'>占用总线</font>，将各种信息送至总线上。</li></ul><p><strong>特点：</strong></p><ul><li>各模块均有权申请占用总线。</li><li>采用同步方式通信，不等对方回答。</li><li>各模块准备数据时，不占用总线。</li><li>总线利用率提高。</li></ul><h1 id="4-总线标准"><a href="#4-总线标准" class="headerlink" title="4.总线标准"></a>4.总线标准</h1><h2 id="4-1-总线标准是什么"><a href="#4-1-总线标准是什么" class="headerlink" title="4.1.总线标准是什么"></a>4.1.总线标准是什么</h2><p><strong>总线标准</strong>：<strong>是国际上公布或推荐的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范</strong>。按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需要根据总线标准的要求完成自方面的功能要求，而无需了解对方接口的要求  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162221056.png" alt="image-20230416222100965" loading="lazy"></p><p><strong>根据总线在计算机系统中的位置，总线可以分为</strong>：</p><ul><li><strong>系统总线</strong>：通常<strong>与 CPU 直接相连</strong>，用于连接 CPU 与北桥芯片，或 CPU 与主存。</li><li><strong>局部总线</strong>：没有直接与 CPU 连接，通常是连<strong>接高速的北桥芯片</strong>，用于连接很多重要的硬件部件（比如显卡和声卡等）。</li><li><strong>设备总线、通信总线</strong>：通常 ** 由南桥芯片控制，** 用于连接计算机与计算机，或连接计算机与外部 I&#x2F;O 设备。</li></ul><h2 id="4-2-总线标准总结"><a href="#4-2-总线标准总结" class="headerlink" title="4.2.总线标准总结"></a>4.2.总线标准总结</h2><p><strong>总线标准总览如下，其中加粗部分为考试重点标准，各总线详细介绍请向下翻阅</strong>：</p><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td><strong>ISA</strong></td><td>Industry Standard Architecture</td><td>8MHz</td><td>8/16</td><td>16MB/s</td><td>系统总线</td></tr><tr><td><strong>EISA</strong></td><td>Extended ISA</td><td>8MHz</td><td>32</td><td>32MB/s</td><td>系统总线</td></tr><tr><td>VISA</td><td>Video Industry Standard Architecture</td><td>33MHz</td><td>32</td><td>132MB/s</td><td>局部总线</td></tr><tr><td><strong>PCI</strong></td><td>Peripheral Component Interconnect</td><td>33/66MHz</td><td>32/64</td><td>528MB/s</td><td>局部总线</td></tr><tr><td>AGP</td><td>Accelerated Graphics Port</td><td>-</td><td>-</td><td>X1:266MB/s；X8:2.1GB/s</td><td>局部总线</td></tr><tr><td><strong>PCI-E</strong></td><td>PCI-Express(3GIO)</td><td>-</td><td>-</td><td>10GB/s 以上</td><td>串行</td></tr><tr><td>SCSI</td><td>Small Computer System Interface</td><td>-</td><td>-</td><td>640MB/s</td><td>智能通用接口</td></tr><tr><td>RS-232C</td><td>Recommended Standard</td><td>-</td><td>-</td><td>20Kbps</td><td>串行通信总线</td></tr><tr><td>PCMCIA</td><td>Personal Computer Memory Card International Association</td><td>-</td><td>-</td><td>90MB/s</td><td>便携通用接口</td></tr><tr><td><strong>USB</strong></td><td>Universal Serial Bus International Association</td><td>-</td><td>-</td><td>1280MB/s</td><td>设备总线、串行</td></tr><tr><td>IDE(ATA)</td><td>Integrated Drive Electronics</td><td>-</td><td>-</td><td>100MB/s</td><td>硬盘光驱接口</td></tr><tr><td>SATA</td><td>Serial Advanced Technology Attachment</td><td>-</td><td>-</td><td>600MB/s</td><td>串行硬盘接口</td></tr></tbody></table><p><strong>思维导图如下（发展趋势）</strong>  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162221954.png" alt="image-20230416222142846" loading="lazy"></p><h2 id="4-3-总线标准详述"><a href="#4-3-总线标准详述" class="headerlink" title="4.3.总线标准详述"></a>4.3.总线标准详述</h2><h3 id="4-3-1-系统总线标准"><a href="#4-3-1-系统总线标准" class="headerlink" title="4.3.1.系统总线标准"></a>4.3.1.系统总线标准</h3><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>ISA</td><td>Industry Standard Architecture</td><td>8MHz</td><td>8/16</td><td>16MB/s</td><td>系统总线</td></tr><tr><td>EISA</td><td>Extended ISA</td><td>8MHz</td><td>32</td><td>32MB/s</td><td>系统总线</td></tr></tbody></table><blockquote><p>最早的 PC 总线是 IBM 公司 1981 年在 PC&#x2F;XT 电脑采用的系统总线，它基于 8bit 的 8088 处理器，被称为 PC 总线或者 PC&#x2F;XT 总线。</p><p>1984 年，IBM 推出基于 16-bit Intel 80286 处理器的 PC&#x2F;AT 电脑，系统总线也相应地扩展为 16bit，并被称呼为 PC&#x2F;AT 总线。而为了开发与 IBM PC 兼容的外围设备，行业内便逐渐确立了以 IBM PC 总线规范为基础的 ISA (工业标准架构: Industry Standard Architecture ) 总线。</p><p>ISA 总线最大传输速率仅为 8MB&#x2F;s，数据传送需要 CPU 或 DMA 接口来管理，传输速率过低、CPU 占用率高、占用硬件中断资源等，很快使 ISA 总线在飞速发展的计算机技术中成为瓶颈。不支持总线仲裁。</p><p>因此在 1988 年，康柏、惠普等 9 个厂商协同把 ISA 扩展到 32 -bit, 这就是著名的 EISA (Extended ISA，扩展 ISA) 总线。EISA 总线的工作频率仍旧仅有 8MHz，并且与 8&#x2F;16bit 的 ISA 总线完全兼容，带宽提高了一 - 倍，达到了 32MB&#x2F;s。从 CPU 中分离出了总线控制权，支持多个总线主控器和突发传送。可惜的是，EISA  仍旧由于速度有限，并且成本过高，在还没成为标准总线之前，在 20 世纪 90 年代初的时候，就给 PCI 总线给取代了。</p></blockquote><h3 id="4-3-2-局部总线标准"><a href="#4-3-2-局部总线标准" class="headerlink" title="4.3.2.局部总线标准"></a>4.3.2.局部总线标准</h3><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>VISA</td><td>Video Industry Standard Architecture</td><td>33MHz</td><td>32</td><td>132MB/s</td><td>局部总线</td></tr></tbody></table><blockquote><p>CPU 的主频提高，数据宽度增大及处理能力的增强使得系统的性能迅速提高。虽然系统总线在不断发展，仍然跟不上软件和 CPU 的发展速度，仍然不能充分利用 CPU 的强大处理能力。大部分时间内，CPU 都处于等待状态，特别是在日益强大的 CPU 处理能力和存储器容量的支持和激励下，操作系统和应用程度变得越来越复杂，而显示卡和硬盘控制器因位于 8 位或 16 位系统 I&#x2F;0 总线上，相对极高的 CPU 的速度而言，传输数据的速度低的多，从而影响了系统的整体工作效率。</p><p>因此，为提高系统的整体性能，解决总线传输问题的一个办法是将外设直接挂在 CPU 局部总线上并以 CPU 速度运行，将外设挂到 CPU 局部总线能够极大地提高外设的运行速度，而成本只有轻微的上浮，这个性能 &#x2F; 价格比为局部总线创造了一个巨大的市场潜力。</p><p>1991 年) 视频电子标准协会针对视频显示的高数据传输率要求而推出了 VESA 总线，又叫做视频局部总线 (VESA local bus)，  简称 VL-BUS 总线， 由 CPU 总 线演化而来，是针对多媒体 PC 要求高速传送活动图像的大量数据应运而生的。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>PCI</td><td>Peripheral Component Interconnect</td><td>33/66MHz</td><td>32/64</td><td>528MB/s</td><td>局部总线</td></tr></tbody></table><blockquote><p>由于 ISA&#x2F;EISA 总线速度缓慢，造成硬盘、显示卡还有其它的外围设备只能通过慢速并且狭窄的瓶颈来发送和接受数据，使得整机的性能受到严重的影响。为了解决这个问题，1992 年 Intel 在发布 486 处理器的时候，也同时提出了 32 -bit 的 PCI (周边组件互连) 总线。  最早提出的 PCI 总线工作在 33MHz 频率之下，传输带宽达到了 133MB&#x2F;s (33MHz X 32bit&#x2F;8)，比 ISA 总线有了极大的改善，基本上满足了当时处理器的发展需要。目前计算机上广泛采用的是这种 32-bit、33MHz 的 PCI 总线，可扩展到 64bit。</p></blockquote><p>特点如下</p><ol><li><strong>高性能</strong>，不依附于某个具体的处理器，支持突发传送</li><li>良好的<strong>兼容性</strong></li><li>支持<strong>即插即用</strong></li><li>支持<strong>多主设备。</strong></li><li>具有与处理器和存储器子系统完全<strong>并行操作</strong>的能力</li><li>提供数据和地址<strong>奇偶校验</strong>的能力</li><li>可扩充性好，可采用<strong>多层结构</strong>提高驱动能力</li><li>采用<strong>多路复用技术</strong>，减少了总线引脚个数</li></ol><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>AGP</td><td>Accelerated Graphics Port</td><td>-</td><td>-</td><td>X1:266MB/s；X8:2.1GB/s</td><td>局部总线</td></tr></tbody></table><blockquote><p>PCI 总线是独立于 CPU 的局部总线，可将显示卡、声卡、网卡、硬盘控制器等高速的外围设备直接挂在 CPU 总线上，打破了瓶颈，使得 CPU 的性能得到充分的发挥。可惜的是，由于 PCI 总线只有 133MB&#x2F;s 的带宽，对付声卡、网卡、视频卡等绝大多数输入 &#x2F; 输出设备也许显得绰绰有舍，但对于胃口越来越大的 3D 显卡却力不从心，并成为了制约显示子系统和整机性能的瓶颈。因此，PCI 总线的补充 —-AGP 总线就应运而生了。Intel 于 1996 年 7 月正式推出了 AGP (加速图形接口，Accelerated Graphics Port) 接口，这是显示卡专用的局部总线，是基于 PCI 2.1 版规范并进行扩充修改而成，工作频率为 66MHz，1X 模式下带宽为 266MB&#x2F;S，是 PCI 总 线的两倍。后来依次又推出了 AGP 2X、AGP 4X，现在则是 AGP 8X，传输速度达到了 2. 1GB&#x2F;S。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>PCI-E</td><td>PCI-Express(3GIO)</td><td>-</td><td>-</td><td>10GB/s 以上</td><td>串行</td></tr></tbody></table><blockquote><p>Intel 在 2001 年春季的 IDF 上，正式公布了旨在取代 PCI 总线的第三代 I&#x2F;0 技术，最后却被正式命名为 PCI-Express,Express 意思是高速、特别快的意思。PCI Express 总线 是一种完全不同于过去 PCI 总线的一种全新总线规范，与 PCI 总线共享并行架构相比，PCI Express 总线是一种点对点串行连接的设备连接方式，点对点意味着每 - 一个 PCI Express 设 备都拥有自己独立的数据连接，各个设备之间并发的数据传输互不影响，而对于过去 PCI 那种共享总线方式，PCI 总线上只能有一个设备进行通信，一旦 PCI 总线上挂接的设备增多，每个设备的实际传输速率就会下降，性能得不到保证。在传输速率方面，PCIExpress 总线利用串行的连接特点将能轻松将数据传输速度提到—个很高的频率，达到远超出 PCI 总线的传输速率。与此同时，PCI Express 总线支持双向传输模式，还可以运行全双工模式。支持热拔插。</p></blockquote><h3 id="4-3-3-设备总线标准"><a href="#4-3-3-设备总线标准" class="headerlink" title="4.3.3.设备总线标准"></a>4.3.3.设备总线标准</h3><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>RS-232C</td><td>Recommended Standard</td><td>-</td><td>-</td><td>20Kbps</td><td>串行通信总线</td></tr></tbody></table><blockquote><p>RS-232C 是应用于串行二进制交换的数据终端设备 (DTE) 和数据通信设备 (DCE)之间的标准接口。RS- 232C 是美国电子工业协会 EIA (Electronic Industry Association) 联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的一. 种串行物理接口标准。RS 是英文 “推荐标准” 的缩写，232 为标识号，C 表示修改次数。RS- -232C 总线标准设有 25 条信号线，包括一个主通道和一一个辅助通道。该标准规定采用 - 一个 25 个脚的 DB–25 连接器，对连接器的每个引脚的信号内容加以规定，还对各种信号的电平加以规定。后来 IBM 的 PC 机将 RS232 简化成了 DB-9 连接器，从而成为事实标准。而工业控制的 RS -232 口一般只使用 RXD、TXD、 GND 三 条线。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>SCSI</td><td>Small Computer System Interface</td><td>-</td><td>-</td><td>640MB/s</td><td>智能通用接口</td></tr></tbody></table><blockquote><p>SCSI (小型<a href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F&spm=1001.2101.3001.7020">计算机系统</a>接口) 是一种用于计算机和智能设备之间 (硬盘、软驱、光驱、打印机、扫描仪等) 系统级接口的独立处理器标准。SCSI 是一种智能的通用接口标准。IDE 的工作方式需要 CPU 的全程参与，CPU 读写数据的时候不能再进行其他操作，这种情况在 Windows 95&#x2F;NT 的多 任务操作系统中，自然就会导致系统反应的大大减慢。而 SCSI 接口，则完全通过独立的高速的 SCSI 卡来控制数据的读写操作，CPU 就不必浪费时间进行等待，显然可以提高系统的整体性能。不过，IDE 接口为改善这个问题也做了很大改进，已经可以使用 DMA 模式而非 PI0 模式来读写，数据的交换由 DMA 通道负责，对 CPU 的占用可大大减小。尽管如此，比较 SCSI 和 IDE 在 CPU 的占用率，还是可以发现 SCSI 仍具有相当的优势。SCSI 的扩充性比 IDE 大，- - 般每个 IDE 系统可有 2 个 IDE 通道，总共连 4 个 IDE 设备，而 SCSI 接口可连接 7- -15 个设备，比 IDE 要多很多，而且连接的电缆也远长于 IDE. 虽然 SCSI 设备价格高些，与 IDE 相 比, SCSI 的性能更稳定、耐用，可靠性也更好。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>PCMCIA</td><td>Personal Computer Memory Card International Association</td><td>-</td><td>-</td><td>90MB/s</td><td>便携通用接口</td></tr></tbody></table><blockquote><p>由于可移动计算机 (笔记本) 用户对 PC 卡的需求变了，要求强度高，能耗低，尺寸小，而且对这几条性能的要求都很高。所以 PC 卡的标准也相应地变了。1991 年， PCMCIA 定 义了原本用于内存卡的 68 个脚的 I&#x2F;0 连接线路标准。同时增加了插槽使用说明。生产商意识到软件需要提高兼容性，因而这项标准也就得到了相应的应用。  PCMCIA 总线分为两类，一类为 16 位的 PCMCIA，另一类为 32 位的 CardBus。CardBus 是 - 种用于笔记本计算机的新的高性能 PC 卡总线接口标准，就像广泛地应用在台式计算机中的 PCI 总线一样。该总线标准与原来的 PC 卡标准相比，具有以下的优势:<br>第一，是 32 位数据传输和 33MHz 操作。CardBus 快速以太网 PC 卡的最大吞吐量接近 90 Mbps，而 16 位快速以太网 PC 卡仅能达到 20-30 Mbps。<br>第二，总线自主。使 PC 卡可以独立于主 CPU，与计算机内存间直接交换数据，这样 CPU 就可以处理其它的任务。<br>第三，3. 3V 供电，低功耗。提高了电池的寿命，降低了计算机内部的热扩散，增强了系统的可靠性。第四，后向兼容 16 位的 PC 卡。老式以太网和 Modem 设备的 PC 卡仍然可以插在 CardBus 插槽_上使用。PCMCIA 支持即插即用。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>USB</td><td>Universal Serial Bus International Association</td><td>-</td><td>-</td><td>1280MB/s</td><td>设备总线、串行</td></tr></tbody></table><blockquote><p>USB 是在 1994 年底由英特尔等多家公司联合在 1996 年推出后，已成功替代串口和并口，已成为当今电脑与大量智能设备的必配接口。USB 属于设备总线，是设备和设备控制器之间的接口。USB 所有新版本都向下兼容，可以连接鼠标、键盘、打印机、扫描仪、摄像头、充电器、闪存盘、MP3 机、手机、数码相机、移动硬盘、外置光软驱、USB 网卡、ADSL Modem、Cable Modem 等几乎所有的外部设备。可以热插拔、即插即用。具有很强的连接能力和很好的可扩充性。采用菊花链形式将众多外设连接起来，可使用 USB 集线器链式连接 127 个外设。标准统一。以前大家常见的是 IDE 接口的硬盘，串口的鼠标键盘，并口的打印机扫描仪，可是有了 USB 之后，这些应用外设统统可以用同样的标准与个人电脑连接，这时就有了 USB 硬盘、USB 鼠标、USB 打印机等等。高速传输。连接电缆轻巧，可为低压 (5V) 外设供电。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>IDE(ATA)</td><td>Integrated Drive Electronics</td><td>-</td><td>-</td><td>100MB/s</td><td>硬盘光驱接口</td></tr></tbody></table><blockquote><p>Integrated Drive Electronics (电子集成驱动器)本意是指把 “硬盘控制器” 与“盘体”集成在一起的硬盘驱动器。用于 IDE 硬盘的接口最初被称为 IDE 接口，后来扩展为 CD-ROM、磁带机、可移动磁盘、LS-120 磁盘等设备的接口。硬盘和光驱通过 IDE 接口与主板连接。</p></blockquote><table><thead><tr><th>总线标准</th><th>全称</th><th>工作频率</th><th>数据线</th><th>最大速度</th><th>特点</th></tr></thead><tbody><tr><td>SATA</td><td>Serial Advanced Technology Attachment</td><td>-</td><td>-</td><td>600MB/s</td><td>串行硬盘接口</td></tr></tbody></table><blockquote><p>SerialATA 即串行高级技术附件，它是一种完全不同于并行 ATA 的新型硬盘接口类型，由于采用串行方式传输数据而知名。是由 APT Technologies、 DELL、IBM、 Intel、 Maxtor、Quantum， Seagate 等公 司合作开发用于取代并行ATA 接口技术。与并行 ATA 相比，SATA 具有比较大的优势。<br>首先，SerialATA 以连续串行的方式传送数据，可以在较少的位宽下使用较高的工作频率来提高数据传输的带宽， Serial ATA - 次只会传送 1 位数据，这样能减少 SATA 接口的针脚数目，使连接电缆数目变少，效率也会更高。同时还能降低系统能耗，减小系统复杂性。其次，Serial ATA 的起点更高、发展潜力更大，Serial ATA 1. 0 定义的数据传输率可达 150MB&#x2F;sec，这比目前最块的并行 ATA(即 ATA&#x2F;133) 所能达到 133MB&#x2F;sec 的最高数据传输率还高，而在已经发布的 SerialATA2.0 的数据传输率将达到 300MB&#x2F;sec，最终 Serial ATA 3. 0 将实现 600MB&#x2F; sec 的最高数据传输率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组-第五章 中央处理器</title>
      <link href="/posts/ea8ec112/"/>
      <url>/posts/ea8ec112/</url>
      
        <content type="html"><![CDATA[<h1 id="1-CPU的基本功能和结构"><a href="#1-CPU的基本功能和结构" class="headerlink" title="1.CPU的基本功能和结构"></a>1.CPU的基本功能和结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161552750.png" alt="image-20230416155227635" loading="lazy"></p><h2 id="1-1-CPU-的功能"><a href="#1-1-CPU-的功能" class="headerlink" title="1.1.CPU 的功能"></a>1.1.CPU 的功能</h2><h3 id="1-1-1-CPU-的具体功能"><a href="#1-1-1-CPU-的具体功能" class="headerlink" title="1.1.1.CPU 的具体功能"></a>1.1.1.CPU 的具体功能</h3><p><strong>CPU 具体功能包括</strong>：</p><ul><li><strong>指令控制</strong>：完成<strong>取指令、分析指令和执行指令</strong>的操作，也即程序的<strong>顺序控制</strong>。</li><li><strong>操作控制</strong>：<strong>一条指令的功能是通过若干操作信号组合来实现的</strong>。CPU 管理并产生由内存取出的每条指令的操作信号，<strong>把各种操作信号送往相应部件，从而控制这些部件按指令的要求进行动作。</strong></li><li><strong>时间控制</strong>：对各种操作加以时间上的控制。时间控制要为每条指令按<strong>时间顺序</strong>提供应有的控制信号。</li><li><strong>数据加工</strong>：对数据进行<strong>算数和逻辑运算。</strong></li><li><strong>中断处理</strong>：对计算机运行过程中出现的<strong>异常情况和特殊请求</strong>进行处理。</li></ul><h3 id="1-1-2-每个部件的功能"><a href="#1-1-2-每个部件的功能" class="headerlink" title="1.1.2.每个部件的功能"></a>1.1.2.每个部件的功能</h3><p><strong>CPU 由运算器和控制器构成，其中运算器主要作用就是对数据进行加工</strong>；<strong>控制器主要作用就是协调和控制计算机各部件执行程序的指令序列，具体来说</strong>：</p><ul><li><strong>取指令</strong>：自动形成<strong>指令地址</strong>，自动发出取指令的命令。</li><li><strong>分析指令</strong>：操作码<strong>译码</strong>（分析本条指令要完成什么操作）；产生操作数的<strong>有效地址。</strong></li><li><strong>执行指令</strong>：由 “操作命令” 和“操作数地址”，形成<strong>操作信号控制序列</strong>，控制运算器、存储器以及 I&#x2F;O 设备完成相应的操作。</li><li><strong>中断处理</strong>：管理<strong>总线</strong>及输入输出；处理<strong>异常情况</strong>（比如掉电、浮点异常等）和<strong>特殊情况</strong>的请求（打印机请求打印一行字符等）。</li></ul><h2 id="1-2-运算器基本结构"><a href="#1-2-运算器基本结构" class="headerlink" title="1.2.运算器基本结构"></a>1.2.运算器基本结构</h2><h3 id="1-2-1-运算器概述"><a href="#1-2-1-运算器概述" class="headerlink" title="1.2.1.运算器概述"></a>1.2.1.运算器概述</h3><p>运算器核心是 <strong>ALU 算数逻辑单元</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161531640.png" loading="lazy">  </p><p>ALU需要<strong>两个操作数</strong>，经过处理后，就会输出运算结果。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532177.png" loading="lazy"></p><p><strong>运算器是计算机中加工数据的中心</strong>，除了 ALU 外，它还有很多寄存器，这里先给出它们的大致功能：</p><ul><li><strong>暂存寄存器</strong>：用于<strong>暂存从主存读过来的数据</strong>，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对<strong>应用程序员</strong>是透明的。</li><li><strong>累加寄存器</strong>：它是一个通用寄存器，用于<strong>暂时存放 ALU 的运算结果</strong>，可以作为加法运算的一个输入端。</li><li><strong>通用寄存器组</strong>：如<code>AX</code>、<code>BX</code>、<code>CX</code>、<code>DX</code>、<code>SP</code>等，用于<strong>存放操作数（包括源操作数，目的操作数及中间结果）和各种地址信息</strong>。注意<code>SP</code>是堆栈指针，用于指示栈顶地址。</li><li><strong>程序状态字寄存器</strong>：保留<strong>由算数逻辑运算指令或测试指令的结果而建立的各种状态信息</strong>，如溢出标志（<code>OF</code>）、符号标志（<code>SF</code>）、零标志（<code>ZF</code>），进行标志（<code>CF</code>）等。PSW 中的这些位参与并决定<strong>微操作</strong>的形成。</li><li><strong>移位器</strong>：对操作数或运算结果进行<strong>移位运算。</strong></li><li><strong>计数器</strong>：控制<strong>乘除运算</strong>的操作步数。</li></ul><h3 id="1-2-2-两种数据通路设计方式"><a href="#1-2-2-两种数据通路设计方式" class="headerlink" title="1.2.2.两种数据通路设计方式"></a>1.2.2.两种数据通路设计方式</h3><ul><li><p>接下来介绍两种数据通路设计方式，来详细探讨这些寄存器的作用。</p></li><li><p>注意下面的叙述仅仅是了解，不知道没有关系，后面会具体学习的。</p></li></ul><p><strong>数据通路：是指执行部件之间传送信息的路径，由控制信号控制。</strong></p><h4 id="1-2-2-1-专用数据通路"><a href="#1-2-2-1-专用数据通路" class="headerlink" title="1.2.2.1.专用数据通路"></a>1.2.2.1.专用数据通路</h4><p><strong>专用数据通路：根据指令执行过程中的数据和地址的流动方向安排连接线路。例如下图中每个寄存器与 ALU 都有专门的数据连线</strong>。</p><ul><li><p>任何一个通用寄存器中保存的数据都有可能作为 ALU 的输入，因此需要<strong>提供两组连线分别将通用寄存器两端连接至 ALU 两端</strong>（注意连线并不是只有一根，而是要视具体的数据传输情况而定）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161532930.png" alt="image-20230416153257853" loading="lazy"></p></li></ul><p><strong>专用数据通路方式下，有可能多个寄存器会同时向 ALU 传输数据，这显然是不合理的，主要有以下两种解决方案</strong>：</p><ul><li><p><strong>多路选择器（MUX)<strong>：根据控制信号选择一路输出，</strong>每个多路选择器都可以决定要把哪一个信号输出</strong>。比如下图左侧的多路选择器信号为 00，就表示让 $R_{0} $通过，右侧的多路选择器信号为 01，就表示让$R_{1} $通过  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161533771.png" alt="image-20230416153317677" loading="lazy"></p></li><li><p><strong>三态门</strong>：控制<strong>每一路是否可以输出</strong>。比如下图， $R_0out  $为 1 时表示 $R_{0} $的数据可以输出到 A 端， $R_0out  $为 0 时表示 $R_{0} $的数据无法输出到 B 端。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161534435.png" alt="image-20230416153447350" loading="lazy"></p></li></ul><p><strong>专用数据通路方式优缺点如下</strong>：</p><ul><li><strong>优点</strong>：基本不存在数据冲突的现象。</li><li><strong>缺点</strong>：结构复杂，流量大，不易实现，只在特殊场合、需求中使用。</li></ul><h4 id="1-2-2-2-CPU-内部单总线（主要使用）"><a href="#1-2-2-2-CPU-内部单总线（主要使用）" class="headerlink" title="1.2.2.2.CPU 内部单总线（主要使用）"></a>1.2.2.2.CPU 内部单总线（主要使用）</h4><p><strong>CPU 内部单总线：此种方式会将所有寄存器的输入和输出端都连接到一条公共的通路上。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124924.png" alt="image-20230416153521914" loading="lazy"></p><ul><li>$R_{x}out $ 表示寄存器的输出控制信号， $ R_{x}in$ 表示寄存器的输入控制信号。</li></ul><p>ALU 接受数据时也是通过总线接受，但这种方式会导致 <strong>ALU 无法分清这是哪一个操作数</strong>，所以我们可以在其中设置一个<strong>暂存寄存器</strong>。例如，<strong>下图中 $R_{0} $的数据会被先送到暂存寄存器上，然后使 $R_{0}out $ 失效，再导通 $R_{1}out $，最后将$R_{1} $数据输出到 B 端，这样的话就可以保证操作数的次序正确</strong>。</p><p>同时，<strong>暂存寄存器也可以避免破坏寄存器原有的内容</strong>。例如，某次运算两个操作数分别来自主存和 $R_{0} $，那么来自主存的操作数就可以直接放入暂存寄存器，而不用先放入 A，<strong>这样就避免了因 A 原本有内容而由于主存操作数的读入破坏了其内容的情况发生</strong>。  </p><p>ALU 在计算完成之后仍然会将计算结果放回内部总线，不过这样做容易产生一个问题，<strong>一旦输入端发送的信号还没有稳定前，ALU 就产生了计算结果，并通过内部总线送回了寄存器，这样会导致运算错误</strong>。所以我们可以在 ALU 的输出端再加一个暂存寄存器，同时在暂存寄存器上方加一个三态门，等 ALU 输出结果稳定之后，让三态门导通，然后给寄存器加上电信号让输出结果送回寄存器即可。</p><h2 id="1-3-控制器基本结构"><a href="#1-3-控制器基本结构" class="headerlink" title="1.3.控制器基本结构"></a>1.3.控制器基本结构</h2><h3 id="1-3-1-控制器概述"><a href="#1-3-1-控制器概述" class="headerlink" title="1.3.1.控制器概述"></a>1.3.1.控制器概述</h3><p><strong>控制器主要作用是取指令，分析指令和执行指令，主要涉及以下寄存器</strong>：</p><ul><li><strong>程序计数器 PC</strong>：用于指出<strong>下一条指令在主存中的存放地址</strong>。</li><li><strong>指令寄存器 IR</strong>：用于保存<strong>当前正在执行的那条指令。</strong></li><li><strong>指令译码器</strong>：仅对操作码字段进行<strong>译码</strong>，向控制器提供特定的操作信号。</li><li><strong>存储器地址寄存器</strong>：用于存放要<strong>访问的主存单元的地址</strong>。</li><li><strong>存储器数据寄存器</strong>：用于存放向<strong>主存写入的信息或从主存读出的信息。</strong></li><li><strong>时序系统</strong>：用于产生各种<strong>时序信号</strong>，它们都是由统一时钟（CLOCK）分频得到。</li><li><strong>微操作信号发生器</strong>：根据 IR 的内（指令）、PSW 的内容及时序信号，<strong>产生控制计算机系统的所需要的各种控制信号</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161540190.png" loading="lazy"></p><h3 id="1-3-2-控制器控制过程概述"><a href="#1-3-2-控制器控制过程概述" class="headerlink" title="1.3.2.控制器控制过程概述"></a>1.3.2.控制器控制过程概述</h3><p><strong>控制器控制过程概述：大致逻辑过程描述如下</strong>：</p><ul><li><p><strong>程序计数器 PC</strong> 会指明下一条指令的地址，当取出该指令后会将其放到<strong>指令寄存器</strong> IR 当中。指令的地址码指明了操作数的地址信息，所以<strong>地址码的信息需要输出到内部总线上，而操作码部分会送给控制单元 CU</strong>。</p></li><li><p><strong>具体来说，操作码会送给指令译码器</strong> ，译码器的对应端会被选通，了解当前的指令类型后，就明白了下次执行的微操作是什么，所以<strong>译码器的输出信号会作为微操作信号发生器</strong>的输入信号，用于产生该指令的<strong>微操作序列</strong>。</p></li><li><p>微操作序列需要受到时序系统的控制。<strong>时序系统</strong>产生时序信号，微操作发生器每接受到一次信号，就会产生一个微操作（注意此时会受到 PSW 标志位的影响，有可能改变微操作的类型）。</p></li><li><p>最后还需要 <strong>MAR 和 MDR</strong>，MAR 连接地址总线，MDR 连接数据总线，用于和存储器进行交互。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161541097.png" alt="image-20230416154119009" loading="lazy"></p><h2 id="1-4-CPU-的本质——寄存器的集合体"><a href="#1-4-CPU-的本质——寄存器的集合体" class="headerlink" title="1.4.CPU 的本质——寄存器的集合体"></a>1.4.CPU 的本质——寄存器的集合体</h2><p><strong>CPU 的本质就是寄存器的集合体，所以这也是 CPU 很贵的原因。</strong></p><ul><li><strong>用户可见的寄存器</strong>：通用寄存器组、程序状态字寄存器 PSW，程序计数器 PC。</li><li><strong>用户不可见的寄存器</strong>：MAR、MDR、IR 和暂存寄存器。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161544495.png" alt="image-20230416154413382" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161550448.png" alt="image-20230416155037353" loading="lazy"></p><h1 id="2-指令执行过程"><a href="#2-指令执行过程" class="headerlink" title="2.指令执行过程"></a><a name="2.指令执行过程">2.指令执行过程</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161611723.png" alt="image-20230416161109612" loading="lazy"></p><h2 id="2-1-指令周期是什么"><a href="#2-1-指令周期是什么" class="headerlink" title="2.1.指令周期是什么"></a>2.1.指令周期是什么</h2><p><strong>指令周期：是指 CPU 从主存中取出并执行一条指令所需要的全部时间，不同指令的指令周期可能不同。指令周期常用若干机器周期（又叫 CPU 周期）来表示，一个机器周期又包含若干时钟周期（也称为节拍或 T 周期，T 是 CPU 操作的最基本单位）</strong>。</p><ul><li><strong>每个指令周期内的机器周期数可以不等。</strong></li><li><strong>每个机器周期内的时钟周期数可以不等。</strong></li></ul><p><strong>机器周期指的是完成一个子过程所花费的时间，下图中的方波表示若干时钟周期。例如 CPU 取指令，它是一个程序化、步骤化的过程，所以需要花费多个时钟周期（对应多个操作）来完成</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161554507.png" alt="image-20230416155450425" loading="lazy"></p><p><strong>不同指令的指令周期可能不同，例如</strong>：</p><ul><li><strong>空指令 NOP</strong>：空指令的意思就是什么也不做，因此其指令周期就是取指周期。</li><li><strong>加法指令 ADD</strong>：指令周期包括取指和执行两个部分，且这个两个部分长度差不多。</li><li><strong>乘法指令 MUL</strong>：相较于加法指令，由于乘法较为复杂，所以它的执行周期可能会更长。</li><li><strong>具有间接寻址的指令</strong>：间接寻址需要多次访问主存才能取到真实的地址，因此它会多一个<strong>间址周期</strong>。</li><li><strong>带有中断周期的指令</strong>：这种类型的指令会专门留出时间用于检测是否有中断信号，所以又会多一个中断周期。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161555299.png" alt="image-20230416155525209" loading="lazy"></p><h2 id="2-2-指令周期流程"><a href="#2-2-指令周期流程" class="headerlink" title="2.2.指令周期流程"></a>2.2.指令周期流程</h2><p><strong>不同指令的指令周期可能不同，自然也会有不一样的执行流程。某个指令在执行过程中是否要经过某个周期需要进行判断。且这四个工作周期都会涉及到 CPU 的访存操作，只是访存的目的不同。</strong></p><ul><li><p><strong>取指周期 (FE)：为了取出指令</strong>。</p></li><li><p><strong>间址周期 (IND)（可能有）：为了得到有效地址。</strong></p></li><li><p><strong>执行周期 (EX)：为了取得操作数。</strong></p></li><li><p><strong>中断周期 (INT)（可能有）：为了保存程序断点</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556575.png" alt="image-20230416155606476" loading="lazy"></p></li><li><p>具体实现时可借助<strong>触发器</strong>完成，通过二进制位是否有效进行控制  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161556914.png" alt="image-20230416155634819" loading="lazy"></p></li></ul><h3 id="2-2-1-取指周期"><a href="#2-2-1-取指周期" class="headerlink" title="2.2.1.取指周期"></a>2.2.1.取指周期</h3><ul><li><p>首先 PC 指明了<strong>当前要执行的指令在主存的存放地址</strong>，所以需要先把 PC 中的内容（指令地址）送入 MAR中，<strong>也即<code>(PC)-&gt;MAR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557655.png" alt="image-20230416155752570" loading="lazy"></p></li><li><p>因为取指令需要访问主存，所以 CU 通过<strong>控制总线</strong>向主存发出<strong>读信号</strong>， <strong>也即<code>1-&gt;R</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161557897.png" alt="image-20230416155721809" loading="lazy"></p></li><li><p>MAR 中的地址信息会通过<strong>地址总线送给主存</strong>，读出相应数据后，该指令会通过<strong>数据总线送到 MDR 当中</strong>，<strong>也即<code>M(MAR)-&gt;MDR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558392.png" alt="image-20230416155819305" loading="lazy"></p></li><li><p>然后把 MDR 中的内容送入 <strong>IR</strong> 当中，<strong>也即<code>(MDR)-&gt;IR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161559158.png" alt="image-20230416155939043" loading="lazy"></p></li><li><p>最后 <strong>CU 发出控制信号</strong>，让 PC+“1”，形成下一条地址，<strong>也即<code>PC=PC+1</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161558096.png" loading="lazy"></p></li></ul><p><strong>总结</strong>：</p><ul><li><code>(PC)-&gt;MAR</code>。</li><li><code>1-&gt;R</code>。</li><li><code>M(MAR)-&gt;MDR</code>。</li><li><code>(MDR)-&gt;IR</code>。</li><li><code>PC+1</code>。</li></ul><h3 id="2-2-2-间址周期"><a href="#2-2-2-间址周期" class="headerlink" title="2.2.2.间址周期"></a>2.2.2.间址周期</h3><p><strong>一旦指令采用间接寻址，就需要进入间址周期。</strong></p><ul><li><p>首先将指令的<strong>地址码送入 MAR</strong>，<strong>也即 Ad(IR)-&gt;MAR</strong>（注意也可以<code>Ad(MDR)-&gt;MAR</code>）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161601516.png" alt="image-20230416160146430" loading="lazy"></p></li><li><p>CU 发出<strong>读控制信号</strong>，**也即<code>1-&gt;R</code>**。</p></li><li><p>将 MAR 所指主存中的内容通过数据总线送入 MDR，<strong>也即<code>M(MAR)-&gt;MDR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161602831.png" alt="image-20230416160207749" loading="lazy"></p></li><li><p>此时 MDR 保存的是操作数的<strong>有效地址</strong>。接下来 <strong>MDR 中的内容可以直接放入 MAR，也可以放入 IR 与原来的指令进行拼接</strong>（因为原来的地址只是形式地址）形成一个新的指令。</p></li></ul><p><strong>总结</strong>：</p><ul><li><code>Ad(IR)-&gt;MAR</code>（也可以是 <code>Ad(MDR)-&gt;MAR</code>）。</li><li><code>1-&gt;R</code>。</li><li><code>M(MAR)-&gt;MDR</code>。</li></ul><h3 id="2-2-3-执行周期"><a href="#2-2-3-执行周期" class="headerlink" title="2.2.3.执行周期"></a>2.2.3.执行周期</h3><p>执行周期的任务就是<strong>根据 IR 中指令字的操作码和操作数通过 ALU</strong> 产生执行结果，由于不同指令的执行周期操作不同，<strong>所以没有统一的数据流向</strong>。</p><h3 id="2-2-4-中断周期"><a href="#2-2-4-中断周期" class="headerlink" title="2.2.4.中断周期"></a>2.2.4.中断周期</h3><h4 id="2-2-4-1-中断"><a href="#2-2-4-1-中断" class="headerlink" title="2.2.4.1.中断"></a>2.2.4.1.中断</h4><p><strong>中断：通俗理解就是暂停当前任务去完成其他任务，完成后返回。</strong></p><p>例如，当前执行的程序由一些指令组成，现在执行到了指令 2，那么此时 PC 应该指向指令 3  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171116631.png" alt="image-20230417111622548" loading="lazy"></p><p>指令 2 结束之后会进行<strong>中断检查</strong>，如果此时有中断信号过来，那么在指令 2 执行完毕之后，就要<strong>暂停当前程序，转而执行中断信号所对应的程序指令</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161604726.png" loading="lazy">  </p><p>执行完毕之后，再返回原来程序继续执行  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161605611.png" loading="lazy"></p><h4 id="2-2-4-2-中断周期"><a href="#2-2-4-2-中断周期" class="headerlink" title="2.2.4.2.中断周期"></a>2.2.4.2.中断周期</h4><p><strong>为了能够找到 “回家的路”，所以需要保存程序断点，其实也就是 PC 的值。一般使用堆栈来保存断点。下图 SP 表示栈顶指针，假设 SP 此时指向栈顶元素，进栈操作是先修改指针，后保存数据</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161606339.png" loading="lazy"></p><ul><li><p>首先 CU 控制 SP，让其减 1，新指向的位置需要放入 PC。需要注意 <strong>SP 是堆栈指针，但其本质指向的是某个主存地址，所以它的意思就是现在需要把 PC 内的值放入 SP 所指向的某个主存单元保存起来</strong>，也即 <strong><code>(SP-1)-&gt;SP</code>，<code>(SP)-&gt;MAR</code></strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608679.png" alt="image-20230416160834593" loading="lazy"></p></li><li><p>CU 通过控制总线向主存发出<strong>写信号</strong>，**也即<code>1-&gt;W</code>**。</p></li><li><p><strong>向 MAR 所指地址处写入 PC（断点）</strong>。一个数据想要写入主存，首先得放入 MDR。因此 <strong>(PC)-&gt;MDR</strong>，至此<strong>断点信息被保存</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161608595.png" alt="image-20230416160857514" loading="lazy"></p></li><li><p>接下来就需要<strong>执行新的程序指令了</strong>，因此 CU 控制<strong>将中断服务程序的入口地址送入 PC</strong>，也就是把最上面示例图的 PC 指向改为指向 “X”，**也即<code>向量地址-&gt;PC</code>**。</p></li><li><p>最后新的程序指令执行完成之后，<strong>依靠堆栈返回到之前的位置继续执行</strong>。</p></li></ul><p><strong>总之</strong>：</p><ul><li><code>(SP-1)-&gt;SP</code></li><li><code>SP-&gt;MAR</code></li><li><code>1-&gt;W</code></li><li><code>(PC)-&gt;MDR</code></li><li><code>MDR-&gt;M(MAR)</code></li><li><code>向量地址 -&gt;PC</code></li></ul><h2 id="2-3-指令执行方案"><a href="#2-3-指令执行方案" class="headerlink" title="2.3.指令执行方案"></a>2.3.指令执行方案</h2><p><strong>指令执行方案：一个指令周期通常要包括几个执行步骤，每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。出于性能和硬件成本的考虑，可以选用如下三种不同的方案来安排指令的执行步骤</strong>：</p><ul><li>单指令周期。</li><li>多指令周期。</li><li>流水线方案。</li></ul><h3 id="2-3-1-单指令周期"><a href="#2-3-1-单指令周期" class="headerlink" title="2.3.1.单指令周期"></a>2.3.1.单指令周期</h3><p><strong>单指令周期：对所有指令都选用相同的执行时间来完成，称为单指令周期方案。</strong></p><p>此时每条指令都在固定的时钟周期内完成，指令之间 <strong>串行执行</strong>，即下一条指令只能在前一条指令执行结束之后启动。<strong>因此指令周期取决于最长的指令的执行时间，对于那些本来可以在更短时间内完成的指令，也要使用这个较长的执行周期，会降低整个系统的运行速度。</strong></p><h3 id="2-3-2-多指令周期"><a href="#2-3-2-多指令周期" class="headerlink" title="2.3.2.多指令周期"></a>2.3.2.多指令周期</h3><p><strong>多指令周期：对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案</strong>。</p><p>指令之间 <strong>串行执行</strong>，即下一条指令只能在前一条指令执行结束后启动。但是可以选用<strong>不同个数的时钟周期来完成不同指令的执行过程</strong>，<strong>指令需要几个周期就分配几个周期，而不再强求所有指令占用相同的执行时间。</strong></p><h3 id="2-3-3-流水线方案"><a href="#2-3-3-流水线方案" class="headerlink" title="2.3.3.流水线方案"></a>2.3.3.流水线方案</h3><p><strong>流水线方案：指令之间可以并行执行的方案，称为流水线方案。</strong></p><p>流水线方案力争 <strong>在每个时钟周期完成一条指令的执行过程</strong>（当然这只有在理想情况下才能达到）。<strong>这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自在不同的执行步骤</strong>。</p><h1 id="3-数据通路单总线结构"><a href="#3-数据通路单总线结构" class="headerlink" title="3.数据通路单总线结构"></a>3.数据通路单总线结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640918.png" alt="image-20230416164054829" loading="lazy"></p><h2 id="3-1-有关概念"><a href="#3-1-有关概念" class="headerlink" title="3.1.有关概念"></a>3.1.有关概念</h2><h3 id="3-1-1-CPU-中数据的流动方式"><a href="#3-1-1-CPU-中数据的流动方式" class="headerlink" title="3.1.1.CPU 中数据的流动方式"></a>3.1.1.CPU 中数据的流动方式</h3><p><strong>一条指令的指令周期是会被划分为不同阶段，而不同阶段的数据流向也会不同，主要有以下三种</strong>：</p><ul><li>寄存器和寄存器之间。</li><li>寄存器与主存之间。</li><li>寄存器与 ALU 之间。</li></ul><h3 id="3-1-2-数据通路和控制信号"><a href="#3-1-2-数据通路和控制信号" class="headerlink" title="3.1.2.数据通路和控制信号"></a>3.1.2.数据通路和控制信号</h3><p><strong>数据通路：描述了数据在各个功能部件之间传送的路径。我们需要确定信息从哪里开始，中间经过哪些部件，最后又传至哪里。因此只要确定了数据的流向，我们就可以发出不一样的控制信号，来控制这些数据的流动。</strong></p><p><strong>控制信号是由控制部件产生的，虽然寄存器种类繁杂，但它们只会发出如下两类控制信号：</strong></p><ul><li><strong><code>in</code>：也即输入路径。</strong></li><li><strong><code>out</code>：也即输出路径</strong>。</li></ul><p><strong>这些信号都是由控制器发出的，所以下图中的 $ACC_{in} $、$ACC_{out} $、 $R0_{in} $和 $R0_{out} $​等控制信号事实上和微操作发生器（CU）有着线路连接，微操作发生器发出不一样的信号就会使这些寄存器之间产生多种多样的联系</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161614739.png" alt="image-20230416161446625" loading="lazy"></p><h3 id="3-1-3-数据通路种类"><a href="#3-1-3-数据通路种类" class="headerlink" title="3.1.3.数据通路种类"></a>3.1.3.数据通路种类</h3><ul><li><p><strong>CPU 内部单总线（上图）</strong>：该方式<strong>将所有寄存器的输入端和输出端都连接到同一条公共的通路上</strong>，这意味着<strong>同一时刻只允许两个部进行数据交换</strong>，它们对总线的使用是独占的。<strong>本小节探讨的内容所用的数据通路方式便是这种</strong>。</p></li><li><p><strong>CPU 内部多总线方式</strong>：将所有寄存器的输入和输出端都连接到<strong>多条公共通路上</strong>。采用多总线方式，可以同时在多个总线上<strong>传送不同的数据。</strong></p></li><li><p><strong>专用数据通路方式</strong>：根据指令执行过程中的数据和地址的流动方向安排连接线路，<strong>避免使用共享的总线</strong>，性能高，但是硬件消耗量大。</p></li></ul><h3 id="3-1-4-内部总线与系统总线"><a href="#3-1-4-内部总线与系统总线" class="headerlink" title="3.1.4.内部总线与系统总线"></a>3.1.4.内部总线与系统总线</h3><ul><li><strong>内部总线</strong>：<strong>同一部件</strong>，如 CPU 内部连接各寄存器及运算部件之间的总线。</li><li><strong>系统总线</strong>：<strong>同一台计算机系统的各部件</strong>，如 CPU、内存、通道和各类 I&#x2F;O 接口间相互连接的总线。</li></ul><p>以下的讲解中会使用这张图  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161616080.png" alt="image-20230416161620990" loading="lazy"></p><h2 id="3-2-寄存器之间的数据流动"><a href="#3-2-寄存器之间的数据流动" class="headerlink" title="3.2.寄存器之间的数据流动"></a>3.2.寄存器之间的数据流动</h2><p><strong>例子：现在要把 PC 的内容送至 MAR，那么传送操作流程如下</strong>：</p><ul><li><p>首先 $ PCout $有效（CU 发出信号），让其和总线导通  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161617187.png" alt="image-20230416161715097" loading="lazy"></p></li><li><p>然后把 $PC$ 的内容（其实就是电信号）送至 $BUS$（总线），也即 ( $PC$)-&gt; $BUS$ 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618824.png" loading="lazy"></p><ul><li><p>最后使 $MAR_{in}$​有效， $BUS$ 内容再送至 $MAR$ 即可，也即 $BUS$-&gt; $MAR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618616.png" loading="lazy"></p></li></ul></li></ul><p>在答题时一定要写清楚数据流向，最规范的模板为  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161618459.png" loading="lazy"></p><h2 id="3-3-主存与-CPU-之间的数据流动"><a href="#3-3-主存与-CPU-之间的数据流动" class="headerlink" title="3.3.主存与 CPU 之间的数据流动"></a>3.3.主存与 CPU 之间的数据流动</h2><p><strong>例子：现在 CPU 要从主存中读取指令，那么传送操作流程如下</strong>：</p><ul><li><p>首先，程序计数器 $PC$ 指明了我们要读取的指令存放在什么地址，所以要把 $PC$ 的内容放入 $MAR$ 当中，即$ (PC)-&gt;Bus-&gt;MAR $（这一步其实也就是上面寄存器与寄存器之间的数据流动）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161619583.png" loading="lazy"></p></li><li><p>刚才，为了实现 PC 到 MAR 而使得 $PC_{out} $​和 $PC_{in} $​有效了，现在<strong>应该撤销这两个控制信号</strong>，让总线空闲。接下来要进行读操作，所以 CU 要向主存发出读信号，即 $1-&gt; R$（注意该信号是通过控制总线发出的）。</p></li><li><p>然后使 $MDR_{in}$ 有效（**注意区分图中的 $MDR_{in} $​， $MDR_{in} $​是控制数据是否可以从内部总线流入 $MDR$**），主存中对应地址信息的内容通过外部数据总线送入 $MDR$ 当中，即 $MEM(MAR)$-&gt; $MDR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161628556.png" alt="1" loading="lazy"></p></li><li><p>最后需要把该指令放入$IR$ 当中， $MDR-&gt;Bus-&gt;IR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161629503.png" alt="image-20230416162948426" loading="lazy"></p></li></ul><p>较为规范的模板为：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161630911.png" loading="lazy"></p><h2 id="3-4-寄存器与-ALU-之间的数据流动"><a href="#3-4-寄存器与-ALU-之间的数据流动" class="headerlink" title="3.4.寄存器与 ALU 之间的数据流动"></a>3.4.寄存器与 ALU 之间的数据流动</h2><p><strong>执行算数或逻辑运算时数据可能会流向 ALU，比如现在要执行一条加法指令，加法运算的其中一个操作数已经被存放在 $ACC$ 中了，另一个操作数地址会由加法指令直接指明</strong>。</p><ul><li><p>首先需要根据该指令的地址码部分读取出参与加法的另一个操作数，即 $ Ad(IR) -&gt;Bus-&gt; MAR$，此时 $MDR_{out} $和 $MAR_{in}$​有效。</p></li><li><p>当然还可以采用另外一种方式。之前就说过，取指令的时候是把指令先取到了 $MDR$ 中然后再拷贝至$IR$ 中，所以取指结束后， $MDR$ 中也存放了这条指令的完整信息，因此可以直接把 $MDR$ 中指令的地址码传送到 $MAR$ 中，此时 $MDR_{out} $​和 $MAR_{in}$​有效。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161634185.png" alt="image-20230416163418087" loading="lazy"></p></li><li><p>CU 向主存发出读控制信号，即 $1-&gt; R $</p></li><li><p>主存中相应信息通过外部数据总线送至 $MDR$ 当中， $MDR_{in}$ 有效，即 $MEM(MAR)$-&gt; 数据总线 -&gt; $MDR$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161635806.png" alt="image-20230416163548712" loading="lazy"></p></li><li><p>接下来把操作数放到暂存寄存器 $Y$ 中，此时 $MDR_{out} $​和 $ Y_{in} $有效，即 MDR-&gt;bus-&gt; $Y$。<strong>之所以这样做是因为 ALU 必须同时接受到两个信号才可以运作，但是内部总线同一时刻只能传送一个输入信号，因此不得不把其中的一个操作放到暂存寄存器中，该寄存器与 ALU 是有一个专门的数据通路的，他们的传送不会占用内部总线</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161636910.png" alt="image-20230416163629820" loading="lazy"></p></li><li><p>CU 向 ALU 发送加命令，然后 $ACC_{out}$和 $ALU_{in} $有效，执行加法操作，即 ( $ACC$)+( $Y$)-&gt;$ Z  $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637327.png" alt="image-20230416163713240" loading="lazy"></p></li><li><p>当输出数据稳定之后，撤销 $ACC_{out}$和 $ALU_{in} $​。最后将结果存回 $ACC$ 中，即 $ Z-&gt; ACC$  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161637988.png" alt="image-20230416163739894" loading="lazy"></p></li></ul><p>较为规范的模板为  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161638315.png" loading="lazy"></p><p><strong>可以看出，通过发出不一样的控制信号，就能使微操作一步接着一步进行下去，每个微操作至少需要消耗一个时钟周期，每一个时钟周期内，CU 都会发出一组相应的控制信号来完成其中的某一个微操作</strong>。</p><h2 id="3-5-有关-CPU-内部单总线经典例题"><a href="#3-5-有关-CPU-内部单总线经典例题" class="headerlink" title="3.5.有关 CPU 内部单总线经典例题"></a>3.5.有关 CPU 内部单总线经典例题</h2><p>设有如下所示的单总线结构，请分支指令<code>ADD (R0),R1</code>的指令流程和控制信号。</p><ul><li>$R  _{1} $表示源操作数（没有括号表示直接存放在寄存器中），$(R  _{0} )$ 表示目的操作数（带有括号表示存储的操作数的地址，同时这两个操作数的运算的结果又会放回 $R _{0} $所指向主存单元）。也即$ ((R _{0} ))+(R <em>{1} )-&gt;(R 0</em>{0} )$。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639870.png" alt="image-20230416163921777" loading="lazy"></p><p>各个阶段的指令流程如下  ：</p><p><strong>1：取指周期</strong>：公共操作，都一样。</p><table><thead><tr><th>时序</th><th>微操作</th><th>有效控制信号</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>(PC)-&gt;MAR</td><td>PCout,MARin</td><td>PC 所指指令地址送至 MAR</td></tr><tr><td>2</td><td>M(MAR)-&gt;MDR</td><td>MemR，MARout，MDRinE</td><td>把指令送到 MDR 中</td></tr><tr><td>3</td><td>(MDR)-&gt;IR</td><td>MDRout,IRin</td><td>把指令由 MDR 送到 IR</td></tr><tr><td>4</td><td>指令译码</td><td>-</td><td>进行译码操作</td></tr><tr><td>5</td><td>(PC)+1-&gt;PC</td><td>-</td><td>PC+1 操作</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161639924.png" alt="image-20230416163938826" loading="lazy"></p><p><strong>2：间指周期</strong>：完成取数操作，被加数在主存中，加数已经存放在寄存器 $R _{1}$中了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424883.png" alt="image-20230416142413792" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161640100.png" alt="image-20230416164011484" loading="lazy"></p><p><strong>3：执行周期</strong>：此时加数在 R1 中，被加数在 Y 中。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161424547.png" alt="image-20230416142439466" loading="lazy"></p><p><strong>注意：本节内容是计组考试中的高频考点，注意考察指令的执行过程。</strong></p><h1 id="4-数据通路专用通路结构"><a href="#4-数据通路专用通路结构" class="headerlink" title="4.数据通路专用通路结构"></a>4.数据通路专用通路结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161649331.png" alt="image-20230416164908239" loading="lazy"></p><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1.概述"></a>4.1.概述</h2><p>如果数据通路采用 CPU 内部单总线，那么就意味着同一时间只允许两个部件进行数据交互。<strong>实际上，如果能使多个部件同时进行数据交互，那么指令的执行速度一定会的得到提升，实现这种需求一方面可以借助多总线的方式，另一方面还可以建立专用数据通路——在任何两个需要进行数据交互的部件之间建立数据通路</strong>。</p><p>如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647652.png" alt="image-20230416164703559" loading="lazy">  </p><p>取指周期如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161428320.png" alt="image-20230416142819239" loading="lazy"></p><h2 id="4-2-例题"><a href="#4-2-例题" class="headerlink" title="4.2.例题"></a>4.2.例题</h2><p>下图是一个简化了的 CPU 与主存连接结构示意图 (图中省略了所有的多路选择器)。其中有一个累加寄存器 (ACC)、一个状态数据寄存器和其他 4 个寄存器（MAR、MDR、PC 和 IR）。各部件及其之间的连线表示数据通路，箭头表示信息传递方向。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161647475.png" alt="image-20230416164757386" loading="lazy"></p><p>完成以下问题：</p><ul><li><strong>请写出图中 a、b、C、d 4 个寄存器的名称</strong>。</li><li><strong>简述图中取指令的数据通路</strong>。</li><li><strong>简述数据在运算器和主存之间进行存 &#x2F; 取访问的数据通路。</strong></li><li><strong>简述完成指令 LDA X 的数据通路 (X 为主存地址，LDA 的功能为 (X)→ACC)。</strong></li><li><strong>简述完成指令 ADD Y 的数据通路 (Y 为主存地址，ADD 的功能为 (ACC)+ (Y)→ACC)。</strong></li><li>**简述完成指令 STA Z 的数据通路 (Z 为主存地址，STA 的功能为 (ACC)→Z)**。</li></ul><p><strong>（1）请写出图中 a、b、C、d 4 个寄存器的名称。</strong></p><p>首先 d 可以自动 “+1”，因此是 PC；PC 的内容是地址，送入 MAR，故 c 是 MAR；b 与微操作信号发生器相连，因此是 IR；相应的 a 就是 MDR。</p><ul><li>a：MDR</li><li>b：IR</li><li>c：MAR</li><li>d：PC</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161648003.png" alt="image-20230416164825907" loading="lazy"></p><p><strong>（2）简述图中取指令的数据通路。</strong></p><ul><li>(PC)-&gt;MAR</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;IR</li></ul><p><strong>（3）简述数据在运算器和主存之间进行存 &#x2F; 取访问的数据通路</strong>。</p><p>假设存 &#x2F; 取的数据放到 ACC 中，并且数据地址已经放入 MAR 中。</p><p><strong>取过程</strong></p><ul><li>M(MAR)-&gt;MDR</li><li>(MDR)-&gt;ALU-&gt;ACC</li></ul><p><strong>存过程</strong></p><ul><li>(ACC)-&gt;MDR</li><li>(MDR)-&gt;M(MAR)</li></ul><p><strong>（4）简述完成指令 LDA X 的数据通路 (X 为主存地址，LDA 的功能为 (X)→ACC)。</strong></p><ul><li>X-&gt;MAR</li><li>M(MAR)-&gt;MDR</li><li>(MDR)-&gt;ALU-&gt;ACC</li></ul><p><strong>（5）简述完成指令 ADD Y 的数据通路 (Y 为主存地址，ADD 的功能为 (ACC)+ (Y)→ACC)。</strong></p><ul><li>Y-&gt;MAR</li><li>M(MAR)-&gt;MDR</li><li>(MDR)-&gt;ALU，(ACC)-&gt;ALU</li><li>ALU-&gt;ACC</li></ul><p>**（6）简述完成指令 STA Z 的数据通路 (Z 为主存地址，STA 的功能为 (ACC)→Z)**。</p><ul><li>Z-&gt;MAR</li><li>(ACC)-&gt;MDR</li><li>(MDR)-&gt;M(MAR)</li></ul><h1 id="5-硬布线控制器"><a href="#5-硬布线控制器" class="headerlink" title="5.硬布线控制器"></a><a name="5.硬布线控制器">5.硬布线控制器</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161713047.png" loading="lazy"></p><h2 id="5-1-内容回顾和一些概念"><a href="#5-1-内容回顾和一些概念" class="headerlink" title="5.1.内容回顾和一些概念"></a>5.1.内容回顾和一些概念</h2><p>高级语言编写的程序会被翻译为与之等价指令序列，每条指令的执行，有可能会涉及如下四个周期：</p><ul><li><strong>取指周期</strong>：完成取指令。</li><li><strong>间指周期</strong>：如果采用间接寻址，需要将形式地址转变为真实地址。</li><li><strong>执行周期</strong>：执行指令。</li><li><strong>中断周期</strong>：处理中断信号。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652162.png" alt="image-20230416165212046" loading="lazy"></p><p>下图中<code>FE</code>、<code>IND</code>、<code>EX</code>和<code>INT</code>分别是上面四个周期的缩写，<strong>各自对应了如下四个触发器，如果某个触发器为 1 就表示指令处于某个周期内。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161652735.png" alt="image-20230416165227648" loading="lazy"></p><p>一个指令周期内又需要若干<strong>微操作序列</strong>来完成该指令周期的工作，每个指令周期又由若干<strong>时钟周期</strong>组成（节拍），CU 会在每一个节拍内发出一个<strong>微命令</strong>，生成对应的微操作。</p><ul><li><strong>微命令和微操作是一一对应的</strong>：比如微命令 1 使得$ PC _{out}$ 、$MAR _{in}$ ​有效，完成对应的微操作 (PC)-&gt;MAR。</li></ul><p><strong>每个节拍内可以并行地完成互不冲突的微操作，而且同一个微操作也可能在不同指令的不同阶段被使用</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161653434.png" alt="image-20230416165312336" loading="lazy"></p><ul><li>上图采用的是<strong>定长周期</strong>的策略（即便执行周期和中断周期可以在两个节拍内完成，但是我们还是让其耗时三个节拍）。</li></ul><p>实际上，不同指令的执行周期所需要的节拍数是各不相同的，因此为了简化设计，选择定长的机器周期，<strong>以可能出现的最大节拍数为准</strong>（通常以访存所需要节拍数作为参考），若实际所需要节拍数较少，<strong>可以将微操作安排在机器周期末尾几个节拍上进行。</strong></p><h2 id="5-2-硬布线控制"><a href="#5-2-硬布线控制" class="headerlink" title="5.2.硬布线控制"></a>5.2.硬布线控制</h2><p><strong>硬布线控制：使用控制单元 CU 进行逻辑控制。</strong></p><h3 id="5-2-1-CU-如何发出微命令"><a href="#5-2-1-CU-如何发出微命令" class="headerlink" title="5.2.1.CU 如何发出微命令"></a>5.2.1.CU 如何发出微命令</h3><p><strong>可以看出，指令间区别最大的地方在于执行周期，像取指周期、间指周期和中断周期都是差不多的。所以，我们只要根据指令操作码、目前的指令周期、节拍信号以及机器状态条件就可以确定现在这个节拍下应该发出哪些微命令。具体来说</strong>：</p><ul><li><p><strong>STEP1：得让 CU 知道现在执行的是什么命令</strong>：首先需要把 IR 的 $n$位操作码送给<strong>操作码译码器</strong>（ $n$位操作码意味着有 $2 ^{n}$ 种不一样的指令，经过操作码译码器译码后对应的地址选择线就会被选通），<strong>CU 通过判断对应哪一个输入信号有效，来判断当前执行的是哪一条指令</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655637.png" alt="image-20230416165504542" loading="lazy"></p></li><li><p><strong>STEP2：得让 CU 知道当前执行到了该指令的哪一个机器周期</strong>：所以需要把<code>FE</code>、<code>IND</code>、<code>EX</code>和<code>INT</code>这四个触发器的二进制信息送给 CU，<strong>CU 通过判断对应的值是否为 1 来判断目前处于哪一个机器周期</strong>（需要注意这四个触发器实际上已经被集成在了 CPU 中）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161655839.png" alt="image-20230416165540748" loading="lazy"></p></li><li><p><strong>STEP3：得让 CU 知道当前处在该机器周期的哪一个节拍</strong>：因此需要给 CU 输入一个节拍信号，节拍信号是通过<strong>节拍发生器</strong>给出的，时钟部件会有规律的发出脉冲信号，每个脉冲信号就是一个时钟周期。<strong>节拍发生器在接受到时钟部件发出的信号后，就会让其中的某个输出线导通</strong>、节拍信号是循环发出的，当$ T _{m} $结束后，就会回到 $T _{0}$，此时表示进入了新的机器周期  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171124920.png" alt="image-20230416201559822" loading="lazy"></p></li><li><p><strong>STEP4：最后需要给 CU 提供机器状态条件</strong>：<strong>状态条件统称为标志，它们来自于执行单元的返回信息</strong>。比如前面说过的来自于运算器的 PSW（溢出判断就在这里）、来自于 ACC 的符号位等，也有可能来自于 I&#x2F;O 设备、主存等  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657694.png" alt="image-20230416165702583" loading="lazy"></p></li></ul><p><strong>这四组信息齐全后，CU 就可以给出当前节拍下应该发出的微命令</strong>：<strong>每个输出的控制信号对应一个微命令，也就是对应一个微操作</strong>。例如，如果$ C _{1} $对应微操作为 $(PC) $-&gt;MAR，那么只需让其接到 $PC  _{out}$​和 $MAR _{in} $​即可  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657883.png" alt="image-20230416165727760" loading="lazy"></p><h3 id="5-2-2-逻辑化表达式"><a href="#5-2-2-逻辑化表达式" class="headerlink" title="5.2.2.逻辑化表达式"></a>5.2.2.逻辑化表达式</h3><p>现在最困难的问题在于：<strong>CU 如何能知道现在应该发出哪条命令？</strong>。比如上面的例子中，$C _{1}$​被接通后就执行了 (PC)-&gt;MAR。</p><ul><li><p>$C _{1}$的比较好解释：因为所有指令在取指周期内，第一步需要做的事情就是 (PC)-&gt;MAR。于是硬件工程师规定：<strong>无论是哪一种指令，只要处于取指周期（FE&#x3D;1），同时还处于第一阶段（$T <em>{0} $）的话，就要完成 (PC)-&gt;MAR 这样的操作，也即是 $C <em>{1}$对应的操作，其对应的逻辑化表达式为 $C</em>{1} $&#x3D; $FE·T</em>{0} $</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161657606.png" loading="lazy"></p></li></ul><p>说到这里大家可能就已经明白了，只要能写出某一个微命令对应的<strong>逻辑化表达式</strong>，然后设计相应的<strong>逻辑电路</strong>即可，但理想很美好，现实很骨感。上面那个例子的逻辑电路设计起来是非常简单的，而且最重要的是该微操作仅出现在取指周期的第一阶段；<strong>但有的微操作，例如 M(MAR)-&gt;MDR 它们使用的就非常频繁，那么他们应该怎么设计呢？这就是本节内容的核心</strong>。在学习硬件时大家要牢牢把握 “<strong>逻辑化表达式是电路的数学化描述</strong>” 这句话的深刻含义。</p><p>$M(MAR)-&gt;MDR$ 的逻辑化表达式和电路如下图所示：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161658376.png" alt="image-20230416165850266" loading="lazy"><br>逻辑化表达式为：  $FE· T_{1} +IND· T_{1} (  ADD+ STA+  LDA+  JMP+ BAN)+ EX· T_{1}(ADD+LDA) $</p><ul><li><p>$ FE· T_{1} $：与运算，如果结果为 1，就表示需要进行 M(MAR)-&gt;MDR 微操作  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017310.png" alt="image-20230416201715192" loading="lazy"></p></li><li><p>$EX· T_{1}(ADD+LDA) $：如果处在 ADD 加法命令或 LDA 命令的执行周期的 $T_{1}$​阶段也表示需要进行 M(MAR)-&gt;MDR 微操作  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161659864.png" alt="image-20230416165902772" loading="lazy"></p></li></ul><h2 id="5-3-硬布线控制器设计"><a href="#5-3-硬布线控制器设计" class="headerlink" title="5.3.硬布线控制器设计"></a>5.3.硬布线控制器设计</h2><ul><li><strong>注意</strong>：此部分内容在考试中基本不会涉及，但是对于理解硬布线控制却很有帮助。</li></ul><h3 id="5-3-1-硬布线控制器设计步骤"><a href="#5-3-1-硬布线控制器设计步骤" class="headerlink" title="5.3.1.硬布线控制器设计步骤"></a>5.3.1.硬布线控制器设计步骤</h3><p><strong>硬布线控制器设计步骤如下</strong>：</p><p><strong>①：分析各个阶段的微操作序列（取指，间指，执行、中断）</strong></p><ul><li>确定哪些指令在什么阶段、在什么条件下会使用到的微操作。</li></ul><p><strong>②：选择 CPU 的控制方式</strong></p><ul><li>采用定长机器周期还是不定长机器周期？每个机器周期安排几个节拍？</li><li>注意：后面讲解采用同步控制方式（定长机器周期），一个机器周期内安排 3 个节拍。</li></ul><p><strong>③：安排微操作时序</strong></p><ul><li>如何用 3 个节拍完成整个机器周期内的所有微操作。</li></ul><p><strong>④：电路设计</strong></p><ul><li>确定微操作命令的逻辑表达式，并用电路实现。</li></ul><h3 id="5-3-2-步骤一：分析各个阶段的微操作序列"><a href="#5-3-2-步骤一：分析各个阶段的微操作序列" class="headerlink" title="5.3.2.步骤一：分析各个阶段的微操作序列"></a>5.3.2.步骤一：分析各个阶段的微操作序列</h3><p><strong>如果我们能罗列出某个系统在各个阶段的微操作序列，就可以知道在什么情况下需要使用到这个微操作</strong>。</p><p><strong>取指周期</strong>（所有指令都一样）。</p><ul><li>PC-&gt;MAR</li><li>1-&gt;R</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;IR</li><li>OP(IR)-&gt;ID（ID 是指令译码器）</li><li>(PC)+1-&gt;PC</li></ul><p><strong>间址周期</strong>（所有指令都一样）。</p><ul><li>Ad(IR)-&gt;MAR（找寻真正地址）</li><li>1-&gt;R</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;Ad(IR)</li></ul><p><strong>执行周期</strong>（各不相同），例如：</p><p><strong>CLA</strong>：clear ACC 指令、ACC 清零。</p><ul><li>0-&gt;ACC</li></ul><p><strong>LDA X</strong>：取数指令，把 X 所指内容取到 ACC。</p><ul><li>Ad(IR)-&gt;MAR</li><li>1-&gt;R</li><li>M(MAR)-&gt;MDR</li><li>MDR-&gt;ACC</li></ul><p><strong>JMP X</strong>：无条件转移。</p><ul><li>Ad(IR)-&gt;PC</li></ul><p><strong>BAN X</strong>：条件转移，当 ACC 为负时转移（属于机器状态条件）。</p><ul><li>$A_{0}⋅Ad(IR)+ \overline A_{0}⋅(PC)-&gt;CP$</li></ul><h3 id="5-3-3-步骤三：安排微操作时序"><a href="#5-3-3-步骤三：安排微操作时序" class="headerlink" title="5.3.3.步骤三：安排微操作时序"></a>5.3.3.步骤三：安排微操作时序</h3><ul><li><strong>注意</strong>：第二步已经完成，我们会采用定长机器周期，并且每个机器周期内安排三个节拍。</li></ul><p><strong>安排微操作时序有如下原则</strong>：</p><ul><li><strong>原则一</strong>：微操作的先后顺序不得随意更改（比如 PC-&gt;MAR 一定在 M(MAR)-&gt;MDR 之前完成）。</li><li><strong>原则二</strong>：被控对象不同的微操作尽量安排在一个节拍内完成（比如 PC-&gt;MAR 控制对象为寄存器，1-&gt;R 控制对象为主存，因此尽量安排在同一个节拍内完成）。</li><li><strong>原则三</strong>：占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序（比如寄存器之间的交互快于寄存器与主存的交互，因此如果可以的话尽量将其放在一个节拍完成）。</li></ul><p>比如<strong>取指周期</strong>，上面得到的微操作序列，在这种原则下是不合适的，因此更改如下：</p><ul><li>PC-&gt;MAR 和 1-&gt;R 由于被控对象不同的，所以放在一个节拍内。</li><li>(PC+1)-&gt;PC 位置随意，只要在 PC-&gt;MAR 之后即可，所以搭配一个 M(MAR)-&gt;MDR 让其在一个节拍内进行。<strong>不把 M(MAR)-&gt;MDR 放在后面的原因是因为这是从主存取数据，时间较长，起码得保证一个时钟周期</strong>。</li><li>后面两个是 CPU 内部寄存器的数据传送，<strong>因此速度很快，在一个时钟周期内是可以一次同时发出两个微命令的</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161700481.png" alt="image-20230416170059393" loading="lazy"></p><p><strong>间址周期安排如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161701021.png" alt="image-20230416170115936" loading="lazy"></p><p><strong>执行周期的设计可以说是整个设计的核心所在</strong>，不同指令的执行周期千差万别，具体如何设计是硬件工程师的任务，在这里我们只是简单了解即可。主要是想让大家明白一点，<strong>指令的设计是一个非常严谨的事情，它有哪几个周期，一个周期内有几个节拍，一个节拍要完成哪些微操作，这些都是必须要考虑到的事情</strong>。</p><ul><li>设计时会将指令分为<strong>非访存，访存和转移指令</strong>等。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161705356.png" alt="image-20230416170547257" loading="lazy"></p><h3 id="5-3-4-步骤四：组合逻辑设计（电路设计）"><a href="#5-3-4-步骤四：组合逻辑设计（电路设计）" class="headerlink" title="5.3.4.步骤四：组合逻辑设计（电路设计）"></a>5.3.4.步骤四：组合逻辑设计（电路设计）</h3><p><strong>①：列出操作时间表：也即列出在取指、间址、执行和中断周期， $T_{0}$​、 $T_{1}$​和 $T_{2}$节拍内有可能用到的所有微操作</strong></p><p><strong>对于取指周期：</strong></p><ul><li><strong>需要用到该微操作的填 “1”，否则空</strong></li><li>注意表格中的<strong>状态条件栏</strong>：如果填 “ $ I$”，表示该指令采用间接寻址，需要将间址特征送入，即 1-&gt;IND；如果填 “ $\overline I $”，表示该指令将直接进入执行周期，即<code> 1-&gt;EX</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708366.png" alt="image-20230416170802261" loading="lazy"></p><p><strong>对于间址周期</strong>：</p><ul><li><p>注意<strong>状态条件栏</strong>：如果填 “ $ \overline I \overline N \overline D $”，表示该指令采用多级间接寻址，直到该状态栏不填任何信息时，才表示结束了间接寻址，可以进入执行周期  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161708736.png" alt="image-20230416170816638" loading="lazy"></p></li></ul><p>③对于执行周期：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709818.png" alt="image-20230416170923708" loading="lazy"></p><p><strong>②：写出微操作命令的最简表达式</strong>。</p><p><strong>从上面的表格中我们可以看到 M(MAR)-&gt;MDR 操作的使用频次。</strong></p><ul><li>对于<strong>取指周期</strong>，只要处在 $T_{1}$​，无论哪一个指令都要用到 M(MAR)-&gt;MDR，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li><li>对于<strong>间址周期</strong>，只要处在 $T_{1}$​，并且是 $ADD$、 $STA$、 $LDA$、 $JMP$ 。<br>、 $BAN $ 指令的话，就要用到 M(MAR)-&gt;MDR，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li><li>对于<strong>执行周期</strong>，只要处在 $T_{1}$​，并且是 $ADD$ 或 $LDA$ 的话，就要用到 <code>M(MAR)-&gt;MDR</code>，故为 $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162018083.png" alt="image-20230416201850969" loading="lazy"></p><p><strong>综上，当逻辑表达式：“ $FE$· $T_{1}$​+ $IND$· $T_{1}$​( $ADD$+ $STA$+ $LDA$+ $JMP$+ $BAN $)+ $EX$· $T_{1}(ADD+LDA)$” 为 1 时，就要执行<code> M(MAR)-&gt;MDR</code> 微操作</strong>。</p><p><strong>③：设计出逻辑表达式对应的电路图</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161709168.png" alt="image-20230416170959038" loading="lazy"></p><h2 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4.总结"></a>5.4.总结</h2><p><strong>硬布线控制器的设计步骤如下</strong>：</p><p>1：分析每个阶段的微操作序列  。<br>2：选择 CPU 的控制方式  。<br>3：安排微操作时序  。<br>4：电路设计。</p><ul><li>列出操作时间表。</li><li>写出微操作命令的最简表达式。</li><li>画出逻辑图。</li></ul><p><strong>硬布线控制器的特点：</strong></p><ul><li>指令越多，设计和实现就越复杂，<strong>因此一般用于 RISC（精简指令集系统）</strong>。</li><li>如果扩充一条新的指令，则控制器的设计就需要大改，因此<strong>扩充指令困难。</strong></li><li>由于使用纯硬件实现控制，因此<strong>执行速度很快</strong>（微操作控制信号由组合逻辑电路即时产生）。</li></ul><h1 id="6-微程序控制器的基本原理"><a href="#6-微程序控制器的基本原理" class="headerlink" title="6.微程序控制器的基本原理"></a>6.微程序控制器的基本原理</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161719373.png" alt="image-20230416171943251" loading="lazy"></p><p>硬布线控制器，就是用纯硬件实现的控制器，电路非常复杂，也是整个计组中的难点之一，好在考试基本不考，而本节需要学习的<strong>微程序控制器倒是在大题中常有出现</strong>。</p><h2 id="6-1-微程序控制器的设计思路"><a href="#6-1-微程序控制器的设计思路" class="headerlink" title="6.1.微程序控制器的设计思路"></a>6.1.微程序控制器的设计思路</h2><ul><li>程序会被翻译为对等的机器指令。</li><li>机器指令又会被分为一个个的微操作序列。</li></ul><p><strong>微程序控制器的设计思路：把每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。所以微指令之于指令就等价于指令之于程序</strong>。</p><ul><li><strong>指令</strong>是对程序执行步骤的描述。</li><li><strong>微指令</strong>是对指令执行步骤的描述。</li><li><strong>微命令与微操作一一对应</strong>。</li><li><strong>微指令</strong>可能包含多个<strong>微命令（微操作）</strong>。</li></ul><p><strong>比如下图中的微指令 d，它指明了 “完成微操作 5、2”。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161714659.png" alt="image-20230416171442530" loading="lazy"><br><strong>每条指令对应一个微程序，这些微程序可以存到一个控制存储器中，用程序机器指令的办法来寻址每个微程序中的微指令。目前，大多计算机都采用微程序设计技术。</strong></p><p><strong>其中，存放微指令的控制存储器的单元地址称为微地址，一条微指令通常包含</strong>：</p><ul><li><strong>操作控制字段</strong>：又称操作码字段，用于产生某一步操作所需要的各种操作控制信号。</li><li><strong>顺序控制字段</strong>：又称微地址码字段，用于控制产生下一条要执行的微指令地址。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161715734.png" alt="image-20230416171506645" loading="lazy"></p><h2 id="6-2-微程序控制器的基本结构"><a href="#6-2-微程序控制器的基本结构" class="headerlink" title="6.2.微程序控制器的基本结构"></a>6.2.微程序控制器的基本结构</h2><h3 id="6-2-1-微程序控制器基本组成"><a href="#6-2-1-微程序控制器基本组成" class="headerlink" title="6.2.1.微程序控制器基本组成"></a>6.2.1.微程序控制器基本组成</h3><p><strong>微程序控制器基本组成:</strong></p><ul><li><p><strong>控制存储器 CM：</strong> 它是微程序控制器的核心部件，<strong>用于存放各指令对应的微程序，使用只读存储器 ROM 构成</strong>。每一条机器指令对应的微指令序列，由 CPU 厂商负责设计，并且在 CPU 出厂之前就已经把 ROM 里面的微程序数据全部写好了。</p></li><li><p><strong>微地址形成部件：</strong> 由于不同指令对应的微程序是不同的，<strong>因此需要根据该指令的操作码来确定它所对应的微程序的起始地址</strong>，以保证微指令的连续进行。</p></li><li><p><strong>微地址寄存器 CMAR：</strong> 有 MAR 就有 CMAR，和 MAR 一样，<strong>它用于接收微地址形成部件送来的微地址</strong>；同时 CMAR 还有一个别名，叫做 u u uPC，其实就是把 PC 和 MAR 整合到了一起。</p></li><li><p><strong>地址译码器：</strong> 有了地址就需要地址译码器，<strong>地址译码器会把地址码转换为存储单元控制信号。</strong></p></li><li><p><strong>微指令寄存器 CMDR：</strong> 有 MDR 就有 CMDR，它是微指令寄存器，别名叫做 u u uIR，<strong>用于存放从 CM 中取出的微指令，它的位数同微指令的字长。</strong></p></li><li><p><strong>顺序逻辑控制单元</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161716475.png" alt="image-20230416171648365" loading="lazy"></p><h3 id="6-2-1-微程序控制器工作过程"><a href="#6-2-1-微程序控制器工作过程" class="headerlink" title="6.2.1.微程序控制器工作过程"></a>6.2.1.微程序控制器工作过程</h3><p><strong>微程序控制器基本组成：当 CPU 取到一条指令之后，流程如下</strong>：</p><ol><li>把指令的<strong>操作码</strong>送给<strong>微地址形成部件</strong>，以确定<strong>微指令序列的起始地址</strong>。</li><li>根据<strong>顺序逻辑</strong>及其他标志信息等来确定<strong>接下来要执行的微指令的地址。</strong></li><li>将微指令地址<strong>放入到 CMAR</strong> 中。</li><li>经过地址译码器译码后就可以<strong>选中 CMAR 所指向的微指令</strong>。</li><li>取出该微指令，<strong>存放到 CMDR 中。</strong></li><li>(执行完该微指令后需要把微指令 “下地址” 信息送给顺序逻辑，结合其他信息用于判断下一个微指令)。</li><li>硬件电路需要根据该微指令的<strong>控制码部分</strong>，向 <strong>CPU 内部其他部件或系统总线</strong>发出控制信号（$PC_{out} ,MAR _{in}$，$1-&gt;R$ 等等）。</li></ol><h2 id="6-3-微程序控制器的工作原理"><a href="#6-3-微程序控制器的工作原理" class="headerlink" title="6.3.微程序控制器的工作原理"></a>6.3.微程序控制器的工作原理</h2><ul><li><p><strong>所有指令的取指周期、间址周期和中断周期几乎是一样的，所以这几个周期所对应的微指令序列也是可以共享的，因此在 CM 中只会存储一份</strong>。</p></li><li><p>取指周期的微程序段通常是公用的，所以 <strong>如果某指令系统中有 n 条机器指令，则 CM 中微程序段的个数至少是 n+1 个</strong>，而对于一些早期的 CPU，物联网设备的 CPU 由于其 CPU 可以不包含间址周期和中断周期，所以不包含进去。</p></li><li><p><strong>需要注意</strong>：物理上取指周期、执行周期看起来像两个微程序，但逻辑上应该将其看作一个整体。因此，“<strong>一条指令对应一个微程序</strong>” 的说法是正确的。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161718354.png" alt="image-20230416171824240" loading="lazy"></p><h1 id="7-微指令的设计"><a href="#7-微指令的设计" class="headerlink" title="7.微指令的设计"></a><a name="7.微指令的设计">7.微指令的设计</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161725625.png" alt="image-20230416172512509" loading="lazy"></p><h2 id="7-1-微指令的格式"><a href="#7-1-微指令的格式" class="headerlink" title="7.1.微指令的格式"></a>7.1.微指令的格式</h2><h3 id="7-1-1-水平型微指令"><a href="#7-1-1-水平型微指令" class="headerlink" title="7.1.1.水平型微指令"></a>7.1.1.水平型微指令</h3><p><strong>水平型微指令：是指一条微指令可以定义多个可并行执行的微命令</strong>。</p><ul><li><strong>优点：</strong> 微程序短，执行速度快。</li><li><strong>缺点：</strong> 微指令长，编写微程序较为麻烦。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721386.png" loading="lazy"></p><p><strong>水平型微指令其操作控制码部分较长，如果采用水平型微指令，那么指令的条数较少（一条微指令可以完成多个微操作或微命令），所以指令体积就会感觉很 “胖”</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721563.png" loading="lazy"></p><h3 id="7-1-2-垂直型微指令"><a href="#7-1-2-垂直型微指令" class="headerlink" title="7.1.2.垂直型微指令"></a>7.1.2.垂直型微指令</h3><p><strong>垂直型微指令：是指一条微指令只能定义一个微命令，由微操作码字段规定具体功能</strong>。</p><ul><li><strong>优点</strong>：微指令短、简单、规整、便于编写微程序。</li><li><strong>缺点</strong>：微程序长，执行速度慢，工作效率低。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161721619.png" loading="lazy"></p><p><strong>垂直型微指令其操作控制码部分短，如果采用垂直型微指令，那么指令的条数较多（一条微指令只能定义一个微操作或微命令），所以指令体积就会感觉很 “瘦”。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722551.png" alt="image-20230416172209461" loading="lazy"></p><h3 id="7-1-3-混合型微指令"><a href="#7-1-3-混合型微指令" class="headerlink" title="7.1.3.混合型微指令"></a>7.1.3.混合型微指令</h3><p><strong>混合型微指令：在垂直型的基础上增加一些不复杂的并行操作。微指令较短，仍便于编写，形成的微程序也不长，执行速度加快。</strong></p><h2 id="7-2-微指令的编码方式"><a href="#7-2-微指令的编码方式" class="headerlink" title="7.2.微指令的编码方式"></a>7.2.微指令的编码方式</h2><p><strong>微指令的编码方式：又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目的是在保证速度的情况下，尽量缩短微指令字长。</strong></p><h3 id="7-2-1-直接编码（直接控制）"><a href="#7-2-1-直接编码（直接控制）" class="headerlink" title="7.2.1.直接编码（直接控制）"></a>7.2.1.直接编码（直接控制）</h3><p><strong>直接编码：直接编码无需译码，在微指令的操作控制字段中，每一位代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置为 1 或 0 即可，每个微命令对应并控制数据通路中的一个微操作。</strong></p><ul><li><strong>优点</strong>：简单、直观、执行速度快、操作并行性好。</li><li><strong>缺点</strong>：微指令字长过长，n 个微指令就要求微指令的操作字段有 n 位，造成控制存储器容量变得很大。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161722368.png" alt="image-20230416172236277" loading="lazy"></p><ul><li>上图表示发出 (PC)-&gt;MAR 和 1-&gt;R 信号。</li></ul><h3 id="7-2-2-字段直接编码"><a href="#7-2-2-字段直接编码" class="headerlink" title="7.2.2.字段直接编码"></a>7.2.2.字段直接编码</h3><p><strong>字段直接编码：将微指令的微命令字段分成若干小字段，然后把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中</strong>。</p><ul><li><strong>互斥性微命令</strong>：不能并发执行（比如 PC-&gt;MAR 和 PC+1-&gt;PC）。</li><li><strong>相容性微命令</strong>：可以并发执行（比如 PC-&gt;MAR 和 1-&gt;R）。</li></ul><p><strong>每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723579.png" alt="image-20230416172300488" loading="lazy"></p><p><strong>微命令字段分段的原则为</strong>：</p><ul><li><strong>互斥性微命令分在同一段内，相容性微命令分在不同段内</strong>。</li><li>每个小段中包含的<strong>信息位不能太多</strong>，否则将增加译码线路的复杂性和移码时间。</li><li><strong>一般每个小段还要留出一个状态，表示本字段不发出任何微命令</strong>。因此当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，通常 000 表示不操作。</li></ul><p><strong>字段直接编码优缺点如下</strong></p><ul><li><strong>优点</strong>：可以缩短微指令字长。</li><li><strong>缺点</strong>：由于要通过译码电路后再发出微命令，因此比直接编码要慢。</li></ul><h3 id="7-2-3-字段间接编码"><a href="#7-2-3-字段间接编码" class="headerlink" title="7.2.3.字段间接编码"></a>7.2.3.字段间接编码</h3><p><strong>字段间接编码：一个字段的某些微命令需要用另一个字段中的某些微命令解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐编码。</strong></p><ul><li><strong>优点</strong>：可以进一步缩短微指令字长。</li><li><strong>缺点</strong>：削弱了微指令的并行控制能力，所以通常作为字段直接编码的一种辅助手段。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723204.png" alt="image-20230416172318107" loading="lazy"></p><h2 id="7-3-微指令的地址形成方式"><a href="#7-3-微指令的地址形成方式" class="headerlink" title="7.3.微指令的地址形成方式"></a>7.3.微指令的地址形成方式</h2><h3 id="7-3-1-下地址给出"><a href="#7-3-1-下地址给出" class="headerlink" title="7.3.1.下地址给出"></a>7.3.1.下地址给出</h3><p><strong>下地址给出：下一个微指令的地址直接由当前微指令的下地址字段指出。</strong></p><h3 id="7-3-2-操作码形成"><a href="#7-3-2-操作码形成" class="headerlink" title="7.3.2.操作码形成"></a>7.3.2.操作码形成</h3><p><strong>操作码形成：当机器指令取至指令寄存器之后，微指令的地址由操作码经微地址形成部件形成</strong>。</p><h3 id="7-3-3-增量计数法"><a href="#7-3-3-增量计数法" class="headerlink" title="7.3.3.增量计数法"></a>7.3.3.增量计数法</h3><p><strong>增量计数法：类似于 (PC+1)-&gt;PC，有 (CMAR+1)-&gt;CMAR。</strong></p><h3 id="7-3-4-分支转移"><a href="#7-3-4-分支转移" class="headerlink" title="7.3.4.分支转移"></a>7.3.4.分支转移</h3><p>有些微指令是转移指令，类似于 JMP。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161723517.png" loading="lazy"></p><h3 id="7-3-5-通过测试网络"><a href="#7-3-5-通过测试网络" class="headerlink" title="7.3.5.通过测试网络"></a>7.3.5.通过测试网络</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161724375.png" alt="image-20230416172418278" loading="lazy"></p><h3 id="7-3-6-由硬件产生微程序入口地址"><a href="#7-3-6-由硬件产生微程序入口地址" class="headerlink" title="7.3.6.由硬件产生微程序入口地址"></a>7.3.6.由硬件产生微程序入口地址</h3><ul><li><strong>第一条微指令地址</strong>：由专门硬件产生（用专门的硬件记录取指周期微程序首地址）。</li><li><strong>中断周期</strong>：由硬件产生中断周期微程序首地址（用专门的硬件记录）。</li></ul><h1 id="8-微程序控制单元的设计"><a href="#8-微程序控制单元的设计" class="headerlink" title="8.微程序控制单元的设计"></a>8.微程序控制单元的设计</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161750234.png" alt="image-20230416175020091" loading="lazy"></p><h2 id="8-1-微程序控制单元设计步骤"><a href="#8-1-微程序控制单元设计步骤" class="headerlink" title="8.1.微程序控制单元设计步骤"></a>8.1.微程序控制单元设计步骤</h2><h3 id="8-1-1-第一步：分析每个阶段的微操作序列"><a href="#8-1-1-第一步：分析每个阶段的微操作序列" class="headerlink" title="8.1.1.第一步：分析每个阶段的微操作序列"></a>8.1.1.第一步：分析每个阶段的微操作序列</h3><p><strong>无论是组合逻辑设计还是微程序设计，对于相同的 CPU 结构，两种控制单元的位操作码和节拍安排都是极其相似的</strong>。以微程序控制单元在取指阶段发出的微操作命令及节拍安排如下：</p><ul><li>$T_{0}$​：PC-&gt;MAR，1-&gt;R（对应微指令 a）。</li><li>$T_{1}$​：M(MAR)-&gt;MDR，PC+1-&gt;PC（对应微指令 b）。</li><li>$T_{2}$：MDR-&gt;IR,OP(IR)-&gt; 微地址形成部件（对应微指令 c）。</li></ul><p>相比于硬布线控制，只是在 $T_{2}$节拍内的微操作命令有所不同：<strong>微程序控制单元在 $T_{2}$节拍内要将指令的操作码送至微地址形成部件（OP(IR)-&gt; 微地址形成部件），以形成该条机器指令的微程序首地址。而硬布线控制单元在 $T_{2}$节拍内要将指令的操作码送至指令译码器，以控制 CU 发出相应的微命令（OP(IR)-&gt;ID）</strong>。</p><p>若把一个节拍 $t$ 内的微操作安排在一条微指令中完成，上述微操作就对应了 3 条微指令。<strong>但是由于微程序控制的所有控制信号都来自于微命令，而微命令又存在于控制存储器中，因此欲完成这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。</strong></p><ul><li>在取指微程序中，除第一条微指令外，<strong>其余微指令的地址均由上一条微指令的下地址字段直接给出</strong>，因此上述每条微指令都需要增加一个<strong>将微指令下地址字段送至 CMAR</strong> 的微操作，也即 <strong>Ad(CMDR)-&gt;CMAR。</strong></li><li>取指微程序的最后一条微指令，<strong>其后继微指令的地址是由微地址形成部件形成的</strong>，即微地址形成部件 -&gt;CMAR。为了反映该地址与操作码有关，因此记为 <strong>OP(IR)-&gt; 微地址形成部件 -&gt;CMAR</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161738357.png" alt="image-20230416173804248" loading="lazy"></p><p><strong>总之，考虑到需要形成后继的微指令地址，上述取指操作应需要 6 条微指令</strong>：</p><ul><li>$T_{0}$​：<strong>PC-&gt;MAR，1-&gt;R</strong></li><li>$T_{1}$​：Ad(CMDR)-&gt;CMAR</li><li>$T_{2}$：<strong>M(MAR)-&gt;MDR,(PC+1)-&gt;PC</strong></li><li>$T_{3} $：Ad(CMDR)-&gt;CMAR</li><li>$T_{4} $：<strong>MDR-&gt;IR</strong></li><li>$T_{5} $​：<strong>OP(IR)-&gt; 微地址形成部件 -&gt;CMAR</strong></li></ul><h3 id="8-1-2-第二步：写出对应机器指令的微操作命令及节拍安排"><a href="#8-1-2-第二步：写出对应机器指令的微操作命令及节拍安排" class="headerlink" title="8.1.2.第二步：写出对应机器指令的微操作命令及节拍安排"></a>8.1.2.第二步：写出对应机器指令的微操作命令及节拍安排</h3><p><strong>首先写出每个周期所需要的微操作，也就是把可以并行的微操作安排在同一时序进行，这一点请参照：</strong><a href=""><a href="#5.硬布线控制器">5.硬布线控制器</a></a>。</p><p>安排微操作时序有如下原则：</p><ul><li>原则一：微操作的<font color='red'>先后顺序</font>不得随意更改（比如PC-&gt;MAR一定在M（MAR）-&gt;MDR之前完成）</li><li>原则二：<font color='red'>被控对象不同的微操作</font>尽量安排在<font color='red'>一个节拍内</font>完成（比如PC-&gt;MAR控制对象为寄存器，1&gt;R控制对象为主存，因此尽量安排在同一个节拍内完成）</li><li>原则三：<font color='red'>占用时间较短</font>的微操作尽量安排在<font color='red'>一个节拍内完成，并允许有先后顺序</font>（比如寄存器之间的交互快于寄存器与主存的交互，因此如果可以的话尽量将其放在一个节拍完成）</li></ul><p>比如取指周期，上面我们所列的微操作序列，在这种原则下是不合适的，因此更改如下：</p><p><strong>另外还要加入一些特有的操作</strong>：</p><ul><li><p>取指周期内，除了最后一条微指令，<strong>每一条微指令结束后都要根据当前微指令的下地址字段指出下一条微指令的地址</strong>，即 Ad(CMDR)-&gt;CMAR；取指周期的最后一条微指令执行完成之后，<strong>要根据指令操作码确定其执行周期的微程序首地址</strong>，即 OP(IR)-&gt; 微地址形成部件 -&gt;CMAR。</p></li><li><p>执行周期内，<strong>每一条微指令结束后都要根据当前微指令的下地址字段指出下一条微指令的地址</strong>，即 Ad(CMDR)-&gt;CMAR；<strong>执行周期最后一条微指令其下地址是 0，又会指向取指周期第一条微指令</strong>  。</p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161747220.png" style="zoom: 50%;" / loading="lazy"></li></ul><h3 id="8-1-3-第三步：确定微指令格式"><a href="#8-1-3-第三步：确定微指令格式" class="headerlink" title="8.1.3.第三步：确定微指令格式"></a>8.1.3.第三步：确定微指令格式</h3><ul><li><strong>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数</strong>。</li><li><strong>根据 CM 中存储的微指令总数，确定微指令的顺序控制字段的位数。</strong></li><li><strong>最后按操作控制字段位数和顺序控制字段位数就可以确定微指令字长</strong>。</li></ul><p>更多细节请看<a href="#7.微指令的设计">7.微指令的设计</a>。</p><h3 id="8-1-4-第四步：编写微指令码点"><a href="#8-1-4-第四步：编写微指令码点" class="headerlink" title="8.1.4.第四步：编写微指令码点"></a>8.1.4.第四步：编写微指令码点</h3><p>根据操作控制字段每一位代表的微操作命令，编写每一条微指令的码点。</p><h2 id="8-2-微程序设计分类"><a href="#8-2-微程序设计分类" class="headerlink" title="8.2.微程序设计分类"></a>8.2.微程序设计分类</h2><h3 id="8-2-1-静态微程序设计和动态微程序设计"><a href="#8-2-1-静态微程序设计和动态微程序设计" class="headerlink" title="8.2.1.静态微程序设计和动态微程序设计"></a>8.2.1.静态微程序设计和动态微程序设计</h3><ul><li><strong>静态</strong>：微程序无需改变，采用 ROM。</li><li><strong>动态</strong>：通过改变微指令和微程序改变机器指令，有利于仿真，采用 DPROM。</li></ul><h3 id="8-2-2-毫微程序设计"><a href="#8-2-2-毫微程序设计" class="headerlink" title="8.2.2.毫微程序设计"></a>8.2.2.毫微程序设计</h3><ul><li><strong>微程序设计</strong>：使用微程序解释机器指令。</li><li><strong>毫微程序设计</strong>：使用毫微程序解释微程序。</li></ul><h2 id="8-3-硬布线控制器和微程序控制器比较"><a href="#8-3-硬布线控制器和微程序控制器比较" class="headerlink" title="8.3.硬布线控制器和微程序控制器比较"></a>8.3.硬布线控制器和微程序控制器比较</h2><table><thead><tr><th></th><th><strong>微程序控制器</strong></th><th><strong>硬布线控制器</strong></th></tr></thead><tbody><tr><td><strong>工作原理</strong></td><td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td><td>微操作控制信号由组合逻辑电路根据当前的指令码，状态和时序即时产生</td></tr><tr><td><strong>执行速度</strong></td><td>慢</td><td>快</td></tr><tr><td><strong>是否规整</strong></td><td>是</td><td>否</td></tr><tr><td><strong>应用场合</strong></td><td>CISC 和 CPU</td><td>RISC 和 CPU</td></tr><tr><td><strong>易扩充性</strong></td><td>易于扩充</td><td>很难扩充</td></tr></tbody></table><h1 id="9-中断和异常"><a href="#9-中断和异常" class="headerlink" title="9.中断和异常"></a>9.中断和异常</h1><h2 id="9-1-中断的作用"><a href="#9-1-中断的作用" class="headerlink" title="9.1.中断的作用"></a>9.1.中断的作用</h2><p><strong>在操作系统引入核心态和用户态这两种工作状态后，就需要考虑它们之间的切换问题了。具体来讲，操作系统内核工作在核心态，用户程序工作在用户态，系统不允许用户程序使用核心态的功能，但是用户程序为了完成某些操作又必须使用这些功能。</strong></p><ul><li>比如 C 语言中的<code>printf</code>可以向屏幕打印一些内容。在屏幕上显示内容，这本就是操作系统才能做到的事情，所以你编写的程序在运行必须使用相关功能。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>因此，需要在核心态建立一些 “门”，以便实现从用户态进入核心态。而中断就是 CPU 运行上层程序时唯一能进入这些 “门” 的途径，同时中断也是让操作系统内核夺回 CPU 使用权的唯一途径。发生中断时，用户态会立即进入核心态，这是通过硬件实现的</strong>。</p><h2 id="9-2-中断的类型"><a href="#9-2-中断的类型" class="headerlink" title="9.2.中断的类型"></a>9.2.中断的类型</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752409.png" alt="image-20230416175223296" loading="lazy"></p><h3 id="9-2-1-外中断（中断）"><a href="#9-2-1-外中断（中断）" class="headerlink" title="9.2.1.外中断（中断）"></a>9.2.1.外中断（中断）</h3><p><strong>中断：也称为外中断，指中断信号来自于 CPU 外部，也即与当前执行的指令无关，例如</strong>：</p><ul><li><p><strong>时钟部件</strong>会每隔一个时间片给 CPU 发送一个<strong>时钟中断</strong>信号，防止某些程序长时间抢占 CPU。</p></li><li><p><strong>输入 &#x2F; 输出处理完成后，相关设备也会发送一个中断信号</strong>，希望处理机能够向设备发下一个输入 &#x2F; 输出请求，同时让完成输入 &#x2F; 输出后的程序继续运行  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161752751.png" alt="image-20230416175236635" loading="lazy"></p></li></ul><h3 id="9-2-2-内中断（异常）"><a href="#9-2-2-内中断（异常）" class="headerlink" title="9.2.2.内中断（异常）"></a>9.2.2.内中断（异常）</h3><p><strong>内中断：也称为异常 (trap)，指中断信号来自于 CPU 内部，也即与当前执行的指令有关，例如</strong>：</p><ul><li>试图在用户态下执行特权指令。</li><li>执行除法指令时发现除数为 0。</li><li>应用程序想要请求操作系统内核为其提供服务，此时会执行一条特殊的指令——<strong>陷入指令（<code>trap</code>）</strong>，该指令会引发一个内中断信号（比如 C 语言中的<code>printf</code>）。</li></ul><p><strong>对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现异常应立即处理</strong>。</p><h2 id="9-3-中断的处理过程"><a href="#9-3-中断的处理过程" class="headerlink" title="9.3.中断的处理过程"></a>9.3.中断的处理过程</h2><p>此部分内容需要用到大量计组的知识，不是三言两语就能说清楚的，这里只是简单谈及，读者可以查阅文章最开始的链接进行学习  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161757080.png" loading="lazy"></p><ul><li><p><strong>关中断</strong>：在中断服务程序中，为了<strong>保护中断现场</strong> (即 CPU 主要寄存器中的内容) 期间不被新的中断所打断，必须关中断，从而<strong>保证被中断的程序在中断服务程序执行完毕后能接着正确地执行</strong>。</p></li><li><p><strong>保存断点</strong>：为保证在中断服务程序执行那个完毕后能<strong>正确地返回原来的程序</strong>，必须将原来程序的断点（即 PC 的内容）<strong>保存</strong>起来。这一点我们在<a href="#2.指令执行过程">2.指令执行过程</a>中有过详细介绍。</p></li><li><p><strong>引出中断服务程序</strong>：<strong>其实质是取出中断服务程序的入口地址并传送给程序计数器 PC。</strong></p></li><li><p><strong>保护现场：</strong> 保存<strong>通用寄存器和状态寄存器</strong>的内容（即保存 ACC 寄存器的值），以便返回原程序后可以<strong>恢复 CPU 环境</strong>，可以使用堆栈，也可以使用特定存储单元。</p></li><li><p><strong>中断服务：</strong> 主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲寄存器 （中断服务的过程中有可能会修改 ACC 寄存器的值）。</p></li><li><p><strong>恢复现场：</strong> 通过<strong>出栈指令或取数指令</strong>把之前保存的信息送回寄存器中（把原程序算到一般的 ACC 值恢复原样）。</p></li><li><p><strong>中断返回：通过中断返回指令回到</strong>原程序断点<strong>处。</strong></p></li></ul><h1 id="10-指令流水线基本概念性能指标"><a href="#10-指令流水线基本概念性能指标" class="headerlink" title="10.指令流水线基本概念性能指标"></a><a name="10.指令流水线基本概念性能指标">10.指令流水线基本概念性能指标</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161945862.png" alt="image-20230416194547727" loading="lazy"></p><h2 id="10-1-指令流水的定义"><a href="#10-1-指令流水的定义" class="headerlink" title="10.1.指令流水的定义"></a>10.1.指令流水的定义</h2><p><strong>前面说过，一条指令的执行过程可以分成多个阶段，不同的计算机有不同的分法，其中比较通用的划分方法就是划分为取指，分析和执行三个阶段</strong>。</p><ul><li><p><strong>取指</strong>：根据 PC 内容访问主存储器，取出一条指令送到 IR 中。</p></li><li><p><strong>分析</strong>：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址 EA，并存有效地址 EA 中取出操作数。</p></li><li><p><strong>执行</strong>：根据操作码字段完成指令规定的功能，即把运算结果写入到通用寄存器或主存中  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758588.png" loading="lazy"></p></li></ul><p>当多条指令在处理器中执行时，会有如下三种执行方式，称之为指令流水：</p><ul><li>顺序执行</li><li>一次重叠</li><li>二次重叠</li></ul><h3 id="10-1-1-顺序执行方式"><a href="#10-1-1-顺序执行方式" class="headerlink" title="10.1.1.顺序执行方式"></a>10.1.1.顺序执行方式</h3><p><strong>顺序执行方式：指令会按顺序执行，前一条指令执行完之后，才启动下一条指令。传统的冯诺依曼机便采用此种方式，又称其为串行执行方式</strong>。</p><ul><li><strong>优点</strong>：控制<strong>简单</strong>，硬件<strong>代价小。</strong></li><li><strong>缺点</strong>：执行指令的<strong>速度较慢</strong>，任何时刻，处理机中<strong>只有一条指令</strong>在执行，各功能部件<strong>利用率很低。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758581.png" loading="lazy"></p><p>**设取指、分析、执行 3 个阶段的时间都相等，用 $t$ 表示，那么顺序执行 $n$条指令所用时间为 $T&#x3D;3nt $**。</p><h3 id="10-1-2-一次重叠方式"><a href="#10-1-2-一次重叠方式" class="headerlink" title="10.1.2.一次重叠方式"></a>10.1.2.一次重叠方式</h3><p><strong>一次重叠方式：同时进行第 k 条指令的 “执行阶段” 和第 k+1 条指令的 “取指阶段”。</strong></p><ul><li><strong>优点</strong>：程序的执行时间<strong>缩短了 $ \frac{1}{3} $​</strong>，各功能部件的<strong>利用率明显提高</strong>。</li><li><strong>缺点</strong>：需要付出较大的<strong>硬件代价</strong>，控制过程也比顺序执行<strong>复杂。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161758172.png" loading="lazy">  </p><p><strong>采用此种方式时，执行 $n$条指令所用时间为</strong>：</p><p>$T&#x3D;3t+(n-1)×2t&#x3D;(1+2n)t $</p><h3 id="10-1-3-二次重叠执行方式"><a href="#10-1-3-二次重叠执行方式" class="headerlink" title="10.1.3.二次重叠执行方式"></a>10.1.3.二次重叠执行方式</h3><p><strong>二次重叠方式：为了进一步提高指令的执行速度，可以把 “取 $K$+1 条指令” 提前到 “分析第 $K$ 条指令”的期间完成，使 “分析第 k+1 条指令” 与“执行第 k 条指令”同时进行</strong>。</p><ul><li><strong>优点</strong>：使指令的执行时间缩短了近 2&#x2F;3。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162017986.png" loading="lazy"></p><p><strong>采用此种方式，执行 $n$条指令所用时间为</strong>：</p><p>$T&#x3D;3t+(n-1)×t&#x3D;(2+n)t $</p><p><strong>这是一种理想的指令执行方式，在正常情况下，处理机中同时有 3 条指令在执行. 若每条指令需要通过 4 个或 5 个执行步骤完成，则可以采取 3 次或 4 次重叠执行方式（考试常考 5 次）</strong>。</p><h2 id="10-2-流水线的表示方法"><a href="#10-2-流水线的表示方法" class="headerlink" title="10.2.流水线的表示方法"></a>10.2.流水线的表示方法</h2><h3 id="10-2-1-指令执行过程图"><a href="#10-2-1-指令执行过程图" class="headerlink" title="10.2.1.指令执行过程图"></a>10.2.1.指令执行过程图</h3><p><strong>指令执行过程图：该图用于描述指令的执行过程以及影响流水线的因素，横坐标表示时间、纵坐标表示指令序列。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161759655.png" alt="image-20230416175911550" loading="lazy"></p><h3 id="10-2-2-时空图"><a href="#10-2-2-时空图" class="headerlink" title="10.2.2.时空图"></a>10.2.2.时空图</h3><p><strong>指令执行过程图：在时空图中，横坐标表示时间（输入流水线中的各个任务在流水线中所经过的时间）；纵坐标表示空间，即流水线的每个流水段（对应各个执行部件）。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171125130.png" alt="image-20230416175942607" loading="lazy"></p><ul><li>从上图中可以看出，第一条指令 $I_{1}$在时刻 $t_{0}$​进入流水线，在时刻$ t_{4}$​流出流水线。</li><li>第二条指令$I_{2} $在时刻 $T_{1}$进入流水线，在时刻 $t_{5}$流出流水线。</li><li>以此类推，每经过一个Δt 时间，便有一条指令进入流水线，从时刻$ t_{4}$开始有一条指令流出流水线。</li></ul><h2 id="10-3-流水线性能指标"><a href="#10-3-流水线性能指标" class="headerlink" title="10.3.流水线性能指标"></a>10.3.流水线性能指标</h2><h3 id="10-3-1-吞吐率"><a href="#10-3-1-吞吐率" class="headerlink" title="10.3.1.吞吐率"></a>10.3.1.吞吐率</h3><p><strong>吞吐率：是指在单位时间内流水线所完成的任务数量，或是输出结果的数量</strong>。</p><p><strong>假设任务数为 n n n，处理完这 $n$个任务所用时间为 $ T_{k}$​，则计算流水线吞吐率（ $ TP$）的最基本公式为</strong></p><p>$ TP&#x3D;\frac{n}{T_{k}} $</p><p><strong>对应时空图如下</strong>：</p><ul><li><p>一条指令的执行分为 $K$ 个阶段，每个阶段耗时Δt，一般取Δt &#x3D; 一个时钟周期  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png" alt="image-20230416180116454" loading="lazy"></p></li></ul><p><strong>则流水线的实际吞吐率为</strong>：</p><p>$TP&#x3D;\frac{n}{(k+n-1)\Delta t} $</p><p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p><p>$ \lim\limits_{n \to \infty}TP&#x3D;\frac{n}{(k+n-1)\Delta t} $</p><p><strong>故</strong>：</p><p>$ TP_{max}&#x3D;\frac{1}{\Delta t} $</p><h3 id="10-3-2-加速比"><a href="#10-3-2-加速比" class="headerlink" title="10.3.2.加速比"></a>10.3.2.加速比</h3><p><strong>加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</strong></p><p><strong>设 $T_{0}$​表示不使用流水线时的执行时间，即顺序执行所有指令花费的时长； $ T_{k}$​表示使用流水线的执行时间，则计算流水线加速比 $S $ 的基本公式为</strong></p><p>$S&#x3D;\frac{T_{0}}{T_{k}} $</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161801567.png" loading="lazy"></p><p><strong>单独完成一个任务耗时为 $ k\Delta t$，则顺序完成 $n$个任务耗时为 $ T_{0}&#x3D;nk\Delta $，且 $ T_{k}&#x3D;(k+n-1)\Delta $，故实际加速比为</strong>：</p><p>$ S&#x3D;\frac{nk\Delta}{(k+n-1)\Delta}&#x3D;\frac{kn}{k+n-1} $</p><p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p><p>$ \lim\limits_{n \to \infty}S&#x3D;\frac{kn}{k+n-1} $</p><p><strong>故</strong>：</p><p>$ S_{max}&#x3D;k $</p><h3 id="10-3-3-效率"><a href="#10-3-3-效率" class="headerlink" title="10.3.3.效率"></a>10.3.3.效率</h3><p><strong>加速比：流水线的设备利用率称为流水线的效率。在时空图上，流水线的效率定义为： $n$个任务占用的时空区有效面积与 $n$个任务所用的时间与 $K$ 个流水段所围成的时空区域总面积之比</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161802331.png" alt="image-20230416180206228" loading="lazy"></p><p><strong>则流水线效率 ( $E$) 的一般公式为</strong>：</p><p>$ E&#x3D;\frac{n 个任务占用的时空区有效面积}{n 个任务所用的时间与 k 个流水段所围成的时空区域总面积}&#x3D;\frac{T_{0}}{kT_{k}} $</p><p><strong>当连续输入 $n$趋向于无穷时就有</strong>：</p><p>$ \lim\limits_{n \to \infty}E&#x3D;\frac{T_{0}}{kT_{k}} $</p><p><strong>故</strong>：</p><p>$ E_{max}&#x3D;1 $</p><h1 id="11-指令流水线影响因素分类"><a href="#11-指令流水线影响因素分类" class="headerlink" title="11.指令流水线影响因素分类"></a>11.指令流水线影响因素分类</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810973.png" alt="image-20230416181019839" loading="lazy"></p><h2 id="11-1-影响指令流水线的因素"><a href="#11-1-影响指令流水线的因素" class="headerlink" title="11.1.影响指令流水线的因素"></a>11.1.影响指令流水线的因素</h2><p><a href="#10.指令流水线基本概念性能指标">10.指令流水线基本概念性能指标</a>中所讲到的流水线都是理想情况，但在实际情况中流水线的衔接似乎不那么完美，那么这当中的影响因素都有哪些呢？</p><h3 id="11-1-1-结构相关（资源冲突）"><a href="#11-1-1-结构相关（资源冲突）" class="headerlink" title="11.1.1.结构相关（资源冲突）"></a>11.1.1.结构相关（资源冲突）</h3><h4 id="11-1-1-1-概述"><a href="#11-1-1-1-概述" class="headerlink" title="11.1.1.1.概述"></a>11.1.1.1.概述</h4><p><strong>结构相关（资源冲突）：由于多条指令在同一时刻争用同一资源而形成的冲突称为结构相关</strong>。</p><p>如下图所示，<code>Load</code>指令在进入<code>Mem</code>阶段时，<code>Instr3</code>指令才刚进入取指阶段，两者都会访问主存所以可能导致资源上的冲突。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161806136.png" alt="image-20230416180647002" loading="lazy"></p><h4 id="11-1-1-2-解决方法"><a href="#11-1-1-2-解决方法" class="headerlink" title="11.1.1.2.解决方法"></a>11.1.1.2.解决方法</h4><p><strong>结构相关（资源冲突）解决方法</strong>：</p><ul><li><p><strong>第一种解决方法</strong>：后一相关指令<strong>暂停一周期</strong>。</p></li><li><p><strong>第二种解决方法</strong>：进行资源重复配置，<strong>专门设立数据存储器和指令存储器</strong>，使访问数据和访问指令<strong>专属于不同的存储块</strong>，互不干扰  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161805535.png" loading="lazy"></p></li></ul><h3 id="11-1-2-数据相关（数据冲突）"><a href="#11-1-2-数据相关（数据冲突）" class="headerlink" title="11.1.2.数据相关（数据冲突）"></a>11.1.2.数据相关（数据冲突）</h3><h4 id="11-1-2-1-概述"><a href="#11-1-2-1-概述" class="headerlink" title="11.1.2.1.概述"></a>11.1.2.1.概述</h4><p><strong>数据相关（数据冲突）：在一个程序中，如果存在必须等前一条指令执行完才能执行后一条指令的情形，则这两条指令为数据相关</strong>。</p><p>如下图所示，众多指令在依次执行。<code>sub</code>、<code>and</code>、<code>or</code>和<code>xor</code>这些指令都会用到<code>r1</code>这个操作数。其中<code>add</code>指令会把<code>r2</code>和<code>r3</code>相加的结果放入<code>r1</code>，在这个过程中，如果<code>and</code>后面的指令在<code>and</code>指令还没有把<code>r1</code>放入内存时就访问了<code>r1</code>，那么就会导致<code>sub</code>、<code>and</code>和<code>or</code>这三个指令拿到错误的<code>r1</code>，而只有<code>xor</code>拿到了正确的<code>r1</code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807614.png" alt="image-20230416180729500" loading="lazy"></p><h4 id="11-1-2-2-解决方法"><a href="#11-1-2-2-解决方法" class="headerlink" title="11.1.2.2.解决方法"></a>11.1.2.2.解决方法</h4><p><strong>数据相关（数据冲突）解决方法</strong>。</p><ul><li><p><strong>第一种解决方法</strong>：把遇到数据相关的指令及其后续指令<strong>都暂停一至几个时钟周期</strong>，直至数据相关问题消失后再继续进行，可以分为 <strong>硬件阻塞 (stall)</strong> 和 <strong>软件插入 “NOP</strong>“ 两种方法  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809003.png" alt="image-20230416180919877" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161808032.png" alt="image-20230416180835875" loading="lazy"></p><p><strong>第二种解决方法</strong>：使用<strong>数据旁路技术</strong>，仔细观察，<code>r1</code>的正确结果其实已经在执行阶段结束之后就生成了，因此<strong>可以把该指令的计算结果作为 ALU 的一个输入来源</strong>，直接开始计算过程  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161807591.png" alt="image-20230416180754468" loading="lazy"></p></li><li><p><strong>第三种解决方法</strong>：使用<strong>编译优化</strong>，通过编译器<strong>调整指令顺序</strong>，使得一些不需要该数据的后续指令先于这些指令执行。</p></li></ul><h3 id="11-1-3-控制相关（控制冲突）"><a href="#11-1-3-控制相关（控制冲突）" class="headerlink" title="11.1.3.控制相关（控制冲突）"></a>11.1.3.控制相关（控制冲突）</h3><h4 id="11-1-3-1-概述"><a href="#11-1-3-1-概述" class="headerlink" title="11.1.3.1.概述"></a>11.1.3.1.概述</h4><p><strong>控制相关（控制冲突）：当流水线遇到转移指令和其他改变 PC 值的指令而造成断流时，会引起控制相关、</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161809667.png" alt="image-20230416180943551" loading="lazy"></p><h4 id="11-1-3-2-解决方法"><a href="#11-1-3-2-解决方法" class="headerlink" title="11.1.3.2.解决方法"></a>11.1.3.2.解决方法</h4><p><strong>控制相关（控制冲突）解决方法</strong>：</p><ul><li><strong>转移指令分支预测</strong>：简单预测（永久 true 或者 false）、动态预测（根据历史情况）动态调整。</li><li><strong>预期转移成功和不成功两个控制流方向上的目标指令。</strong></li><li><strong>加快和提前形成条件码。</strong></li><li><strong>提高转移方向的猜准率。</strong></li></ul><h2 id="11-2-流水线的分类"><a href="#11-2-流水线的分类" class="headerlink" title="11.2.流水线的分类"></a>11.2.流水线的分类</h2><h3 id="11-2-1-根据流水线使用的级别不同分类"><a href="#11-2-1-根据流水线使用的级别不同分类" class="headerlink" title="11.2.1.根据流水线使用的级别不同分类"></a>11.2.1.根据流水线使用的级别不同分类</h3><ul><li><p><strong>部件功能级流水</strong>：就是<strong>把复杂的算数逻辑运算组成流水线工作方式</strong>。例如可以把浮点加法操作分为求阶、对阶、尾数相加以及规格化 4 个子过程。</p></li><li><p><strong>处理机级流水</strong>：就是<strong>把一条指令解释过程分为多个子过程</strong>。例如我们经常提到的取指、译码、执行和访存及写回 5 个子过程。</p></li><li><p><strong>处理间流水</strong>：就<strong>是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需要存放在与下一个处理器所共享的存储器中。</strong></p></li></ul><h3 id="11-2-2-根据流水线可以完成的功能分类"><a href="#11-2-2-根据流水线可以完成的功能分类" class="headerlink" title="11.2.2.根据流水线可以完成的功能分类"></a>11.2.2.根据流水线可以完成的功能分类</h3><ul><li><p><strong>单功能流水线</strong>：只能实现<strong>一种固定的专门功能</strong>的流水线。</p></li><li><p><strong>多功能流水线</strong>：通过<strong>各段间的不同连接方式可以同时或不同时地</strong>实现多种功能的流水线。</p></li></ul><h3 id="11-2-3-根据同一时间内各段之间的连接方式"><a href="#11-2-3-根据同一时间内各段之间的连接方式" class="headerlink" title="11.2.3.根据同一时间内各段之间的连接方式"></a>11.2.3.根据同一时间内各段之间的连接方式</h3><ul><li><p><strong>静态流水线</strong>：在同一时间内，流水线的各段<strong>只能按同一种功能</strong>的连接方式工作。</p></li><li><p><strong>动态流水线</strong>：在同一时间内，<strong>当某些段正在实现某种运算时，另一些段正在进行另一种运算</strong>。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</p></li></ul><h3 id="11-2-4-根据流水线的各个功能段之间是否有反馈信号"><a href="#11-2-4-根据流水线的各个功能段之间是否有反馈信号" class="headerlink" title="11.2.4.根据流水线的各个功能段之间是否有反馈信号"></a>11.2.4.根据流水线的各个功能段之间是否有反馈信号</h3><ul><li><p><strong>线性流水线</strong>：从输入到输出，<strong>每个功能段只允许经过一次</strong>，不存在反馈回路。</p></li><li><p><strong>非线性流水线</strong>：存在反馈回路，<strong>从输入到输出过程中，某些功能段将数次通过流水</strong>线，这种流水线适合进行线性递归的运算。</p></li></ul><h2 id="11-3-流水线多发技术"><a href="#11-3-流水线多发技术" class="headerlink" title="11.3.流水线多发技术"></a>11.3.流水线多发技术</h2><h3 id="11-3-1-超标量技术"><a href="#11-3-1-超标量技术" class="headerlink" title="11.3.1.超标量技术"></a>11.3.1.超标量技术</h3><p><strong>超标量技术：每个时钟周期内可以<font color='orange'>并发执行多条独立指令</font>，即以并行操作方式将两条或多条指令编译并执行，为此需要配置多个功能部件。超标量计算机<font color='orange'>不能调整指令的执行顺序</font>，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161810398.png" alt="image-20230416181059298" loading="lazy"></p><h3 id="11-3-2-超流水技术"><a href="#11-3-2-超流水技术" class="headerlink" title="11.3.2.超流水技术"></a>11.3.2.超流水技术</h3><p>超流水技术：在<font color='yellow'>一个时钟周期</font>内<font color='yellow'>再分段</font>，在一个时钟周期内<font color='yellow'>一个功能部件使用多次</font>。<font color='yellow'>不能调整</font>指令的<font color='yellow'>执行顺序</font>，靠编译程序解决优化问题。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161811432.png" alt="image-20230416181152329" loading="lazy"></p><h3 id="11-3-3-超长指令字"><a href="#11-3-3-超长指令字" class="headerlink" title="11.3.3.超长指令字"></a>11.3.3.超长指令字</h3><p><strong>超流水技术：由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可以达到上百位），为此需要采用多个处理部件。</strong></p><h1 id="12-五段式指令流水线"><a href="#12-五段式指令流水线" class="headerlink" title="12.五段式指令流水线"></a>12.五段式指令流水线</h1><p><strong>本节会介绍如下 5 类指令的执行过程，它们在考试中经常出现</strong>：</p><ul><li>运算类指令</li><li>LOAD 指令</li><li>STORE 指令</li><li>条件转移指令</li><li>无条件转移指令</li></ul><p><strong>指令在执行过程中会涉及如下过程</strong>：</p><ul><li><code>IF</code>：取指</li><li><code>ID</code>译码 &amp; 取数</li><li><code>EX</code>执行</li><li><del><code>M</code>：访存</del></li><li><code>WB</code>：写回寄存器</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161947573.png" alt="image-20230416194733427" loading="lazy"></p><p><strong>注意</strong>：</p><ul><li>在 RISC 处理器中只有 LOAD 和 STORE 才能访问主存。</li><li>转移类指令通常采用相对寻址（相对于 PC）。</li></ul><h2 id="12-1-运算类指令的执行过程"><a href="#12-1-运算类指令的执行过程" class="headerlink" title="12.1.运算类指令的执行过程"></a>12.1.运算类指令的执行过程</h2><p><strong>下表展示了 2 个较为典型的运算类指令:</strong></p><table><thead><tr></th></tr></thead><tbody><tr><td>加法指令（另个寄存器相加）</td><td>ADD R<sub>s</sub>,R<sub>d</sub></td><td>(R<sub>s</sub>)+(R<sub>d</sub>)-&gt; R<sub>d</sub></td></tr><tr><td>加法指令（寄存器与立即数相加）</td><td>ADD #996,R<sub>d</sub></td><td>996+(R<sub>d</sub>)-&gt; R<sub>d</sub></td></tr><tr><td>算数左移指令</td><td>SHL R<sub>d</sub></td><td>(R<sub>d</sub>)&lt;&lt;&lt;2-&gt; R<sub>d</sub></td></tr></tbody></table><p><strong>运算类指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p><strong>运算类指令步骤二（<code>ID</code>）：取出操作数到 ID 段的锁存器。</strong></p><ul><li>ADD Rs,Rd：Rs 放到 $A$中、Rd 放到 $B$ 中。</li><li>ADD #996,Rd：Rd 放到 $A$中，966 放到 $Imm$ 中。</li><li>SHL Rd：Rd 放到 $A$中。</li></ul><p><strong>运算类指令步骤三（<code>EX</code>）：进行运算，将结果存入 EX 段锁存器</strong>。</p><p><strong>运算类指令步骤四（<code>M</code>） ：对于 RISC 系统，计算结果会直接放入寄存器，所以是空段，什么事情都不用做，但要消耗相应的时间</strong>。</p><p><strong>运算类指令步骤五（<code>WB</code>）：运算结果写回指定寄存器</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161948409.png" loading="lazy"></p><h2 id="12-2-LOAD-指令执行过程"><a href="#12-2-LOAD-指令执行过程" class="headerlink" title="12.2.LOAD 指令执行过程"></a>12.2.LOAD 指令执行过程</h2><p><strong>LOAD 指令的功能是取数，会把主存或寄存器中的内容取至寄存器中，有如下两种描述方式</strong>：</p><table><thead><tr></tr></thead><tbody><tr><td>LOAD R<sub>d</sub>, 996(R<sub>s</sub>)</td><td>(996+(R<sub>s</sub>)) -&gt;R<sub>d</sub></td></tr><tr><td>LOAD R<sub>d</sub>, mem</td><td>(mem)-&gt;R<sub>d</sub></td></tr></tbody></table><p><strong>LOAD 指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p>**LOAD 指令步骤二（<code>ID</code>）：将基址寄存器的值放到锁存器 A A A、将偏移量放到 $Imm$**。</p><p><strong>LOAD 指令步骤三（<code>EX</code>）：进行运算，得到有效地址。</strong></p><p><strong>LOAD 指令步骤四（<code>M</code>） ：从数据 Cache 中取数并放入锁存器。</strong></p><p><strong>LOAD 指令步骤五（<code>WB</code>）：将取出的数写回寄存器。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161950321.png" loading="lazy"></p><h2 id="12-3-STORE-指令执行过程"><a href="#12-3-STORE-指令执行过程" class="headerlink" title="12.3.STORE 指令执行过程"></a>12.3.STORE 指令执行过程</h2><p><strong>STORE 指令的功能是存数，有如下两种描述方式</strong>：</p><table><thead><tr></tr></thead><tbody><tr><td>STORE R<sub>s</sub>, 996(R<sub>d</sub>)</td><td>R<sub>s</sub>-&gt;996+(R<sub>d</sub>))</td></tr><tr><td>STORE R<sub>s</sub>, mem</td><td>R<sub>s</sub>-&gt;(mem)</td></tr></tbody></table><p><strong>Store 指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p>**Store 指令步骤二（<code>ID</code>）：将基址寄存器的值放到锁存器 A A A、将偏移量放到 $Imm$、将要存的数放到 $B$**。</p><p><strong>Store 指令步骤三（<code>EX</code>）：进行运算，得到有效地址，并将锁存器 $B$ 的内容放到锁存器 Store。</strong></p><p><strong>Store 指令步骤四（<code>M</code>） ：写入数据 Cache</strong>。</p><p><strong>Store 指令步骤五（<code>WB</code>） ：空段。</strong></p><h2 id="12-4-条件转移指令执行过程"><a href="#12-4-条件转移指令执行过程" class="headerlink" title="12.4.条件转移指令执行过程"></a>12.4.条件转移指令执行过程</h2><p><strong>如下</strong>：</p><ul><li><strong>beq Rs,Rt, #偏移量</strong>：若 (Rs)&#x3D;&#x3D;(Rt)，则 (PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC，否则有 (PC)+ 指令字长 -&gt;PC。</li><li><strong>bne Rs,Rt, #偏移量</strong>：若 (Rs)!&#x3D;(Rt)，则 (PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC，否则有 (PC)+ 指令字长 -&gt;PC。</li></ul><p><strong>条件转移指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器。</strong></p><p>**条件转移指令步骤二（<code>ID</code>）：进行比较的两个数放入锁存器 $A$和 $B$、偏移量放入 $Imm$**。</p><p><strong>条件转移指令步骤三（<code>EX</code>）：进行运算，比较两个数。</strong></p><p><strong>条件转移指令步骤四（<code>M</code>） ：将目标 PC 值写回 PC。</strong></p><p><strong><del>条件转移指令步骤五</del>（<code>WB</code>） ：空段</strong>。</p><h2 id="12-5-无条件转移指令执行过程"><a href="#12-5-无条件转移指令执行过程" class="headerlink" title="12.5.无条件转移指令执行过程"></a>12.5.无条件转移指令执行过程</h2><p><strong>如下</strong>：</p><ul><li><strong>jmp #偏移量</strong>：(PC)+ 指令字长 +（偏移量 × 指令字长）-&gt;PC。</li></ul><p><strong>无条件转移指令步骤一（<code>IF</code>）：根据 PC 从指令 Cache 取指令到 IF 段的锁存器</strong>。</p><p>**无条件转移指令步骤二（<code>ID</code>）：偏移量放入 $Imm$**。</p><p><strong>无条件转移指令步骤三（<code>EX</code>）：将目标 PC 值写回 PC。</strong></p><p><strong>无条件转移指令步骤四（<code>M</code>） ：空段。</strong></p><p><strong>无条件转移指令步骤五（<code>WB</code>） ：空段</strong>。</p><h1 id="13-多处理器基本概念"><a href="#13-多处理器基本概念" class="headerlink" title="13.多处理器基本概念"></a>13.多处理器基本概念</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162004915.jpg" alt="第5章 中央处理器" loading="lazy"></p><h2 id="13-1-SISD、SIMD、MIMD-基本概念"><a href="#13-1-SISD、SIMD、MIMD-基本概念" class="headerlink" title="13.1.SISD、SIMD、MIMD 基本概念"></a>13.1.SISD、SIMD、MIMD 基本概念</h2><p><strong>计算机体系结构分类：基于指令流的数量和数据流的数量，可以将计算机体系结构分为如下 4 类</strong>：</p><ul><li><strong>单指令单数据流 SISD</strong></li><li><strong>单指令多数据流 SIMD</strong></li><li><strong>多指令单数据流 MISD</strong></li><li><strong>多指令多数据流 MIMD</strong></li></ul><h3 id="13-1-1-单指令单数据流-SISD"><a href="#13-1-1-单指令单数据流-SISD" class="headerlink" title="13.1.1.单指令单数据流 SISD"></a>13.1.1.单指令单数据流 SISD</h3><p><strong>单指令单数据流 SISD：常规的单处理器便是 SISD，其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：①各指令序列<strong>只能并发而不能并行</strong>；②每条指令<strong>处理一两个数据</strong>；③不是<strong>数据级并行技术</strong>。</li><li><strong>硬件组成</strong>：①一个<strong>处理器</strong> + 一个<strong>主存储器</strong>；②若采用指令流水线，则<strong>需要设置多个功能部件，采用多模块交叉存储器</strong>。</li></ul><p>《<a href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86&spm=1001.2101.3001.7020">计算机组成原理</a>》这门课程一直研究的便是 SISD。如下，<strong>此 CPU 在同一时间段内仅能处理一个进程或线程的一个指令序列，每条指令只能处理一两个数据。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955615.png" alt="image-20230416195506504" loading="lazy"></p><h3 id="13-1-2-单指令多数据流-SIMD"><a href="#13-1-2-单指令多数据流-SIMD" class="headerlink" title="13.1.2.单指令多数据流 SIMD"></a>13.1.2.单指令多数据流 SIMD</h3><p><strong>单指令多数据流 SIMD：其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：①各指令序列<strong>只能并发而不能并行</strong>；②每条指令<strong>可以同时处理多个具有相同特征的数据</strong>；③是<strong>数据级并行技术</strong>。</li><li><strong>硬件组成</strong>：①一个<strong>指令控制部件</strong> + 多个<strong>处理单元 &#x2F; 执行单元</strong> + 一个<strong>主存储器</strong>；②每个执行单元有<strong>各自的寄存器组、局部存储器、地址寄存器</strong>；③不同执行单元<strong>执行同一条指令、处理不同的数据。</strong></li></ul><p>如下，在 SIMD 系统中，<strong>CU 每次会取出一条指令，根据此指令发出控制信号给各个执行部件（如 ALU），每个执行部件都有各自的寄存器（组）。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161955174.png" alt="image-20230416195538067" loading="lazy"></p><p><strong>SIMD 系统善于对结构类似的大量数据做相同处理，例如</strong>：</p><ul><li>图像处理时，对每个像素点作 “高斯模糊”。</li><li>可用于优化 for 循环中对数组元素的重复处理。</li></ul><h3 id="13-1-3-多指令单数据流-MISD"><a href="#13-1-3-多指令单数据流-MISD" class="headerlink" title="13.1.3.多指令单数据流 MISD"></a>13.1.3.多指令单数据流 MISD</h3><p><strong>多指令单数据流 MISD：多条指令并行执行，处理同一个数据。现实中并不存在这种计算机。</strong></p><h3 id="13-1-4-多指令多数据流-MIMD"><a href="#13-1-4-多指令多数据流-MIMD" class="headerlink" title="13.1.4.多指令多数据流 MIMD"></a>13.1.4.<strong>多指令多数据流 MIMD</strong></h3><p><strong>多指令多数据流 MIMD：常规的多处理器便是 MIMD，其特性如下</strong>：</p><ul><li>各指令序列<strong>并行执行，分别处理多个不同的数据</strong>。</li><li>是一种<strong>线程级并行技术</strong>（甚至是线程级以上）。</li></ul><p><strong>MIMD 可以进一步分为：</strong></p><ul><li>多处理器系统</li><li>多计算机系统</li></ul><h4 id="13-1-4-1-多处理器系统"><a href="#13-1-4-1-多处理器系统" class="headerlink" title="13.1.4.1.多处理器系统"></a>13.1.4.1.多处理器系统</h4><p><strong>多处理器系统：是共享内存多处理器（SMP）的简称。其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：各处理器之间，可以通过 LOAD&#x2F;STORE 指令访问<strong>同一个主存储器</strong>，可以通过<strong>主存相互传送数据</strong>。</li><li><strong>硬件组成</strong>：①一台计算机内，有多个<strong>处理器</strong> + 一个<strong>主存储器</strong>；②多个处理器<strong>共享单一的物理地址空间。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161956973.png" alt="image-20230416195608820" loading="lazy"></p><h4 id="13-1-4-2-多计算机系统"><a href="#13-1-4-2-多计算机系统" class="headerlink" title="13.1.4.2.多计算机系统"></a>13.1.4.2.多计算机系统</h4><p><strong>多计算机系统：其特性和硬件组成如下</strong>：</p><ul><li><strong>特性</strong>：各计算机之间，<strong>不可以通过 LOAD&#x2F;STORE 指令直接访问对方的存储器</strong>，只能通过<strong>消息传递相互传送数据</strong>。</li><li><strong>硬件组成</strong>：①由多台计算机组成，所以有多个<strong>处理器</strong> + 多个<strong>主存储器</strong>；②每台计算机拥有<strong>各自的私有存储器</strong>，物理地址空间<strong>相互独立。</strong></li></ul><p>实际应用中，可以把单个任务拆分为多个任务，分别指派给不同的计算机执行。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161957622.png" alt="image-20230416195712433" loading="lazy"></p><h2 id="13-2-向量处理器"><a href="#13-2-向量处理器" class="headerlink" title="13.2.向量处理器"></a>13.2.向量处理器</h2><p>向量处理机的LOAD指令，可以将一个向量取到向量寄存器中；加法指令，可以实现两个向量相加应用于：向量计算、大量浮点数计算，空气动力学、核物理学、巨型矩阵计算问题很多超级计算机如中国的“银河”就是向量处理器。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304161959391.png" alt="image-20230416195929243" loading="lazy"></p><h1 id="14-硬件多线程的基本概念"><a href="#14-硬件多线程的基本概念" class="headerlink" title="14.硬件多线程的基本概念"></a>14.硬件多线程的基本概念</h1><p><strong>硬件多线程：在 <a href="">(王道 408 考研操作系统) 第二章进程管理 - 线程概念和多线程模型</a>这一节中我们说到了线程的一些缺点。线程粒度较进程来讲更细，而且线程切换包含很多开销，频繁切换线程必然会影响系统性能，所以为了减少开销便诞生了硬件多线程。在支持硬件多线程的 CPU 中，必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的切换只需激活选中的寄存器，从而省略了与存储器数据交换的环节，大大减少了线程切换的开销。共有如下 3 种实现方式</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162011405.png" alt="image-20230416201131263" loading="lazy"></p><p><strong>如下</strong>：</p><ul><li>对于<strong>不支持硬件多线程的 CPU</strong>：同一时刻只能有一个线程运行，线程切换时需要保护现场，产生额外开销。</li><li>对于<strong>支持硬件多线程的 CPU</strong>：不同线程运行在不同环境中。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012378.png" alt="image-20230416201232259" loading="lazy"></p><h2 id="14-1-细粒度多线程"><a href="#14-1-细粒度多线程" class="headerlink" title="14.1.细粒度多线程"></a>14.1.细粒度多线程</h2><p><strong>细粒度多线程：关键特征如下</strong>：</p><ul><li><strong>指令发射：轮流发射各线程的指令（每个时钟周期发射一个线程）</strong>。</li><li><strong>线程切换频率：每个时钟周期切换一次线程。</strong></li><li><strong>线程切换代价：低。</strong></li><li><strong>并行性：指令级并行、线程间不并行</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162012684.png" alt="image-20230416201249567" loading="lazy"></p><h2 id="14-2-粗粒度多线程"><a href="#14-2-粗粒度多线程" class="headerlink" title="14.2.粗粒度多线程"></a>14.2.粗粒度多线程</h2><p><strong>粗粒度多线程：关键特征如下</strong>：</p><ul><li><strong>指令发射：连续几个时钟周期，都发射同一线程的指令序列。流水线阻塞时，才切换另一个线程</strong>。</li><li><strong>线程切换频率：只有流水线阻塞时才切换另一个线程。</strong></li><li><strong>线程切换代价：高（需要重载流水线）。</strong></li><li><strong>并行性：指令级并行、线程间不并行。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013395.png" alt="image-20230416201302277" loading="lazy"></p><h2 id="14-3-同时多线程"><a href="#14-3-同时多线程" class="headerlink" title="14.3.同时多线程"></a>14.3.同时多线程</h2><p><strong>同时多线程：关键特征如下</strong>：</p><ul><li><strong>指令发射：一个时钟周期内同时发射多个线程的指令</strong>。</li><li><strong>线程切换频率：NULL。</strong></li><li><strong>线程切换代价：NULL</strong>。</li><li><strong>并行性：指令级并行、线程级并行。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162013448.png" alt="image-20230416201314329" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组-第四章 指令系统</title>
      <link href="/posts/de459af/"/>
      <url>/posts/de459af/</url>
      
        <content type="html"><![CDATA[<h1 id="1-指令和指令格式"><a href="#1-指令和指令格式" class="headerlink" title="1.指令和指令格式"></a>1.指令和指令格式</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152005362.png" alt="image-20230415200545273" loading="lazy"></p><h2 id="1-1-指令的概念及构成"><a href="#1-1-指令的概念及构成" class="headerlink" title="1.1.指令的概念及构成"></a>1.1.指令的概念及构成</h2><p><strong>指令（机器指令）：指示计算机执行某种操作的命令，是计算机运行的最小功能单位</strong>。</p><ul><li><p>指令集（指令系统）：一台计算机的所有指令的集合。</p></li><li><p><strong>注意</strong>：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。例如 X86 和 ARM。</p></li></ul><p><strong>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。指令通常包括操作码字段和地址码字段两个部分</strong>：</p><ul><li><p><strong>操作码：指明了该指令是一个什么类型的指令，也即它具有怎样的功能。它是识别指令，了解指令功能及操作数地址的关键信息</strong>。比如：操作码可以指出该操作是 “算数加” 还是 “算数减” 运算，是 “程序转移” 还是 “返回操作” 等等。</p></li><li><p><strong>地址码</strong>：<strong>给出了被操作的信息（指令或数据）的地址。</strong> 比如：“参与运算的一个和多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址” 等等  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151952547.png" alt="image-20230415195203431" loading="lazy"></p></li></ul><h2 id="1-2-指令字长、机器字长和存储字长"><a href="#1-2-指令字长、机器字长和存储字长" class="headerlink" title="1.2.指令字长、机器字长和存储字长"></a>1.2.指令字长、机器字长和存储字长</h2><ul><li><strong>指令字长</strong>：一条指令的<strong>总长度</strong>（可能会变），也即<strong>一条指令中所包含的二进制代码的位数</strong>，它取决于<strong>操作码的长度、操作数地址码的长度和操作数地址的个数</strong>。</li><li><strong>机器字长</strong>：CPU 进行<strong>一次运算所能处理的二进制数据的位数</strong>（通常和 ALU 直接相关）。</li><li><strong>存储字长</strong>：一个<strong>存储单元</strong>中的二进制代码位数（通常和 MDR 位数相同）。</li></ul><p><strong>注意</strong>：指令字长与机器字长<strong>没有固定的关系</strong>，它可以等于机器字长，也可以大于或小于。<strong>通常，把指令字长等于机器字长的指令称为单字长指令</strong>，相应地还有<strong>半字长指令、双字长指令</strong>。指令字长会影响取指令所需时间，例如，当机器字长 &#x3D; 存储字长 &#x3D; 16bit，则取一条双字长指令就需要两次访存操作。</p><h2 id="1-3-定长指令字和变长指令字"><a href="#1-3-定长指令字和变长指令字" class="headerlink" title="1.3.定长指令字和变长指令字"></a>1.3.定长指令字和变长指令字</h2><p><strong>定长指令字结构</strong>：在一个指令系统中，如果<strong>所有指令的长度都是相等的</strong>，则称为定长指令字结构。具有定长指令字结构的指令其<strong>执行速度快，控制简单。</strong></p><p><strong>变长指令字结构</strong>：各种指令的长度<strong>随指令功能而不同</strong>。由于主存一般是按字节编址的，所以指令字长多为<strong>字节的整数倍。</strong></p><h1 id="2-指令的分类"><a href="#2-指令的分类" class="headerlink" title="2.指令的分类"></a>2.指令的分类</h1><h2 id="2-1-按操作数地址码的数目不同进行分类"><a href="#2-1-按操作数地址码的数目不同进行分类" class="headerlink" title="2.1.按操作数地址码的数目不同进行分类"></a>2.1.按操作数地址码的数目不同进行分类</h2><h3 id="2-1-1-零地址指令"><a href="#2-1-1-零地址指令" class="headerlink" title="2.1.1.零地址指令"></a>2.1.1.零地址指令</h3><p><strong>零地址指令：它只给出了操作码 OP，没有给出显式地址，有以下两种情况</strong>：</p><ul><li><strong>该指令本身就不需要操作数</strong>：比如<strong>空操作</strong>、<strong>停机</strong>、<strong>关中断</strong>等等。</li><li><strong>零地址的运算类指令它仅仅会用于堆栈计算机中</strong>：通常参与运算的两个操作<strong>隐含地从栈顶和次栈顶弹出</strong>，送到运算器进行运算，运算结果再隐含地压入堆栈。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151954484.png" loading="lazy"></p><p>对于第二种情况，最为经典的例子就是后缀表达式的计算，扫描后缀表达式时遇到操作数就会压栈，遇到运算符就会取操作数再运算，结果仍会压入栈中  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955003.png" alt="image-20230415195551908" loading="lazy"></p><h3 id="2-1-2-一地址指令"><a href="#2-1-2-一地址指令" class="headerlink" title="2.1.2.一地址指令"></a>2.1.2.一地址指令</h3><p><strong>一地址指令：一地址指令有两种常见的形态，需要根据操作的含义确定究竟属于哪一种</strong>：</p><ul><li>**只有目的操作数：根据地址 $A_{1} $读取操作数，进行 $OP $操作后，结果存回原地址，也即 $OP(A_{1}) $-&gt; $A_{1} $**。比如常见的 “加 1、减 1、求反、求补” 等操作。完成一条指令需要3次访存：取指→读A1→写A1。</li><li><strong>需要两个操作数，但其中一个操作数隐含在某个寄存器中，比如 ACC：也即 $ (ACC)OP(A_{1})-&gt;A_{1} $，其中 $A_{1} $指某个主存地址， $ (A_{1}) $ 表示地址中的内容，可以类比 C 语言中的指针理解</strong>。完成一条指令需要2次访存：取指→读A1。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151955085.png" loading="lazy"></p><h3 id="2-1-3-二、三地址指令"><a href="#2-1-3-二、三地址指令" class="headerlink" title="2.1.3.二、三地址指令"></a>2.1.3.二、三地址指令</h3><p>**二地址指令：二地址指令往往就是常见的算数和逻辑运算，它们需要使用两个操作数，也即目的操作数和。地址中会给出目的操作数和源操作数的地址，其中目的操作数地址还可用于保存本次运算的结果，也即$(A_{1})OP(A_{2}) $-&gt; $A_{1} $**。完成一条指令需要访存4次，取指→读A1→读A2→写A1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956996.png" loading="lazy"></p><p><strong>三地址指令：相比二地址指令，三地址指令需要新的地址来存储运算结果，也即 $ (A_{1})OP(A_{2}) $-&gt; $A_{3} $</strong>  。完成一条指令需要访存4次，取指→读A1→读A2→写A3。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151956072.png" loading="lazy"></p><h3 id="2-1-4-四地址指令"><a href="#2-1-4-四地址指令" class="headerlink" title="2.1.4.四地址指令"></a>2.1.4.四地址指令</h3><p>**四地址指令：相比三地址指令，多了一个用于指明下一条指令地址的功能。这样就实现了指令的跳转功能（如果没有跳转，指令将会正常 + 1），也即$ (A_{1})OP(A_{2})- &gt; A_{3} $， $A_{4}&#x3D; 下一条指令的地址$**。完成一条指令需要访存4次，取指→读A1→读A2→写A3。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152001244.png" loading="lazy"></p><h2 id="2-2-按操作码长度分类"><a href="#2-2-按操作码长度分类" class="headerlink" title="2.2.按操作码长度分类"></a>2.2.按操作码长度分类</h2><p><strong>定长操作码：</strong>在指令字的最高位部分分配固定的若干位（定长）表示操作码。指令系统中<strong>所有指令的操作码长度都相同</strong>，有 $n $ 位就有 $2^{n} $条指令。定长操作码的控制器译码电路<strong>设计简单，但是灵活较差</strong>。</p><ul><li>优：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。</li><li>缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。</li></ul><p><strong>扩展操作码（不定长操作码）：</strong>全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上。最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。指令系统中<strong>各指令的操作码长度可变</strong>。可变长操作码控制器译码电路<strong>设计复杂，但灵活性很高</strong>。</p><ul><li>优：在指令字长有限的前提下仍保持比较丰富的指令种类。</li><li>缺：增加了指令译码和分析的难度，使控制器的设计复杂化。</li></ul><h2 id="2-3-按操作类型分类"><a href="#2-3-按操作类型分类" class="headerlink" title="2.3.按操作类型分类"></a>2.3.按操作类型分类</h2><p><strong>数据传送（进行主存与CPU之间的数据传送）</strong></p><ul><li><strong><code>LOAD</code>作用</strong>：把存储器中的数据放到寄存器。</li><li><strong><code>STORE</code>作用</strong>：把寄存器中的数据放到存储器。</li></ul><p><strong>算数逻辑操作（运算类）</strong></p><ul><li><strong>算数</strong>：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算等。</li><li><strong>逻辑</strong>：与、或、非、异或、位操作、位测试、位清除、位求反。</li></ul><p><strong>移位操作（运算类）</strong></p><ul><li>算数移位、逻辑移位、循环移位。</li></ul><p><strong>转移操作（程序控制类：改变程序执行的顺序）</strong></p><ul><li>无条件转移<code>JMP</code></li><li>条件转移（<code>JZ</code>: 结果为 0；<code>JP</code>：结果溢出；<code>JC</code>：结果有进位）。</li><li>调用和返回<code>CALL</code>及<code>RETURN。</code></li><li>陷阱（<code>Trap</code>）与陷阱指令。</li></ul><p><strong>输入和输出操作（输入输出类（I&#x2F;0）：进行CPU和I&#x2F;0设备之间的数据传送）</strong></p><ul><li>CPU 寄存器与 IP 端口之间的数据传送（端口即 IO 接口中的寄存器）。</li></ul><h1 id="3-扩展操作码指令格式"><a href="#3-扩展操作码指令格式" class="headerlink" title="3.扩展操作码指令格式"></a>3.扩展操作码指令格式</h1><h2 id="3-1-重述几个概念"><a href="#3-1-重述几个概念" class="headerlink" title="3.1.重述几个概念"></a>3.1.重述几个概念</h2><p><strong>指令格式：有两部分构成</strong>：</p><ul><li><strong>操作码</strong>。</li><li><strong>地址码。</strong></li></ul><p><strong>根据指令字长是否固定对指令分类：</strong></p><ul><li><strong>定长指令字结构</strong>：指令系统中所有指令的长度都相等。</li><li><strong>变长指令字结构</strong>：指令系统中各种指令的长度不固定。</li></ul><p><strong>根据操作码字段长度是否固定对指令分类：</strong></p><ul><li><strong>定长操作码</strong>：指令系统中所有指令的操作码长度都固定且相同。</li><li><strong>变长操作码</strong>：指令系统中各指令的操作码长度不固定。</li></ul><p><strong>所以这里会有以下四种类型：</strong></p><ul><li><strong>定长指令字定长操作码</strong>。</li><li><strong>定长指令字变长操作码：本节扩展操作码基于此类进行，也就是说不同地址数的指令会使用不同长度的操作码。</strong></li><li><strong>变长指令字定长操作码</strong>。</li><li><strong>变长指令字变长操作码。</strong></li></ul><h2 id="3-2-为什么要扩展操作码"><a href="#3-2-为什么要扩展操作码" class="headerlink" title="3.2.为什么要扩展操作码"></a>3.2.为什么要扩展操作码</h2><p>**如下图，假设指令字长为 16 位，其中前 4 位为操作码字段 $ OP $，另外有 3 个 4 位的地址字段 $A_{1} $、 $A_{2} $和 $ A_{3} $**。</p><p>如果 4 位操作码全部用于三地址指令，由于 $2^{4}&#x3D;16 $，所以该结构<strong>仅能表示 16 条指令</strong>。但这种方式是不合理的，因为所能表示的<strong>指令数是在是太少了</strong>。所以我们要做适当的处理，<strong>使其虽然不能涵盖全部的三地址指令，但是我能在牺牲有限条三地址指令的情况下向下扩展出更多的二地址、一地址、零地址指令，这样一来，所能表示的指令数目将会大大增大</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152009401.png" loading="lazy"></p><h2 id="3-3-扩展操作码方法"><a href="#3-3-扩展操作码方法" class="headerlink" title="3.3.扩展操作码方法"></a>3.3.扩展操作码方法</h2><h3 id="3-3-1-最常用方法"><a href="#3-3-1-最常用方法" class="headerlink" title="3.3.1.最常用方法"></a>3.3.1.最常用方法</h3><ul><li>以上图为例。</li></ul><p><strong>扩展二地址指令：</strong></p><ul><li><strong>三地址指令操作码范围为</strong><code>0000</code>~&#96;1111。&#96;</li><li>将<code>1111</code>留作扩展码，也即<code>1111</code>开头的指令不再代表三地址指令，此时三地址指令<strong>变更为 15 条</strong>，<strong>操作码范围为<code>0000</code>~&#96;1110。&#96;</strong></li><li>于是，二地址指令操作码将会以<code>1111</code>开头。</li><li><strong>实际上，CPU 在取得一条指令时，一定是直接读入 16 位，所以只需要根据所读入的是否为<code>1111</code>即可判断它是三地址还是二地址指令。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010007.png" loading="lazy"></p><p><strong>扩展一地址指令：</strong></p><ul><li><strong>此时二地址指令操作码范围为<code>1111</code> <code>0000</code>~&#96;1111<code> </code>1111。&#96;</strong></li><li>将<code>1111</code> <code>1111</code>留作扩展码，也即<code>1111</code> <code>1111</code>开头的指令不再代表二地址指令，<strong>此时二地址指令变更为 15 条，操作码范围<code>1111</code> <code>0000</code>~&#96;1111<code> </code>1110。&#96;</strong></li><li>于是，一地址指令操作码将会以<code>1111</code> <code>1111</code>开头。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010438.png" loading="lazy"></p><p><strong>扩展零地址指令：</strong></p><ul><li><p>**此时二地址指令操作码范围为<code>1111</code> <code>1111</code> <code>0000</code> ~&#96;1111<code> </code>1111<code> </code>1111&#96;**。</p></li><li><p>将<code>1111</code> <code>1111</code> <code>1111</code>留作扩展码，也即<code>1111</code> <code>1111</code> <code>1111</code>开头的指令不再代表一地址指令，<strong>此时一地址指令变更为 15 条，操作码范围为<code>1111</code> <code>1111</code> <code>0000</code> ~&#96;1111<code> </code>1111<code> </code>1110。&#96;</strong></p></li><li><p>于是，零地址指令操作码将会以<code>1111</code> <code>1111</code> <code>1111</code>开头。</p></li><li><p>由于<strong>零地址指令不需要再向后扩展</strong>，所以是 16 条，范围为<code>1111</code> <code>1111</code> <code>1111</code> <code>0000</code> ~ <code>1111</code> <code>1111</code> <code>1111</code> <code>1111。</code></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152010492.png" loading="lazy"></p><p><strong>总之，在整个扩展过程中，操作码的位数会随着地址码位数的减少而增加。相比于之前的 16 条三地址指令。经过扩展，仅损失了一个三地址指令，却增加了 15 条二地址指令、15 条一地址指令和 16 条零地址指令，这是很划算的。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152029832.png" alt="image-20230415202944745" loading="lazy"></p><h3 id="3-3-2-其他方法"><a href="#3-3-2-其他方法" class="headerlink" title="3.3.2.其他方法"></a>3.3.2.其他方法</h3><p><strong>上面展示的是扩展操作码比较常用的一种方法，还有很多种设计方案。不过，不论使用哪种方法，在设计时一定要注意以下几点</strong>：</p><ul><li><strong>不允许短码是长码的前缀，也即短操作码不能与长操作码的前面部分相同</strong>：这一点，类似于<strong>哈夫曼树的前缀编码</strong>，比如<code>0011</code>和<code>0011</code> <code>0000</code>，如果这样设计就会产生歧义。</li><li><strong>各指令操作码不能重复。</strong></li></ul><p>通常情况下，<strong>对于使用频率较高的指令，分配较短的操作码；对使用频率较低的指令则分配较长的操作码</strong>，从而尽可能减少指令译码和分析的时间。</p><ul><li>这一点其实可通过哈夫曼树看出。</li></ul><h2 id="3-4-经典例题"><a href="#3-4-经典例题" class="headerlink" title="3.4.经典例题"></a>3.4.经典例题</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152030447.png" loading="lazy">  </p><p>设地址长度为 $n $，上一层留出 $m$种状态，则下一层可以扩展出 $ m×2^{n} $种状态。</p><h1 id="4-指令寻址"><a href="#4-指令寻址" class="headerlink" title="4.指令寻址"></a>4.指令寻址</h1><ul><li><p><strong>指令寻址</strong>：下一条欲执行指令的地址会由<strong>程序计数器 $PC $ <strong>给出，分为</strong>顺序寻址</strong>和<strong>跳跃寻址。</strong></p></li><li><p><strong>数据寻址</strong>：执行一条指令时，<strong>将地址码当作形式地址码，需要对其按照一定规则进行解释翻译，才能得到真实的地址</strong>。当按不同方式进行解释时，就会形成不同的数据寻址方式，共有十种。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png" alt="image-20230415205156229" loading="lazy"></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152049452.png" alt="image-20230415204957355" loading="lazy"></p><h2 id="4-1-什么是指令寻址"><a href="#4-1-什么是指令寻址" class="headerlink" title="4.1.什么是指令寻址"></a>4.1.什么是指令寻址</h2><ul><li>程序运行实则就是指令执行，<strong>指令可以顺序执行也可以跳跃执行</strong>，这就涉及到指令寻址的问题了。</li></ul><p><strong>指令寻址：我们编写的程序最终会被翻译等价的机器指令，指令和数据无差别地存放在主存当中。CPU 中有一个很重要的寄存器——程序计数器 PC（Program-Counter），它指明了下一条指令的存放地址，CPU 在执行完一条指令后会让程序计数器自动 + 1。</strong></p><ul><li><strong>注意</strong>：这里的 “+1” 不是简单的 + 1，下面会在顺序寻址中说明。</li></ul><p><strong>指令寻址有两类</strong>：</p><ul><li><p>顺序寻址。</p></li><li><p>跳跃寻址  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152039616.png" alt="image-20230415203927527" loading="lazy"></p></li></ul><h2 id="4-1-两类指令寻址"><a href="#4-1-两类指令寻址" class="headerlink" title="4.1.两类指令寻址"></a>4.1.两类指令寻址</h2><h3 id="4-1-2-顺序寻址"><a href="#4-1-2-顺序寻址" class="headerlink" title="4.1.2.顺序寻址"></a>4.1.2.顺序寻址</h3><p><strong>顺序寻址：顺序寻址可以简单的理解为：(PC)+“1”-&gt;PC，但是这里的 “1” 要理解为一个指令字长，要视具体的指令长度、编址方式的不同而定</strong>。</p><p><strong>只有在系统采用定长指令字结构，并且指令字长 &#x3D; 存储字长 &#x3D; 16bit&#x3D;2B，且主存按字编址时，PC 才能简单的 + 1。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152041940.png" alt="image-20230415204101855" loading="lazy"></p><p><strong>其余条件不变，如果主存按字节编址，即每一条指令会占两个地址，此时 PC 要 + 2</strong> 。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152043693.png" alt="image-20230415204343610" loading="lazy"></p><p><strong>如果采用变长指令字结构同时按字节编址，此时不同指令的字长是不一样的。由于 CPU 无法确定当前指向的指令占多少存储字，此时 CPU 可以先读入一个字，操作码一定会包含在其中，因此可以通过操作码来判断这是一个几地址的指令，就可以确定这条指令具体占的字节数 n，接着 PC+n 即可。</strong></p><ul><li><p>下图中相同颜色表示一条指令。</p></li><li><p><strong>注意</strong>：在这种方式下，由于 CPU 无法预先知道总字节数，所以可能会进行多次访存，每次读入一个字，对于一条指令可能要读多次才能读干净  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152044979.png" alt="image-20230415204409893" loading="lazy"></p></li></ul><h3 id="4-1-2-跳跃寻址"><a href="#4-1-2-跳跃寻址" class="headerlink" title="4.1.2.跳跃寻址"></a>4.1.2.跳跃寻址</h3><p><strong>跳跃寻址：所谓跳跃，是指下一条指令的地址码不再由程序计数器给出，而由本条指令给出下一条指令地址的计算方式。跳跃寻址通过转移类指令实现</strong>。</p><ul><li>无条件转移<code>JMP。</code></li><li>条件转移（<code>JZ</code>: 结果为 0；<code>JP</code>：结果溢出；<code>JC</code>：结果有进位）。</li><li>调用和返回<code>CALL</code>及<code>RETURN。</code></li><li>陷阱（<code>Trap</code>）与陷阱指令。</li></ul><p>如下，CPU 正常执行指令，<strong>在遇到无条件转移指令<code>JMP</code>时会把 PC 中的内容强制改为 7</strong>，意味着下次执行要从 7 的位置开始执行，这有点类似<code>goto</code> 语句。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152045696.png" alt="image-20230415204503605" loading="lazy"></p><h1 id="5-数据寻址"><a href="#5-数据寻址" class="headerlink" title="5.数据寻址"></a>5.数据寻址</h1><ul><li><p><strong>指令寻址</strong>：下一条欲执行指令的地址会由<strong>程序计数器 $PC $ <strong>给出，分为</strong>顺序寻址</strong>和<strong>跳跃寻址。</strong></p></li><li><p><strong>数据寻址</strong>：执行一条指令时，<strong>将地址码当作形式地址码，需要对其按照一定规则进行解释翻译，才能得到真实的地址</strong>。当按不同方式进行解释时，就会形成不同的数据寻址方式，共有十种。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152051306.png" loading="lazy"></p></li></ul><h2 id="5-1-什么是数据寻址"><a href="#5-1-什么是数据寻址" class="headerlink" title="5.1.什么是数据寻址"></a>5.1.什么是数据寻址</h2><h3 id="5-1-1-理解什么是数据寻址"><a href="#5-1-1-理解什么是数据寻址" class="headerlink" title="5.1.1.理解什么是数据寻址"></a>5.1.1.理解什么是数据寻址</h3><p><strong>数据寻址：借用上一节文章中最后一个例子，该程序是从主存地址为 0 的单元开始向后存储的，执行到<code>JMP</code>指令后会把 PC 改为 7，所以接下来会直接跳转到 7 这个地方，因此这里的 7 就是真实的地址，没有歧义。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053245.png" alt="image-20230415205335170" loading="lazy"></p><p><strong>但在实际情况中，几乎不可能保证当前运行的程序恰好就从主存位置为 0 的地方开始存储。比如下面，该程序是从主存位置为 100 的单元向后存储的。在这种情况下，如果<code>JMP</code>依旧采用之前的方式去理解，那么在 103 执行完毕之后，它仍然会跳转到 7 这个位置</strong>。</p><p><strong>这显然是不合理的，因为 7 的位置是一个未知区域，甚至有可能是别的程序正在使用的区域，这就属于非法越界了</strong>。<strong>因此这里的 7 则可以解释为基于程序开始位置 100 的偏移量，也即 107</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152054671.png" alt="image-20230415205420595" loading="lazy"></p><p>当然还有其它解释方式，例如下图可以解释为：<strong>JMP 执行完成之后 PC 会自动 + 1，然后从 PC 所指向的位置向后偏移 3 个单位开始执行</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152223607.png" alt="image-20230415222358516" loading="lazy"></p><h3 id="5-1-2-数据寻址分类"><a href="#5-1-2-数据寻址分类" class="headerlink" title="5.1.2.数据寻址分类"></a>5.1.2.数据寻址分类</h3><p><strong>可以发现，不同的解读方式下地址码会有不同的含义，也就会产生不同的寻址方式。所以，我们会在地址码的前边新加入寻址方式位（寻址特征）来标识该指令的地址会采用何种方式来解释（或寻址）。主要会有以下十种寻址方式。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152055941.png" loading="lazy"></p><h3 id="5-1-3-数据寻址指令格式"><a href="#5-1-3-数据寻址指令格式" class="headerlink" title="5.1.3.数据寻址指令格式"></a>5.1.3.数据寻址指令格式</h3><p><strong>共有十种寻址方式，所以寻址方式位（寻址特征）需要 4 个比特位。总之，根据寻址方式位（寻址特征）可以确定形式地址$ (A)$采用怎样的方式解读，得到相应的真实地址（称为有效地址 $ (EA) $）。</strong></p><ul><li><strong>注意</strong>：n 地址指令需要 n 个寻址特征。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152053399.png" alt="image-20230415205302318" loading="lazy"></p><p><strong>在下面的介绍中，假设指令字长 &#x3D; 机器字长 &#x3D; 存储字长，且操作数为 3。</strong></p><h2 id="5-2-第一类数据寻址（将形式地址按照某种规则解释）"><a href="#5-2-第一类数据寻址（将形式地址按照某种规则解释）" class="headerlink" title="5.2.第一类数据寻址（将形式地址按照某种规则解释）"></a>5.2.第一类数据寻址（将形式地址按照某种规则解释）</h2><h3 id="5-2-1-直接寻址"><a href="#5-2-1-直接寻址" class="headerlink" title="5.2.1.直接寻址"></a>5.2.1.直接寻址</h3><p><strong>直接寻址：指令字中的形式地址 A 就是操作数的真实地址，即 EA&#x3D;A</strong>。</p><ul><li><p><strong>访存次数</strong>：取指令的 1 次 + 执行指令的 1 次 &#x3D;<strong>2 次</strong>（暂不考虑存结果）。</p></li><li><p><strong>优点：</strong> <strong>简单</strong>，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址。</p></li><li><p><strong>缺点：</strong> A 的位数决定了该指令操作数的<strong>寻址范围</strong>，且操作数的地址<strong>不易修改</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152056041.png" alt="image-20230415205648964" loading="lazy"></p></li><li><p>上图是一个取数指令。</p></li></ul><h3 id="5-2-2-间接寻址"><a href="#5-2-2-间接寻址" class="headerlink" title="5.2.2.间接寻址"></a>5.2.2.间接寻址</h3><p>**间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数的有效地址所在存储单元的地址，也就是操作数地址的地址，即 EA&#x3D;(A)**。</p><ul><li><strong>访存次数</strong>：取指令的 1 次 + 执行指令的 2 次 &#x3D;<strong>3 次</strong>（暂不考虑存结果）。</li><li><strong>优点</strong>：可以<strong>扩大寻址范围</strong>（有效地址 EA 的位数大于形式地址 A 的位数）；便于<strong>编写程序</strong>（间接寻址方式可以很方便地完成子程序返回）。</li><li><strong>缺点：</strong>：指令在执行阶段要<strong>多次访存</strong>（一次间接寻址需要两次访存，多次寻址需要根据存储字的最高位确定几次访存）。</li></ul><p>下图一次间接寻址：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057481.png" alt="image-20230415205716403" loading="lazy"></p><p>下图两次间接寻址 ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057887.png" alt="image-20230415205724809" loading="lazy"></p><h3 id="5-2-3-寄存器寻址"><a href="#5-2-3-寄存器寻址" class="headerlink" title="5.2.3.寄存器寻址"></a>5.2.3.寄存器寻址</h3><p><strong>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即 EA&#x3D;Rs，所其操作数就在由 Rs 所指的寄存器内存放</strong>。</p><ul><li><strong>访存次数</strong>：取指令 1 次 + 执行指令 0 次 &#x3D;<strong>1 次</strong>（暂不考虑存结果）。</li><li><strong>优点</strong>：指令在执行阶段<strong>不访问主存</strong>，只访问寄存器；指令字段且执行<strong>速度快</strong>，支<strong>持向量 &#x2F; 矩阵</strong>运算。</li><li><strong>缺点</strong>：寄存器<strong>价格昂贵</strong>，<strong>个数有限。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152057215.png" alt="image-20230415205755139" loading="lazy"></p><h3 id="5-2-4-寄存器间接寻址"><a href="#5-2-4-寄存器间接寻址" class="headerlink" title="5.2.4.寄存器间接寻址"></a>5.2.4.寄存器间接寻址</h3><p><strong>寄存器间接寻址：寄存器 Ri 中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA&#x3D;（R）。</strong></p><p><strong>访存次数：</strong> 取指令 1 次 + 执行指令 1 次 &#x3D;<strong>2 次</strong>（暂不考虑存结果）  。<br><strong>特点：</strong> 与一般间接寻址方式相比速度更快，但指令的执行阶段需要访问主存。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152058012.png" alt="image-20230415205826937" loading="lazy"></p><h3 id="5-2-5-隐含寻址"><a href="#5-2-5-隐含寻址" class="headerlink" title="5.2.5.隐含寻址"></a>5.2.5.隐含寻址</h3><p><strong>隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。</strong></p><ul><li><strong>优点</strong>：有利于<strong>缩短指令字长。</strong></li><li><strong>缺点</strong>：需要<strong>增加存储操作数和隐含地址的硬件。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152059943.png" alt="image-20230415205938862" loading="lazy"></p><h3 id="5-2-6-立即寻址"><a href="#5-2-6-立即寻址" class="headerlink" title="5.2.6.立即寻址"></a>5.2.6.立即寻址</h3><p><strong>立即寻址：形式地址 A 就是操作数本身，又称为立即数，一般采用补码形式。它的寻址特征为<code>#</code>，<code>#</code>表示立即寻址特征。</strong></p><ul><li><strong>访存次数</strong>： 取指令 1 次 + 执行指令 0 次 &#x3D;<strong>1 次</strong>（暂不考虑存结果）。</li><li><strong>优点：</strong> 指令执行阶段不需要访问主存，<strong>指令执行时间最短。</strong></li><li><strong>缺点：</strong> A 的<strong>位数限制了立即数的范围</strong>  。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152100062.png" alt="image-20230415210026975" loading="lazy"></li></ul><h3 id="5-2-7-堆栈寻址"><a href="#5-2-7-堆栈寻址" class="headerlink" title="5.2.7.堆栈寻址"></a>5.2.7.堆栈寻址</h3><p>堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出(LIFO)”原则管理的存储区，该存储区中被读&#x2F;写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。</p><p><strong>堆栈寻址：是指操作数存放在堆栈中，隐含使用堆栈指针 ($SP$) 作为操作数地址。其中，堆栈是存储器（或专用寄存器组）中一块特定的按 “先进后出” 原则管理的存储区，该存储区中被读 &#x2F; 写单元的地址由一个特定的寄存器给出的，也就是我们上面说到的堆栈指针（$SP$）。</strong></p><p><strong>如下，记栈顶单元为 $ M_{sp} $​，那么完成一次加法运算的过程为</strong>：</p><ul><li>首先是<code>POP ACC</code>，也就是将栈顶单元弹出并将其内容送入<code> ACC</code>，也即 $(M_{sp})-&gt;ACC$，同时栈顶指针向下移动，也即<code> (SP)+1=SP</code>，指向次栈顶元素。</li><li>接着是<code>POP X</code>，将操作数放到 <code>X </code>寄存器中，重复。</li><li>然后进行加法运算<code>ADD Y</code>，结果保存在变量 <code>Y</code> 中，也即<code> (ACC)+(X)-&gt;Y</code>。</li><li>接着进行压栈，结果压回栈顶<code>PUSH Y</code>，栈顶指针向上移动，结果送入此时的栈顶，也即 <code>(SP-1)-&gt;SP</code> 和$ (Y)-&gt;(M_{sp})$。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152105746.png" alt="image-20230415210524651" loading="lazy"></p><p><strong>堆栈可以分为硬堆栈和软堆栈两种（上面的例子属于硬堆栈）。</strong></p><ul><li><strong>硬堆栈</strong>：又称为寄存器堆栈，其成本较高，不适合做大容量的堆栈。</li><li><strong>软堆栈（最常用）</strong>：是指从主存中划分一段区域来做堆栈。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152107218.png" alt="image-20230415210726133" loading="lazy"></p><h1 id="6-第二类数据寻址（将形式地址视为偏移量）"><a href="#6-第二类数据寻址（将形式地址视为偏移量）" class="headerlink" title="6.第二类数据寻址（将形式地址视为偏移量）"></a>6.第二类数据寻址（将形式地址视为偏移量）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152221646.png" loading="lazy"></p><p>主要介绍以下三种数据寻址方式，它们都是将形式地址视为 “偏移量”。**</p><ul><li><strong>基址寻址</strong>：以程序的起始存放地址作为起点，即 <code>EA=(BR)+A</code>。</li><li><strong>变址寻址</strong>：程序员自己决定从哪里作为起点，即 <code>EA=(IX)+A</code>。</li><li><strong>相对寻址</strong>：以程序计数器 <code>PC</code> 所指地址作为起点，即<code> EA=(PC)+A</code>。</li></ul><h2 id="6-1-基址寻址"><a href="#6-1-基址寻址" class="headerlink" title="6.1.基址寻址"></a>6.1.基址寻址</h2><h3 id="6-1-1-基本概念"><a href="#6-1-1-基本概念" class="headerlink" title="6.1.1.基本概念"></a>6.1.1.基本概念</h3><p>**基址寻址：将 CPU 中基址寄存器 BR 中的内容加上指令格式中的形式地址 A，从而形成操作数的有效地址，也即<code> EA=(BR)+A</code>**。</p><p><strong>如下，采用基址寻址，指令中会包含一个形式地址 A，BR 会指向当前程序存放的起始位置</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152111168.png" alt="image-20230415211139086" loading="lazy"></p><p>需要注意，有的计算机内部不会专门设计一个基址寄存器，而会使用<strong>通用寄存器</strong>代替基址寄存器。如果采用通用寄存器，除了要给明寻址特征外，<strong>指令中还要多出几位 ( $R_{0} $​) 用于说明要将哪个通用寄存器作为基址寄存器使用。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152112597.png" alt="image-20230415211214513" loading="lazy"></p><h3 id="6-1-2-基址寻址的作用"><a href="#6-1-2-基址寻址的作用" class="headerlink" title="6.1.2.基址寻址的作用"></a>6.1.2.基址寻址的作用</h3><p><strong>基址寻址作用：基址寻址利于程序浮动，程序存储位置可以更改，但指令内容不需要修改，只需要更改基址寄存器，让其始终指向程序的起始地址，这&#x3D;&#x3D;有利于多道程序并发运行&#x3D;&#x3D;；另外，采用基址寻址可以扩大寻址范围（因为基址寄存器的位数大于形式地址 A 的位数）。</strong></p><p>例如下面有这样一段 C 语言段程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>y<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻译为等价的机器指令</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152113336.png" alt="image-20230415211325256" loading="lazy"></p><p>下图中该程序从 <strong>主存 “100”</strong> 处开始存储，第一个指令是一个取数指令，目的是<strong>为了把 “105” 处的变量<code>a=2</code>取到 <code>ACC </code>中</strong>，此时该地址码就会被解释为<strong>偏移量</strong>，因此<strong>真实地址 &#x3D; 基址寄存器 + 地址码</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152114002.png" alt="image-20230415211429896" loading="lazy"></p><h2 id="6-2-变址寻址"><a href="#6-2-变址寻址" class="headerlink" title="6.2.变址寻址"></a>6.2.变址寻址</h2><h3 id="6-2-1-基本概念"><a href="#6-2-1-基本概念" class="headerlink" title="6.2.1.基本概念"></a>6.2.1.基本概念</h3><p><strong>变址寻址：有效地址 EA 等于形式地址 $A $与变址寄存器 IX 中的内容相加之和，也即 $ EA&#x3D;(IX)+A $。其中 IX 可以是专用的，也可以将通用寄存器用作变址寄存器</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152115537.png" alt="image-20230415211546457" loading="lazy"></p><p><strong>可以看出变址寄存器和基址寄存器非常相像，那么他们的区别又在哪里呢？</strong></p><ul><li><p><strong>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间无关性。在程序执行过程中，基址寄存器内容不变（作为基地址）、形式地址可变（作为偏移量）；另外，采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但是其内容仍然由操作系统确定</strong>。</p></li><li><p><strong>变址寄存器是面向用户的，在程序的执行过程中，变址寄存器中的内容可以由用户改变，其中 IX 作为偏移量，形式地址 A 不变，作为基地址，这一点和基址寄存器恰好相反</strong>。</p></li></ul><h3 id="6-2-2-变址寄存器的作用"><a href="#6-2-2-变址寄存器的作用" class="headerlink" title="6.2.2.变址寄存器的作用"></a>6.2.2.变址寄存器的作用</h3><p><strong>变址寻址作用：变址寻址特别适合编写循环程序，例如在下面所述的数组处理过程中，可将形式地址 A 设置为基地址，这里就是数组的首地址，而变址寄存器 $ IX $的内容为偏移量，也就是循环变量。</strong></p><p>依旧采用基址寻址，如下有一段 C 语言程序，其作用是对<code>a[0]~a[9]</code>进行求和，涉及到了循环语句。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻译为等价的机器指令：</p><ul><li>第 0 条指令是立即寻址，将 0 取到 ACC 中。</li><li>第 1 条第 10 条均为加法指令，从地址码指示位置取得操作数然后和 ACC 中内容相加并送入 ACC 中。</li><li>第 11 条是一个取数指令，将累加结果放回到 sum 中。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152116381.png" alt="image-20230415211627288" loading="lazy"></p><p>可以发现对于基址寻址，它在处理循环时显得不那么合适，一旦数组的内容成百上千，难道还要继续这样操作吗？答案显然不是这样的，这时候就要用到变址寻址了。</p><ul><li>第 0 条指令是取数指令，取到 <code>ACC</code> 中。</li><li>第 1 条指令是取数指令，取到<code> IX</code> 中。</li><li>第 2 条指令采用变址寻址，也即<code> EA=(IX)+A</code>。这条指令的 A 指向了 “7”，也就是数组的起始位置，此时执行这条指令的结果<strong>就是把 <code>ACC</code> 中的内容（目前为 0）加上$ IX$偏移 7 后所指内存单元中的内容（也即<code>a[0]</code>），然后再放到<code> ACC</code> 中，完成第一轮循环。</strong></li><li>第 3 条指令是 IX+1，对应于循环变量<code>i++。</code></li><li>第 4 条指令是 IX 与 10 做比较，来决定是执行第 5 条指令还是第 6 条指令。<strong>如果 IX&lt;10 参见第 5 条指令，如果 IX&gt;&#x3D;10 参见第 6 条指令。</strong></li><li>第 5 条指令是条件跳转，程序会跳转至 “2”，进行第 2 轮循环，然后依次类推。</li><li>第 6 条指令是存数指令，此时结束循环。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152117766.png" alt="image-20230415211759664" loading="lazy"></p><h3 id="6-2-3-复合寻址（基址-变址）"><a href="#6-2-3-复合寻址（基址-变址）" class="headerlink" title="6.2.3.复合寻址（基址 + 变址）"></a>6.2.3.复合寻址（基址 + 变址）</h3><p>实际上，基址和变址这两种寻址方式通常会配合使用，上面变址的例子中仅仅展示了当程序从主存 “0” 位置开始存储的情形，当然是没有问题的，<strong>但是一旦改变程序的起始位置，那么仅仅依靠变址寻址就不行了。</strong></p><p>基本规则如下：</p><ul><li><strong>基址寻址</strong>：<code>EA=(BR)+A</code>。</li><li><strong>变址寻址</strong>：<code>EA=(IX)+A</code>。</li><li><strong>先基址再变址</strong>：<code>EA=(IX)+((BR)+A)</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152119029.png" alt="image-20230415211930926" loading="lazy"></p><h2 id="6-3-相对寻址"><a href="#6-3-相对寻址" class="headerlink" title="6.3.相对寻址"></a>6.3.相对寻址</h2><h3 id="6-3-1-基本概念"><a href="#6-3-1-基本概念" class="headerlink" title="6.3.1.基本概念"></a>6.3.1.基本概念</h3><p><strong>相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，也即 <code>EA=(PC)+A</code>，其中 A 是相对于 PC 所指地址的偏移量，可正可负，使用补码表示</strong>。</p><p>前面说过，当前指令执行完毕之后，<strong>PC 会自动 +“1”</strong>（注意这里的 “1” 仅仅表示下一步的意思，并不是实际 + 1，这要视具体情况而定，具体细节读者可查看上一节）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152120334.png" alt="image-20230415212029247" loading="lazy"></p><h3 id="6-3-2-相对寻址作用"><a href="#6-3-2-相对寻址作用" class="headerlink" title="6.3.2.相对寻址作用"></a>6.3.2.相对寻址作用</h3><p><strong>相对寻址的作用：相对寻址中，操作数地址不是固定不变的，可以随 PC 值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序的浮动（注意区分基址寻址的浮动，这里的浮动是指&#x3D;&#x3D;一段代码在程序内部的浮动&#x3D;&#x3D;），相对寻址&#x3D;&#x3D;广泛应用在转移指令中&#x3D;&#x3D;。</strong></p><p>还是这样一段加和程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环部分对应的指令如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152121255.png" alt="image-20230415212116157" loading="lazy"></p><p>在编写程序时我们常常有跳转的需求，比如上面的那一段程序可能循环未结束，我们需要马上执行它下面的一段程序，那么在这种情况下如果进行跳转，会出现很大的问题  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152122415.png" alt="image-20230415212211319" loading="lazy">  </p><p>为了解决这样的问题，引入相对寻址。<strong>在上图中，执行完 “M+3” 处的指令后会自动跳转至 “M+4”，如果想要跳回至 “M” 处，那么就要将 “M+3” 中的地址码改为 - 4 即可</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152123253.png" alt="image-20230415212306147" loading="lazy">  </p><p>自此，这段程序就似乎自我形成了一个封闭的体系，无论你把程序放到什么位置，只要他们的相对位置不变，总能跳转到正确的位置。</p><h2 id="6-4-数据寻址总结"><a href="#6-4-数据寻址总结" class="headerlink" title="6.4.数据寻址总结"></a>6.4.数据寻址总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152126019.png" alt="image-20230415212429695" loading="lazy"></p><h1 id="7-高级语言、汇编语言、机器语言"><a href="#7-高级语言、汇编语言、机器语言" class="headerlink" title="7.高级语言、汇编语言、机器语言"></a>7.高级语言、汇编语言、机器语言</h1><p><strong>使用高级语言编写的源程程序会经过以下两步转变为与之对应的机器语言</strong>：</p><ul><li><strong>编译：</strong> 高级语言经<strong>编译程序</strong> 编译后 转变为汇编语言，<strong>一条高级语言语句可能对应多条汇编语言语句。</strong></li><li><strong>汇编：</strong> 汇编语言经<strong>汇编程序</strong> 汇编后 转变为机器语言，<strong>一条汇编语言语句对应一条机器语言语句</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152129027.png" alt="image-20230415212955901" loading="lazy"></p><h2 id="7-1-汇编程序简单入门"><a href="#7-1-汇编程序简单入门" class="headerlink" title="7.1.汇编程序简单入门"></a>7.1.汇编程序简单入门</h2><p>如下为一段 C 语言程序，输出 “Hello World”：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>  <span class="token keyword">int</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 gcc 生成汇编程序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>file <span class="token string">"hello.c"</span>       <span class="token punctuation">.</span>intel_syntax noprefix      <span class="token punctuation">.</span>section <span class="token punctuation">.</span>rodata  <span class="token punctuation">.</span>LC0<span class="token operator">:</span>      <span class="token punctuation">.</span>string <span class="token string">"Hello, world!"</span>      <span class="token punctuation">.</span>text      <span class="token punctuation">.</span>globl   main      <span class="token punctuation">.</span>type    main<span class="token punctuation">,</span> @function  main<span class="token operator">:</span>      push     rbp      mov      rbp<span class="token punctuation">,</span> rsp      sub      rsp<span class="token punctuation">,</span> <span class="token number">16</span>      mov      DWORD PTR <span class="token punctuation">[</span>rbp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> edi      mov      QWORD PTR <span class="token punctuation">[</span>rbp<span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rsi      mov      edi<span class="token punctuation">,</span> OFFSET FLAT<span class="token operator">:</span><span class="token punctuation">.</span>LC0      call     puts      mov      eax<span class="token punctuation">,</span> <span class="token number">0</span>      leave      ret      <span class="token punctuation">.</span>size    main<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token operator">-</span>main      <span class="token punctuation">.</span>ident   <span class="token string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.9)"</span>      <span class="token punctuation">.</span>section <span class="token punctuation">.</span>note<span class="token punctuation">.</span>GNU<span class="token operator">-</span>stack<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>一个汇编程序由如下 4 个基本组件构成</strong>：</p><ul><li><p><strong>指令（instruction）</strong>：是 CPU 执行的<strong>实际操作</strong>。</p></li><li><p><strong>伪指令（directive）</strong>：告诉汇编工具生成特定数据，并<strong>将指令或数据放在指定的节。</strong></p></li><li><p><strong>标号（label）</strong>：在汇编工具中在<strong>汇编工具中引用指令或数据的符号名称。</strong></p></li><li><p><strong>注释（comment）</strong>：在汇编程序中，可以使用 <code>COMMENT</code> 伪指令来定义注释。</p></li><li><p>&#96;&#96;&#96;c<br>COMMENT [regexp] ; 在此处输入注释内容    </p><pre class="line-numbers language-none"><code class="language-none">  **例如**：| 类型   | 示例                  | 含义                            || ------ | --------------------- | ------------------------------- || 指令   | mov eax,0             | 给 eax 赋值为 0                 || 伪指令 | .section .text        | 将以下代码放入.text 节          || 伪指令 | .string &quot;foobar&quot;      | 定义包含&quot;foobar”的 ASCII 字符串 || 伪指令 | .long 0x12345678      | 定义一个双字 0x12345678         || 标号   | foo: .string &quot;foobar&quot; | 使用符号定义“foobar”&quot;字符串     || 注释   | #这是注释             | 可读注释                        |注意：上面的示例是伪指令和标号的示例，它们并不是实际的汇编代码。在实际的汇编代码中，指令和伪指令的顺序是固定的，并且伪指令和标号后面的字符串必须是唯一的。7.2.什么是 x86 架构------------**x86 架构：是微处理器执行的计算机语言指令集，指一个 intel 通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。1978 年 6 月 8 日，Intel 发布了新款 16 位微处理器 “8086”，也同时开创了一个新时代——x86 架构。**![image-20230415213903625](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152139726.png)7.3.x86 指令结构----------### 7.3.1.x86 的汇编层表示**x86 的汇编层表示：x86 指令通常表示为助记符 目标地址，源地址。***   **助记符**：是人类可读的机器指令表示。*   **源地址和目标地址**：指令的操作数。**如汇编指令&#96;mov rbx,rax&#96;就是将寄存器&#96;rax&#96;的值赋给&#96;rbx。&#96;**![image-20230415214114111](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152141207.png)### 7.3.2.x86 指令的机器级结构**x86 指令的机器级结构：由以下部分组成**：*   **前缀**（可选）：前缀**可以修改指令的行为**，如让一条指令重复执行多次或访问不同的内存段。*   **操作码**：是指令对其进行**操作的数据**。*   **寻址模式字节**（可选）：包含有关指令操作数类型的元数据，SIB（scale&#x2F;index&#x2F;base）字节和偏移（displacement）用来表示内存操作数，立即数字段（immediate）包含立即操作数（常量数值），**标识特定的寻址方式。**![](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152141551.png)### 7.3.3.x86 操作数来源**x86 中操作数有三个来源**：*   寄存器。*   内存。*   操作数。#### 7.3.3.1.寄存器操作数**x86 寄存器操作数：x86 下只需关注如下 8 个寄存器，每个寄存器以&#96;E&#96;开头，表示&#96;Extended&#96;，长度为 32bit。分为三类**：*   **以&#96;X&#96;结尾**：通用寄存器。*   **以&#96;I&#96;结尾**：变址寄存器。*   **以&#96;P&#96;结尾**：堆栈寄存器。![image-20230415214508206](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152145304.png)**对于上面的四个通用寄存器，也可以只使用低 16bit 或低 8bit。**![image-20230415214540807](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152145906.png)![image-20230415214552671](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152148376.png)#### 7.3.3.2.内存操作数**内存操作数：在 x86 中，可以用&#96;[base+index*scale+displacement]&#96;指定内存操作数**。*   &#96;base&#96;和&#96;index&#96;：是 64 位寄存器。*   &#96;scale&#96;：1、2、4 或 8 的整数值。*   &#96;displacement&#96;（偏移）：是 32 位常量或符号。**例如&#96;mov eax, dword ptr[af966h]&#96;就表示将内存地址 af996h 所指的 32bit 值复制到寄存器&#96;eax&#96;中**。*   &#96;dword ptr&#96;：双字（32bit）。*   &#96;word ptr&#96;：单字（16bit）。*   &#96;byte ptr&#96;：字节（8bit）。#### 7.3.3.1.立即数**立即数：立即数就是指令中硬编码的常量整数操作数，如指令&#96;add rax,42&#96;，其中 42 就是一个立即数。**7.4.x86 指令例子----------*   &#96;mov eax, ebx&#96;：将寄存器&#96;ebx&#96;的值复制到寄存器&#96;eax&#96;中。*   &#96;mov eax, 5&#96;：将立即数 5 复制到寄存器&#96;eax&#96;中。*   &#96;mov eax, dword ptr[af996h]&#96;：将内存地址 af996h 所指的 32bit 值复制到寄存器&#96;eax&#96;中。*   &#96;mov byte prt[af996h], 5&#96;：将立即数 5 复制到内存地址 af996h 所指的一字节中。*   &#96;mov eax, dword ptr[ebx]&#96;：将&#96;ebx&#96;所指主存地址的 32bit 复制到&#96;eax&#96;寄存器中。*   &#96;mov dword ptr[ebx], eax&#96;：将&#96;eax&#96;的内容复制到&#96;ebx&#96;所指主存地址的 32bit 中。*   &#96;mov eax byte ptr[ebx]&#96;：将&#96;ebx&#96;所指的主存地址的 8bit 复制到&#96;eax&#96;中。*   &#96;mov eax, [ebx]&#96;: 若未指明主存读写长度，默认 32 bit。*   &#96;mov [af996h], eax&#96;：将&#96;eax&#96;的内容复制到 af996h 所指的地址（未指明长度默认 32 bit）。*   &#96;mov eax, dword ptr[ebx+8]&#96;：将&#96;ebx+8&#96;所指主存地址的 32bit 复制到&#96;eax&#96;寄存器中。7.5.AT&amp;T 格式和 intel 格式对比---------------------![image-20230415220645899](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152206018.png)**表示 x86 机器指令的语法格式主要有两种，其中 intel 格式考试最为常见**：*   **AT&amp;T 格式**（Linux）：显式地在每个**寄存器名称**的前面加上 % 符号，每个**常量**前面加上 $ 符号；源操作数在目的操作数**前面**。*   **Intel 格式**（Windows）：相对简洁、不加符号；源操作数在目的操作数**后面。****区别一：操作数位置**。*   **AT&amp;T 格式源操作数在左，目的操作数在右面**：&#96;op s, d。&#96;*   **intel 格式目的操作数在左，源操作数在右面**：&#96;op d, s。&#96;**区别二：寄存器表示。***   **AT&amp;T 格式寄存器名之前必须加&#96;%&#96;**：&#96;mov %ebx, %eax。&#96;*   **intel 格式直接写寄存器名即可**： &#96;mov eax, ebx。&#96;**区别三：立即数表示**。*   **AT&amp;T 格式立即数之前必须加&#96;$&#96;**：&#96;mov $985, %eax。&#96;*   **intel 格式直接写立即数即可**： &#96;mov eax, 985。&#96;**区别四：主存地址表示。***   **AT&amp;T 格式使用中括号&#96;()&#96;表示主存地址**：&#96;mov $eax, (af996h)。&#96;*   **intel 格式使用中括号&#96;[]&#96;表示主存地址**： &#96;mov [af996], eax。&#96;**区别五：读写长度表示。***   **AT&amp;T 格式使用&#96;b&#96;、&#96;w&#96;、&#96;l&#96;分别代表&#96;byte&#96;、&#96;word&#96;、&#96;dword&#96;，写到指令的后面**：&#96;movb $5, (af997h)&#96;、&#96;movw $5, (af997h)&#96;、&#96;movl $5, (af997h)&#96;。*   **intel 格式在主存地址前面使用&#96;byte&#96;、&#96;word&#96;、&#96;dword&#96;说明**：&#96;mov byte ptr [af996h], 5&#96;、&#96;mov word ptr [af996h], 5&#96;、&#96;mov dword ptr [af996h], 5&#96;。**区别六：主存地址偏移量表示***   **AT&amp;T 格式使用&#96;偏移量(基址)&#96;或&#96;偏移量（基址,变址,比例因子）&#96;表示**：&#96;movl -8(%ebx), %eax&#96;、&#96;mov eax,[ebx+ecx*32+4]&#96;。*   **intel 格式使用&#96;[基址+偏移量]&#96;或&#96;[基址+变址*比例因子+偏移量]&#96;表示**： &#96;mov eax, [ebx-8]&#96;、&#96;mov eax, [ebx+ecx*32+4]&#96;。# 8.常用的x86汇编指令、选择和循环语句的机器级表示![image-20230415220429441](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152204539.png)8.1.常见的算数运算指令-----------**注意**：*   除法中&#96;s&#96;作除数，被除数会被**提前放置**到&#96;edx&#96;和&#96;eax&#96;当中。*   &#96;edx:eax&#96;：在进行除法运算之前，需要把被除数进行**位扩展**为 64bit，所以需要两个寄存器。&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文名&lt;&#x2F;th&gt;&lt;th&gt;英文名&lt;&#x2F;th&gt;&lt;th&gt;汇编指令&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;加&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;add&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;add d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;计算&lt;code&gt;d+s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;减&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;subtract&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;sub d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;计算&lt;code&gt;d-s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;乘&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;multiply&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;mul d,s&lt;&#x2F;code&gt; 和&lt;code&gt;imul d, s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;无符号数&lt;code&gt;d*s&lt;&#x2F;code&gt;和有符号数&lt;code&gt;d*s&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;除&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;divide&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;div d,s&lt;&#x2F;code&gt;和&lt;code&gt;idiv d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;无符号数和有符号除法&lt;code&gt;edx:eax&#x2F;s&lt;&#x2F;code&gt; ，其中商存入&lt;code&gt;eax&lt;&#x2F;code&gt;，余数存入&lt;code&gt;edx&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;取负数&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;negative&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;neg d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;取负数，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;自增&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;increase&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;inc d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;也即&lt;code&gt;d++&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;自减&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;decrease&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;dec d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;也即&lt;code&gt;d--&lt;&#x2F;code&gt;，结果存入&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;**举例**：*   &#96;sub eax, 10&#96;：计算&#96;eax-10&#96;并存入&#96;eax&#96;。*   &#96;add byte ptr [var], 10&#96;：&#96;var&#96;所指内存地址一字节值与 10 相加，结果存入&#96;var&#96;所指内存地址处。8.2.常见的逻辑运算指令-----------&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;中文名&lt;&#x2F;th&gt;&lt;th&gt;英文名&lt;&#x2F;th&gt;&lt;th&gt;汇编指令&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;与&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;and&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;and d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位相与，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;或&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;or&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;or d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位相或，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;非&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;not&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;not d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逐位取反，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;异或&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;exclusive or&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;xor d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;和&lt;code&gt;s&lt;&#x2F;code&gt;逐位异或，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;左移&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shift left&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shl d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逻辑左移&lt;code&gt;s&lt;&#x2F;code&gt;位，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;右移&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shift rightft&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;shr d,s&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;将&lt;code&gt;d&lt;&#x2F;code&gt;逻辑右移&lt;code&gt;s&lt;&#x2F;code&gt;位，结果放回&lt;code&gt;d&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;8.3.其他类型指令--------### 8.3.1.数据传送类指令*   &#96;mov&#96;：将第二个操作数 (寄存器的内容、内存中的内容或常数值) **复制**到第一个操作数 (寄存器或内存)。但不能用于直接从内存复制到内存。*   &#96;push&#96;：将**操作数压入内存的栈**，常用于函数调用。ESP 是栈顶，压栈前先将 ESP 值减 4 (栈增长方向与内存地址增长方向相反)，然后将操作数压入 ESP 指示的地址。*   &#96;pop&#96;：与 push 指令相反，pop 指令执行的是**出栈工作**，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4。### 8.3.2.控制流指令**指令指针寄存器 IP（相当于 ARM 型 CPU 中的程序计数器 PC）：x86 处理器维持着一个指示当前执行指令的指令指针 (IP)， 当一条指令执行后，此指针自动指向下一条指令。IP 寄存器不能直接操作，但可以用控制流指令更新。通常用标签 (label) 指示程序中的指令地址，在 x86 汇编代码中，可在任何指令前加入标签。***   &#96;jmp&#96;：**无条件转移指令**，控制 IP 转移到 **label 所指示的地址** (从 label 中取出指令执行)。*   &#96;jcondition&#96;：**条件转移指令**，依据 CPU 状态字中的一系列条件状态转移。CPU 状态字中包括指示最后一个算术运算结果是否为 0，运算结果是否为负数等。*   &#96;comp&#x2F;test&#96;：&#96;cmp&#96;指令用于**比较两个操作数的值**，&#96;test&#96; 指令**对两个操作数进行逐位与运算**，这两类指今都不保存操作结果，仅根据运算结果**设置 CPU 状态字中的条件码。***   &#96;call&#x2F;ret&#96;：**无条件转移指令**，分别用于实现子程序 (过程、函数等) 的调用及返回。**对于无条件转移指令&#96;call&#x2F;ret&#96;，其过程调用的执行步骤如下，假设$P$ 调用 $Q$***   $P$ 将入口参数 (实参) 放在 $Q$ 能访问到的地方。*   $P$ 将返回地址存到特定的地方，然后将控制转移到 $Q$。*   $Q$ 保存$P$ 的现场 (通用寄存器的内容)，并为自己的非静态局部变量分配空间*   执行过程 $Q$。*   $Q$ 恢复$P$ 的现场，将返回结果放到$P$ 能访问到的地方，并释放局部变量所占空间。*   $Q$ 取出返回地址，将控制转移到$P$。#### 8.3.2.1.无条件转移指令 jmp![image-20230415220911290](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;wushuai2000&#x2F;PicGo&#x2F;main&#x2F;img&#x2F;202304152209403.png)**对于&#96;jmp&#96;指令，有如下四种使用方法**：*   &#96;jmp 128&#96;：地址由常数给出。*   &#96;jmp eax&#96;：地址可以来自于寄存器。*   &#96;jmp[999]&#96;：地址可以来自于主存。*   &#96;jmp NEXT&#96;：地址可以由 “标号” 给出，类似于 C 语言中的 goto 语句。&#96;&#96;&#96;cmov eax, 7mov ebx, 6jmp NEXTmov ecx, ebxNEXT:mov ecx, eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="8-3-2-2-条件转移指令-jcondition"><a href="#8-3-2-2-条件转移指令-jcondition" class="headerlink" title="8.3.2.2.条件转移指令 jcondition"></a>8.3.2.2.条件转移指令 jcondition</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209013.png" alt="image-20230415220928884" loading="lazy"></p><p><strong><code>jmp</code>指令是很不灵活的，无法实现一些复杂条件转移操作，所以需要借助条件转移指令<code>jcondition</code>来完成，同时要借助<code>cmp a, b</code>（比较<code>a</code>和<code>b</code>的大小）。</strong></p><ul><li><code>je &lt;地址&gt;</code>：若<code>a == b</code> 则跳转（ZF &#x3D;&#x3D; 1）。</li><li><code>jne &lt;地址&gt;</code>：若 <code>a != b</code> 则跳转（ZF &#x3D;&#x3D; 0）。</li><li><code>jg &lt;地址&gt;</code>：若 <code>a &gt; b</code> 则跳转（ZF &#x3D;&#x3D; 0 &amp;&amp; SF &#x3D;&#x3D; OF）。</li><li><code>jge &lt;地址&gt;</code>：若 <code>a &gt;= b</code> 则跳转（ SF &#x3D;&#x3D; OF）。</li><li><code>jl &lt;地址&gt;</code>：若 <code>a &lt; b</code> 则跳转（ SF !&#x3D; OF）。</li><li><code>jle &lt;地址&gt;</code>：若 <code>a &lt;= b</code> 则跳转（ SF !&#x3D; OF || ZF &#x3D;&#x3D; 1）。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">cmp eax<span class="token punctuation">,</span>ebx # 比较寄存器eax和ebx里的面的值jg NEXT #若eax<span class="token operator">></span>ebx则跳转至NEXT位置处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8-4-选择语句的机器级表示"><a href="#8-4-选择语句的机器级表示" class="headerlink" title="8.4.选择语句的机器级表示"></a>8.4.选择语句的机器级表示</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152209886.png" alt="image-20230415220954778" loading="lazy"></p><p>如下是 C 语言中的<code>if-else</code>语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>c <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token punctuation">&#123;</span>c <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应机器级表示如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">mov eax<span class="token punctuation">,</span> <span class="token number">7</span>  # 变量a<span class="token operator">=</span><span class="token number">7</span>，存入eax中mov ebx<span class="token punctuation">,</span> <span class="token number">6</span>  # 变量b<span class="token operator">=</span><span class="token number">6</span>，存入ebx中cmp eax<span class="token punctuation">,</span> ebx  # 比较a和bjg NEXT  # 若a<span class="token operator">></span>b，跳转至NEXT处mov ecx<span class="token punctuation">,</span> ebx  # 使用ecx存入变量c，使c<span class="token operator">=</span>bjmp ENDNEXT<span class="token operator">:</span>mov ecx<span class="token punctuation">,</span> eax  # 使用ecx存入变量c，使c<span class="token operator">=</span>aEND：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-5-循环语句的机器级表示"><a href="#8-5-循环语句的机器级表示" class="headerlink" title="8.5.循环语句的机器级表示"></a>8.5.循环语句的机器级表示</h2><h3 id="8-5-1-使用条件转移指令实现循环"><a href="#8-5-1-使用条件转移指令实现循环" class="headerlink" title="8.5.1.使用条件转移指令实现循环"></a>8.5.1.使用条件转移指令实现循环</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214569.png" alt="image-20230415221409430" loading="lazy"></p><p><strong>使用条件转移指令实现循环由以下 4 部分构成</strong>：</p><ul><li>循环前的初始化。</li><li>是否直接跳过循环。</li><li>循环主体。</li><li>是否继续循环。</li></ul><p>如下代码是 C 语言中的<code>for</code>循环，用于求解 1+2+…+100。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>result <span class="token operator">+=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对应机器级表示如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">mov eax<span class="token punctuation">,</span><span class="token number">0</span>  # 使用eax保存result，初始值为<span class="token number">0</span>mov edx<span class="token punctuation">,</span><span class="token number">1</span>  # 使用edx保存i，初始值为<span class="token number">1</span>cmp edx<span class="token punctuation">,</span><span class="token number">100</span> # 比较i和<span class="token number">100</span>的大小jg L2 # 如果i<span class="token operator">></span><span class="token number">100</span>，跳转至L2处L1<span class="token operator">:</span> # 循环主体add eax<span class="token punctuation">,</span>edx # result <span class="token operator">+=</span> iinc edx # i<span class="token operator">++</span>cmp edx<span class="token punctuation">,</span><span class="token number">100</span> # 比较i和<span class="token number">100</span>的大小jle L1 # 如果i<span class="token operator">&lt;=</span><span class="token number">100</span>，跳转至L1处l2<span class="token operator">:</span>  # 结束循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-5-2-使用-loop-指令实现循环"><a href="#8-5-2-使用-loop-指令实现循环" class="headerlink" title="8.5.2.使用 loop 指令实现循环"></a>8.5.2.使用 loop 指令实现循环</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152214515.png" alt="image-20230415221427405" loading="lazy"></p><p><strong>从理论上讲，能用 loop 指令实现的功能也一定能用条件转移指令实现。loop 指令的存在目的是为了使代码更加清晰、简洁，让其余分支语句区别更明显</strong>。</p><p>如下代码是 C 语言中的<code>for</code>循环，固定循环 500 次：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">do</span> something<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对应机器级表示如下，其中：</p><ul><li><code>loop Looptop</code>：等价于<code>dec ecx</code>、<code>cmp ecx, 0</code>、<code>jne Looptop</code>。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">mov ecx<span class="token punctuation">,</span> <span class="token number">500</span>  # ecx是循环变量Looptop<span class="token operator">:</span>  # 循环开始<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">do</span> something<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>loop Looptop  # ecx<span class="token operator">--</span>，若ecx <span class="token operator">!=</span> <span class="token number">0</span>，跳转至Looptop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-6-cmp指令的底层原理"><a href="#8-6-cmp指令的底层原理" class="headerlink" title="8.6.cmp指令的底层原理"></a>8.6.cmp指令的底层原理</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152213132.png" alt="image-20230415221302986" loading="lazy"></p><h1 id="9-CISC和RISC简单了解"><a href="#9-CISC和RISC简单了解" class="headerlink" title="9.CISC和RISC简单了解"></a>9.CISC和RISC简单了解</h1><p>指令系统的设计如今朝着两个截然不同的方向发展：</p><p><strong>一是增强原有指令的功能，设置为更复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC），典型的如 ×86 架构的计算机；二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC），典型的有 ARM，MIPS 架构的计算机</strong>。</p><h2 id="9-1-复杂指令系统计算机（CISC）"><a href="#9-1-复杂指令系统计算机（CISC）" class="headerlink" title="9.1.复杂指令系统计算机（CISC）"></a>9.1.复杂指令系统计算机（CISC）</h2><p>随着 VLSI 技术的发展，硬件成本不断降低，软件成本不断上升，促使人们在系统中增加更多、更复杂的指令，以适应不同的应用领域，这样就构成了 CISC。其主要特点如下：</p><ol><li>指令系统复杂庞大，指令数目一般为 200 条以上。</li><li>指令的长度不固定，指令格式多，寻址方式多。</li><li>可以访存的指令不受限制。</li><li>各种指令使用的频度相差很大。</li><li>各种指令执行时间相差很大，大多数指令需要多个时钟周期才能完成。</li><li>控制器大多数采用微程序编程。有的指令非常复杂，以至于无法采用硬连线控制。</li><li>难以用优化编译生成高效的目标代码途径。</li></ol><p>如此庞大的指令系统，对指令的设计提出了极高的要求，胭研制周期变得很长。后来人们发现一味地追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径。对传统 CISC 指令系统测试表明，各种指令的使用频率相差悬殊，从这一事实出发，人们开始了指令系统合理性的研究，于是 RISC 随之诞生。</p><h2 id="9-2-精简指令系统计算机（RISC）"><a href="#9-2-精简指令系统计算机（RISC）" class="headerlink" title="9.2.精简指令系统计算机（RISC）"></a>9.2.精简指令系统计算机（RISC）</h2><p>RISC 的中心思想是要求指令系统简化，尽量使用寄存器 - 寄存器操作指令，指令格式力求一致。其主要特点如下：</p><ol><li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令组合实现。</li><li>指令长度固定，指令格式种类少，寻址方式种类少。</li><li>只有 Load&#x2F;Store(取数 &#x2F; 存数) 指令访存，其余指令的操作都在寄存器之间进行。</li><li>CPU 中通用寄存器的数量相当多。</li><li>RISC 一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li><li>以硬布线控制为主，少用或者不用微程序控制。</li><li>特别重视编译优化工作，以减少程序执行时间。</li></ol><p>值得注意的是，从指令系统的兼容性来看，CISC 大多能够实现软件兼容，即高高档机包含了低档机的全部指令，并可以进行扩充。但 RISC 简化了指令系统，指令条数少，格式也不同于老机器，因此大多数 RISC 机不能与老机器兼容。由于 RISC 具有更强的实用性，因此应该是未来处理器发展的方向。但事实上，当今时代 Intex 几乎一统江湖，且早期很多软件都是根据 CISC 设计的，单纯的 RISC 将无法兼容。此外，现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分，其性能差距已经越来越小。CISC 可以提供更多的功能，这一点是程序设计所需要的。</p><h2 id="9-3-CISC-和-RISC-比较"><a href="#9-3-CISC-和-RISC-比较" class="headerlink" title="9.3.CISC 和 RISC 比较"></a>9.3.CISC 和 RISC 比较</h2><p>和 CISC 相比，RISC 的优点主要集中在以下几个方面：</p><ol><li><strong>RISC 更能充分利用 VLSI 芯片的面积</strong>。CISC 的控制器大多采用微程序控制，其控制存储器在 CPU 芯片内所占面积会达到 50% 以上，而 RISC 控制器采用组合逻辑控制，其硬布线逻辑只占 CPU 芯片面积的 10% 左右。</li><li><strong>RISC 更能提高运行速度</strong>。RISC 的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。</li><li><strong>RISC 便于设计</strong>，可以降低成本，提高可靠性。RISC 指令系统简单，因此机器设计周期短，其逻辑简单。</li><li><strong>RISC 有利于程序优化</strong>。RISC 指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更加高效化。</li></ol><p>RISC 和 CISC 具体区别如下 ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152216907.png" alt="image-20230415221635811" loading="lazy"></p><h2 id="9-4-计算机的工作过程"><a href="#9-4-计算机的工作过程" class="headerlink" title="9.4.计算机的工作过程"></a>9.4.计算机的工作过程</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304152217826.png" alt="image-20230415221755716" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组-第三章 存储系统</title>
      <link href="/posts/2dbdbfc/"/>
      <url>/posts/2dbdbfc/</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储器概述"><a href="#1-存储器概述" class="headerlink" title="1.存储器概述"></a>1.存储器概述</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141356715.png" alt="image-20230414135654630" loading="lazy"></p><h2 id="1-1-存储器分类"><a href="#1-1-存储器分类" class="headerlink" title="1.1.存储器分类"></a><a name="存储器分类">1.1.存储器分类</a></h2><h3 id="1-1-1-按在计算机中的作用（层次）分类"><a href="#1-1-1-按在计算机中的作用（层次）分类" class="headerlink" title="1.1.1.按在计算机中的作用（层次）分类"></a>1.1.1.按在计算机中的作用（层次）分类</h3><ul><li><strong>主存储器</strong>：简称<strong>主存</strong>，又称<strong>内存</strong>；用来存放计算机运行期间所需的大量程序和数据；CPU 可以<strong>直接对其进行访问</strong>，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据；特点是<strong>容量较小，存储速度较快，造价高</strong>。</li><li><strong>辅助存储器</strong>：简称<strong>辅存</strong>，又称<strong>外存</strong>；是主存储器的后援存储器，用来存放<strong>当前暂时不用的程序和数据，以及一些需要永久性保存</strong>的信息，它不能与 CPU 直接交换信息；特点是<strong>容量极大，存储速度较慢，造价低。</strong></li><li><strong>高速缓冲存储器</strong>：简称 <strong>Cache</strong>；它位于主存和 CPU 之间，用来存放<strong>正在执行的程序段和数据</strong>，以便 CPU 能够高速地使用它们；Cache 的读取速度可以和 CPU 相匹配，但<strong>存储容量小，价格高，目前会被集成在 CPU 当中</strong>。</li></ul><h3 id="1-1-2-按照存储介质分类"><a href="#1-1-2-按照存储介质分类" class="headerlink" title="1.1.2.按照存储介质分类"></a>1.1.2.按照存储介质分类</h3><ul><li><strong>磁表面存储器</strong>：如磁盘、磁带等。</li><li><strong>磁心存储器半导体存储器</strong>：如 MOS 型存储器、双极型存储器。</li><li><strong>光存储器</strong>：如光盘。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355109.png" loading="lazy"></p><h3 id="1-1-3-按存储方式分类"><a href="#1-1-3-按存储方式分类" class="headerlink" title="1.1.3.按存储方式分类"></a>1.1.3.按存储方式分类</h3><ul><li><strong>随机存储器（RAM）</strong>：存储器的任何一个存储单元的内容都可以<strong>随机存取</strong>，而且<strong>存取时间与存储单元的物理位置无关</strong>；其优点是<strong>读写方便，使用灵活，主要用作主存或高速缓冲存储器</strong>；RAM 又分为<strong>静态 RAM</strong>（以触发器原理寄存信息）和<strong>动态 RAM</strong>（以电容充电原理寄存信息）。</li><li><strong>只读存储器（ROM）</strong>：存储器的内容<strong>只能随机读出而不能写入</strong>；<strong>信息一旦写入存储器就固定不变，即使断电内容也不会丢失</strong>。因此通常用它存放固定不变的程序，常数和汉字字库，甚至用于操作系统的固化。<strong>它与随机存储器可以共同作为主存的一部分，统一构成主存的地址域。</strong></li><li><strong>串行访问存储器</strong>：对存储单元进行 I&#x2F;O 操作时，<strong>需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）</strong>。</li></ul><p><strong>注意</strong>：</p><ul><li><strong>顺序存储寄存器</strong>的内容<strong>只能按照某种顺序存取</strong>，存取时间的长短与信息在存储体的<strong>物理位置</strong>有关，其特点是<strong>存储速度慢，例如：磁带；</strong></li><li><strong>直接存取存储器</strong>既不像 RAM 那样随机访问任何一个存储单元，又不像顺序存取存储器那样完全按照顺序存取，而是介于两者之间，存取信息是<strong>通常先寻找整个存储器中的某个小区域，再在小区域内顺序查找，例如：机械硬盘</strong>。</li></ul><h3 id="1-2-4-按信息的可保存性分类"><a href="#1-2-4-按信息的可保存性分类" class="headerlink" title="1.2.4.按信息的可保存性分类"></a>1.2.4.按信息的可保存性分类</h3><ul><li><strong>易失性存储器</strong>：断电后，存储的信息<strong>会消失</strong>，如 RAM；</li><li><strong>非易失性存储器</strong>：断电后，存储的信息<strong>仍然会保持</strong>，如 ROM。</li></ul><p><strong>注意：</strong></p><ul><li><strong>破坏性读出</strong>：某个存储单元所存储的信息被读出时，原存储信息被破坏；具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个<strong>再生</strong>操作，以便恢复被破坏的信息，例如：DRAM（栅极电容）。</li><li><strong>非破坏性读出</strong>某个存储单元所存储的信息被读出时，原存储信息不被破坏，例如：SRAM（双稳态触发器）。</li></ul><h2 id="1-2-多级存储系统"><a href="#1-2-多级存储系统" class="headerlink" title="1.2.多级存储系统"></a>1.2.多级存储系统</h2><p><strong>多级存储系统：为了缓解存储系统容量、速度和成本这三者之间的矛盾。在计算机系统中，存储器系统通常会采用多级结构，如下图所示，从上至下</strong>：</p><ul><li><strong>价格</strong>越来越低。</li><li><strong>速度</strong>越来越慢。</li><li><strong>容量</strong>越来越大。</li><li><strong>CPU 访问的频度</strong>越来越低。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355824.png" loading="lazy"></p><p><strong>实际上，存储系统的层次结构主要体现在 “Cache - 主存” 和 “主存 - 辅存” 这两层</strong>：</p><ul><li><strong>“Cache - 主存”</strong>：主要解决 <strong>CPU 和主存速度</strong>不匹配的问题。</li><li><strong>“主存 - 辅存”</strong>：主要解决<strong>存储系统的容量</strong>问题。</li></ul><p><strong>在多级存储系统中</strong>：</p><ul><li>Cache、主存可以和 CPU 直接交换信息。</li><li>辅存则要通过主存和 CPU 交换信息。</li><li>主存与 CPU、Cache、辅存都能交换信息。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355061.png" loading="lazy">  </p><p><strong>多级存储系统的核心思想是：让上一层的存储器作为下一层存储器的高速缓存</strong>。</p><ul><li>“<strong>Cache - 主存</strong>” 层速度接近于 Cache，容量和价位却接近于主存。</li><li>“<strong>主存 - 辅存</strong>” 层速度接近于主存，容量和价位却接近于辅存。</li></ul><p><strong>另外注意</strong>：</p><ul><li>主存和 Cache 之间的数据调动是由<strong>硬件自动完成的</strong>，对所有程序员透明。</li><li>主存和辅存之间的数据调动则是<strong>由硬件和操作系统共同完成的</strong>，对应用程序员是透明。</li></ul><h2 id="1-3-存储器性能指标"><a href="#1-3-存储器性能指标" class="headerlink" title="1.3.存储器性能指标"></a>1.3.存储器性能指标</h2><p><strong>存储器有以下三个性能指标（相互制约），通过协调这三个指标，设计者尽可能地设计大容量、低成本和高速度的存储器系统</strong>。</p><ul><li>存储容量。</li><li>单位成本。</li><li>存储速度。</li></ul><h3 id="1-3-1-存储容量"><a href="#1-3-1-存储容量" class="headerlink" title="1.3.1.存储容量"></a>1.3.1.存储容量</h3><p><strong>存储容量 &#x3D; 存储字数 × 字长（如 1M×8 位）。</strong></p><ul><li>单位换算：<strong>1B(Byte，字节)&#x3D;8b(bit，位)。</strong></li><li>存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。</li></ul><h3 id="1-3-2-单位成本"><a href="#1-3-2-单位成本" class="headerlink" title="1.3.2.单位成本"></a>1.3.2.单位成本</h3><p><strong>每位价格 &#x3D; 总成本 ÷ 总容量</strong>。</p><h3 id="1-3-3-存储速度"><a href="#1-3-3-存储速度" class="headerlink" title="1.3.3.存储速度"></a>1.3.3.存储速度</h3><p><strong>数据传输率 &#x3D; 数据的宽度 ÷ 存储周期</strong>。</p><ul><li><strong>存取时间（ $T_{a} $​）</strong>：是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li><li><strong>存取周期 ( $ T_{m} $​)<strong>：</strong>存取周期</strong>又称<strong>读写周期</strong>或<strong>访问周期</strong>。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储操作（读或写操作）之间所需的最小时间间隔。</li><li><strong>主存带宽（ $ B_{M} $）</strong>: 主存宽度又称为数据传输率，表示每秒从主存进出信息的最大容量，单位为字 &#x2F; 秒，字节 &#x2F; 秒 (B&#x2F;s) 或位 &#x2F; 秒(b&#x2F;s)。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141355072.png" loading="lazy"></p><h1 id="2-主存储器"><a href="#2-主存储器" class="headerlink" title="2.主存储器"></a>2.主存储器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408552.png" alt="image-20230414140744990" loading="lazy"></p><h2 id="2-1-基本的半导体元件及原理"><a href="#2-1-基本的半导体元件及原理" class="headerlink" title="2.1.基本的半导体元件及原理"></a><a name="锚点名称">2.1.基本的半导体元件及原理</a></h2><p>在 <a href="">(计算机组成原理) 第一章计算机系统概述 - 计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这篇文章中说到：<strong>一个存储器由存储体、MAR（地址寄存器）和 MDR（数据寄存器） 构成，这三部分会在时序逻辑电路 的控制下相互配合进行工作</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408302.png" loading="lazy"></p><p><strong>存储体是用来存放二进制数据的，它由多个存储单元构成，而存储单元又有存储元构成，下图就是一个存储元，由 MOS 管和电容实现</strong>。</p><ul><li><strong>MOS 管</strong>：可以理解为一种电控开关，输入电压达到 ** 某个阈值时，**MOS 管就可以接通。</li><li><strong>电容</strong>：当产生电压差时就会充电，可以<strong>保存一定电荷</strong>。<strong>电容带电和不带电分别对应两种状态</strong>，也即二进制中的 0 和 1。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359286.png" loading="lazy"></p><p><strong>利用 MOS 管和电容可以进行如下操作</strong>：</p><ul><li><p><strong>读出二进制</strong>：假如电容有电，此时当 MOS 管接通时，<strong>电荷就可以顺着导线向 MOS 管右侧流动</strong>，当在该侧检测到电流时相当于输出了 1，反之则输出了 0  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408799.png" loading="lazy"></p></li><li><p><strong>写入二进制</strong>：在 MOS 管右侧接入电压，然后导通 MOS 管，<strong>这样电流就会从右向左流动</strong>，此时电容一端接地，于是两块板子上有电压差，<strong>电荷就会被 “装载” 进去</strong>，接着再把 MOS 管断开，这样电荷就跑不出去了 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359707.png" loading="lazy"></p></li></ul><p><strong>上述仅仅是一个存储元，如果把多个存储元按照一定方式连接，那么就能一次性读出或者写入多位数据，比如下图</strong>：</p><ul><li><p>下图中<strong>红色导线连接了每个存储元的 MOS 管</strong>，因此如果给其加上电压，就意味着所有存储元的 MOS 管都可以被导通。</p></li><li><p>当 MOS 管导通后，<strong>电容里存储的电荷就可以顺着绿色的线导出</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408417.png" loading="lazy"></p></li></ul><p><strong>于是按照上述方式就可以读出一整行存储元所存储的数据信息，而这一行其实就是存储单元（也即一个存储字），多个存储单元组合便构成了存储体</strong>。</p><ul><li>为什么存储器每次读写操作的单位是一个存储字：<strong>因为同属于一个存储字的存储元它们的 MOS 管一端接的都是同一根线。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141359359.png" loading="lazy"></p><h2 id="2-2-存储器芯片的基本原理"><a href="#2-2-存储器芯片的基本原理" class="headerlink" title="2.2.存储器芯片的基本原理"></a>2.2.存储器芯片的基本原理</h2><ul><li>读出和写入的功能有了，那么下一个问题就是<strong>如何决定我们要读或者写的具体是哪一个存储字呢</strong>，这就要涉及到<strong>译码器</strong>的概念了。</li></ul><p><strong>译码器</strong>：当给出 $n$ 位地址时，<strong>这 $n$ 位地址就会对应 $2^{n} $ 个存储单元（因为是地址是二进制）</strong>，所以<strong>译码器会根据 MAR</strong>（它和 CPU 连接）里面给出的这几位地址，<strong>将其转化为某一条字选线的高电平信号。</strong></p><ul><li>例如：MAR 送过来的地址是<code>000</code>，对应十进制的 0，所以译码器会给第 0 根字选线一个高电平，<strong>此时第一个存储字对应的存储元件都会被选通</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408186.png" loading="lazy"></p><p>如下，<strong>当第 0 根字选线被接通后，就可以通过数据线（也叫位线，绿色），把每一位的二进制信息传送到 MDR 当中</strong>，然后 <strong>CPU 会通过数据总线（宽度等于存储字长）从 MDR 当中取走这一存储字的数据。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631446.png" loading="lazy">  </p><p><strong>为此，我们需要新增一个控制电路来控制 MAR、MDR 和译码器</strong>：</p><ul><li><strong>控制 MAR</strong>：当 CPU 通过地址总线把地址送入 MAR 时，由于使用的是电信号，而电信号<strong>容易紊乱</strong>，因此<strong>在 MAR 中电信号稳定之前，该地址不能被送入译码器当中</strong>。</li><li><strong>控制 MDR</strong>：和 MAR 相同，稳定时才能输出。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408664.png" loading="lazy"></p><p><strong>另外，存储芯片还需要向外提供片选线，用 $  \overline C $ $ \overline S $（芯片选择信号）或 $ \overline C $ $\overline E $（芯片使能信号）表示（横线表示低电平有效）</strong>。</p><p><strong>当然，控制电路还需要提供读控制线和写控制线</strong>：</p><ul><li><p>$ \overline W $$ \overline E $：低电平时，表示正在进行<strong>写操作</strong>，也就是要把 MDR 里保存的数据把它输入到电容中。</p></li><li><p>$ \overline O $$ \overline E$：低电平时，进行<strong>读操作。</strong></p></li><li><p>下图中读写控制线分为两根，也可以整合为一根， $ \overline W $ $\overline E $就表示<strong>低电平写，高电平读</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141403668.png" loading="lazy"></p><p><strong>最后屏蔽内部实现细节后，存储器芯片会这样表示</strong> ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141403640.png" loading="lazy"></p><p><strong>最后再次说明一下片选线的作用</strong>：下图是内存条，一个内存条由很多存储芯片组成（如果是 8G，那么每个存储芯片大概就是 1G），<strong>因此片选线就是为了操作指定的存储芯片</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141407141.png" alt="image-20230414140709086" loading="lazy"></p><p>同时上面原理图中讲到的每一根线其实就是对应了芯片的<strong>引脚</strong>。</p><ul><li><p>$n$ 位地址就对应了 $2^{n} $ 个存储单元，因此总容量 &#x3D; 存储单元个数 × 存储字长</p></li><li><p>有时我们会见到这样的描述，<strong>8×8 位的存储单元</strong>，比如 8K×8 位，就是 $2^{13}×8bit $</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408214.png" loading="lazy"></p></li></ul><h2 id="2-3-寻址"><a href="#2-3-寻址" class="headerlink" title="2.3.寻址"></a>2.3.寻址</h2><p>如下矩阵方格中每一个方格表示 8bit 的信息，<strong>每一行表示一个存储字</strong>，为 4B 大小，该矩阵共有 256 行，大小为 1KB </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141405823.png" loading="lazy"></p><p>现代计算机通常是<strong>按照字节寻址</strong>的，因此 1 个小方格就对应 1 个地址，这里有 1K 个字节那么就有 1K 个地址。既然有 1K 个地址，那么根据之前叙述，应该就有 10 根地址线（ $2^{10} $）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141408887.png" loading="lazy"></p><p>虽然是按照字节编址的，但还可以按照字、半字、双字等方式寻址：</p><ul><li><strong>按字节寻址</strong>：1K 个单元，每个单元 1B。</li><li><strong>按字寻址</strong>：256 个单元，每个单元 4B。</li><li><strong>按半字寻址</strong>：512 个单元，每个单元 2B。</li><li><strong>按双字寻址</strong>：128 个单元，每个单元 8B。</li></ul><blockquote><ul><li><strong>位（bite）</strong>: 音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。</li><li><strong>字节（byte）</strong>：一个字节等于8位，即1Byte&#x3D;8bit。</li><li><strong>字</strong>：一串数码作为一个整体来处理运算，被称为一个字，字的位数称为字长，一个字通常有若干个字节，例如286微机的字由2个字节组成，它的字长为16；486微机的字由4个字节组成，它的字长为32位机。 计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越优越。</li></ul></blockquote><h1 id="3-SRAM芯片和DRAM芯片"><a href="#3-SRAM芯片和DRAM芯片" class="headerlink" title="3.SRAM芯片和DRAM芯片"></a>3.SRAM芯片和DRAM芯片</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141618171.png" loading="lazy"></p><p><strong>本节会在上节的基础上，介绍两种重要的存储器芯片：DRAM 和 SRAM</strong>。</p><ul><li><strong>DRAM(Dynamic-Random- Access -Memory)：动态 DRAM，主要用于主存。</strong></li><li><strong>SRAM(Static- Random -Access -Memory)：静态 RAM，主要用于 Cache</strong>。</li></ul><p><strong>注意</strong>：DRAM 芯片已经过时了，现在主存通常采用 SDRAM（如 DDR3 和 DDR4）。</p><h2 id="3-1-存储器元件不同导致的特性差异"><a href="#3-1-存储器元件不同导致的特性差异" class="headerlink" title="3.1.存储器元件不同导致的特性差异"></a>3.1.存储器元件不同导致的特性差异</h2><p>上一节介绍的芯片实则就是 <strong>DRAM 芯片</strong>，主要被用于制作主存。<strong>其实 DRAM 芯片和 SRAM 芯片的核心区别点就在于他们的存储元制作材料不一样。</strong></p><ul><li><p><strong>DRAM</strong>：使用<strong>栅极电容</strong>。</p></li><li><p><strong>SRAM</strong>：使用<strong>双稳态触发器</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619753.png" loading="lazy"></p></li></ul><h3 id="3-1-1-栅极电容"><a href="#3-1-1-栅极电容" class="headerlink" title="3.1.1.栅极电容"></a>3.1.1.栅极电容</h3><p><strong>栅极电容：当给字选择线一高电平时，MOS 管会接通，然后给数据线一高电平，由于电容一端接地，因此电容板之间产生电压差，于是电荷被 “写入” 电容</strong>。</p><ul><li><strong>1</strong>：表示电容内<strong>存储</strong>了电荷。</li><li><strong>0</strong>：表示电容内<strong>未存储</strong>电荷。</li></ul><p><strong>在读出时，如果电容里面有电荷，那么当 MOS 管接通后，一定会在数据线位置检测到电流信号，反之则不会，分别对应数据 1 和数据 0。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619128.png" loading="lazy"></p><h3 id="3-1-2-双稳态触发器"><a href="#3-1-2-双稳态触发器" class="headerlink" title="3.1.2.双稳态触发器"></a>3.1.2.双稳态触发器</h3><ul><li><strong>关于双稳态触发器具体原理请点击链接跳转</strong>：<a href="http://www.360doc.com/content/19/0827/18/2289804_857407763.shtml">双稳态触发器</a>。</li></ul><p><strong>双稳态触发器：是一种具有记忆功能的逻辑单元电路，它能储存一位二进制码。它有两个稳定的工作状态，在外加信号触发下电路可从一种稳定的工作状态转换到另一种稳定的工作状态</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141619373.png" loading="lazy"></p><p><strong>相比栅极电容，双稳态触发器有两根数据线。当给字选择线一高电平信号后</strong>：</p><ul><li><strong>如果里面存储的是 1</strong>，那么将会在 BLX 这条线上输出低电平信号（左边没有）。</li><li><strong>如果存储的是 0</strong>，那么将会在 BL 这条线上输出低电平信号（右边没有）。</li></ul><p><strong>同时在写入时</strong>：</p><ul><li><strong>如果要写入数据 0</strong>：那么只需要给 BL 一<strong>低电平信号</strong>，同时给 BLX 一<strong>高电平信号</strong>。</li><li><strong>如果要写入数据 1</strong>，那么只需要给 BL 一<strong>高电平信号</strong>，同时给 BLX 一<strong>低电平信号。</strong></li></ul><h3 id="3-1-3-SRAM-和-DRAM-对比"><a href="#3-1-3-SRAM-和-DRAM-对比" class="headerlink" title="3.1.3.SRAM 和 DRAM 对比"></a>3.1.3.SRAM 和 DRAM 对比</h3><p><strong>关于读写速度</strong>：</p><ul><li><strong>DRAM 使用栅极电容的充放电来完成读写操作</strong>：电容的物理特性就决定了其充放电是一种<strong>破坏性读出</strong>，读出后应该<strong>有重写操</strong>作，也就是需要重新充电，也称之为<strong>再生</strong>，读写<strong>速度较慢</strong>。</li><li><strong>SRAM 使用双稳态触发器</strong>：在读写数据时，触发器的状态是<strong>保持稳定的</strong>，因此属于<strong>非破坏性读出</strong>，无需进行<strong>重写操作</strong>，读写速度<strong>也就更快。</strong></li></ul><p><strong>2：关于成本和功耗</strong></p><ul><li><strong>DRAM</strong>：单个存储元制造成本<strong>低</strong>，集成度<strong>高</strong>，功耗<strong>低。</strong></li><li><strong>SRAM</strong>：单个存储元制造成本更<strong>高</strong>，集成度<strong>低</strong>，功耗<strong>大</strong>。</li></ul><p><strong>3：其它区别</strong></p><table><thead><tr><th>类型 / 特点</th><th>SRAM（静态 RAM）</th><th>DRAM（动态 RAM）</th></tr></thead><tbody><tr><td><strong>存储原理</strong></td><td>触发器</td><td>电容</td></tr><tr><td><strong>是否是破坏性读出</strong></td><td>否</td><td>是</td></tr><tr><td><strong>是否需要重写</strong></td><td>否</td><td>是</td></tr><tr><td><strong>运行速度</strong></td><td>快</td><td>慢</td></tr><tr><td><strong>集成度</strong></td><td>低</td><td>高</td></tr><tr><td><strong>发热量</strong></td><td>大</td><td>小</td></tr><tr><td><strong>成本</strong></td><td>高</td><td>低</td></tr><tr><td><strong>是否是易失性存储器</strong></td><td>是</td><td>是</td></tr><tr><td><strong>是否需要 “刷新”</strong></td><td>否</td><td>是</td></tr><tr><td><strong>送行列地址</strong></td><td>同时送</td><td>分两次</td></tr><tr><td><strong>用途</strong></td><td>Cache</td><td>主存</td></tr></tbody></table><ul><li>刷新：<strong>电容里面的电荷不能永久存在</strong>，一般只能维持 2ms，因此即使不断电，2ms 后信息也会丢失，因此对于 DRAM 需要 “刷新”，也就是再充电；而 SRAM 只要不断电，触发器的状态就不会改变。</li></ul><h2 id="3-2-DRAM-的刷新"><a href="#3-2-DRAM-的刷新" class="headerlink" title="3.2.DRAM 的刷新"></a>3.2.DRAM 的刷新</h2><h3 id="3-2-1-译码器需要使用行列地址"><a href="#3-2-1-译码器需要使用行列地址" class="headerlink" title="3.2.1.译码器需要使用行列地址"></a>3.2.1.译码器需要使用行列地址</h3><p>上一节说到了译码器的作用：<strong>把某一位的地址，转化为相应的选通线的高电平信号， $n$位地址就对应 $2^{n} $ 个选通线。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622269.png" loading="lazy"></p><p><strong>当地址数变多时，选通线数量级将会非常大</strong>，例如仅 20 个地址就需要 $ 2^{20}&#x3D;1 048 576 $ 根选通线，这已接近百万了。</p><p><strong>解决方法就是：将原来的单纯的一维的地址，改变为行列地址，也就是一个矩阵，分别交给行地址译码器和列地址译码器管理，这样的话每个译码器只需处理一半的地址信息，也就是 1024 根选通线</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622248.png" loading="lazy"></p><p>例如地址<code>0000</code> <code>0000</code>，如果采用之前的方案，那么经过译码器译码后，第 0 根选通线会被选中 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622141.png" loading="lazy"></p><p>而如果采用行列译码器的方案，<strong>地址<code>0000</code> <code>0000</code>的低四位将会交给列地址译码器，高四位将会交给行地址译码，每个存储单元只有列选通线和行选通线同时被选中时才能被选中</strong>，因此<code>(1,1)</code>位置的存储单元此时会被选中。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622038.png" loading="lazy">  </p><p><strong>对于八位地址，原本需要使用 $2^{8}&#x3D;256 $ 根选通线，而现在只需要$2^{4}+2^{4}&#x3D;16+16&#x3D;32$根选通线，所以使用行列地址的本质就是要减少选通线数量</strong>。</p><h3 id="3-2-2-分散刷新、集中刷新和异步刷新"><a href="#3-2-2-分散刷新、集中刷新和异步刷新" class="headerlink" title="3.2.2.分散刷新、集中刷新和异步刷新"></a>3.2.2.分散刷新、集中刷新和异步刷新</h3><h4 id="3-2-2-1-DRAM-刷新"><a href="#3-2-2-1-DRAM-刷新" class="headerlink" title="3.2.2.1.DRAM 刷新"></a>3.2.2.1.DRAM 刷新</h4><p><strong>关于 DRAM 的刷新，这里有 4 个问题需要回答</strong>：</p><ul><li><strong>多久刷新一次</strong>：一般为 2ms。</li><li><strong>每次刷新多少存储单元</strong>：以行为单位，每次刷新一行存储单元。</li><li><strong>如何刷新</strong>：有硬件支持，读出一行的信息后重新写入，占用 1 个读写周期。</li><li><strong>什么时候刷新</strong>：分散刷新、集中刷新和异步刷新（接下来介绍）。</li></ul><h4 id="3-2-2-2-分散刷新、集中刷新和异步刷新特点"><a href="#3-2-2-2-分散刷新、集中刷新和异步刷新特点" class="headerlink" title="3.2.2.2.分散刷新、集中刷新和异步刷新特点"></a>3.2.2.2.分散刷新、集中刷新和异步刷新特点</h4><p>假设 DRAM 内部结构排列形式为 128×128，存储周期为 0.5 $us $，电容最多坚持 2ms，因此对应 2ms&#x2F;0.5 $us $&#x3D;4000 个周期，有 128 行，刷新每一行都需要 0.5 $us $，同时注意以下内容：</p><ul><li>刷新对 CPU 是透明的，也即<strong>刷新不依赖于外部的访问</strong>。</li><li>DRAM 刷新单位是行，因此<strong>刷新操作时仅需要行地址。</strong></li><li>刷新操作类似于读操作，但又有所不同：<strong>刷新操作仅给栅极电容补充电荷，不需要信息输出，另外刷新时不需要进行选片，即整个存储器中的所有芯片同时被刷新。</strong></li></ul><p>一共有<strong>分散刷新、集中刷新和异步刷新</strong>这三种方式：</p><ul><li><p><strong>分散刷新</strong>：把对每行的刷新分散到各个工作周期当中，这样，一个存储器的系统工作周期就分为了两个部分，<strong>前半部分用于正常读写或保持；后半部分用于刷新某一行</strong>。这种刷新方式增加了系统的存取周期，增加为 1 $us $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141622334.png" loading="lazy"></p></li><li><p><strong>集中刷新</strong>：<strong>是指利用一段固定的时间，依次对存储器的所有行进行逐一再生，存储周期不变</strong>，在刷新期间内会停止对存储器的访问，因此称之为 “死时间”，又称访存 “死区” 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141623410.png" loading="lazy"></p></li><li><p><strong>异步刷新</strong>：它是前两种刷新方式的结合。<strong>具体做法是用刷新周期除以行数，得到两次刷新操作之间的时间间隔 t（2ms&#x2F;128&#x3D;15.6 $us $）</strong>，接着利用逻辑电路每隔该时间间隔 t(15.6 $us $) 产生一次刷新请求，因此每 15.6 $us $ 内会有 0.5 $us $ 的死时间。所以死时间会分散在整个过程中，而且可以在译码阶段刷新 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632079.png" loading="lazy"></p></li></ul><h4 id="3-2-2-3-分散刷新、集中刷新和异步刷新优缺点"><a href="#3-2-2-3-分散刷新、集中刷新和异步刷新优缺点" class="headerlink" title="3.2.2.3.分散刷新、集中刷新和异步刷新优缺点"></a>3.2.2.3.分散刷新、集中刷新和异步刷新优缺点</h4><p><strong>集中刷新</strong>：</p><ul><li><strong>优点</strong>：读写操作不受刷新工作的影响，因此系统的<strong>存取速度较高</strong>。</li><li><strong>缺点</strong>：是在集中刷新期间（死区）不能访问存储器。</li></ul><p><strong>分散刷新</strong>：</p><ul><li><strong>优点</strong>：是<strong>没有死区。</strong></li><li><strong>缺点</strong>：是加长了系统的存取周期<strong>降低了整体速度。</strong></li></ul><p><strong>异步刷新</strong>：综合最优。</p><ul><li>可以避免使 CPU 连续等待过长的时间，而且减少了刷新次数，从根本上<strong>提高了整机的工作效率</strong>；</li><li>同时如果将刷新安排在不需要访问存储器的译码阶段，则<strong>既不会加长存取周期，又不会产生 “死时间”</strong>，这是分散刷新的方式的发展，也称之为 “<strong>透明刷新</strong>”。</li></ul><h2 id="3-3-DRAM-的地址线复用技术"><a href="#3-3-DRAM-的地址线复用技术" class="headerlink" title="3.3.DRAM 的地址线复用技术"></a>3.3.DRAM 的地址线复用技术</h2><ul><li>前面说过 SRAM 需要同时送行列地址，也即<strong>行列地址信息会同时丢给行译码器和列译码器。</strong></li></ul><p>而 DRAM 由于用于主存，所以容量可能较大，因此地址线可能也会更多，<strong>所以为了使地址线电路变得更简单，会采用一种地址线的复用技术，也就是分两次送。</strong></p><p><strong>这种技术可以使行列地址分两次前后进行传送，传送时只需要一半地址，先传送至缓冲区，再传送给译码器即可，这样会使地址线更少</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703887.png" loading="lazy"></p><h1 id="4-只读存储器"><a href="#4-只读存储器" class="headerlink" title="4.只读存储器"></a>4.只读存储器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141625901.png" alt="image-20230414162516788" loading="lazy"></p><h2 id="4-1-只读存储器（ROM）特点"><a href="#4-1-只读存储器（ROM）特点" class="headerlink" title="4.1.只读存储器（ROM）特点"></a>4.1.只读存储器（ROM）特点</h2><p><strong>只读存储器（ROM）：前文说到的 SRAM 和 DRAM 都属于 RAM 芯片，RAM 芯片属于数据易失性芯片，断电后数据将会消失。但很多情况下需要对数据进行长期保存，所以就要使用到 ROM 芯片。它有两个显著的特点</strong>：</p><ul><li>结构简单，所以位密度比可读存储器的高。</li><li>具有非易失性，可靠性高。</li></ul><h2 id="4-2-ROM-的类型"><a href="#4-2-ROM-的类型" class="headerlink" title="4.2.ROM 的类型"></a>4.2.ROM 的类型</h2><ul><li><strong>掩模式只读存储器（MROM）</strong>：MROM 的内容由<strong>半导体制造厂家按用户提出的要求在芯片的生产过程中直接写入，写入以后任何人无法改变其内容</strong>。优点是<strong>可靠性高、集成度高、价格便宜</strong>；缺点则是灵活性差。</li><li><strong>一次可编程只读存储器（PROM）</strong>：PROM 是可以实现一次性编程的只读存储器，允许用户<strong>利用专门的设备写入自己的程序</strong>，一旦写入，内容无法改变。</li><li><strong>可擦除可编程只读存储器（EPROM）</strong>：EPROM <strong>可以让用户利用编程器写入信息，而且内容也可以进行多次改写</strong>。如果需要修改 EPROM 内容，则先将其全部内容擦除，然后再编程。EPROM 又可以分为<strong>紫外线擦除（UVEPROM）</strong>和电擦除<strong>（$E  ^{2} PROM$）</strong>。EPROM 虽然既可以读又可以写，但是它不能取代 RAM，因为 EPROM 的编程次数有限，且写入时间过长。</li><li><strong>闪存存储器（Flash Memory）</strong>：Flash Memory 是在 EPROM 与 $E  ^{2} PROM$ 的基础上发展起来的，其主要特点是<strong>即可以在不加电的情况下长期保存信息，又能在线进行快速擦除和重写</strong>。需要注意的是<strong>闪存需要先擦除再写入，因此闪存的写速度要比读速度更慢</strong>。</li><li><strong>固态硬盘（SSD）</strong>：基于闪存，<strong>由控制单元和存储单元组成</strong>。保留了闪存长期保存信息，快速擦除与重写的特性。对比传统的硬盘也具有读写速度快，功耗低，其缺点就是价格高。</li></ul><h2 id="4-3-计算机内的重要-BIOS"><a href="#4-3-计算机内的重要-BIOS" class="headerlink" title="4.3.计算机内的重要 BIOS"></a>4.3.计算机内的重要 BIOS</h2><p><strong>BIOS：是计算机主板一个非常重要的 ROM 芯片，它存储了 “自举装入程序”，负责引导装入操作系统，进行开机操作。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141633488.png" alt="如何在BIOS中设置USB第一启动项_AwardBIOS" loading="lazy"></p><h1 id="5-主存储器和CPU的连接"><a href="#5-主存储器和CPU的连接" class="headerlink" title="5.主存储器和CPU的连接"></a>5.主存储器和CPU的连接</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141634276.png" loading="lazy"></p><p><strong>现代计算机中，MAR 和 MDR 通常集成在 CPU 的内部，而存储芯片内的仅是一个普通的寄存器。主存储器与 CPU 的连接示意图如下</strong>：</p><ul><li>主存储器通过<strong>数据总线、地址总线和控制总线</strong>与 CPU 连接。</li><li>数据总线的位数与工作频率的乘积正比于<strong>数据传输率。</strong></li><li><strong>地址总线的位数</strong>决定了可寻址的最大内存空间。</li><li><strong>控制总线</strong>（读或写）指出总线周期的类型和本次输入输出操作完成的时刻。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703006.png" loading="lazy"></p><h2 id="5-1-单块存储芯片与-CPU-的连接"><a href="#5-1-单块存储芯片与-CPU-的连接" class="headerlink" title="5.1.单块存储芯片与 CPU 的连接"></a>5.1.单块存储芯片与 CPU 的连接</h2><p>下图是前文中讲到过的一<strong>单个存储芯片的内部构造</strong>（<a href="#锚点名称">2.1.基本的半导体元件及原理</a>），它和 CPU 通过以下总线连接（<strong>具体过程会在 “二：多块存储芯片与 CPU 的连接 -（1）位扩展 -①：单个连接” 中进行描述</strong>）。</p><ul><li><strong>数据总线（绿色线）</strong>：用于传送数据。</li><li><strong>地址总线（红色线）</strong>：用于传送地址。</li><li><strong>控制总线（橙色线）</strong>：用于发出控制信号。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703643.png" loading="lazy"></p><h2 id="5-2-多块存储芯片与-CPU-的连接"><a href="#5-2-多块存储芯片与-CPU-的连接" class="headerlink" title="5.2.多块存储芯片与 CPU 的连接"></a>5.2.多块存储芯片与 CPU 的连接</h2><p><strong>上图展示的只是一个 8×8 位的存储芯片，仅能存储 8B 的数据，所以会存在以下问题</strong>：</p><ul><li>问题一：存储字长为 8 位，也即 CPU 一次只能读或写 8 位，而现代计算机数据总线宽度至少是 64 位，严重不匹配。因此问题在于如何<strong>增加存储字长，使 CPU 一次能读或写多位数据</strong> （对应<strong>位扩展</strong>）。</li><li>问题二：只有 8 个地址，地址数目太少。因此问题在于如何<strong>扩展地址空间，使地址数目变多</strong>（对应<strong>字扩展</strong>）。</li></ul><p><strong>这里，为了后续描述方便，为一块存储芯片的输入输出信号进行命名</strong>：</p><ul><li><strong>地址线</strong>：有可能输入多位的地址，因此地址用$A_{n} $表示， $n$从 0 开始，表示从地址低位到地址高位</li><li><strong>数据线</strong>：用 $ D_{n} $表示， $n$从 0 开始，表示从数据低位到数据高位。</li><li><strong>片选线</strong>：片选信号通常用 $\overline C\overline S $ 或 $ \overline C\overline E $ 表示，其中的横线表示低电平有效，高电平无效。</li><li><strong>读写控制线</strong>：该信号用 $\overline W\overline E $ 或 $ \overline W\overline R $ 表示，其中的横线表示低电平写，高电平读。（注意有些地方也可能将读写分开，分别为 $\overline O\overline E $ 或 $ \overline W\overline E $，低电平表示有效，高电平无效）。</li></ul><h3 id="5-2-1-位扩展"><a href="#5-2-1-位扩展" class="headerlink" title="5.2.1.位扩展"></a>5.2.1.位扩展</h3><h4 id="5-2-1-1-单个连接"><a href="#5-2-1-1-单个连接" class="headerlink" title="5.2.1.1.单个连接"></a><a name="5.2.1.1.单个连接">5.2.1.1.单个连接</a></h4><p>下图是买来的一块 8K×1 位的存储芯片。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703104.png" loading="lazy"></p><p>该存储芯片有 8K 个存储单元，由于 $ 2^{13}&#x3D;8192 $，这意味着至少需要 <strong>13 根地址线</strong>才能表示这么多地址，<strong>因此该存储芯片要向外暴露出 13 个地址引脚</strong>，然后 CPU 会把它想要访问的地址通过<strong>地址总线</strong>送过来。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703711.png" loading="lazy"></p><p>左下角的 “ $W E $” 表示<code>Write Enable</code>，上方没有横线，那么就表示<strong>低电平读、高电平写</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703778.png" loading="lazy"></p><p>上图显示 CPU 一次是可以读写 8 位数据的，<strong>但是由于存储芯片字长的限制，所以一次最多只能进行一位</strong>，这导致数据总线没有被充分利用。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703722.png" loading="lazy"></p><p>还有一个片选线 $C S$ ，表示高电平有效，这里暂时先给一个高电平，具体作用后面会说。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703968.png" loading="lazy">  </p><p>至此，单个芯片的连接已经完成了。<strong>但是由于存储字长为 1，一次只能读写一位数据，所以数据总线利用率很差</strong>，因此在这种情况下可以进行<strong>位扩展</strong>。</p><h4 id="5-2-1-2-多个连接"><a href="#5-2-1-2-多个连接" class="headerlink" title="5.2.1.2.多个连接"></a>5.2.1.2.多个连接</h4><p>接着又买到了一个和上面相同规格的存储芯片。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703307.png" loading="lazy"></p><p>对于地址线，<strong>我们从刚才连接的每一个地址线分别分流出一根线连接到该存储芯片的引脚上，这意味着一个地址可以同时选中两个存储单元。</strong></p><p>对于读写控制线也是这样连接，这意味着它们是<strong>同时读或者同时写</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703345.png" loading="lazy"></p><p>对于数据线，<strong>该存储芯片的引脚可以连接在 CPU 的$D_{1} $位置</strong>。</p><p>最后，也给片选$CS $ 线给一高电平。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703536.png" loading="lazy"></p><p>至此，两块芯片连接完成。现在，<strong>从整体上看存储字长被扩展为了 2 位，也即可以同时读或写两位的信息了</strong>。</p><p>最后，再买来 6 块芯片，连接好即可。</p><ul><li><p>每块芯片都有 8 个存储单元，CPU 发出的 $A_{0}$$A_{12} $的这 13 位的地址信息会同时送给 8 片存储芯片 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703902.png" loading="lazy"></p></li></ul><h3 id="5-2-2-字扩展"><a href="#5-2-2-字扩展" class="headerlink" title="5.2.2.字扩展"></a>5.2.2.字扩展</h3><h4 id="5-2-2-1-线选法"><a href="#5-2-2-1-线选法" class="headerlink" title="5.2.2.1.线选法"></a>5.2.2.1.线选法</h4><p>如下是买来的一块 8K×8 位的存储芯片 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703763.png" loading="lazy"></p><p>单个芯片的连接过程同 “<a href="#5.2.1.1.单个连接">5.2.1.1.单个连接</a>”，可自行研究。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703177.png" loading="lazy"></p><p>这个芯片明显不需要进行位扩展。但其问题在于：<strong>此 CPU 的寻址能力很大，可以达到$ 2^{16} $，但却只利用了其中一部分，有 3 位没有被利用，所以在这情况下就要采用字扩展的方式来解决问题。</strong></p><p>再买来一块相同规格的存储芯片，先采用之前的位扩展的规则进行连接，如下图：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703432.png" loading="lazy">  </p><p>可以发现采用这种方式连接将会产生很大的问题：<strong>两块芯片会被同时选中，比如读数据时，两块存储芯片的 8 位数据会同时传给 CPU，因此存在数据冲突</strong>。</p><p><strong>解决方法就在于片选信号$CS $。现在，将 $ A_{13}$​连接到左边存储芯片的片选信号$CS $ 上，将 $ A_{14}$连接到右边存储芯片的片选信号$CS $ 上。由于是高电平有效，因此当地址位为 1 时表示该存储芯片工作。</strong></p><p><strong>$ A_{13}$​和 $ A_{14}$只有两位，故取值只会有四种情况：01、10、11、00</strong>。</p><ul><li><p><strong>如果是 01（注意 $ A_{14}$是 0 $ A_{13}$​是 1， $ A_{14}$是地址高位）</strong>：此时左边芯片工作，右边片不工作。因此现在 <strong>CPU 提供的这 13 位的地址只会读取左边存储芯片对应的 8 位的数据</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703773.png" loading="lazy"></p></li><li><p><strong>如果是 10</strong>：此时右边芯片工作，左边芯片不工作；因此现在 <strong>CPU 提供的这 13 位的地址只会读取右边存储芯片对应的 8 位的数据</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703922.png" loading="lazy"></p></li><li><p><strong>如果是 11 或 00</strong>：这种情况又会出现刚才的矛盾，因此<strong>不能出现</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703111.png" loading="lazy"></p></li></ul><p><strong>这样操作后，芯片所表示的地址范围会发生改变</strong>：</p><ul><li><strong>左边芯片</strong>：010 0000 0000 0000~011 1111 1111 1111。</li><li><strong>右边芯片</strong>：100 0000 0000 0000~101 1111 1111 1111。</li></ul><p><strong>这种连接方法称之为 “线选法”，其缺点在于以 00 和 11 开头的地址是不能用的。</strong></p><ul><li>注意：不是仅有两个地址，是以 00 和 11 开头的所有地址均不可用，其数量是相当多的。</li></ul><h4 id="5-2-2-2-译码片选法"><a href="#5-2-2-2-译码片选法" class="headerlink" title="5.2.2.2.译码片选法"></a>5.2.2.2.译码片选法</h4><ul><li><strong>译码片选法会在线选法的基础上做一定改进，只需要加入一个非门。</strong></li></ul><p><strong>以 $ A_{13}$​为例，让它分别连接左边芯片和右边芯片的片选信号$CS $ 上，但是在第二个线路中加入一个非门，这样当 $ A_{13}$​为 1 时，左边会被选中，右边由于非门的取反作用会变为不工作</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703041.png" loading="lazy"></p><p>这样的话，<strong>左边芯片的地址范围就为：10 0000 0000 0000~11 1111 1111 1111；右边的则为：00 0000 0000 0000 ~01 1111 1111 1111，整个主存地址空间是连续的。</strong></p><p>上面用到的非门叫做 “<strong>1-2 译码器</strong>”，这种方法叫做<strong>译码片选法</strong>，<strong>如果 CPU 有 n 条多余的片选线，那么他可以对应 $2^{n} $ 个片选信号。</strong></p><ul><li>译码器编号：1-2 译码器是输入 1 个对应 2 个，2-4 译码器是输入两个对应 4 个，以此类推。</li></ul><p>讲完上面的操作，现在可以使用真正使用字扩展了。<strong>这里采用一个 2,4 译码器，也就是输入两个信号，输出 4 个信号，接着加入 4 个 8×8 位的存储芯片，每块存储芯片都会接受 CPU 发过来的低 13 位的地址信息</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703842.png" loading="lazy"></p><ul><li>注意上方图片中，每个存储芯片所有的地址信息都是直接来自于 CPU 的，不是从左边相邻的芯片传递过来的，这里是这样画只是为了整洁。</li><li>在电路图中，当需要表示低电平有效时，通常会在上面画一个 “小圆”。</li></ul><p>当 $ A_{13}$​， $ A_{14}$为均为 0 时，就表示第一根线为 1，剩余为 0，但是经过译码器后，由于是取反，所以第一根为 0，其余为 1，而正好 0 表示存储芯片工作，所以这种情况第一个存储芯片工作，其余不工作 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703002.png" loading="lazy">  </p><p>类似的，当 $ A_{13}$​为 1， $ A_{14}$为 0 时，就表示第二根线为 1，剩余为 0，但是经过译码器后，由于是取反，所以第二根为 0，其余为 1，而正好 0 表示存储芯片工作，所以这种情况就表示第二个存储芯片工作，其余不工作 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703889.png" loading="lazy">  </p><p>因此：</p><p><strong>要访问第一块存储芯片，就要保证 $ A_{13}$​为 0， $ A_{14}$为 0，此时地址范围为：<code>000 0000 0000 0000 到 001 1111 1111 1111</code><br>要访问第二块存储芯片，就要保证 $ A_{13}$​为 1， $ A_{14}$为 0，此时地址范围为：<code>010 0000 0000 0000 到 011 1111 1111 1111</code><br>要访问第三块存储芯片，就要保证 $ A_{13}$​为 0， $ A_{14}$为 1，此时地址范围为：<code>100 0000 0000 0000 到 101 1111 1111 1111</code><br>要访问第四块存储芯片，就要保证 $ A_{13}$​为 1， $ A_{14}$为 1，此时地址范围为：<code>110 0000 0000 0000 到 111 1111 1111 1111</code></strong></p><p><strong>所以这样的操作就能保证主存地址范围从全 0 到全 1，而且是连续的</strong>。</p><p>另外还需要注意的是，考试时可能不会是连续的 $ A_{13}$​和 $ A_{14}$，有可能是 $ A_{13}$​和 $ A_{15}$，<strong>但是无论怎么样，只要不选中，就不影响选片操作，是 0 是 1 不用管，只看选中的那几位</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703422.png" loading="lazy"></p><p>最后，这里的 $ A_{15}$没有被启用，如果要使用的话那么就需要一个 3-8 译码器，然后再增加 4 个相同规格的存储芯片即可。</p><h4 id="5-2-2-3-字位同时扩展"><a href="#5-2-2-3-字位同时扩展" class="headerlink" title="5.2.2.3.字位同时扩展"></a>5.2.2.3.字位同时扩展</h4><p>位扩展可以使得存储芯片的字长变得更长，从而更好的发挥<strong>数据总线的传输能力</strong>；字扩展可以增加存储器的存储字数，从而更好利用 <strong>CPU 的寻址能力</strong>。既然二者都有的优点，那么就可以将它们综合起来，这种方法就是<strong>字位同时扩展。</strong></p><p>如下图有 8 块芯片，共有 4 组，每组两块，每组芯片实现了位扩展。</p><ul><li>前面的可以连接 $D_{0}-D_{3} $​, 后面的可以连接前面的可以连接$D_{4}-D_{7}$。</li></ul><p>这是一个 16K 的存储芯片，因此将 $A_{0}-A_{13} $作为片内地址， $ A_{14}-A_{15} $介入 2,4 译码器（因为有 4 组）。<strong>一个芯片是 16K×4 位，一组就是 16K×8 位，整体就是 64×8 位。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141703507.png" loading="lazy"></p><h2 id="5-3-译码器-补充知识点"><a href="#5-3-译码器-补充知识点" class="headerlink" title="5.3.译码器(补充知识点)"></a>5.3.译码器(补充知识点)</h2><p>1：需要注意的是片选信号和译码器要配合使用，一定要注意是高电平有效还是低电平有效 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702454.png" loading="lazy">  </p><p>2：译码器往往还有一个 (还有可能是多个) 和$CS $ 类似功能的控制端，叫做使能端，即$EN $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702965.png" loading="lazy"></p><ul><li>下面两个必须是低电平，上面必须是高电平才能工作。如果是其他非法状态，译码器右侧输出将会是全 1。</li></ul><p>3：在实际场景中，CPU 上还会有一个 MREQ（访问存储器的控制信号），CPU 会通过它来控制访问存储器。如下，只有当 MREQ 发出高电平时，经过非门，变为低电平后，译码器使能端变为低电平，此时译码器工作，地址才会被映射。</p><ul><li>之所以 CPU 需要控制，是因为这些地址信息都是电信号，开始时电信号是不稳定的，因此需要等稳定后才能 “打开” 译码器。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702120.png" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702333.png" loading="lazy">  </p><p>4：注意 74ls138</p><h1 id="6-双端口RAM和多模块存储器"><a href="#6-双端口RAM和多模块存储器" class="headerlink" title="6.双端口RAM和多模块存储器"></a>6.双端口RAM和多模块存储器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141716857.png" alt="image-20230414171604726" loading="lazy"></p><p>之前在<a href="">存储器分类、多级存储系统和存储器性能指标</a> 这篇文章中讲到了存取周期的概念：：<strong>存取周期又称读写周期或访问周期，它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储操作（读或写操作）之间所需的最小时间间隔</strong>。对于 DRAM芯片，它的恢复时间是比较长的，有时有可能会到达存取周期的几倍，而现代计算机 CPU 通常都是多核的，<strong>那么这么多 CPU 核心究竟应该怎样访问主存才能解决恢复时间过长带来的问题呢</strong>？主要有两种思路：</p><ul><li>双端口 RAM。</li><li>多模块存储器。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702109.png" loading="lazy"></p><p><strong>双端口 RAM：是指同一个存储器有左右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。该项技术可以优化多核 CPU 访问一根内存条的速度</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702087.png" loading="lazy"></p><p><strong>两个端口对同一主存操作时无外乎有以下四种情况</strong>：</p><ul><li><strong>两个端口不同时对同一地址单元读出数据</strong>：没有错误。</li><li><strong>两个端口同时对同一地址单元读出数据</strong>：没有错误。</li><li><strong>两个端口同时对同一地址单元写入数据</strong>：发生写入错误。</li><li><strong>两个端口同时对同一地址单元操作，一个写入，一个读出</strong>：发生读出错误。</li></ul><p>其解决方法为：<strong>置 “忙” 信号 $ \overline B\overline U\overline S\overline Y $为 0</strong>，由判断逻辑决定暂时关闭一个端口（延时）。<strong>未被关闭的端口正常访问，被关闭的延长一个很短的时间段后再访问。</strong></p><p><strong>多模块存储器：多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。有两种编址方式</strong>：</p><ul><li><strong>高位交叉编址</strong>。</li><li><strong>低位交叉编址。</strong></li></ul><h2 id="6-1-高位交叉编址"><a href="#6-1-高位交叉编址" class="headerlink" title="6.1.高位交叉编址"></a>6.1.高位交叉编址</h2><p><strong>高位交叉编址：高位地址表示体号，低位地址为体内地址。在这种编址方式下，总是把低的体内地址送到由高位体号所确定的模块内进行译码。访问一个连续的主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU 总是按顺序访问存储模块，存储模块不能并行访问，因此不能提高存储器的吞吐率。</strong></p><p>如下图，存储器共有 4 个模块 $ M_{0}-M_{3} $（可以将其理解为 “4 根内存条”），按照这种方式编址后，<strong>地址前两位（高位）表示的是某根内存条，后面部分（低位）表示的是该内存条中的具体地址</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702942.png" loading="lazy"></p><p>假设每个存储体的存取周期为 $T$，存取时间为 $r$，且 T&#x3D;4r。如果多体存储器采用高位交叉编址，那么 CPU 真正花在读数据上的时间只有 $r$，但却要再花费 3r 的时间用来等待，效率不高。<strong>也就是说连续读取 $n$个存储字，就要耗时 $ nT $</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141702048.png" alt="image-20230414170230959" loading="lazy"></p><h2 id="6-2-低位交叉编址"><a href="#6-2-低位交叉编址" class="headerlink" title="6.2.低位交叉编址"></a>6.2.低位交叉编址</h2><p><strong>低位交叉编址：低位地址表示体号，高位地址为体内地址。在这种编址方式下，总是把高位的体内地址送到由低位体号所确定的模块内进行译码。程序连续存放在相邻的模块中，将采用此编址方式的存储器称为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器带宽</strong>。</p><p>如下图，存储器共有 4 个模块$ M_{0}-M_{3}$（可以将其理解为 “4 根内存条”），<strong>每个模块的模块号 &#x3D; 单元地址 %4</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632277.png" loading="lazy"></p><p>**采用低位交叉编址的存储器连续读取 $n$个存储字，耗时为 $ T+(n-1)r $<strong>。CPU 每经过时间 $r$ 后会启动下一模块，</strong>因此交叉存储器要求其模块数必须大于等于 $\frac{T}{r} $**，以保证某模块后经过$ T $ 时间后再次启动该模块时，其上次的存取周期已到（也就是已经恢复） 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632248.png" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632896.png" loading="lazy"></p><h1 id="7-磁盘存储器（磁盘的基本结构，磁盘阵列）"><a href="#7-磁盘存储器（磁盘的基本结构，磁盘阵列）" class="headerlink" title="7.磁盘存储器（磁盘的基本结构，磁盘阵列）"></a>7.磁盘存储器（磁盘的基本结构，磁盘阵列）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141717032.png" alt="image-20230414171734928" loading="lazy"></p><h2 id="7-1-磁盘存储器"><a href="#7-1-磁盘存储器" class="headerlink" title="7.1.磁盘存储器"></a>7.1.磁盘存储器</h2><p><strong>计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。所谓 “磁表面存储”，是把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。</strong></p><p><strong>磁表面存储器有以下优点</strong>：</p><ul><li>存储容量大，价位低。</li><li>记录介质可以重复使用。</li><li>记录信息可以长期保存而不丢失，甚至可以脱机存档。</li><li>非破坏读出，读出时不需要再生。</li></ul><p><strong>磁表面存储器有以下缺点</strong>：</p><ul><li>存取速度慢。</li><li>机械结构复杂。</li><li>对环境要求较高。</li></ul><h3 id="7-1-1-磁盘设备组成"><a href="#7-1-1-磁盘设备组成" class="headerlink" title="7.1.1.磁盘设备组成"></a>7.1.1.磁盘设备组成</h3><h4 id="7-1-1-1-存储区域"><a href="#7-1-1-1-存储区域" class="headerlink" title="7.1.1.1.存储区域"></a>7.1.1.1.存储区域</h4><p><strong>存储区域：一块硬盘含有若干记录面，每个记录面划分为若干条磁道，每条磁道又划分为若干扇区，扇区（也称之为块）是磁盘读写的最小单位，也就是磁盘是按块存取。</strong></p><ul><li><p><strong>磁头数：也即记录面数，表示硬盘总共有多个磁头，磁头分为读磁头和写磁头，每个磁头对应一个记录面。</strong></p></li><li><p><strong>柱面数：表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面</strong>。</p></li><li><p><strong>扇区数：表示每一条磁道上有多少个扇区。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141709066.png" alt="22cc501b8cef4462a2a98f52726b64d7" loading="lazy"></p><h4 id="7-1-1-2-硬盘存储器的构成"><a href="#7-1-1-2-硬盘存储器的构成" class="headerlink" title="7.1.1.2.硬盘存储器的构成"></a>7.1.1.2.硬盘存储器的构成</h4><p><strong>硬盘存储器的构成：由磁盘驱动器，磁盘控制器和盘片组成。</strong></p><ul><li><p><strong>磁盘驱动器：核心部件是磁头组件和硬件组件，温彻斯特是一种可移动磁头固定盘片的硬盘存储器</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141710265.png" loading="lazy"></p></li><li><p><strong>磁盘控制器：硬盘存储器和主机的接口，主流的标准有 IDE,SCSI,SATA 等</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141711584.png" alt="1" loading="lazy"></p></li></ul><h3 id="7-1-2-磁盘性能指标"><a href="#7-1-2-磁盘性能指标" class="headerlink" title="7.1.2.磁盘性能指标"></a>7.1.2.磁盘性能指标</h3><p><strong>①：磁盘容量：一个磁盘所能存储的字节总数。磁盘容量有格式化容量和非格式化容量之分</strong>。</p><ul><li><strong>非格式化容量</strong>：磁记录表面可以利用的磁化单元总数。</li><li><strong>格式化容量</strong>：是指按照某种特定的记录格式所能存储信息的总量。</li></ul><p><strong>②：记录密度：是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。</strong></p><ul><li><p><strong>道密度</strong>：沿磁盘半径方向单位长度上的磁道数。</p></li><li><p><strong>位密度</strong>：是磁道单位长度上所能记录的二进制代码的位数。</p></li><li><p><strong>面密度</strong>：是道密度和位密度的乘积  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141712979.png" alt="1" loading="lazy"></p></li></ul><p><strong>磁盘所有磁道记录的信息量一定是相等的，并不是说圆越大记录的信息就越多，因此越靠近里面的磁道位密度就越大。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141716338.png" alt="image-20230414171641252" loading="lazy"></p><h3 id="7-1-3-平均存取时间"><a href="#7-1-3-平均存取时间" class="headerlink" title="7.1.3.平均存取时间"></a>7.1.3.平均存取时间</h3><p><strong>平均存取时间：一次磁盘读写花费的时间由以下三种时间决定</strong>：</p><p><strong>①：寻道时间 $ T_{S} $：在读 &#x2F; 写数据前，将磁头移动到指定磁道所花费时间</strong>。</p><ul><li><strong>启动磁头臂花费时间</strong>：$ s $（约为 2ms）。</li><li><strong>移动磁头花费时间：</strong> 假设磁头匀速移动，每跨越一个磁道耗时为 $ m$（约为 0.2ms），总共需要跨越 $n$条磁道。</li><li><strong>总花费时间： $ T_{S} $​&#x3D; $ s$+ $ m$× $ n$。</strong></li></ul><p><strong>②：延迟时间 T R T_{R} TR​：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</strong></p><ul><li><strong>磁盘转速为</strong> $r$(单位为 “转 &#x2F; 秒” 或“转 &#x2F; 分”，典型转速为 5400r&#x2F;min 或 7200r&#x2F;min)。</li><li><strong>转一圈所需要时间</strong>： $ \frac{1}{r} $。</li><li><strong>目标扇区平均需要转半圈</strong>： $ \frac{1}{2}$。​</li><li>**总花费时间： $ T_{R} $&#x3D; $\frac{1}{2} $​× $\frac{1}{r} $​&#x3D; $r \frac{1}{2r} $**。</li></ul><p><strong>③：传输时间 $T_{t} $：从磁盘读出或向磁盘写入数据所经历的时间</strong>。</p><ul><li><strong>每个磁道可以存储 $n$字节的数据，因此对于$ b $字节的数据需要的磁道数为</strong>： $\frac{b}{N} $。</li><li><strong>读写一个磁道所需要的时间刚好又是转一圈所需要的时间</strong>： $\frac{1}{r} $。</li><li><strong>总花费时间：$ T_{t} $&#x3D; $ \frac{1}{r} $× $ \frac{b}{N} $&#x3D; $ \frac{b}{rN} $。</strong></li></ul><p><strong>因此：总的平均存储时间 $T_{a} $&#x3D; 寻道时间 + 延迟时间 + 传输时间 &#x3D; $ T_{s} $​+ $ \frac{1}{2r} $+ $ \frac{b}{rN} $​</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141714919.png" alt="0" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632827.png" loading="lazy"></p><ul><li>寻道时间为 6ms。</li><li>10000r&#x2F;min，所以 166r&#x2F;s，因此转一圈大约 6ms，所以半圈 3ms，所以延迟时间为 3ms。</li><li>传输时间为 4(KB)&#x2F;20(MB\s)&#x3D;0.2ms。</li><li>其他时间为 0.2ms。</li><li>所以平均时间为 9.4ms。</li></ul><h3 id="7-1-4-磁盘地址"><a href="#7-1-4-磁盘地址" class="headerlink" title="7.1.4.磁盘地址"></a>7.1.4.磁盘地址</h3><p><strong>主机会向磁盘发送地址信息，格式如下</strong>：</p><table><thead><tr><th>驱动器号</th><th>柱面（磁道）号</th><th>盘面号</th><th>扇区号</th></tr></thead><tbody><tr><td>确定是哪一个硬盘</td><td>用于移动寻道</td><td>激活某个磁头</td><td>旋转扇区划过磁头</td></tr></tbody></table><p>如果系统中有 4 个驱动器，每个驱动器带一个磁盘，每个磁盘 256 个磁道，16 个盘面，每个盘面划分为 16 个扇区，则每个扇区地址要 18 位二进制代码，分布如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151632236.png" loading="lazy"></p><h3 id="7-1-5-磁盘工作过程"><a href="#7-1-5-磁盘工作过程" class="headerlink" title="7.1.5.磁盘工作过程"></a>7.1.5.磁盘工作过程</h3><p><strong>硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151633673.gif" loading="lazy"></p><p>需要注意的是硬盘属于机械式部件，其读写操作是并行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。所以是需要串 - 并变换电路的 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630537.png" alt="image-20230415163009440" loading="lazy"></p><h2 id="7-2-磁盘阵列"><a href="#7-2-磁盘阵列" class="headerlink" title="7.2.磁盘阵列"></a>7.2.磁盘阵列</h2><p><strong>磁盘阵列：RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储，并行访问，具有更好的存储性能，可靠性和安全性</strong>。</p><p><strong>RAID 的分级如下。在 RAID1~RAID5 几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。</strong></p><ul><li><p><strong>RAID0</strong>：无冗余和无校验的磁盘阵列（逻辑上相邻的两个扇区在物理上存到两个磁盘）。</p></li><li><p><strong>RAID1</strong>：镜像磁盘阵列（直接存两份数据）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630116.png" alt="image-20230415163024022" loading="lazy"></p></li><li><p><strong>RAID2</strong>：逻辑上连续的几个 bit 物理上分散存储在各个盘中，4bit 信息为 + 3bit 海明校验位，可纠正一位错误  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151630970.png" alt="image-20230415163045848" loading="lazy"></p></li><li><p><strong>RAID3</strong>：位交叉奇偶校验码的磁盘阵列。</p></li><li><p><strong>RAID4</strong>：块交叉奇偶校验的磁盘阵列。</p></li><li><p><strong>RAID5</strong>：无独立校验的奇偶校验磁盘阵列。</p></li></ul><p><strong>总之，RAID 通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量了通过镜像功能，提高安全可靠性；通过数据校验，提高容错能力</strong>。</p><h2 id="7-3-光存储器"><a href="#7-3-光存储器" class="headerlink" title="7.3.光存储器"></a>7.3.光存储器</h2><p><strong>光盘存储器是利用光学原理读 &#x2F; 写信息的存储装置，它采用聚集激光束对盘式介质以非接触的方式记录信息</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631878.png" loading="lazy"></p><h1 id="8-固态硬盘"><a href="#8-固态硬盘" class="headerlink" title="8.固态硬盘"></a>8.固态硬盘</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304141718909.png" alt="image-20230414171800773" loading="lazy"></p><p><strong>在微小型高档笔记本电脑中，采用高性能 Flash Memory 作为硬盘记录数据——固态硬盘</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151623950.png" alt="img" loading="lazy"></p><h2 id="8-1-固态硬盘（SSD）概述"><a href="#8-1-固态硬盘（SSD）概述" class="headerlink" title="8.1.固态硬盘（SSD）概述"></a>8.1.固态硬盘（SSD）概述</h2><p><strong>固态硬盘（SSD）：它是一种基于闪存技术的存储器，与 U 盘并无本质区别，属于电可擦除 ROM，也即 EEPROM。传统机械硬盘与固态硬盘内部构造如下图所示</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151624494.png" alt="img" loading="lazy"></p><p><strong>SSD 有以下特点</strong>：</p><ul><li><strong>SSD 读写速度较快，随机访问性能高，用电路控制访问位置</strong>（机械硬盘则是通过移动磁臂旋转磁盘控制访问位置）。</li><li><strong>SSD 安静无噪音、耐摔抗震、能耗低、造价更高</strong>。</li><li><strong>SSD 容易出现坏块（读写次数过多可能会导致）。</strong></li></ul><h2 id="8-2-固态硬盘（SSD）组成"><a href="#8-2-固态硬盘（SSD）组成" class="headerlink" title="8.2.固态硬盘（SSD）组成"></a>8.2.固态硬盘（SSD）组成</h2><h3 id="8-2-1-闪存翻译层"><a href="#8-2-1-闪存翻译层" class="headerlink" title="8.2.1.闪存翻译层"></a>8.2.1.闪存翻译层</h3><p><strong>闪存翻译层：主要作用是负责翻译逻辑块号，找到对应页。具体来说，I&#x2F;O 总线会给出系统所要读 &#x2F; 写的逻辑块号，然后闪存翻译层会把逻辑块号映射为对应的物理地址。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151627038.png" loading="lazy"></p><h3 id="8-2-2-存储介质"><a href="#8-2-2-存储介质" class="headerlink" title="8.2.2.存储介质"></a>8.2.2.存储介质</h3><p><strong>存储介质：上面 SSD 构造图中的黑色块状部分为闪存芯片，多个闪存芯片构成 SSD 的闪存芯片组。每个闪存芯片内由多个数据块组成（每个数据块大小为 16KB<del>512KB）、每个数据块又有多个页组成（每个页大小为 512B</del>4KB）。这里特别注意 “逻辑块” 在不同的存储器下有不同的含义：</strong></p><ul><li><strong>如果是磁盘</strong>：逻辑块指的就是磁盘的块或扇区。</li><li><strong>如果是 SSD</strong>：逻辑块指的就是 SSD 的页。</li><li><strong>所以，SSD 的一个页相当于磁盘的一个扇区、SSD 的一个块相当于磁盘的一个磁道。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151627683.png" loading="lazy"></p><h2 id="8-3-固态硬盘（SSD）的读写"><a href="#8-3-固态硬盘（SSD）的读写" class="headerlink" title="8.3.固态硬盘（SSD）的读写"></a>8.3.固态硬盘（SSD）的读写</h2><p><strong>固态硬盘（SSD）的读写：主要由以下特点</strong>：</p><ul><li><strong>以页为单位进行读写</strong>。</li><li><strong>以块为单位进行擦除，擦干净的块，其中的每页都可以写一次，读无限次。</strong></li><li><strong>支持随机访问，也即系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址。</strong></li><li><strong>SSD 读速度要快于写速度，这是因为要写的页如果有数据则需要先将块内其他页全部复制到一个新的块中，再写入新的页</strong>。</li></ul><h2 id="8-4-磨损均衡技术"><a href="#8-4-磨损均衡技术" class="headerlink" title="8.4.磨损均衡技术"></a>8.4.磨损均衡技术</h2><p><strong>磨损均衡技术：由于反复写会导致闪存快磨损，所以引入磨损均衡技术，闪存翻译层有一个平均磨损逻辑试图通过将擦除平均分布在所有块上来最大化每个块的寿命。有如下两种方式</strong>：</p><ul><li><p><strong>动态磨损均衡</strong>：写入数据时，优先选择<strong>累计擦除次数少</strong>的新闪存块。</p></li><li><p><strong>静态磨损均衡</strong>：SSD 监测并自动进行数据分配、迁移。让<strong>老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务。</strong></p></li></ul><h1 id="9-高速缓冲存储器Cache"><a href="#9-高速缓冲存储器Cache" class="headerlink" title="9.高速缓冲存储器Cache"></a>9.高速缓冲存储器Cache</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142146250.png" loading="lazy"></p><p><strong>由于程序的转移概率和数据分布的离散性很大，所以想要仅仅通过提高主存系统的并行性以此来提升存储器带宽的想法是不现实的。因此这就我们必须从系统结构上加以改进，也即采用<a href="#存储器分类">1.1存储器分类</a>中讲到的多级存储体系</strong>。</p><ul><li>Cache - 主存层次。</li><li>主存 - 辅存层次。</li></ul><h2 id="9-1-Cache-基本原理"><a href="#9-1-Cache-基本原理" class="headerlink" title="9.1.Cache 基本原理"></a>9.1.Cache 基本原理</h2><p>以微信为例，当你打开微信时，与微信有关的数据和代码将会被加载进主存，比如文字数据、支付数据、运动数据等等。这些数据很多，涉及各个功能，但有的人使用微信可能只偏好于某些方面（比如视频聊天）。所以在这样的情况下，CPU 在较长时间内使用到的只是微信的部分程序和数据 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142139806.png" alt="image-20230414213910707" loading="lazy"></p><p><strong>所以可以把把这一部分的数据复制一份给 Cache，由于 Cache 的速度和 CPU 十分接近，这样的话 CPU 会直接和 Cache 交流，整机性能会有明显提升</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142139431.png" alt="image-20230414213956332" loading="lazy"></p><h2 id="9-2-程序访问的局部性原理"><a href="#9-2-程序访问的局部性原理" class="headerlink" title="9.2.程序访问的局部性原理"></a>9.2.程序访问的局部性原理</h2><p>如下是一段简单的 C 语言程序：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> M <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>j<span class="token operator">++</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该程序在运行后会被加载进内存，程序的本质就是<strong>指令和数据</strong>，所以这段程序在主存中分布情况可能是下面这样：</p><ul><li><p>假定 M、N 为 2048，按字节编址，int 占用 4 个字节。</p></li><li><p>这个二维数组看似是二维的，实则在主存中是一维的，相当于把第二行接到了第一行的尾巴后面。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142142096.png" alt="image-20230414214251984" loading="lazy"></p></li></ul><p><strong>程序访问的局部性原理包括空间局部性和时间局部性</strong>：</p><p><strong>空间局部性</strong>：<strong>是指最近未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的</strong>。例如上例中形参是一个数组，在一个元素访问完毕之后，下一个元素的物理位置和它其实是相邻的。</p><p><strong>时间局部性</strong>：<strong>是指最近未来要用到的信息，很可能就是现在正在使用的信息</strong>。比如上例中 for 循环内的<code>sum+=a[i][j]</code>，这一条语句明显会被重复使用多次。</p><p><strong>Cache + 局部性原理：可以把 CPU 目前正在访问的元素的邻近数据放到 Cache 中，之后 CPU 的访存操作大多数就会针对 Cache 进行，程序的执行速度的也会得到提升。</strong></p><p>下面是一个空间局部性很差的程序，它只是在上面程序的基础上把 “<strong>一行一行的访问” 变为了 “一列一列的访问</strong>”。之前，访问完<code>a[0][0]</code>，下一个访问的就是<code>a[0][1]</code>，而现在下一个却变成了<code>a[1][0]</code>了。因为每次访问都要跳过 2048 个数组元素，也就是 8192 字节，假如主存与 Cache 的交换单位较小，<strong>那么每访问一个数组元素都需要装入一个主存块到 Cache 中</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j <span class="token operator">&lt;</span> M<span class="token punctuation">;</span>j<span class="token operator">++</span>sum<span class="token operator">+=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-3-主存块"><a href="#9-3-主存块" class="headerlink" title="9.3.主存块"></a>9.3.主存块</h2><p><strong>主存块：这是主存与 Cache 之间交换数据的最小单位。也即将主存的存储空间分块，比如每 1KB 为一块，主存与 Cache 之间就会以块为单位进行数据交换。</strong></p><p>例如下图数组，对于<code>a[0][0]</code>我们先判断它属于哪一块，确定好之后再将它所在的块复制到 Cache 中去。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142144189.png" alt="image-20230414214417102" loading="lazy"></p><p><strong>假设主存大小为 4M，每 1KB 为一块，由于 4M&#x3D;4096KB，因此会被分为 4096 块，然后对其编号（0-4095）</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142145548.png" alt="image-20230414214502471" loading="lazy"></p><p>**由于 $2^{22}&#x3D;4 194 $，所以这些地址至少需要 22 位才能全部表示，我们将 22 位地址拆分为两个部分，前 12 位表示块号（ $ 2^{12}&#x3D;4096 $），后 10 位表示块内地址（ $ 2^{10}&#x3D;1024 $)**。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142145283.png" alt="image-20230414214539186" loading="lazy"></p><h2 id="9-4-命中率和缺失率"><a href="#9-4-命中率和缺失率" class="headerlink" title="9.4.命中率和缺失率"></a>9.4.命中率和缺失率</h2><p><strong>命中率 $H$： CPU 欲访问的信息已经在 Cache 中的比率</strong>。</p><p><strong>缺失率： CPU 欲访问的信息未经在 Cache 中的比率，为 $1-H$。</strong></p><ul><li><p>假设某程序执行期间，Cache 的的总命中次数为 $ N_{c} $，访问主存的总次数为 $ N_{M} $，<strong>那么 $H$&#x3D; $ \frac{N_{c}}{N_{c}+N{m}} $。​​</strong></p></li><li><p><strong>命中率 $H$ 越接近 1 越好</strong>。</p></li><li><p>设 $ t_{c} $为命中时的 Cache 访问时间， $ t_{m} $为未命中时的访问时间, 则 <strong>Cache - 主存系统的平均访问时间 $ T_{a}&#x3D;Ht_{c}+(1-H)t_{m} $。​</strong></p></li></ul><h1 id="10-Cache和主存的映射方式"><a href="#10-Cache和主存的映射方式" class="headerlink" title="10.Cache和主存的映射方式"></a><a name="10.Cache和主存的映射方式">10.Cache和主存的映射方式</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142201730.png" alt="image-20230414220104642" loading="lazy"></p><p>前面说过，Cache 中保存的实际是主存中的数据副本，所以这里就会涉及一个很重要的问题：<strong>主存内容和 Cache 中的内容是如何对应，也即是如何映射的？</strong> 地址映射的方法有以下三种：</p><ul><li><strong>全相联映射</strong>：主存块可以放在 Cache 的<strong>任何位置</strong>。</li><li><strong>直接映射</strong>：每个主存块<strong>只能放到一个特定的位置</strong>，由<strong>主存块号 %Cache 总块数</strong>来确定。</li><li><strong>组相联映射</strong>：将 Cache 块分为<strong>若干组</strong>，每个主存块可以放到<strong>特定分组中的任意一个位置</strong>，其中<strong>组号 &#x3D; 主存块号 % 分组数。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142149568.png" alt="image-20230414214921473" loading="lazy"></p><p>把主存块放到 Cache 中后：</p><ul><li><p><strong>要给每个 Cache 块增加一个 “标记位”</strong>，记录<strong>对应的主存块号</strong>。</p></li><li><p><strong>再给每个 Cache 块增加一个 “有效位”</strong>，用于<strong>控制其是否生效</strong>，以免产生冲突 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142150662.png" alt="image-20230414215019584" loading="lazy"></p></li></ul><p><strong>分块后需要对主存进行编号，假设某个计算机的主存地址空间大小为 256MB，按字节编址，Cache 有 8 个 Cache 行（也即 Cache 块），行长（也即块大小）为 64B。</strong></p><ul><li><strong>主存块号编号</strong>：块大小为 $64B&#x3D;2^6B$、主存大小为 $256MB&#x3D;2^28B$，那么就有 $2^{28}&#x2F;2^6$ 个主存块，所以主存编号为从 0 到 $2^{22}-1$。</li><li><strong>块内地址</strong>：这 22 位是用于区分主存块的，所以剩下的 28-22&#x3D;6 位则为每个主存块的地址范围（或空间）。也即先利用高 22 位确定是哪一块，然后在该块中用低 6 位确定地址。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142153801.png" alt="image-20230414215317711" loading="lazy"></p><h2 id="10-1-全相联映射"><a href="#10-1-全相联映射" class="headerlink" title="10.1.全相联映射"></a>10.1.全相联映射</h2><h3 id="10-1-1-如何映射"><a href="#10-1-1-如何映射" class="headerlink" title="10.1.1.如何映射"></a>10.1.1.如何映射</h3><p><strong>全相联映射：主存块可以放在 Cache 的任何位置。</strong></p><p>例如下图中的 0 号主存块，它就可以放置到 Cache 的 3 号位置，每行的标记号用于指出该行取自主存的哪一块，同时将对应的有效位置为 1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142153856.png" alt="image-20230414215356771" loading="lazy"></p><h3 id="10-1-2-如何访存"><a href="#10-1-2-如何访存" class="headerlink" title="10.1.2.如何访存"></a>10.1.2.如何访存</h3><p><strong>以上图紫色主存块为例，其地址为 1…1101001110，在全相联映射下，CPU 访存时首先会取该地址的前 22 位，也即主存块号，来和 Cache 中每一行的标记进行对比</strong>。</p><ul><li><strong>若标记号 &#x3D; 块号且有效位为 1</strong>：说明 <strong>Cache 命中</strong>，也就是说此时访问的数据在 Cache 中是有副本的，接着<strong>只需在 Cache 中访问后 6 位地址所定位的单元</strong>即可。</li><li><strong>若标记号不匹配或匹配但有效位为 0</strong>：此时说明 <strong>Cache 未命中</strong>，则正常访问主存，也即要从主存中取数据。</li></ul><h2 id="10-2-直接映射"><a href="#10-2-直接映射" class="headerlink" title="10.2.直接映射"></a>10.2.直接映射</h2><h3 id="10-2-1-如何映射"><a href="#10-2-1-如何映射" class="headerlink" title="10.2.1.如何映射"></a>10.2.1.如何映射</h3><p><strong>直接映射：每个主存块只能放到一个特定的位置，由主存块号 %Cache 总块数来确定</strong>。</p><p>例如下图中的 0 号主存块，由于 0%8&#x3D;0，因此它<strong>只能放到 Cache 的 0 号位置</strong>；对于 8 号主存块，由于 8%8&#x3D;0，所以它也要放到 0 号位置，<strong>而且需要把之前的 0 号主存块给腾空</strong>，相应的标记位也要修改 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142155753.png" alt="image-20230414215559659" loading="lazy"></p><p><strong>“%” 运算具有一些特性，这里 Cache 块数 &#x3D; 8&#x3D;$2^3$，其指数部分为 3，这意味着主存块号中的后 3 位直接反映了该主存块在 Cache 中的位置。例如上图中的 0 号和 8 号，其主存块号的后三位均为 000，这正好对应了它们在 Cache 的第 0 行</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142157753.png" alt="image-20230414215737664" loading="lazy">  </p><p><strong>因此标记可以直接取主存块号的前 19 位，相应地址形式会变化为下面这样</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142158500.png" alt="image-20230414215838387" loading="lazy"></p><h3 id="10-2-2-如何访存"><a href="#10-2-2-如何访存" class="headerlink" title="10.2.2.如何访存"></a>10.2.2.如何访存</h3><p><strong>以上图橙色主存块为例，其地址为 0…01000001110。在直接映射下，CPU 访存时首先会根据主存块号的后三位确定 Cache 行（而不用挨个比较），接着会判断前 19 位和标记号是否匹配并同时判断有效位是否为 1</strong>。</p><h2 id="10-3-组相联映射"><a href="#10-3-组相联映射" class="headerlink" title="10.3.组相联映射"></a>10.3.组相联映射</h2><h3 id="10-3-1-如何映射"><a href="#10-3-1-如何映射" class="headerlink" title="10.3.1.如何映射"></a>10.3.1.如何映射</h3><p><strong>组相联映射：将 Cache 块分为若干组，每个主存块可以放到特定分组中的任意一个位置，其中组号 &#x3D; 主存块号 % 分组数。</strong></p><p>以 2 路组相联为例（2 块为一组，分为四组）。对于下图中 1 号主存块，由于 1%4&#x3D;1，因此它会被放入<strong>第一组的任意位置</strong>；对于 222-3 号主存块也会放入第一组，它会放到该组另一个空闲位置 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142159993.png" alt="image-20230414215932900" loading="lazy"></p><p><strong>和直接映射一样，由于 “%” 的运算特性，这里分组数 &#x3D; 4&#x3D;22，这意味着主存块号中的后 2 位反映了该主存块在哪一个组。所以标记号只需取前 20 位，相应地址形式会变化为下面这样</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304142200971.png" alt="image-20230414220008881" loading="lazy"></p><h3 id="10-3-2-如何访存"><a href="#10-3-2-如何访存" class="headerlink" title="10.3.2.如何访存"></a>10.3.2.如何访存</h3><p><strong>以上图橙色主存块为例，其地址为 1…0100001110。在组相联映射下，CPU 访存时首先会根据主存块号的后两位确定所属分组号，接着会判断主存块号的前 20 位与分组内的某个标记号是否匹配同时判断有效位是否为 1</strong>。</p><h2 id="10-4-三种方式各自优缺点"><a href="#10-4-三种方式各自优缺点" class="headerlink" title="10.4.三种方式各自优缺点"></a>10.4.三种方式各自优缺点</h2><p><strong>全相联映射</strong>：</p><ul><li><strong>优点</strong>：Cache 存储空间利用充分，命中率高。</li><li><strong>缺点</strong>：查找慢，有时可能要比对所有行的标记。</li></ul><p><strong>直接映射</strong>：</p><ul><li><strong>优点</strong>：对于任意一个位置，只需对比一个标记，速度最快。</li><li><strong>缺点</strong>：缺点就是 Cache 存储空间利用不充分，命中率低。</li></ul><p><strong>组相联映射</strong>：<strong>综合效果较好。</strong></p><h1 id="11-Cache替换算法"><a href="#11-Cache替换算法" class="headerlink" title="11.Cache替换算法"></a><a name="11.Cache替换算法">11.Cache替换算法</a></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151527611.png" alt="image-20230415152732490" loading="lazy"></p><p>在<a href="#10.Cache和主存的映射方式"><strong>10.Cache和主存的映射方式</strong></a>中我们讲到了 Cache 和主存之间的映射关系，细致分析了三种映射方式各自的特点。那么下一个亟待解决的问题就是：<strong>Cache 是很小的，主存却很大，如果 Cache 满了应该怎么办？</strong> 这就是本节的主题——<strong>Cache 的替换算法</strong>。当然，不同的映射方式其替换机制也会有所不同。</p><ul><li><strong>全相联映射：Cache 完全满了才需要替换，需要在全局中选择替换哪一块</strong>。</li><li><strong>直接映射：如果对应位置为空则直接替换，无需考虑替换算法。</strong></li><li><strong>组相联映射：分组内满了才需要替换，需要在分组内选择替换哪一块。</strong></li></ul><p><strong>本节以全相联映射为例，介绍以下四种替换算法</strong>：</p><ul><li><strong>随机算法（RAND）</strong>。</li><li><strong>先进先出算法（FIFO）。</strong></li><li><strong>近期最少使用算法（LRU）。</strong></li><li><strong>最不频繁使用算法（LFU）</strong>。</li></ul><p><strong>在讲解之前大家一定明白一点，CPU 每访问一个内存块，都会立即把该内存块调入 Cache 中</strong>。</p><h2 id="11-1-随机算法（RAND）"><a href="#11-1-随机算法（RAND）" class="headerlink" title="11.1.随机算法（RAND）"></a>11.1.随机算法（RAND）</h2><p><strong>随机算法（RAND）：若 Cache 已满，则随机选择一块进行替换。</strong></p><ul><li><strong>通过以下叙述可知：随机算法十分简单，但是它完全没有考虑到局部性原理，命中率很低，实际效果很不稳定。</strong></li></ul><p>如下有 4 个 Cache 块，初始状态下 4 个 Cache 块均为空，采用<strong>全相连映射</strong>，CPU 访问主存块的顺序为：{1,2,3,4,1,2,5,1,2,3,4,5}，CPU <strong>每访问一个内存块，都会立即把该内存块调入 Cache 中</strong>，前四次调入时由于都有空闲 Cahce 块，所以不会发生替换。</p><table><thead><tr><th >访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr></thead><tbody><tr><td><strong>Cache #0</strong></td><td bgcolor="red">1</td><td>1</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>Cache #1</strong></td><td></td><td bgcolor="red">2</td><td>2</td><td>2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>Cache #2</strong></td><td></td><td></td><td bgcolor="red">3</td><td>3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>Cache #3</strong></td><td></td><td></td><td></td><td bgcolor="red">4</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>是否命中？</strong></td><td>否</td><td>否</td><td>否</td><td>否</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>是否替换？</strong></td><td>否</td><td>否</td><td>否</td><td>否</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>继续访存，{1,2,3,4,<strong>1,2</strong>,5,1,2,3,4,5}。由于 1,2 主存块已经被调入了 Cache，所以<strong>直接命中。</strong></p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。对于 5 号主存块，它并没有调入 Cache 中，因此需要立即被调入，<strong>但此时已经没有空闲 Cache 块了，所以需要使用替换算法选择一块换出，然后再把 5 号主存块调入。这里采用的是随机算法，所以我们可以任意挑选一块调入，比如把 3 号主存块给替换出去</strong>。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,<strong>1,2</strong>,3,4,5}。直接命中。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。和上面一样，随机挑选一块换出。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。和上面一样，随机挑选一块换出。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">4</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>访存结束，{1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。直接命中。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>    </tr>  </tbody></table><h2 id="11-2-先进先出算法（FIFO）"><a href="#11-2-先进先出算法（FIFO）" class="headerlink" title="11.2.先进先出算法（FIFO）"></a>11.2.先进先出算法（FIFO）</h2><p><strong>先进先出算法（FIFO）：若 Cache 已满，则替换最先被调入 Cache 的块</strong>。</p><ul><li><strong>通过以下叙述可知：先进先出算法实现也很简单，但该算法依然没有考虑到局部性原理，因为最先被调入的 Cache 块也有可能是会频繁访问到的。而且此算法容易产生抖动现象（—刚换上去的块又立马被换下）。</strong></li></ul><p>仍然采用之前的例子，直接进行到这一步。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。对于 5 号主存块，它并没有调入 Cache 中，因此需要立即被调入，但此时已经没有空闲 Cache 块了，所以需要使用替换算法选择一块换出，然后再把 5 号主存块调入。<strong>这里采用的是 FIFO 算法，根据先进先出原则，最先被调入 Cache 的最先被替换，因此 1 号被替换</strong>。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,<strong>1</strong>,2,3,4,5}。此时应该替换 2 号。</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td bgcolor="red">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>后续步骤不再详细演示，最终结束状态如下：</p><table>  <thead>    <tr>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>    </tr>    <tr>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>是</td>      <td>是</td>        <td>是</font></td>      <td>是</td>      <td></td>    </tr>  </tbody></table><h2 id="11-3-近期最少使用算法（LRU）——效率最高"><a href="#11-3-近期最少使用算法（LRU）——效率最高" class="headerlink" title="11.3.近期最少使用算法（LRU）——效率最高"></a>11.3.近期最少使用算法（LRU）——效率最高</h2><p><strong>近期最少使用算法（LRU）：该算法会为每一个 Cache 块设置一个计数器，用于记录每个 Cache 块究竟有多长时间没有被访问了。在替换时直接选取计数器最大的替换即可。</strong></p><ul><li><strong>通过以下叙述可知：LRU 算法是基于局部性原理的，近期访问过的主存块，在不久的将来很有可能会被再次访问到，因此这种淘汰机制是合理的。LRU 算法的实际运行效果也很优秀，Cache 命中率也高</strong>。</li></ul><p><strong>计数器的变化规则如下</strong>：</p><ul><li><strong>命中时：所命中的块的计数器清零，计数器比其低的块的计数器 + 1，其余不变</strong>。</li><li><strong>未命中且还有空闲块时：新装入的块的计数器置为 0，其余非空闲块的计数器全 + 1。</strong></li><li><strong>未命中且没有空闲块时：计数器最大的块被淘汰，新装入块的计数器置为 0，其余块的计数器 + 1。</strong></li></ul><p>如下表格表示初始状态：</p><table><thead><tr><th>计时器</th><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr></thead><tbody><tr><td>0</td><td><strong>Cache #0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #2</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #3</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否命中？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否替换？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>继续访存，{<strong>1</strong>,2,3,4,1,2,5,1,2,3,4,5}。由于 1 装入了第一个 Cache 块，属于<strong>未命中且还有空闲块</strong>，因此该块计数器置为 0，其余非空闲块计数器全 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,<strong>2</strong>,3,4,1,2,5,1,2,3,4,5}。情况同上。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>第三、四个主存块亦是如此。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>3</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,<strong>1</strong>,2,5,1,2,3,4,5}。<strong>此时 Cache 命中，因此需要将所命中块的计数器清零，比其低的块的计数器 + 1，其余不变。</strong></p><ul><li>这一点其实就体现了 LRU 算法的核心，它能保证最近访问的块的计数器一定很低。</li></ul><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,<strong>2</strong>,5,1,2,3,4,5}，情况同上。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。此时属于 <strong>“未命中且没有空闲行”，所以计数器最大的块会被淘汰（淘汰 3 号主存块），新装入块的计数器置为 0，其余块计数器全 + 1。</strong></p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,<strong>1</strong>,2,3,4,5}。直接命中。</p><ul><li><strong>注意</strong>：只需要将 “比该块计数器值小的块的计数器 + 1” 即可，大的不变，因此上面表格中的 3 号 Cache 的计时器就不用动了，这里很容易犯错。</li></ul><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>4</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,1,<strong>2</strong>,3,4,5}。直接命中。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>5</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，{1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。未命中，且没有空行。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。未命中，且没有空行。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>3</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">4</td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。未命中，且没有空行。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="red">5</td>      <td></td>    </tr>    <tr>      <td>3</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>是</td>      <td></td>    </tr>  </tbody></table><h2 id="11-4-最不经常使用算法（LFU）"><a href="#11-4-最不经常使用算法（LFU）" class="headerlink" title="11.4.最不经常使用算法（LFU）"></a>11.4.最不经常使用算法（LFU）</h2><p><strong>最不经常使用算法（LFU）：该算法会为每一个 Cache 块设置一个计数器，用于记录每个 Cache 块被访问过几次。在替换时直接选取计数器最小的替换即可。</strong></p><ul><li><strong>通过以下叙述可知：LFU 算法并没有很好地遵循局部性原理，比如微信聊天相关的块，在某个时间段内使用率会很高，但是一段时间后使用率会很低，并不科学。</strong></li></ul><p><strong>计数器的变化规则为：</strong></p><ul><li><strong>新调入的块计数器为 0，之后每访问一次计数器就 + 1。需要替换时，选择计数器最小的一行替换。</strong></li><li><strong>若有多个计数器最小的行，可以按照行号递增或 FIFO 策略进行选择。</strong></li></ul><table><thead><tr><th>计时器</th><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr></thead><tbody><tr><td>0</td><td><strong>Cache #0</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #1</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #2</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td><strong>Cache #3</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否命中？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td><strong>是否替换？</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>继续访存，也即 {<strong>1,2,3,4</strong>,1,2,5,1,2,3,4,5}。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>0</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,**1,2,**5,1,2,3,4,5}。发生命中，计数器 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,<strong>5</strong>,1,2,3,4,5}。<strong>选择计数器最小的那一行，但是这里有两行相同（都是 0），所以再按照 FIFO 策略选择 3 号主存块淘汰。</strong></p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,<strong>1,2</strong>,3,4,5}。1,2 命中，计数器 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td></td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,<strong>3</strong>,4,5}。需要进行替换，<strong>这里我们再采用行号递增的规则淘汰 5 号主存块。</strong></p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">3</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,<strong>4</strong>,5}。命中，计时器 + 1。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td></td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">3</td>      <td>3</td>      <td></td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="green">4</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td></td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td></td>      <td></td>    </tr>  </tbody></table><p>继续访存，也即 {1,2,3,4,1,2,5,1,2,3,4,<strong>5</strong>}。需要替换，只剩一个最小的了，替换 3 号主存块即可。</p><table>  <thead>    <tr>      <th>计时器</th>      <th>访问主存块</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>1</th>      <th>2</th>      <th>5</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>      <th>5</th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <td>2</td>      <td>        <strong>Cache #0</strong></td>      <td bgcolor="red">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td bgcolor="green">1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td></td>    </tr>    <tr>      <td>2</td>      <td>        <strong>Cache #1</strong></td>      <td></td>      <td bgcolor="red">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td bgcolor="green">2</td>      <td>2</td>      <td>2</td>      <td>2</td>      <td></td>    </tr>    <tr>      <td>0</td>      <td>        <strong>Cache #2</strong></td>      <td></td>      <td></td>      <td bgcolor="red">3</td>      <td>3</td>      <td>3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td>5</td>      <td>5</td>      <td bgcolor="red">3</td>      <td>3</td>      <td bgcolor="red">5</td>      <td></td>    </tr>    <tr>      <td>1</td>      <td>        <strong>Cache #3</strong></td>      <td></td>      <td></td>      <td></td>      <td bgcolor="red">4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td>4</td>      <td bgcolor="green">4</td>      <td>4</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否命中？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td></td>    </tr>    <tr>      <td></td>      <td>        <strong>是否替换？</strong></td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>否</td>      <td>是</td>      <td>否</td>      <td>是</td>      <td></td>    </tr>  </tbody></table><h1 id="12-Cache的写策略"><a href="#12-Cache的写策略" class="headerlink" title="12.Cache的写策略"></a>12.Cache的写策略</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151543520.png" alt="image-20230415154310416" loading="lazy"></p><p>在<a href="https://blog.csdn.net/qq_39183034/article/details/119967515?spm=1001.2014.3001.5501"><a href="#10.Cache和主存的映射方式">10.Cache和主存的映射方式</a></a>和<a href="https://blog.csdn.net/qq_39183034/article/details/120016603?spm=1001.2014.3001.5501"><a href="#11.Cache替换算法">11.Cache替换算法</a></a>这两篇文章中分别探讨了主存、Cache 之间的映射关系以及 Cache 的替换算法。关于 Cache，最后需要解决的一个问题就是：<strong>如何保持 Cache 与数据母体的一致性</strong>？因为我们知道，Cache 中保存的只是<strong>主存数据的副本</strong>，一旦对 Cache 进行写操作就一定会导致两部分数据出现不一致，而对于读操作则不关心。这就是 Cache 写策略所要探讨的问题。</p><p><strong>Cache 写策略分写命中和写不命中两种情况</strong>：</p><ul><li><strong>写命中</strong>：有全写法和写回法。</li><li><strong>写不命中</strong>：有写分配法和非写分配法两种。</li></ul><h2 id="12-1-写命中"><a href="#12-1-写命中" class="headerlink" title="12.1.写命中"></a>12.1.写命中</h2><p><strong>写命中：写命中时主存块被调入 Cache 中，也即要被修改的单元在 Cache 中。此时有两种方法</strong>：</p><ul><li>写回法。</li><li>全写法。</li></ul><h2 id="12-1-1-写回法-write-back"><a href="#12-1-1-写回法-write-back" class="headerlink" title="12.1.1.写回法 (write-back)"></a>12.1.1.写回法 (write-back)</h2><p><strong>写回法 (write-back)：是指当 CPU 写命中时，只修改 Cache 中的内容，而不立即写入主存，只有当此块被换出时才写回主存。如下图，绿色主存块写命中，修改时只在 Cache 上修改，而不立即写入主存，只有当绿色块被替换时才会写回主存</strong>。</p><ul><li><strong>优点</strong>：减少了访存次数。</li><li><strong>缺点</strong>：存在数据不一致的隐患。</li></ul><p><strong>这种方法需要判断 Cache 是否被修改过，因此在对应 Cache 块还会增加一个 “脏位”，用于标识是否修改过，如果对应位为 1 表示修改过，那么在被替换时该 Cache 块中的内容会被写回至标记位所定位的主存块上</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151537514.png" alt="image-20230415153708377" loading="lazy"></p><h2 id="12-1-2-全写法-write-through"><a href="#12-1-2-全写法-write-through" class="headerlink" title="12.1.2.全写法 (write-through)"></a>12.1.2.全写法 (write-through)</h2><p><strong>全写法 (write-through)：是指当 CPU 写命中时，必须把数据同时写入 Cache 和主存。当某一块需要替换时，不必把这一块写回主存，新调入的块直接覆盖即可</strong>。</p><ul><li><strong>优点</strong>：实现简单，更能保持数据的一致性。</li><li><strong>缺点</strong>：增加了访存次数，降低了 Cache 的效率。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151538715.png" alt="image-20230415153819596" loading="lazy"></p><p><strong>为了减少全写法直接写入主存时所产生时间损耗，通常会在 Cache 和主存之间加入写缓冲（Write Buffer）。CPU 同时写数据到 Cache 和写缓冲中，写缓冲再控制将内容写入主存，写缓冲是一个 FIFO 队列，可以解决速度不匹配的问题。</strong></p><ul><li><p>注意频繁写会导致缓冲区溢出 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151631121.png" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151539724.png" alt="image-20230415153919610" loading="lazy"></p></li></ul><h2 id="12-2-写不命中"><a href="#12-2-写不命中" class="headerlink" title="12.2.写不命中"></a>12.2.写不命中</h2><p><strong>写不命中：写不命中时被修改的单元不在 Cache 中。此时有两种方法</strong>：</p><ul><li>写分配法。</li><li>非写分配法。</li></ul><h3 id="12-2-1-写分配法-write-allocate"><a href="#12-2-1-写分配法-write-allocate" class="headerlink" title="12.2.1.写分配法 (write-allocate)"></a>12.2.1.写分配法 (write-allocate)</h3><p><strong>写分配法：是指当写不命中时，会把主存的块加载到 Cache 中，然后更新此 Cache 块，通常会结合写回法使用。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151540924.png" alt="image-20230415154008820" loading="lazy"></p><h3 id="12-2-2-非写分配法（not-write-allocate）"><a href="#12-2-2-非写分配法（not-write-allocate）" class="headerlink" title="12.2.2.非写分配法（not-write-allocate）"></a>12.2.2.非写分配法（not-write-allocate）</h3><p><strong>非写分配法：是指当写不命中时，CPU 直接对主存的块进行修改，而不调入 Cache 中（注意只有读操作才将主存块调入 Cache 中），通常会结合全写法使用</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151541097.png" alt="image-20230415154128984" loading="lazy"></p><h1 id="13-多级-Cache"><a href="#13-多级-Cache" class="headerlink" title="13.多级 Cache"></a>13.多级 Cache</h1><p>现代计算机的 Cache 一般是多级的（通常三级）。对于三级 Cache，<strong>按离 CPU 的远近可命名为 L1 Cache、 L2 Cache、 L3Cache，离 CPU 越远，访问速度就越慢，容量也越大，反之相反。</strong> 其中指令 Cache 与数据 Cache 分离一般在 L1 级，此时通常<strong>为写分配法和写回法</strong>合用。</p><p>下图是一个含有两级的 Cache 系统，<strong>L1 对 L2 使用全写法，L2 对主存使用写回法</strong>，由于 L2 的存在，其访问速度远大于主存，因此避免了因频繁写时导致的缓冲区溢出 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151541752.png" loading="lazy"></p><p>如下图是资源管理器中显示的 Cache 信息。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151542250.png" alt="image-20230415154239158" loading="lazy"></p><h1 id="14-虚拟存储器"><a href="#14-虚拟存储器" class="headerlink" title="14.虚拟存储器"></a>14.虚拟存储器</h1><h2 id="14-1-页式存储器"><a href="#14-1-页式存储器" class="headerlink" title="14.1.页式存储器"></a>14.1.页式存储器</h2><p>前面说过主存和 Cache 之间是以块作为数据的传输单位的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151551467.png" alt="image-20230415155133378" loading="lazy"></p><p>我们知道，应用程序运行时需要加载进主存。比如说微信，假如它有 1GB 大小，那么想要在主存中找到连续的 1GB 空间是很困难的，并且就算加载进去了，也会极大的破坏主存的利用率，产生很多碎片。</p><p><strong>因此为了提高主存利用率，可以将程序（所谓程序就是数据、指令的集合体）分为一个个大小相同的 “页”，每个页面的大小和“物理块” 的大小是相同的。给每个页面编号后，就可以分散在主存中</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151552958.png" alt="image-20230415155241848" loading="lazy">  </p><p>所以页式存储系统是这样的：<strong>一个程序（操作系统中称为进程)在逻辑上被分为若干大小相同的 “页面”，“页面” 大小与 “块” 大小相同，每个页面可以离散地放入不同的主存块</strong>。</p><ul><li>页面的划分属于逻辑角度，主存和 Cache 块的划分属于物理角度。</li></ul><h2 id="14-2-逻辑地址和物理地址"><a href="#14-2-逻辑地址和物理地址" class="headerlink" title="14.2.逻辑地址和物理地址"></a>14.2.逻辑地址和物理地址</h2><ul><li><strong>逻辑地址</strong>：程序员视角中看到的地址。</li><li><strong>物理地址</strong>：数据在主存中真实的地址。</li></ul><p>我们编写程序时，所操作的数据其显示的地址均为虚拟地址，真实的地址需要操作系统进行映射。那么为什么需要虚拟地址呢？</p><p>早期的计算机启动进程时，会将进程或程序所包含的东西全部加载进内存，而且访问的就是真实的物理内存。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151556888.png" loading="lazy"></p><p><strong>但是这种粗暴的操作有很大弊端</strong>，比如说经典的<strong>野指针</strong>问题在这种情况下就很容易产生，而且进程在运行中会产生大量数据，这些数据一旦不能连续存放，就会另外开辟空间，这无疑增加了异常访问的情况。</p><p>所以计算机设计者意识到了这种模式缺陷，想到了一种方法：增加一个中间层，利用中间层映射物理内存。程序访问内存时不直接访问物理内存，先访问中间层，如果中间层访问没有问题，那么操作系统就会将中间层映射到物理层，完成正常执行。</p><p><strong>一个进程创建之后，操作系统会为这个进程分配一个专属于它的大小为 4GB 的虚拟进程地址空间（4GB 是因为 32 位系统中，指针是 4 个字节），与它相对的是一片真实的物理地址空间，操作系统在映射虚拟内存时只会映射到那一片物理空间，而且需要特别注意这个虚拟空间并不是真的有 4GB，它只是虚拟的 。由于每一个进程都有自己的虚拟的进程地址空间，所以它只能访问自己的进程的数据，这样做实现了隔离，也就是进程之间的相互独立。并且把虚拟地址空间划分为这样、那样的区，也能实现数据的连续存放。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151557336.png" loading="lazy"></p><p>操作系统负责分页操作，该过程对程序员是不可见的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151604882.png" alt="image-20230415160453779" loading="lazy"></p><p>站在程序员的视角上，对于一个打包好的 4KB 程序，<strong>我们肯定是知道它的大小的，由于 4KB&#x3D;$ 2^{12}B $，因此可以编址，其范围为：000000000000~111111111111</strong>  。<br><strong>假设该程序中有一个变量 $x$ 的逻辑地址为：001000000011，另外一个变量 y 的逻辑地址为：110000001010</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151605640.png" loading="lazy"></p><p>在学习第一章时，我们知道取变量 $x$ 到 $ ACC $ 寄存器的操作对应的机器指令是：**000001 001000000011，分别对应操作码和地址码（逻辑地址)**，我们指明的仅仅是一个相对的地址，并不是说 $x$ 的地址真的就在那里。</p><p><strong>每个页的大小是 1KB。也就是 $2  ^{10} $B，因此可以将变量 $x$ 的逻辑地址分为两个部分：一个表示页号，一个表示页内地址，其中页内地址的大小取决于每个页面的大小，如果是 1KB，那么就需要 10 个比特位</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151605544.png" loading="lazy"></p><p>因此 $x$ 的逻辑地址：001000000011 就表示它在第 0 页，<strong>而 $x$ 的真实的物理地址可以用该页所在的主存的块号（12 位）+ 页内地址表示</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151606954.png" alt="image-20230415160639824" loading="lazy"></p><ul><li>此例中，第 0 页放在了主存的第 2 块，因此 $x$ 的真实地址为：0000000000101000000011。</li></ul><h2 id="14-3-页表和地址变换过程"><a href="#14-3-页表和地址变换过程" class="headerlink" title="14.3.页表和地址变换过程"></a>14.3.页表和地址变换过程</h2><h3 id="14-3-1-页表"><a href="#14-3-1-页表" class="headerlink" title="14.3.1.页表"></a>14.3.1.页表</h3><p>所以我们见到的地址均为虚拟的地址，给出逻辑地址后，操作系统必须将其转化为真实的物理地址再进行访存，<strong>其中最基本的一个操作就是把页号映射为块号</strong>，所以为了记录这样的映射关系，操作系统会建立一张页表 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151607454.png" alt="image-20230415160728373" loading="lazy"></p><p><strong>值得注意的是，页表中存放的数据是保存在主存中的，因此进行地址转换时还要要进行访存操作</strong>。</p><p>地址的变化过程大致如下：</p><ul><li><strong>拆分逻辑地址为页号和页内地址</strong>。</li><li><strong>CPU 中的页表基址寄存器指明了页表在主存中的存放位置</strong>（以地址为 1058 为例，就表示当前运行的程序其所对应的页表是从 1058 后的存储单元开始存储的，由于每个页表项的大小相同，所以只需顺次读取即可）。</li><li><strong>查询页表找到逻辑页面对应的主存块。</strong></li><li><strong>块号 + 页内地址 &#x3D; 物理地址</strong>。</li><li><strong>进行访存操作</strong>（Cache 未命中时进入主存）。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151609908.png" alt="image-20230415160914781" loading="lazy"></p><h3 id="14-3-2-快表"><a href="#14-3-2-快表" class="headerlink" title="14.3.2.快表"></a>14.3.2.快表</h3><p><strong>依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项放在一个高速缓冲器中，称之为页表（TLB）中，则明显可以提高效率，相应地把放在主存中的页表称为慢表（Page）。</strong></p><p><strong>相应地在进行地址转换时，首先查快表，若命中，则无需访问主存中的页表；否则查询主存中完整的页表，查询之后为了以后便于访问将其加入到快表中</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151610663.png" alt="image-20230415161038540" loading="lazy">  </p><p>结合之前的 Cache，整个访存操作可以是如下流程 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151612532.png" alt="image-20230415161248408" loading="lazy"></p><h2 id="14-4-页式虚拟存储器"><a href="#14-4-页式虚拟存储器" class="headerlink" title="14.4.页式虚拟存储器"></a>14.4.页式虚拟存储器</h2><p>我们知道，运行一个程序时，需要将该程序调入主存，然后根据局部性原理，主存中的部分相关数据会调入 Cache 以提高性能。那么现在的问题是，<strong>一个程序调入主存时需要全部调入吗，还是只需要调入一部分就可以了呢？答案是部分即可</strong>。这一点大家可以联系我们日常使用的手机就能明白，手机内存有限，但是可以同时运行多个大体积程序。<strong>这就是虚拟存储系统：实际物理内存很有限，但是运行时似乎很大很大</strong>。</p><ul><li>Tips：游戏开局（比如英雄联盟）前面，会有一段加载资源的过程，也就是 “loading”，其实其中绝大部分的工作就是将相关数据从辅存调入主存。</li></ul><p>这一点其实与前面讲过的主存和 Cache 之间的关系比较相似，<strong>操作系统仍然会将程序分页，程序加载进主存时，会加载一部分，也就是说有的页已经加载进了主存，有的页还留在辅存中</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151614663.png" alt="image-20230415161451555" loading="lazy"></p><p>有分页自然也有负责映射的页表，只不过这里的页表和前面所讲的页表稍有不同，除了完成最基本的映射工作外，这里的页表还会增加以下选项：</p><ul><li><strong>有效位</strong>：该有效位如果为 1 表示该页已经被加载进了主存，如果为 0 表示仍然留在辅存中。</li><li><strong>外存块号</strong>：为了方便以后快速找到需要加载的页的位置，所以也会将辅存进行分块，并且记录其块号。这样以后程序在运行时，如果需要该数据就会能快速找到并加载进主存。</li><li><strong>访问位</strong>：前面说过 Cache 被填满后就要执行 Cache 替换算法。而访问位涉及到的就是<strong>页面置换算法</strong>，主存相较于辅存很小，注定只能保存一部分辅存的副本，所以主存很容易会被填满，当其填满时就要进行替换。访问位可以记录最近一段时间内，该页被访问了多少次，因此淘汰页面时可以优先淘汰次数最少的页面。</li><li><strong>脏位</strong>：如果脏位为 1 表示进行了更改，如果淘汰页面时则需要写回主存。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151615172.png" alt="image-20230415161547083" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151616896.png" loading="lazy">  </p><p>置于主存和辅存更详细的过程就需要在操作系统这么课中深究了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151617181.png" alt="image-20230415161744067" loading="lazy"></p><h2 id="14-5-段式虚拟存储器"><a href="#14-5-段式虚拟存储器" class="headerlink" title="14.5.段式虚拟存储器"></a>14.5.段式虚拟存储器</h2><p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两个部分：<strong>段号和段内地址</strong>。虚拟地址到实地址之间的变换是由段表实现的。段表是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变所以段表中要给出各段的起始地址和段的长度。</p><p>CPU 根据虚拟地址访存时，首先根据段号与该段基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存。已调入主存时，从段表读出该段在主存中的起始地址与段内地址（偏移量）相加，得到对应的主存实地址 。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304151618608.png" alt="image-20230415161833520" loading="lazy"></p><p>段式虚拟存储器的<strong>优点</strong>是：段的分界与程序的自然分界对应，因为具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享  。<br><strong>缺点</strong>则是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p><h2 id="14-6-段页式虚拟存储器"><a href="#14-6-段页式虚拟存储器" class="headerlink" title="14.6.段页式虚拟存储器"></a>14.6.段页式虚拟存储器</h2><p><strong>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器</strong>。在段页式虚拟存储器中，每个程序对应一个段表， 每段对应一个页表， 段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</p><p>虚地址分为<strong>段号、段内页号、页内地址</strong>三部分。CPU 根据虚地址访存时，首先根据段号得到段表地址; 然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址; 最后从页表中取出实页号，与页内地址拼接形成主存实地址。</p><p>段页式虚拟存储器的<strong>优点</strong>是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。<strong>缺点</strong>是在地址变换过程中需要两次查表，系统开销较大。</p><h2 id="14-7-虚拟存储器与-Cache-比较"><a href="#14-7-虚拟存储器与-Cache-比较" class="headerlink" title="14.7.虚拟存储器与 Cache 比较"></a>14.7.虚拟存储器与 Cache 比较</h2><h3 id="14-7-1-相同"><a href="#14-7-1-相同" class="headerlink" title="14.7.1.相同"></a>14.7.1.相同</h3><ol><li>最终目的都是为了<strong>提高系统性能</strong>，两者都有<strong>容量、速度和价格</strong>的梯度。</li><li>都把数据分为<strong>小的信息块，并作为基本的传递单位</strong>，虚拟存储器系统的信息块更大。</li><li>都有地址的<strong>映射、替换算法和更新</strong>策略等问题。</li><li>依据程序的局部性原理应用 “<strong>快速缓存的思想</strong>”，将活跃的数据放在相对高速的部件中。</li></ol><h3 id="14-7-2-不同"><a href="#14-7-2-不同" class="headerlink" title="14.7.2.不同"></a>14.7.2.不同</h3><ol><li>Cache 主要为了解决<strong>系统的速度</strong>，而虚拟存储器则为了解决<strong>主存容量。</strong></li><li><strong>Cache 全由硬件实现</strong>，是硬件存储器，对程序员透明；<strong>而虚拟存储器由 OS 和硬件共同实现</strong>，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</li><li>由于 CPU 的速度约为 Cache 的 10 倍，主存的速度约为硬盘的 100 倍以上，<strong>因此虚拟存储器系统不命中时对系统的性能影响很大。</strong></li><li><strong>CPU 与 Cache 和主存都建立了直接访问的通路，而辅存与 CPU 没有直接通路</strong>。也就是说在 Cache 不命中时主存能和 CPU 直接通信，同时将数据调入 Cache；而虚拟存储器系统不命中时，只能先由硬盘调入内存，而不能直接和 CPU 通信。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组-第二章 数据的表示和运算</title>
      <link href="/posts/189f252b/"/>
      <url>/posts/189f252b/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数制与编码"><a href="#1-数制与编码" class="headerlink" title="1.数制与编码"></a>1.数制与编码</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912268.png" alt="image-20230413140118235" loading="lazy"></p><h2 id="1-1-进位计数法"><a href="#1-1-进位计数法" class="headerlink" title="1.1.进位计数法"></a>1.1.进位计数法</h2><h3 id="1-1-1-进位计数法"><a href="#1-1-1-进位计数法" class="headerlink" title="1.1.1.进位计数法"></a>1.1.1.进位计数法</h3><p><strong>进位计数法</strong>：进位计数法是一种计数的方法。常用的有十进制、二进制、八进制和十六进制等。日常生活中最常使用的就是十进制，其余则主要是计算机在运算是时使用。在进行计数法中，每个数所用到的不同数码的个数称为<strong>基数</strong>。</p><ul><li>例如：十进制的基数为 0~9，每个数位计满 10 后就会向高位进位。</li></ul><p><strong>每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加</strong>。</p><p><strong>例如</strong>：一个<code>r</code>进制数$(K_nK_{n-1}…K_0K_{-1}…K_{-m})$的数值可以表示为<br>具${K_nr^2+K_{n-1}r^{n-1}+…+K_0r^0+K_{-1}r^{-1}+…+K_{-m}r^{-m}&#x3D;\sum_{i&#x3D;n}^{-m} k_ir^i}$，具体来说：</p><ul><li><p><strong>十进制</strong>：例如 975</p><p>$975.36 &#x3D; 9 × 100 + 7 × 10 + 5 × 1 + 3 × 0.1 + 6 × 0.01 $ ，也即 $975 &#x3D; 9 × 1 0 ^2 + 7 × 1 0 ^1 + 5 × 1 0^ 0 + 3 × 1 0 ^{− 1} + 6 × 1 0 ^{− 2} $</p></li><li><p><strong>二进制</strong>：只有 0 和 1 两种数字符号，“逢 2 进 1”，其任意数位的权为$2^i$ ，<code>i </code>为所在位数。</p></li><li><p><strong>八进制</strong>：八进制作为二进制的一种书写形式，其基数是 8，有 0~7 共 8 个不同的数字符号，“逢 8 进 1”。由于$ r&#x3D;8&#x3D;2^{3}$。</p></li><li><p><strong>十六进制</strong>：其基数为 16，“逢 16 进 1”，其中 A、B、C、D、E、F 分别表示 10、11、12、13、14、15. 由于$r&#x3D;16&#x3D;2^{4}$。</p></li></ul><h3 id="1-1-2-计算机采用二进制编码的原因"><a href="#1-1-2-计算机采用二进制编码的原因" class="headerlink" title="1.1.2.计算机采用二进制编码的原因"></a>1.1.2.计算机采用二进制编码的原因</h3><p><strong>原因如下</strong>：</p><ul><li><strong>二进制只有两种状态</strong>：使用有两个稳定状态的器件就可以表示二进制数的每一位，制造成本较低。比如可以利用高低电平和电荷正负表示 0 和 1。</li><li><strong>二进制的 1 和 0 正好与逻辑值真和假相对应</strong>：这为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。</li><li><strong>二进制的编码和运算规则很简单</strong>：通过逻辑门电路可以方便地实现算数运算。</li></ul><h2 id="1-2-进制转换"><a href="#1-2-进制转换" class="headerlink" title="1.2.进制转换"></a>1.2.进制转换</h2><p><strong>进制转换黄金原则（看完下面再看）：一切转换均可借助二进制作为媒介完成</strong>。</p><ul><li><strong>八进制、十六进制和二进制之间是有位数对应的关系的。</strong></li><li><strong>十进制和二进制可以直接通过权值累加得到。</strong></li></ul><h3 id="1-2-2-其他进制数转换为十进制"><a href="#1-2-2-其他进制数转换为十进制" class="headerlink" title="1.2.2.其他进制数转换为十进制"></a>1.2.2.其他进制数转换为十进制</h3><p><strong>其他进制数转换为十进制：其他进制数转化为十进制较为简单，只需代入下面的公式即可<br>${K_nr^2+K_{n-1}r^{n-1}+…+K_0r^0+K_{-1}r^{-1}+…+K_{-m}r^{-m}&#x3D;\sum_{i&#x3D;n}^{-m} k_ir^i}$</strong></p><p><strong>例如</strong>：要把一个二进制数转为十进制数，那么上式中的 $r$ 就设为 2， 然后用二进制数的每一位乘以 $ r^{n} $，这个 n 表示的是位权（小数点左侧从右向左由 0 递增，小数点右侧从左至右由 - 1 递减），再举几个例子：</p><ul><li><p><strong>二进制数 10010010.100 转化为十进制数：</strong> $10010010.110 &#x3D; 1×2^{7}+1×2^{4}+1×2^{1}+1×2^{-1}+1×2^{-2}&#x3D;146.75 $</p></li><li><p>**八进制数 251.5 转化为十进制数：$251.5 &#x3D;2×8^{2}+5×8^{1}+1×8^{0}+5×8^{-1} $。</p></li><li><p><strong>十六进制数 AE86.1 转化为十进制数：</strong> $AE86.1&#x3D;10×16^{3}+14×16^{2}+8×16^{1}+6×16^{0}+1×16^{-1}&#x3D;44678.0625 $</p></li></ul><h3 id="1-2-2-十进制数转化为其他进制数"><a href="#1-2-2-十进制数转化为其他进制数" class="headerlink" title="1.2.2.十进制数转化为其他进制数"></a>1.2.2.十进制数转化为其他进制数</h3><p><strong>十进制数转化为其他进制数：需要把整个过程分为求整数部分和求小数两部分</strong>。</p><ul><li><strong>求整数：第 i 次除以基数 b 所得到的的余数即为 $A_i$，然后继续利用所得商运算，直到所得商为 0，其中$i\in (1,n) $，最后结果反着写。</strong></li><li><strong>求小数： 第 i次乘以基数 b 所得的整数部分即为$A_{-i}$​，其中 $i\in (1,n)$，需要注意每次乘法之后要把个位处置 0。</strong></li></ul><p><strong>例如</strong>：7562.03125 转化为 16 进制数。</p><p>首先，列一个表格计算整数部分：</p><ul><li>整数部分为 1D8A。</li></ul><table><thead><tr><th>除以 16</th><th>所得商</th><th>所得余数</th><th>对应符号</th></tr></thead><tbody><tr><td>7562/16</td><td>472</td><td>10</td><td>A</td></tr><tr><td>472/16</td><td>29</td><td>8</td><td>8</td></tr><tr><td>29/16</td><td>1</td><td>13</td><td>D</td></tr><tr><td>1/16</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>然后计算小数部分：</p><ul><li><strong>注意</strong>：再进行下一次乘积运算时，要取上一次乘积的小数部分作为新的乘数进行运算，比如第二次运算乘积为 8，下一次运算时直接要取小数部分进行运算。</li><li>小数部分为 08。</li></ul><table><thead><tr><th>乘以 16</th><th>所得乘积</th><th>取乘积整数位</th><th>对应符号</th></tr></thead><tbody><tr><td>0.03125×16</td><td>0.5</td><td>0</td><td>0</td></tr><tr><td>0.5×16</td><td>8.0</td><td>8</td><td>8</td></tr><tr><td>0×16</td><td>0.0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>到这里转换完成，答案为 1D8A.08</strong>。</p><p>上述方法是比较通用的方法。在实际情况中，尤其涉及编程、网络时，会频繁涉及到 10 进制数转化为 2 进制数的问题，<strong>所以这里还可以使用拼凑法，首先你需要牢记常用 $ 2^{n} $ 的值</strong>。</p><table><thead><tr><th>2 10 2^{10}</th><th>2 9 2^{9}</th><th>2 8 2^{8} </th><th>2 7 2^{7}</th><th>2 6 2^{6}</th><th>2 5 2^{5} </th><th>2 4 2^{4}</th><th>2 3 2^{3}</th><th>2 2 2^{2} </th><th>2 1 2^{1} </th><th>2 0 2^{0} </th><th>2 − 1 2^{-1} </th><th>2 − 2 2^{-2} </th><th>2 − 3 2^{-3} </th></tr></thead><tbody><tr><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr></tbody></table><p>转换时，只需要目测估值即可，比如 260.75，260&#x3D;256+4，同时 0.75 等于 0.5+0.25，相应位置填 1 即可。</p><table><thead><tr><th>2 10 2^{10}</th><th>2 9 2^{9}</th><th>2 8 2^{8} </th><th>2 7 2^{7}</th><th>2 6 2^{6}</th><th>2 5 2^{5} </th><th>2 4 2^{4}</th><th>2 3 2^{3}</th><th>2 2 2^{2} </th><th>2 1 2^{1} </th><th>2 0 2^{0} </th><th>2 − 1 2^{-1} </th><th>2 − 2 2^{-2} </th><th>2 − 3 2^{-3} </th></tr></thead><tbody><tr><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0.5</td><td>0.25</td><td>0.125</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>所以  $(260.75)<em>{10}\rightarrow (100000100.11)</em>{2} $</p><h3 id="1-2-3-二进制、八进制和十六进制的相互转换"><a href="#1-2-3-二进制、八进制和十六进制的相互转换" class="headerlink" title="1.2.3.二进制、八进制和十六进制的相互转换"></a>1.2.3.二进制、八进制和十六进制的相互转换</h3><p><strong>二进制、八进制和十六进制的相互转换：这几个进制之间是具有对应关系的，所以可以快速转换。</strong></p><ul><li><strong>八进制</strong>：八进制作为二进制的一种书写形式，其基数是 8，有 0~7 共 8 个不同的数字符号，“逢 8 进 1”。由于$ r&#x3D;8&#x3D;2^{3} $，<strong>所以 3 位二进制数码与 1 位八进制数码相对应</strong>。</li><li><strong>十六进制</strong>：其基数为 16，“逢 16 进 1”，其中 A、B、C、D、E、F 分别表示 10、11、12、13、14、15. 由于 $r&#x3D;16&#x3D;2^{4}$，<strong>所以 4 位二进制数码与 1 位十六进制数码相对应。</strong></li></ul><p><strong>因此转换时，以小数点作为起始点，向左向右分别进行划分，如果是八进制就是三位，如果是十六进制就是 4 位。</strong></p><ul><li>如果位数不足要把 “0” 补上，防止误判。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912461.png" loading="lazy"></p><p>再比如：</p><ul><li>$ (251.5)<em>{8}\rightarrow (010 101 001 . 101)</em>{2} $</li><li>$(AE86.1)<em>{16}\rightarrow (1010111010000110.0001 )</em>{2} $</li></ul><h2 id="1-3-真值和机器数（考纲已删除）"><a href="#1-3-真值和机器数（考纲已删除）" class="headerlink" title="1.3.真值和机器数（考纲已删除）"></a>1.3.真值和机器数（考纲已删除）</h2><p><strong>真值：日常生活中，对于正数和负数我们可以使用正号 (通常省略) 和负号来表示，如 15 和 - 8。</strong>这种带 “+” 和“-”符号的数称为真值，真值是机器数所代表的实际值。</p><p><strong>机器数：在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。例如后面需要学习的原码，补码和反码。这几种表示法都将数据的符号数字化，通常用 “0” 表示正，用 “1” 表示负</strong>。</p><h1 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2.BCD码"></a>2.BCD码</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912380.png" alt="image-20230413140143728" loading="lazy"></p><h2 id="2-1-什么是-BCD-码"><a href="#2-1-什么是-BCD-码" class="headerlink" title="2.1.什么是 BCD 码"></a>2.1.什么是 BCD 码</h2><p><strong>BCD 码 (Binary-Coded Decimal)：</strong>是指二进制编码的十进制数。我们可以用 4 位二进制数来表示一位十进制数中的 0~9，这种编码方法使得二进制数和十进制数之间的转换得以快速进行。4 位二进制数最多有 16 种组合，足以表示 0 到 9 这十个数，所以<strong>有 6 种状态为冗余状态</strong>。</p><h2 id="2-2-常用的-BCD-码"><a href="#2-2-常用的-BCD-码" class="headerlink" title="2.2.常用的 BCD 码"></a>2.2.常用的 BCD 码</h2><h3 id="2-1-1-8421-码（最常用）"><a href="#2-1-1-8421-码（最常用）" class="headerlink" title="2.1.1.8421 码（最常用）"></a>2.1.1.8421 码（最常用）</h3><p><strong>A：8421 码表示</strong></p><p><strong>8421 码 (Binary-Coded Decimal)：它是一种有权码，设其每一位的数值为$b1,b2,b3,b4 $，则权值从高到低依次为 8 , 4 , 2 , 1 ，它表示的十进制数为 $D&#x3D;8b_{3}+4b_{2}+2b_{1}+1b_{0}$​</strong>。</p><ul><li>例如 985 的 8421 码为<code>1001</code> <code>1000</code> <code>0101</code>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912137.png" loading="lazy"></p><p><strong>B：8421 码运算规则</strong></p><p><strong>8421 码运算规则：</strong></p><ul><li><strong>如果两个 8421 码相加之和小于等于$(1001)_{2}$不需要修正</strong>。</li><li><strong>如果两个 8421 码相加之和大于$ (1001)_{2} $则需要修正</strong>：<strong>修正时需要 + 6</strong>。</li></ul><p>以 5+8 为例：  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131912688.png" loading="lazy"></p><h3 id="2-1-2-余-3-码"><a href="#2-1-2-余-3-码" class="headerlink" title="2.1.2.余 3 码"></a>2.1.2.余 3 码</h3><p>余 3 码：余 3 码是一种<strong>无权码</strong>，是在 8421 码的基础上加$(3)<em>{10}$，也即$ (0011)</em>{2}$形成的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913061.png" loading="lazy"></p><h3 id="2-1-3-2421-码"><a href="#2-1-3-2421-码" class="headerlink" title="2.1.3.2421 码"></a>2.1.3.2421 码</h3><p>2421 码：这是一种<strong>有权码</strong>。权值由高到低分别为 2 4 2 1，特点是<strong>大于等于 5 (5<del>9)<strong>的 4 位二进制数中最高位为 1，</strong>小于 5 (0</del>4</strong>)的最高位为 0。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913503.png" loading="lazy"></p><h1 id="3-无符号数的表示和运算"><a href="#3-无符号数的表示和运算" class="headerlink" title="3.无符号数的表示和运算"></a>3.无符号数的表示和运算</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913478.png" alt="image-20230413140703670" loading="lazy"></p><h2 id="3-1-机器数的定点表示"><a href="#3-1-机器数的定点表示" class="headerlink" title="3.1.机器数的定点表示"></a>3.1.机器数的定点表示</h2><p>根据小数点的位置是否固定，在计算机中有两类数据表示方法：<strong>定点表示和浮点表示</strong>。浮点表示类似于科学计数法，将在第三节介绍。</p><p><strong>机器数的定点表示：定点表示就是约定机器数中的小数点位置固定不变，小数点不再使用<code>.</code>表示，而是约定其位置。理论上，小数点位置固定在任何一位都可以，但是在计算机中通常采用两种简单的约定：</strong></p><ul><li><p>定点整数：将小数点的位置固定在数据的最低位之后。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913271.png" alt="在这里插入图片描述" loading="lazy"></p></li><li><p>定点小数：将小数点的位置固定在数据的最高位之前。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913416.png" alt="在这里插入图片描述" loading="lazy"></p></li></ul><h2 id="3-2-无符号整数的概念及其在计算机中的应用"><a href="#3-2-无符号整数的概念及其在计算机中的应用" class="headerlink" title="3.2.无符号整数的概念及其在计算机中的应用"></a>3.2.无符号整数的概念及其在计算机中的应用</h2><p>**无符号整数（无符号数）：无符号整数是指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值，它就是我们常说的自然数； n 位无符号数其范围为$(0，2^{n}-1)$**。</p><p>在 C 语言中，使用关键字<code>unsigned</code>修饰后，该变量即为无符号数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>以下讨论中假设机器字长为 8 位。</li></ul><p><strong>无符号整数硬件表示：由于无符号整数全部二进制位均为数值位，没有符号位，所以数值位均有位权，也即之前说到过的二进制。注意</strong>：</p><ul><li><p><strong>最小的无符号整数为全 0</strong>。</p></li><li><p><strong>最大的无符号整数为全 1。</strong></p></li><li><p>$n$位无符号数其范围为$(0,2^{n}-1)$<strong>，一旦超出则会溢出。</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913535.png" alt="image-20230413140452529" loading="lazy"></p><h2 id="3-3-加法运算"><a href="#3-3-加法运算" class="headerlink" title="3.3.加法运算"></a>3.3.加法运算</h2><p><strong>无符号整数加法运算规则：从低位开始，按位相加，向更高位进位</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913538.png" alt="image-20230413140521323" loading="lazy"></p><h2 id="3-4-减法运算"><a href="#3-4-减法运算" class="headerlink" title="3.4.减法运算"></a>3.4.减法运算</h2><p><strong>无符号整数减法运算规则：由于减法电路实现较加法电路困难，所以成本较高，因此会将减法运算转换为加法运算来完成运算。具体来说：</strong></p><ul><li><strong>被减数不变，减数按位取反、末位 + 1。</strong></li><li><strong>从低位开始，按位相加，向更高位进位。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913568.png" alt="image-20230413140618463" loading="lazy"></p><ul><li>注意高位被丢弃了。</li></ul><h1 id="4-有符号数的表示和运算"><a href="#4-有符号数的表示和运算" class="headerlink" title="4.有符号数的表示和运算"></a>4.有符号数的表示和运算</h1><h2 id="4-1-有符号数的概念及其在计算机中应用"><a href="#4-1-有符号数的概念及其在计算机中应用" class="headerlink" title="4.1.有符号数的概念及其在计算机中应用"></a>4.1.有符号数的概念及其在计算机中应用</h2><p>有符号数：由于计算机是无法直接识别数的正负的，所以可以将<strong>符号数值化</strong>。规定：对于有符号数，用 <strong>“0” 表示正</strong>，<strong>用 “1” 表示负</strong>，且<strong>通常约定二进制数位的最高位为符号位</strong>。<strong>有符号数</strong>分为<strong>定点整数</strong>和<strong>定点小数</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913802.png" alt="image-20230413143308253" loading="lazy"></p><p><strong>定点整数和定点小数可以原码、反码、补码和移码(只有定点整数有)来表示。假设真值为<code>x</code>，则：</strong></p><ul><li><strong>原码</strong>： $[x]_{原}$</li><li><strong>反码</strong>： $[x]_{反}$</li><li><strong>补码</strong>： $ [x]_{补} $</li><li><strong>移码</strong>： [$[x]_{移}$</li></ul><h2 id="4-2-有符号数的表示"><a href="#4-2-有符号数的表示" class="headerlink" title="4.2.有符号数的表示"></a>4.2.有符号数的表示</h2><h3 id="4-2-1-原码"><a href="#4-2-1-原码" class="headerlink" title="4.2.1.原码"></a>4.2.1.原码</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913076.png" alt="image-20230413142430182" loading="lazy"></p><p><strong>原码：原码是一种比较简单、直观的机器数表示法。用机器数的最高位表示该数的符号，其余的各位表示数的绝对值，其中 0 表示正，1 表示负</strong>。</p><p>以 <code>19.75 </code> 为例，假设机器字长为 8 位：</p><ul><li>整数部分：19</li><li>小数部分：0.75</li></ul><h4 id="4-2-1-1-定点整数的原码表示"><a href="#4-2-1-1-定点整数的原码表示" class="headerlink" title="4.2.1.1.定点整数的原码表示"></a>4.2.1.1.定点整数的原码表示</h4><p>①：表示方法</p><p><strong>定点整数的原码表示方法</strong>：按照二进制的位权书写即可，不足位可以用 0 补齐。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913783.png" loading="lazy"></p><p>②：原码整数的表示范围</p><p><strong>原码整数的表示范围</strong>：假如机器字长为<code>n</code>位，那么原码整数的表示范围为$ -(2^{n-1}-1) \leqslant x \leqslant 2^{n-1}-1 $。</p><p>③：真值 0</p><ul><li>真值 0 有 <code>+ 0 0 0</code> 和 <code>- 0 0 0 </code><strong>两种形式。</strong></li></ul><h4 id="4-2-1-2-定点小数的原码表示"><a href="#4-2-1-2-定点小数的原码表示" class="headerlink" title="4.2.1.2.定点小数的原码表示"></a>4.2.1.2.定点小数的原码表示</h4><p>①：表示方法</p><p><strong>定点小数的原码表示方法</strong>：按照二进制的位权书写即可，不足位可以用 0 补齐。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913110.png" loading="lazy"></p><p>②：原码小数的表示范围</p><p><strong>原码小数数的表示范围</strong>：假如机器字长为 <code>n </code> 位，那么原码小数数的表示范围为$ -(1-2^{-n+1}) \leqslant x \leqslant 1-2^{-n+1} $。</p><p>③：真值 0</p><ul><li>真值 0 有<code>+ 0 0 0</code>和<code> - 0 0 0</code> <strong>两种形式</strong>。</li></ul><h3 id="4-2-2-反码"><a href="#4-2-2-反码" class="headerlink" title="4.2.2.反码"></a>4.2.2.反码</h3><p><strong>反码：反码是原码转换为补码的一个中间状态。</strong></p><p><strong>①：如果是正数，则反码与原码相同</strong></p><ul><li><p>例如 + 19D，其$ [x]<em>{原}&#x3D;0,0010011 [x] $， $ [x]</em>{反}&#x3D;0,0010011 $</p></li><li><p>例如 + 0.75D，其$[x]<em>{原}&#x3D;0.1100000 $， $[x]</em>{反}&#x3D;0.1100000$</p></li></ul><p><strong>②：如果是负数，则除符号位外，其他位按位取反</strong></p><ul><li><p>例如 - 19D，其$ [x]<em>{原}&#x3D;1,0010011$， $[x]</em>{反}&#x3D;1,1101100 [x] $</p></li><li><p>例如 - 0.75D，其 $ [x]<em>{原}&#x3D;1.1100000$， $[x]</em>{反}&#x3D;1.0011111 [x] $</p></li></ul><p><strong>③：特别注意真值 0 的 + 0 和 - 0 所对应的形式</strong></p><ul><li><p>[$ [+0]<em>{原}&#x3D;00000000 [+0] $，$[+0]</em>{反}&#x3D;00000000$</p></li><li><p>$ [-0]<em>{原}&#x3D;10000000$，$ [-0]</em>{反}&#x3D;11111111$</p></li></ul><h3 id="4-2-3-补码"><a href="#4-2-3-补码" class="headerlink" title="4.2.3.补码"></a>4.2.3.补码</h3><p><strong>①：如果是正数，则补码和原码一致</strong></p><ul><li><p>例如 + 19D，其 $ [x]<em>{原}&#x3D;0,0010011$， $ [x]</em>{反}&#x3D;0,0010011$， $[x]_{补}&#x3D;0,0010011$</p></li><li><p>例如 + 0.75D，其$[x]<em>{原}&#x3D;0.1100000 [x] $， $[x]</em>{反}&#x3D;0.1100000 [x] $， $ [x]_{补}&#x3D;0.1100000$</p></li></ul><p><strong>②：如果是负数，则补码 &#x3D; 反码 + 1（注意进位）</strong></p><ul><li><p>例如 - 19D，其$ [x]<em>{原}&#x3D;1,0010011 $，$[x]</em>{反}&#x3D;1,1101100 [x] $， $ [x]_{补}&#x3D;1,1101101 $</p></li><li><p>例如 - 0.75D，其 $ [x]<em>{原}&#x3D;1.1100000 $， $ [x]</em>{反}&#x3D;1.0011111 [x] $， $ [x]_{补}&#x3D;1.0100000$</p></li></ul><p><strong>③：特别注意的是补码的真值 0 只有一种表现形式</strong></p><p>因为 $ [-0]<em>{原}&#x3D;10000000 $， $ [-0]</em>{反}&#x3D;11111111 [−0] $，其补码如果在此基础再加 1，就会超出机器数位的限制（这里假定 8 位），变为$1,00000000 $。这样一来，低八位就又变成了 $00000000$，反而和 <code>+ 0 0 0 </code>冲突了，并且显得浪费，所以把我们这个**特殊的补码直接规定为 $−128$*<em>。所以这里如果机器字长为 n 位，那么</em>补码整数的表示范围就为（多了一个<code>-128</code>）：  </p><p>​                                $ -(2^{n-1}) \leqslant x \leqslant 2^{n-1}-1 $</p><p>相应的，<strong>补码小数 1.00000000 1.00000000 1.00000000 的表示范围会变为（多了一个 - 1）</strong>。<br>                                $-1 \leqslant x \leqslant 1-2^{-n+1} $</p><h3 id="4-2-4-移码"><a href="#4-2-4-移码" class="headerlink" title="4.2.4.移码"></a>4.2.4.移码</h3><blockquote><p><strong>移码只能用来表示整数，而不能表示小数</strong>。</p></blockquote><p><strong>移码：移码是在补码的基础上将符号位取反，需要注意移码只能用于表示整数，且移码和补码的真值 0 是保持一致的</strong></p><ul><li><p>例如 + 19D，其$ [x]<em>{原}&#x3D;0,0010011 $，$ [x]</em>{反}&#x3D;0,0010011 [x] $， $ [x]<em>{补}&#x3D;0,0010011 $， $ [x]</em>{移}&#x3D;1,0010011 $</p></li><li><p>例如 - 19D，其 $ [x]<em>{原}&#x3D;1,0010011 $， $ [x]</em>{反}&#x3D;1,1101100 [x] $， $ [x]<em>{补}&#x3D;1,1101101 $，$ [x]</em>{移}&#x3D;0,1101101 $</p></li></ul><p><strong>移码是补码的符号位取反，可以将其看做一个无符号数，因此真值增大时移码也在增大，可以很方便的使用移码对数的大小进行比较</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913671.png" loading="lazy"></p><h2 id="4-3-原码、反码、补码总结"><a href="#4-3-原码、反码、补码总结" class="headerlink" title="4.3.原码、反码、补码总结"></a>4.3.原码、反码、补码总结</h2><h3 id="4-3-1-原码、补码运算技巧"><a href="#4-3-1-原码、补码运算技巧" class="headerlink" title="4.3.1.原码、补码运算技巧"></a>4.3.1.原码、补码运算技巧</h3><ul><li>如果已经知道 X 的补码，让你求 - X 的补码，只需<strong>所有位全部取反，末位 + 1 即可</strong>。</li><li>负数补码是在反码末位 + 1 后得到的，所以这就导致反码最右边连续的 1 都会因为进位而变为 0，直到进位碰到第一个 0 为止。因此，负数补码中，<strong>最右边的（最后一个 1）及其右面与原码相同，而其左面则与反码相同。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913413.png" alt="image-20230413143849083" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913974.png" alt="image-20230413143041534" loading="lazy"></p><h3 id="4-3-2-原码、反码、补码、移码特性（整数）"><a href="#4-3-2-原码、反码、补码、移码特性（整数）" class="headerlink" title="4.3.2.原码、反码、补码、移码特性（整数）"></a>4.3.2.原码、反码、补码、移码特性（整数）</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913053.png" alt="image-20230413143152103" loading="lazy"></p><h3 id="4-3-3-定点小数和定点整数对比"><a href="#4-3-3-定点小数和定点整数对比" class="headerlink" title="4.3.3.定点小数和定点整数对比"></a>4.3.3.定点小数和定点整数对比</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913125.png" alt="image-20230413143430341" loading="lazy"></p><h2 id="4-4-引入补码的目的"><a href="#4-4-引入补码的目的" class="headerlink" title="4.4.引入补码的目的"></a>4.4.引入补码的目的</h2><h3 id="4-4-1-直接使用原码进行运算的弊端"><a href="#4-4-1-直接使用原码进行运算的弊端" class="headerlink" title="4.4.1.直接使用原码进行运算的弊端"></a>4.4.1.直接使用原码进行运算的弊端</h3><p>对于<strong>无符号数</strong>，直接使用原码进行运算是没有问题的，如下图：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913854.png" loading="lazy"></p><p> 但对于<strong>有符号数</strong>，由于最高位表示的是符号位，所以下面计算的结果<strong>明显是错误的</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913956.png" loading="lazy">  </p><p>要想得到正确的运算结果，那就得要求计算机能够识别加减运算，也即算术逻辑单元 ALU 不只需要加法器，还得需要减法器才行。<strong>但由于减法器实现比较困难且成本巨大，所以一个可行的方案就是使用加法代替减法。</strong></p><h3 id="4-4-2-如何使用加法实现减法"><a href="#4-4-2-如何使用加法实现减法" class="headerlink" title="4.4.2.如何使用加法实现减法"></a>4.4.2.如何使用加法实现减法</h3><p><strong>如下是一个时钟，指针开始时指向的是 10，如果要让其指向 7，那么有两种方法</strong>：</p><ul><li><strong>逆时针旋转至 7</strong>：相当于做了减法，即<code>10-3=7</code>。</li><li><strong>顺时针旋转至 7</strong>：相当于做了加法，但这里应该加多少呢？可以加 9，然后由于表盘最大数为 12，所以<code>19%12=7</code>，便指向了 7。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913736.png" loading="lazy"></p><p><strong>这个例子说明了一个道理：一个减法操作可以转换为一个与之对应的加法操作，而这里采用的是取余</strong></p><ul><li>-3 和 + 9 在 <strong>mod 12</strong> 这样的情况下是等价的，而这两个数相差正好就是 12。还有很多这样的数，比如 21、33、-15 等等，<strong>这些数之间的差距均为 12 或其倍数。</strong></li></ul><p>其实，上例中的 - 3 和 9 <strong>互为补数</strong>，因为<strong>这两个数的绝对值之和为 12。</strong></p><p>$ -a(a&gt;0) 的补数 &#x3D; 模 -|a| $</p><p><strong>补数的性质非常重要，假设互为补数的两数之和为 <code> m</code>，那么在 <code>mod m</code> 的条件下，若能找到负数的补数，就可以用正数的加法代替减法</strong></p><p>如下例  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131913069.png" loading="lazy"> </p><p>按照上面所述，要完成运算，<strong>只需要找到 - 14 的补数即可</strong>。这里机器字长为<code>8bit</code>，所以可以表示的数范围为$2^{8}− 1 $，这个$2^{8}− 1 $就相当于表盘上的 12，<strong>所以当某数大于 $2^{8}− 1 $ 时，由于机器字长的限制，计算机便帮助我们 “自动” 进行了一个 mod 运算，该数会被重新映射到合法范围内</strong>。</p><ul><li><code>mod 12</code>把数映射到了 0-11 这个范围内，<code>mod</code> $2^{8}$把数映射到了 $ 0-2^{8}-1 $这个范围内。</li></ul><p>因此，**-14 的补数为 $+ 1 , 00000000 - 00001110 &#x3D; 11110010 $<strong>，</strong>大家认真观察就可以发现 -14 的补数其实就是 - 14 的补码**。</p><p>最后，使用 11110010 11110010 11110010 替换原来的减法完成运算，其结果就是 0（截断）  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914467.png" loading="lazy"></p><h2 id="4-5-有符号数补码运算"><a href="#4-5-有符号数补码运算" class="headerlink" title="4.5.有符号数补码运算"></a>4.5.有符号数补码运算</h2><ul><li>原码运算不用多说，以下运算中必须把运算数全部转换为<strong>补码</strong>进行（特指负数）。</li></ul><h3 id="4-5-1-定点整数的补码运算"><a href="#4-5-1-定点整数的补码运算" class="headerlink" title="4.5.1.定点整数的补码运算"></a>4.5.1.定点整数的补码运算</h3><h4 id="4-5-1-1-加法运算"><a href="#4-5-1-1-加法运算" class="headerlink" title="4.5.1.1.加法运算"></a>4.5.1.1.加法运算</h4><p><strong>定点整数补码加法运算规则：从最低位开始，按位相加（符号位参与运算），向更高位进位</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914964.png" alt="image-20230413144152183" loading="lazy"></p><h4 id="4-5-1-2-减法运算"><a href="#4-5-1-2-减法运算" class="headerlink" title="4.5.1.2.减法运算"></a>4.5.1.2.减法运算</h4><p><strong>定点整数补码减法运算规则：$ [A]<em>{补} - [B]</em>{补}&#x3D;  [A]<em>{补} +  [-B]</em>{补}$，重点问题在于已知 $ [B]<em>{补} $如何求$ [-B]</em>{补}$，如下</strong>  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922275.png" alt="image-20230413144231881" loading="lazy"></p><p><strong>这样一来，减法就转变为了加法，剩余步骤同上</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914938.png" alt="image-20230413144349687" loading="lazy"></p><h3 id="4-5-2-定点小数的补码运算"><a href="#4-5-2-定点小数的补码运算" class="headerlink" title="4.5.2.定点小数的补码运算"></a>4.5.2.定点小数的补码运算</h3><h4 id="4-5-2-1-加法运算"><a href="#4-5-2-1-加法运算" class="headerlink" title="4.5.2.1.加法运算"></a>4.5.2.1.加法运算</h4><ul><li>同定点整数运算规则</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914914.png" loading="lazy"></p><h4 id="4-5-2-2-减法运算"><a href="#4-5-2-2-减法运算" class="headerlink" title="4.5.2.2.减法运算"></a>4.5.2.2.减法运算</h4><ul><li>同定点整数运算规则</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914546.png" loading="lazy"></p><h2 id="4-6-溢出判别方法"><a href="#4-6-溢出判别方法" class="headerlink" title="4.6.溢出判别方法"></a>4.6.溢出判别方法</h2><p>如下，求 $ [A+C]<em>{补} $和 $ [B-C]</em>{补} $​。运算过后你会得到一非常奇怪的结果。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914234.png" loading="lazy"></p><p>这是因为<strong>发生了溢出</strong>，溢出分为上溢和下溢：</p><ul><li><p><strong>正数 + 正数导致上溢</strong>：正 + 正 &#x3D; 负  。</p></li><li><p><strong>负数 + 负数导致下溢</strong>：负 + 负 &#x3D; 正  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914548.png" loading="lazy"></p></li></ul><h3 id="4-6-1-采用一位符号位依据溢出表达式判断"><a href="#4-6-1-采用一位符号位依据溢出表达式判断" class="headerlink" title="4.6.1.采用一位符号位依据溢出表达式判断"></a>4.6.1.采用一位符号位依据溢出表达式判断</h3><p>对于上面的例子：</p><ul><li>$[A+C]_{补}&#x3D;0,0001111+0,1111100&#x3D;1,0001011$，真值 - 117</li><li>$ [B-C]_{补}&#x3D;1,1101000+1,0000100&#x3D;0,1101100$，真值 + 108</li></ul><p>假设 A 的符号位为 $A_{s} $， B  的符号位为$ B_{S} $，其运算结果符号位为 $S_{s} $，则<strong>溢出逻辑表达式为</strong>：</p><ul><li>$V&#x3D;0 $表示无溢出。</li><li>$ V&#x3D;1$ 表示有溢出。</li></ul><p>​                                $V&#x3D;(A_{s}B_{s}(\overline S_{s} ))+ ((\overline A_{s})( \overline B_{s})S_{s}) $</p><blockquote><p>注意逻辑运算规则：</p><ul><li><strong>与</strong>： $A B C$表示与运算，A 与 B 与 C，当 A、B、C 全部为 1 时结果为 1，有一个为 0 结果为 0</li><li><strong>或</strong>： $A+B+C $ 表示或运算，A 或 B 或 C，当 A、B、C 全部为 0 时结果为 0，有一个为 1 结果为 1</li><li><strong>非</strong>： $\overline A $ 表示非运算，比如 $A $为 1 则 $  \overline A$ 为 0</li></ul></blockquote><p>在上面的例子中：</p><ul><li>$ [A]<em>{补}$​符号位为 <strong>0</strong>， $ [C]</em>{补} $符号位为 <strong>0</strong>， $ S_{s}&#x3D; [ A + C]<em>{补} $​符号位为 <strong>1</strong>，则 $\overline S</em>{s} $为 0 ，因此$A_{s}C_{s}\overline S_{s}$逻辑运算结果为 0；</li><li>$ \overline [A]<em>{补} $​为 <strong>1</strong>，$ \overline[C]</em>{补} $为 <strong>1</strong>, 则$ (\overline A_{s})( \overline C_{s})S_{s}$结果为 1。</li></ul><p>于是 $ V&#x3D;000 + 111&#x3D;0+1&#x3D;1$（有溢出），其实这也对应了正数 + 正数必有溢出的结论。</p><ul><li>负数 + 负数，也即 [ B − C ] 补 [B-C]_{补} [B−C] 补​读者可以根据上面的逻辑自行验证，会发现也是溢出的。</li></ul><p><strong>逻辑表达式有了，接着就可以设计与之对应的电路结构，计算机在判断溢出时可根据此逻辑进行判断</strong>。</p><h3 id="4-6-2-采用一位符号位依据数据位的进位情况判断"><a href="#4-6-2-采用一位符号位依据数据位的进位情况判断" class="headerlink" title="4.6.2.采用一位符号位依据数据位的进位情况判断"></a>4.6.2.采用一位符号位依据数据位的进位情况判断</h3><p><strong>这里有两个进位需要区别开来</strong>：</p><ul><li><p>**符号位的进位$ C_{s}$**：最高数值位向符号位进的位。</p></li><li><p><strong>最高数值位的进位 $C_{1} $​</strong>：最高数值位得到的进位。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914829.png" loading="lazy"></p></li></ul><p><strong>溢出判断规则为：</strong></p><ul><li><strong>上溢</strong>： $C_{s}&#x3D;0 $， $ C_{1}&#x3D;1$。</li><li><strong>下溢</strong>：$ C_{s}&#x3D;1 $， $C_{1}&#x3D;0$。</li></ul><p>比如$ [A+C]<em>{补} $会上溢，所以运算时有$C</em>{s}&#x3D;0 $，$ C_{1}&#x3D;1 $ 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914087.png" loading="lazy"></p><p>可以发现只要发生溢出$C_{s} 和 C_{1} $一定是不同的，计算机在判断时会<strong>使用异或运算</strong>。</p><ul><li>$V &#x3D; 0 $表示无溢出。</li><li>$V &#x3D; 1 $ 表示有溢出。</li></ul><p>$V&#x3D;C_{s}⊕C_{1}$</p><h3 id="4-6-3-采用双符号位判断（常考）"><a href="#4-6-3-采用双符号位判断（常考）" class="headerlink" title="4.6.3.采用双符号位判断（常考）"></a>4.6.3.采用双符号位判断（常考）</h3><p>之前符号位都是一位，这种方法将符号位扩展为了 2 位。</p><ul><li><strong>“00” 表示正数</strong></li><li><strong>“11 表示负数”</strong></li></ul><p>如下为运算过程：</p><ul><li>$[A+C]_{补}&#x3D;00,0001111+00,1111100&#x3D;01,0001011$，真值 - 117。</li><li>$ [B-C]_{补}&#x3D;11,1101000+11,0000100&#x3D;10,1101100 $，真值 + 108。</li></ul><p>运算结果符号位自然也有两位，<strong>这两个符号位第一位表示本来应该的符号，第二位符号表示实际得到的符号</strong>。比如<code>A+C </code> 结果中本来正数 + 正数应该是正数，但是实际是负数，所以判断溢出，而且是上溢。</p><p><strong>记这两个符号位为$S_{s1}S_{s2} $​，则溢出表达式为</strong>：</p><ul><li>$V &#x3D; 0 $ 无溢出。</li><li>$V &#x3D; 1$ 有溢出。</li></ul><p>$ V&#x3D;S_{s1}⊕S_{s2} $</p><h2 id="4-7-符号扩展"><a href="#4-7-符号扩展" class="headerlink" title="4.7.符号扩展"></a>4.7.符号扩展</h2><p>从上面的叙述中可以看出，溢出现象发生的本质原因就是机器字长不够。所以最容易想到的一个方式就是把<strong>短数据扩展为长数据</strong>，比如<code>int-&gt;long</code>，那么这又带来一个新的问题就是：<strong>多出来的那些位应该如何填补</strong>？</p><p>对于<strong>定点正整数</strong>来说，由于其原码、反码和补码都一样，因此直接补<code> 0</code> 即可  。<br>如 <code>0,1011010 0,1011010 0,1011010—&gt; 0,000000001011010 0,00000000 1011010 0,000000001011010</code>。</p><p>对于<strong>定点负整数</strong>来说，原码补 <code>0</code>，反码则对应位置补 <code>1</code>，而补码根据前面讲到的规则从右向左数第一个 1 开始（包括）左侧部分同补码  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914877.png" loading="lazy">  </p><p>对于<strong>定点正小数</strong>，最后面补 0 即可  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914071.png" loading="lazy"></p><p>对于<strong>定点负小数</strong>，和定点负整数同理  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914648.png" loading="lazy"></p><h1 id="5-字符与字符串在计算机中的表示详解（考纲删除了解即可）"><a href="#5-字符与字符串在计算机中的表示详解（考纲删除了解即可）" class="headerlink" title="5.字符与字符串在计算机中的表示详解（考纲删除了解即可）"></a>5.字符与字符串在计算机中的表示详解（考纲删除了解即可）</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914193.png" loading="lazy"></p><p>现代计算机不仅要处理数值领域的问题，而且还要处理大量<strong>非数值领</strong>域的问题。这样一来，必然要引入<strong>文字、字母及某些专用符号</strong>，以便表示文字语言、逻辑语言等信息。例如，人机交换信息时使用英文字母、标点符号、十进制数及诸如<code>$</code>、<code>%</code>、<code>+</code>等符号。然而，<strong>数字计算机只能处理二进制数据</strong>，因此，上述信息应用到计算机中时，<strong>都必须编写成二进制格式的代码，也就是字符信息用数据表示，称为符号数据</strong>。</p><h2 id="5-1-字符编码与-ASCII-编码"><a href="#5-1-字符编码与-ASCII-编码" class="headerlink" title="5.1.字符编码与 ASCII 编码"></a>5.1.字符编码与 ASCII 编码</h2><p><strong>ASCII 编码：这是目前国际上普遍采用的一种字符系统，其美国版称为 ASCII 码 (美国国家信息交换标准字符码)。它包括 10 个十进制数码，26 个英文字母和一定数量的专用符号，如<code>$</code>、<code>%</code>、<code>+</code>等，总共 128 个元素。因此二进制编码需要 7 位，再加上一个校验位，共 8 位，刚好为一个字节</strong>。</p><p><strong>ASCII 码字符排布情况如下</strong>：</p><ul><li>0~31 为控制字符, 用于通信控制和设备的功能控制。</li><li>127 是 DEL 码。</li><li><strong>32 是空格码。</strong></li><li>32~196 共 95 个字符为可打印字符。</li><li><strong>65~90 为大写字母范围。</strong></li><li><strong>97~122 位小写字母范围</strong>。</li><li>数字 0-9 的 ASCII 码为 48(011 0000) 到 57(011 1001)。注意去掉高三位后剩余部分正好是它们对应的 BCD 码形式。<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914754.png" alt="ASCII码表" loading="lazy"></li></ul><h2 id="5-2-汉字的表示和编码"><a href="#5-2-汉字的表示和编码" class="headerlink" title="5.2.汉字的表示和编码"></a>5.2.汉字的表示和编码</h2><p><strong>汉字编码：在不同情况下需要使用到不同搞得汉字编码，主要有：</strong></p><ul><li><strong>输入码</strong>：为了<strong>方便汉字输入</strong>而采取的编码方式。</li><li><strong>内码</strong>：为了在<strong>计算机内部表示汉字</strong>而采取的编码方式。</li><li><strong>输出码（字模码）</strong>：为了<strong>显示、打印汉字</strong>而采取的编码方式。</li></ul><h3 id="5-2-1-汉字的输入编码"><a href="#5-2-1-汉字的输入编码" class="headerlink" title="5.2.1.汉字的输入编码"></a>5.2.1.汉字的输入编码</h3><p><strong>汉字的输入编码：为了能直接使用西文标准键盘把汉字输入到计算机，就必须为汉字设计相应的输入编码方法，主要有以下三类：</strong></p><ul><li><p><strong>数字编码（主要使用）</strong>：数字编码用<strong>数字串</strong>代表一个汉字输入。常用的是<strong>区位码</strong>，区位码是将国家标准局公布的 6763 个两级汉字分为 94 个区，每个区 94 位。也就说把汉字表示成二维数组，<strong>每个汉字在数组的下</strong>标就是区位码。<strong>区码和位码</strong>总共是两位十进制数字，<strong>所以输入一个汉字需要键入四次</strong>。例如下面的 “啊” 字位于第 16 区 01 位，所以它的区位码就是 1601。使用数字编码方式输入<strong>无重码，且与内码转换较为方便</strong>，但缺点即使代码<strong>太难记忆</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914304.png" loading="lazy"></p></li><li><p><strong>拼音码</strong>：拼音码是以<strong>汉语拼音</strong>为基础的输入方法，只要掌握汉语拼音就可以轻松输入。但由于<strong>汉字同音字太多，所以输入的重码率会很高，输入速度也会受到影响。</strong></p></li><li><p><strong>字形编码</strong>：汉字总数虽然很多，但所有汉字都由最基本的笔画构成，因此全部汉字的部件和笔画是有限的。所以可以把<strong>汉字的笔画部件用字母或数字进行编码</strong>，按笔画的顺序依次输入就可以表示一个汉字。例如<strong>五笔打字。</strong></p></li></ul><h3 id="5-2-2-汉字内码"><a href="#5-2-2-汉字内码" class="headerlink" title="5.2.2.汉字内码"></a>5.2.2.汉字内码</h3><h4 id="5-2-2-1-国际码（交换码）"><a href="#5-2-2-1-国际码（交换码）" class="headerlink" title="5.2.2.1.国际码（交换码）"></a>5.2.2.1.国际码（交换码）</h4><p><strong>国际码（交换码）：上面说到的区位码还考虑一个问题，那就是必须要避开 ASCII 字符中 0~32 的不可显示字符和空格字符。因此会在区位码的基础上让其向后偏移 32，也就是加上 20H（十六进制），形成国际码。</strong></p><ul><li><strong>注意</strong>：区码和位码必须同时加上 20H（因为区码和位码分别代表一个字节）。也即<strong>国际码 &#x3D;(区位码)16+20H</strong></li></ul><h4 id="5-2-2-2-汉字内码"><a href="#5-2-2-2-汉字内码" class="headerlink" title="5.2.2.2.汉字内码"></a>5.2.2.2.汉字内码</h4><p><strong>国际码（交换码）</strong>：国标码还不能直接在计算机上使用，因为它还<strong>会和 ASCII 中的除控制字符外的其他字符冲突</strong></p><ul><li>这里 以<code>“中”</code>字为例，其国标码中的高位字节为 86，这会与 ASCII 中大写字母’V’冲突，低位字节为 80，会与’P’冲突。</li></ul><p>因此，为避免这种情况，<strong>规定：国标码中的每个字节的最高位都从 0 换成 1，相当于每个字节都再加上 128(十六进制为 80，即 80H；二进制为 1000 0000)<strong>，从而得到国标码的 “</strong>机内码</strong>” 表示，简称 <strong>“内码”</strong>。也即 <strong>汉字内码 &#x3D;(国际码)16+ 80 H 80H 80H</strong>。</p><ul><li>另外，由于 ASCII 码只用了一个字节的低 7 位，所以，<strong>一旦首位为 1 就表示这是汉字编码，若为 0 就是这是 ASCII 字符</strong>。</li></ul><p><strong>总之它们的关系如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914575.png" loading="lazy"></p><h4 id="5-2-2-3-汉字输出码（字模码）"><a href="#5-2-2-3-汉字输出码（字模码）" class="headerlink" title="5.2.2.3.汉字输出码（字模码）"></a>5.2.2.3.汉字输出码（字模码）</h4><p><strong>汉字输出码（字模码）</strong>： 为了显示或输出汉字，我们把汉字按图形符号设计成<strong>点阵图</strong>，就得到了相应的<strong>点阵代码 (字形码)<strong>。具体来说是用 0、1 表示汉字的字形，然后将汉字放入 $n$行 × $n$列的正方形 (<a href="https://so.csdn.net/so/search?q=%E7%82%B9%E9%98%B5&spm=1001.2101.3001.7020">点阵</a>) 内，该正方形共有 n 2 n^{2} n2 个小方格，</strong>每个小方格用一位二进制表示，凡是笔划经过的方格值为 1，未经过的值为 0</strong>。</p><ul><li>**字节数 &#x3D; 点阵行数 ×(点阵列数 &#x2F; 8)**。</li></ul><p>同时，汉字信息处理系统还需要配有<strong>汉字字形库，也称字模库，简称字库</strong>，它集中了汉字的字形信息。当显示输出或打印输出时才检索字库，输出子模点阵，得到字形。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131914040.gif" alt="点阵描述字形" loading="lazy"></p><h4 id="5-2-2-4总结"><a href="#5-2-2-4总结" class="headerlink" title="5.2.2.4总结"></a>5.2.2.4总结</h4><p><strong>综上所述，这三类码关系如下</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915178.jpeg" loading="lazy"></p><h2 id="5-3-字符串（考纲已删除）"><a href="#5-3-字符串（考纲已删除）" class="headerlink" title="5.3.字符串（考纲已删除）"></a>5.3.字符串（考纲已删除）</h2><p><strong>字符串</strong>：字符串是指<strong>连续的一串字符</strong>。通常情况下，它们占用主存连续的多个字节，<strong>每个字节存一个字符</strong>。</p><p><strong>英文字符，以 “abc” 为例。</strong></p><ul><li><p>计算机按字节编址，每个内存地址对应一个字节，最后一个字符往往是结束标志  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915296.png" loading="lazy">  </p><p><strong>中文字符，以 “abc 啊” 为例</strong>。</p></li><li><p>两字节表示一个汉字  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915632.png" loading="lazy"></p></li></ul><h1 id="6-校验码（考纲删除但计网会用建议学习）"><a href="#6-校验码（考纲删除但计网会用建议学习）" class="headerlink" title="6.校验码（考纲删除但计网会用建议学习）"></a>6.校验码（考纲删除但计网会用建议学习）</h1><h2 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1.基本概念"></a>6.1.基本概念</h2><h3 id="6-1-1-校验码"><a href="#6-1-1-校验码" class="headerlink" title="6.1.1.校验码"></a>6.1.1.校验码</h3><p><strong>校验码：校验码是指能够发现或自动纠正错误的数据编码，也称检错纠错编码。具体实现时，校验码会增加一些冗余码，来帮助检验或纠错</strong>。</p><h3 id="6-1-2-码字和码距"><a href="#6-1-2-码字和码距" class="headerlink" title="6.1.2.码字和码距"></a>6.1.2.码字和码距</h3><p><strong>为了实现网络传输，会把原信息进行编码，形成二进制序列，这里就会涉及两个概念。</strong></p><ul><li><strong>码字</strong>：由若干位代码组成的<strong>一个字</strong>称为码字，比如下图中 “00”，“01”。</li><li><strong>码距</strong>：将两个码字逐位比较，<strong>具有不同的位的个数称为两个码字的距离</strong>，比如下图中 “00” 和“10”距离就是 1；<strong>一种编码方法可能有若干合法码字，各合法码字之间的最小距离称为 “码距”</strong>，下图所示编码方案其码距为 1。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915122.png" loading="lazy"></p><p><strong>码距大小与校验码的检错和纠错能力直接相关</strong>。</p><ul><li>码距为 1 <strong>无检错能力</strong>。</li><li>码距大于等于 2 具有<strong>检错能力</strong>。</li><li><strong>码距越大，检错、纠错能力就越强。</strong></li><li>检错能力总大于等于纠错能力。</li></ul><h1 id="6-2-常见校验码"><a href="#6-2-常见校验码" class="headerlink" title="6.2.常见校验码"></a>6.2.常见校验码</h1><h2 id="6-2-1-奇偶校验码"><a href="#6-2-1-奇偶校验码" class="headerlink" title="6.2.1.奇偶校验码"></a>6.2.1.奇偶校验码</h2><p><strong>在原编码的基础上增加一个校验码，它的码距为 2，可以检测出一位错误 (或奇数位错误)，但不能确定出错位置，也不能检测出偶数位出错，增加的冗余位称为奇偶校验位</strong>。</p><p>实现方法：由若干位有效信息（比如 1B，0001 1011），再加上一个二进制位（检验位）组成校验码。如下图所示，<strong>校验位的取值为 0 或 1，它的加入使整个校验码中 “1” 的个数要么是奇数要么是偶数，所以就有两种可选的校验规律</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915807.png" loading="lazy"></p><ul><li><strong>奇校验码</strong>：整个检验码中 “1” 的个数为奇数。</li><li><strong>偶校验码</strong>：整个校验码中 “1” 的个数为偶数。</li></ul><p>举个例子，1001101 的奇校验码和偶校验码设置如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915862.png" loading="lazy">  </p><p>奇偶校验具有很大的局限性，<strong>只能发现数据代码中的奇数位出错的情况</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915796.jpeg" loading="lazy">  </p><p>校验原理：传输前，发送端和接收端会协议确定彼此之间采用奇校验还是偶校验。以偶校验为例，<strong>计算机首先会将二进制所有位进行异或运算，所得结果就是偶校验位</strong>，比如上面信息 “1001101”，进行异或运算“1⊕0⊕0⊕1⊕1⊕0⊕1&#x3D;0”，这表明 1 的个数为偶数个，故偶校验位为 0；<strong>接收端再接受信息后会进行异或运算，一旦结果出现 1 表明错误</strong>，比如上图中第一个例子，再接受到之后进行异或运算 “0⊕1⊕0⊕1⊕1⊕1⊕0⊕1&#x3D;1”，所以结果错误（同时大家也可以发现如果再更改一位为 1，那么最终结果仍然是，这就是奇偶校验的局限性)。</p><h2 id="6-2-海明校验码"><a href="#6-2-海明校验码" class="headerlink" title="6.2.海明校验码"></a>6.2.海明校验码</h2><p>海明码是一种广泛采用的有效的校验码，本质是一种多重奇偶校验码。<strong>其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到奇偶校验组中。当某一位出现错误后，就会引起有关的几个校验位的值发生变化。它不但可以发现错误位置，还可以为自动纠错提供依据。</strong></p><h3 id="6-2-1-纠错理论"><a href="#6-2-1-纠错理论" class="headerlink" title="6.2.1.纠错理论"></a>6.2.1.纠错理论</h3><p><strong>假设信息位为 <code> n</code>，校验位为<code> k</code>，因此 <code> k</code> 个比特位一共可以映射$2^{k} $ 种状态；海明码由信息位和校验位组成，因此共有 $n + k$ 位， $n+k$ 位每一个位置都有可能出现错误，因此这$2^{k} $种状态要把这$n+k $ 种全部映射到，但是要注意其中还要包含一种全部正确的情况。</strong></p><p>综上所述，得出下面的重要不等式：</p><p>$2^{k}\geqslant n+k+1 $</p><h3 id="6-2-2-求解海明码"><a href="#6-2-2-求解海明码" class="headerlink" title="6.2.2.求解海明码"></a>6.2.2.求解海明码</h3><p><strong>范例：求 1010 的海明码</strong>，具体流程如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915363.png" loading="lazy"></p><p><strong>6.2.2.1.确定海明码位数</strong></p><p>此二进制序列信息位$n&#x3D;4$，根据前述不等式 ： $2^{k}\geqslant n+k+1$，可知$ k $ 为 3 时不等式方可成立。</p><ul><li><p>除了实际计算，也可以熟悉下面这张表，从而快速写出  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915112.png" loading="lazy"></p></li></ul><p>为了区分信息位和校验位，我们用$D_{4}D_{3}D_{2}D_{1} $表示<strong>信息位</strong>（对应$1010$）；用 $ P_{3}P_{2}P_{1} $表示<strong>校验位</strong>；整个<strong>海明码</strong>序列可以表示为 $ H_{7}H_{6}H_{5}H_{4}H_{3}H_{2}H_{1} $。</p><p><strong>6.2.2.2.确定校验位分布</strong></p><p><strong>海明码中校验位不能直接放在信息位的头部和尾部</strong>。 </p><p>规定：<strong>校验位 $p_{i}$应该放在海明码 $H_{2^{i-1}} $​的位置</strong>，因此 $P_{1}P_{2}P_{3} $​分别对应 $ H_{1}H_{2}H_{4}$​，其实也就是 2 进制的权值。</p><p>校验位分布如下，首先放入校验位，信息位从低到高依次补全空位。</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td></td><td>0</td><td></td><td></td></tr></tbody></table><p>接下来，<strong>由于校验位为 3 位，因此信息位需要根据校验位分为 3 组，每个分组分别进行偶校验</strong>。</p><p><strong>6.2.2.3.求校验位的值</strong></p><p>首先，<strong>我们需要海明码中对应位置为信息位的下标（也就是所处位置）转为二进制序列</strong>，比如上面表格中，$H_{7} $对应位置为信息，其下标为<code>7 </code>，对应二进制序列为 <code>111</code>。</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>信息位值</strong></td><td>1</td><td>0</td><td>1</td><td></td><td>0</td><td></td><td></td></tr></tbody></table><p><strong>然后我们需要根据二进制序列确定每个校验位所在组包括哪些信息位</strong>。</p><p><strong>前面我们说过， $P_{3}P_{2}P_{1} $实则对应的是二进制的权值<code>421</code>，而分组依据就是根据这个权值，比如 $P_{1} $​表示所有二进制序列第 0 位为 1 的分到该组，  所以 $ H_{3}H_{5}H_{7} $就分到了这一组</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915457.jpeg" loading="lazy"></p><p>分为三个组后，我们就要对每一组进行偶校验。<strong>上面内容提到，偶校验码计算实则通过异或运算完成，因此对每组进行异或运算，确定 <code>P </code> 的取值</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915299.jpeg" loading="lazy">  </p><p>填充表格如下：</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td><strong>0</strong></td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table><p><strong>6.2.2.4.校验纠错</strong></p><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查。这里是偶校验，如果$S_{3}S_{2}S_{1}$​为 “000”，表明无错误。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915348.jpeg" loading="lazy">  </p><p>如果 $ S_{3}S_{2}S_{1}$​为 “010”，表明第 2 位出现错误  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915986.jpeg" loading="lazy">  </p><p>其原理可以用下面的这张图解释。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915616.jpeg" loading="lazy"></p><ul><li>比如$D_{3} $信息位发生变化，由于$D_{3} $包含于 $ P_{2} 和 P_{3} $​，同时 $ P_{2} 和 P_{3}$​又在 $ S_{2}S_{3}$​的校验方程中，导致 $ S_{3}S_{2}S_{1} $为 <code>110 </code>， 也就是$ H_{6} $发生改变。</li><li>再比如校验位 $ P_{2} $发生改变时，其只存在于$S_{2}$的校验方程中，所以 $ S_{3}S_{2}S_{1} $​为 $ 010 $，也就是 $H_{2} $发生改变。</li></ul><h3 id="6-2-2-4-补充-全校验位"><a href="#6-2-2-4-补充-全校验位" class="headerlink" title="6.2.2.4.补充 - 全校验位"></a>6.2.2.4.补充 - 全校验位</h3><p><strong>海明码具有 1 位的纠错能力和 2 位的检错能力</strong></p><p>刚才设计的海明码，在使用时还是有一定问题的，比如发送刚数据为：</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table><p>发送中， $ P_{2}P_{1} $这两个校验位发生改变。</p><table><thead><tr><th>海明码位置</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td><strong>分布情况</strong></td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>0</strong></td><td><strong>1</strong></td></tr></tbody></table><p>那么按照之前的校验规则，$ S_{3}S_{2}S_{1} $的值为 “110”，表明$H_{3} $位置发生错误。很明显发现，判断错误，此时发生的是两个比特位的改变。<strong>所以之前的方案是没有办法区分 1 位错误，还是 2 位错误的。</strong></p><p><strong>为此，在使用时我们在海明码首部加入 “全校验位”，对整体统一进行一次偶校验</strong>。</p><p>发送方数据：</p><table><thead><tr><th>海明码位置</th><th> H8​</th><th> H7​</th><th> H6​</th><th>H5​</th><th>H4​</th><th>H3​</th><th>H2​</th><th>H1​</th></tr></thead><tbody><tr><td>二进制</td><td></td><td>111</td><td>110</td><td>101</td><td></td><td>011</td><td></td><td></td></tr><tr><td><strong>分布情况</strong></td><td>P 全​</td><td>D4​</td><td> D3​</td><td>D2​</td><td>P3​</td><td>D1​</td><td> P2​</td><td>P1​</td></tr><tr><td><strong>海明码</strong></td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td><strong>1</strong></td><td><strong>0</strong></td></tr></tbody></table><ul><li>如果此时接收方校验后 $S_{3}S_{2}S_{1} $的值为 “000”，并且全体偶校验成功，表明没有错误；</li><li>如果$S_{3}S_{2}S_{1}$​的值不为 “000”，并且全体偶校验失败，表明有 1 位错误，纠正即可；</li><li>如果 $S_{3}S_{2}S_{1} $​的值不为 “000”，并且全体偶校验成功，很明显产生了两位错误，此时无法纠正，需要重传。</li></ul><h2 id="6-3-循环冗余校验码（CRC-码）"><a href="#6-3-循环冗余校验码（CRC-码）" class="headerlink" title="6.3.循环冗余校验码（CRC 码）"></a>6.3.循环冗余校验码（CRC 码）</h2><p>举个例子，A 要向 B 传送数据<code>882</code>，为了校验数据是否准确，A 和 B 约定了一个除数<code>7</code>，<code>882</code>除以<code>7</code>是可以出除尽的。在 B 接受到数据之后用，使用 882 除以 7，如果没有余数，表示数据可能正确，<strong>但如果有余数那么一定错误</strong>。</p><p>其实，CRC 的基本思想和刚才的除法思想基本一致。<strong>发送方和接收方提前约定好一个数，作为除数（这里的数自然指的是二进制序列），在 <code>K </code>个信息位后拼接 <code>R</code>个校验位作为被除数（添加校验位需要保证除法余数为 0），接受方在接收到数据之后进行相应除法运算，检查余数是否为 0。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915952.png" loading="lazy"></p><p><strong>一般来说题目会将除数表现一种多项式的形式</strong>，比如：**设多项式 $ G(x)&#x3D;x^{3}+x^{2}+1 $**，信息码为 $101001$，求对应的$ C R C$ 码。</p><p>多项式 $G (x) $的<strong>完整形式</strong>实则为 $G(x)&#x3D;1\times x^{3}+1\times x^{2}+0\times x^{1}+1\times x^{0} $，<strong>取系数</strong>，指明除数为 $1101 $。</p><p><strong>1：确定<code>K</code>、 <code>R </code>以及生成多项式对应的二进制码</strong></p><p>其中 $R&#x3D; 生成多项式最高幂次 &#x3D; 3 $， $K&#x3D; 信息码长度的 &#x3D; 6 $，于是整个编码位数$N&#x3D;K+R&#x3D;9 $<br>多项式$ G (x) $对应二进制码为$ 1101 $</p><p><strong>2：移位</strong></p><p>现在我们要确保添加的 <code>3</code> 位校验位形成的被除数可以整除除数，<strong>因此首先将信息码 <code>101001 </code>左移 R 位，低位补 0，也即 <code>101001000</code>，称其为新信息码。</strong></p><p><strong>3：相除</strong><br>对于新信息码，用生成多项式进行<strong>模 2 除</strong>法，产生余数。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915441.png" loading="lazy"></p><ul><li><p>举个例子，用 1001000 作为被除数，1011 作为除数，模 2 除法为的是求余数，不关心商。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922316.png" loading="lazy"></p><p>首先商为 1，得出结果  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915361.png" loading="lazy"></p><p>此时不应该做减法，而应该做对应为的异或运算  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915631.png" loading="lazy">  </p><p>接着如果高位为 0，就抹去一位，同时后面用被除数的补齐一位  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922276.png" loading="lazy">  </p><p>这里经过异或运算，然后抹位补位得到的结果（比如上图 0100）中，如果首位为 0 就商 0，首位为 1 就商 1  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915177.png" loading="lazy">  </p><p>继续异或，然后抹位，补位后  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915336.png" loading="lazy">  </p><p>继续  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915213.png" loading="lazy">  </p><p>运算到这里，其实可以进行快捷操作。异或后前面有多少 0 都全部扔掉，再从被除数哪里补齐相应位即可。但是这里很明显只能取一个，于是就得到下面的结果，此时也是最终结果，<strong>因为余数位数小于除数</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915005.png" loading="lazy"></p></li></ul><p>好的，回到正题。此时运算出的余数为 001，作为校验位。于是整个 CRC 码即为$信息码 + 校验码 &#x3D; 101001001 $。</p><p><strong>4：检验纠错</strong></p><p>接收方接受到到数据后，使用约定的除数进行模 2 除运算，如果余数为 000，结果正确。<br>如果接收方数据为<code> 101001011</code>（导数第二位出现错误），计算结果为 010，对应是十进制数为 2，表示第二位出现错误，<strong>但是特别注意这只是巧合，出错位置与计算结果没有必然联系，但是也有一定联系</strong>。</p><p>我们把每一个位置出错的情况统计如下，大家可以发现，余数为 3 位最多映射 8 种情况，因此第 1-7 位是属于一个周期，但是从第 8 位又开始了一个新的周期，因此 010 有可能对应第 2 位出错，也有可能是第 9 位  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131915877.png" loading="lazy"></p><p>难道说 CRC 码不能确定出错位置吗？其实也不是的，出现这种情况的原因主要在于信息位过长，无法一一映射。所以要想确定纠错位置就要选择合适的多项式 (纠错 1 位)，具体关系如下面不等式：</p><p>​                                                                    $ 2^{R}\geq K+R+1$</p><p>其实这和海明码类似。但是实际应用中，尤其在网络中主要用来检错。</p><h1 id="7-算数逻辑单元和电路基本知识以及基本逻辑运算和全加器"><a href="#7-算数逻辑单元和电路基本知识以及基本逻辑运算和全加器" class="headerlink" title="7.算数逻辑单元和电路基本知识以及基本逻辑运算和全加器"></a>7.算数逻辑单元和电路基本知识以及基本逻辑运算和全加器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916535.png" alt="image-20230413170602808" loading="lazy"></p><h2 id="7-1-算数逻辑单元-ALU"><a href="#7-1-算数逻辑单元-ALU" class="headerlink" title="7.1.算数逻辑单元 ALU"></a>7.1.算数逻辑单元 ALU</h2><p>数字运算过程中一直离不开一个十分重要的部件——<strong>运算器</strong>，其构成如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916032.png" loading="lazy"></p><p>其中有一个<strong>核心部件——算数逻辑单元 ( Arithmetic and Logic Unit )，也即 ALU</strong>，其作用主要有以下三类</p><ul><li><strong>算数运算</strong>：如加、减、乘、除等。</li><li><strong>逻辑运算</strong>：如与、或、非、异或等。</li><li><strong>辅助功能</strong>：如移位、求补等。</li></ul><p>大家在课本中见到的 ALU 经常会被画成这样：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916244.png" loading="lazy"></p><ul><li>$A_{i}B_{i} $：是<strong>输入信号</strong>，这是一种电信号。通过高低电平，输入不同的电信号。</li><li>$F_{i} $：这是<strong>输出信号</strong>，也就是运算结果。</li><li>$K_{i} $​：这<strong>是控制信号</strong>，由控制单元发出 (CU)；控制单元负责解析指令，比如这个运算是什么类型的运算等等。</li></ul><p>上面是抽象图，下面是一个比较具体的图象，经典的 74181 芯片，是一个 4 位的 ALU  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916276.png" loading="lazy"> </p><p>上面的 M 会指明当前是一个逻辑运算还是算数运算（M&#x3D;1 是逻辑运算，M&#x3D;0 是算数运算)。<strong>总之，ALU 是在输入输出和控制信号下工作的</strong>。</p><h2 id="7-2-最基本的逻辑运算"><a href="#7-2-最基本的逻辑运算" class="headerlink" title="7.2.最基本的逻辑运算"></a>7.2.最基本的逻辑运算</h2><h3 id="7-2-1-与、或、非"><a href="#7-2-1-与、或、非" class="headerlink" title="7.2.1.与、或、非"></a>7.2.1.与、或、非</h3><p><strong>无论是多复杂的逻辑还是算数运算，都是通过最基本的逻辑运算复合而成的，这里最基本的逻辑运算指的是一个位的运算，他们分别是 “与”、“或” 和非。</strong></p><ul><li><strong>与：全 1 才是 1，有 0 就是 0。</strong></li><li><strong>或：全 0 才是 0，有 1 就是 1</strong>。</li><li><strong>非：0 为，1 为 0。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916466.png" loading="lazy"></p><p><strong>上面是从数学抽象的角度来描述的，它们对应的真实电路是如下三个门电路（从左到右依次为：与、或和非）</strong>：</p><ul><li><p><strong>与：只有 A 和 B 全部输入为高电平时，Y 才会是高电平，只要有一个是低电平 Y 就会是低电平。</strong></p></li><li><p><strong>或：如果 A 和 B 输入中有一个是高电平时，Y 就会是高电平，只有全部输入为低电平时，输出才会是低电平</strong>。</p></li><li><p><strong>非：输入的是高输出的就是低，反之亦然</strong> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916740.png" loading="lazy"></p></li></ul><p><strong>另外需要注意这几个运算的表达式：</strong></p><ul><li><strong>与</strong>： $ Y&#x3D;A▪B$</li><li><strong>或</strong>： $ Y&#x3D;A+B$</li><li><strong>非</strong>： $&#x3D;A+\bar{B} $</li></ul><p><strong>其中与的优先级要大于或，也就是对于 $ AB+CD $，要先计算与再计算或，他们也满足一些计算定律</strong>：</p><ul><li><strong>分配律</strong>： $ A(C+D)&#x3D;AC+AD $</li><li><strong>结合律</strong>： $ABC&#x3D;A(BC) $、$A+B+C&#x3D;A+(B+C) $</li></ul><p><strong>在掌握与、或、非这三种基本运算后，我们就可以实现任何一种复杂的逻辑运算了</strong>。</p><p><strong>例如：实现 $ AC+AD$</strong></p><p>这是一个逻辑运算，可以让 A 和 C 以及 A 和 D 分别进行与运算然后结果再进行或运算 。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916389.png" loading="lazy"></p><p>也可以转变为等价的运算，即$A(C+D) $，先让 C 和 D 进行或运算，然后再和 A 进行与运算，这样一来还节省了一个电路元件  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916563.png" loading="lazy"></p><h3 id="7-2-2-与非、或非、异或、同或"><a href="#7-2-2-与非、或非、异或、同或" class="headerlink" title="7.2.2.与非、或非、异或、同或"></a>7.2.2.与非、或非、异或、同或</h3><ul><li><strong>与非：实则是与运算取反；也就是说全 1 则为 0，全 0 则为 1，有 1 则是 1。</strong></li><li><strong>或非：实则是或运算取反；也就是说全 1 则为 0，全 0 则为 1，有 0 则是 0</strong>。</li><li><strong>异或：相同数异或运算结果为 0,0 异或任何数是任何数。</strong></li><li><strong>同或：相同数异或运算结果为 1,1 异或任何数是任何数。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916756.png" loading="lazy"></p><p><strong>他们对应的电路符号分别为</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916619.png" loading="lazy"></p><h2 id="7-3-一位全加器"><a href="#7-3-一位全加器" class="headerlink" title="7.3.一位全加器"></a>7.3.一位全加器</h2><p><strong>一位全加器：一位全加器（FA）是最基本的加法单元，首先注意以下两个概念</strong>。</p><ul><li><strong>本位</strong>：<strong>指的是当前运算的那一位</strong>。</li><li><strong>本位的和</strong>：<strong>包括本位对应的两个数和来自低位向本位的进位。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916443.png" loading="lazy"></p><p><strong>运算时是按照一位一位的方式加的，来自本位的两个数和来自低位的进位会确定本位的和，同时确定向高位进位的数值。</strong></p><p><strong>因此输入共有三个</strong>：</p><ul><li>$A_{i} $和 $B_{i} $以及$ C_{i-1}$</li></ul><p><strong>输出共有两个：</strong></p><ul><li>**第一个是$ S_{i} $**：由于是二进制，因此$ S_{i} $只能是 1 或者是 0，所以就可以使用异或运算确定输入中 1 的奇偶个数，如果有奇数个 1 那么结果为 1，否则为 0，也即$ S_{i}&#x3D;A_{i}⊕B_{i}⊕C_{i-1}$。</li><li><strong>第二个是 $C_{i} $<strong>：</strong>第一种情况</strong>就是 $ A_{i}&#x3D;1 且 B_{i}&#x3D;1 $，那么无论进位为多少都要进一位；<strong>第二种情况</strong>就是$A_{i} 和 B_{i}$中有一个本位为 1 并且来自低位的进位是 1。这两种情况属于或的关系，因此逻辑表达式为：$ C_{i}&#x3D;A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}$</li></ul><p><strong>因此电路表示可以为</strong>  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916294.png" loading="lazy">  </p><p><strong>屏蔽内部实现细节后：</strong>  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916482.png" loading="lazy"></p><h2 id="7-4-串行加法器和并行加法器"><a href="#7-4-串行加法器和并行加法器" class="headerlink" title="7.4.串行加法器和并行加法器"></a>7.4.串行加法器和并行加法器</h2><h3 id="7-4-1-串行加法器"><a href="#7-4-1-串行加法器" class="headerlink" title="7.4.1.串行加法器"></a>7.4.1.串行加法器</h3><p><strong>串行加法器：串行加法器中只有一个全加器，数据会逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算</strong>。</p><ul><li><strong>缺点</strong>：如果操作数为 <code>n</code>位，加法就要分 <code>n </code>次进行，每次产生一位和并且串行逐位送回寄存器中，所以效率非常低。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131916944.png" loading="lazy"></p><h3 id="7-4-2-并行加法器（串行进位）"><a href="#7-4-2-并行加法器（串行进位）" class="headerlink" title="7.4.2.并行加法器（串行进位）"></a>7.4.2.并行加法器（串行进位）</h3><p><strong>串行进位的并行加法器：最简单的并行加法器是串行进位的并行加法器：是将多个加法器串联在一起，这样就能同时输入两个 $n$位的数，每一位都可以使用一个加法器进行就算，且低位加法器产生的进位，会作为下一个高位加法器的输入信号</strong>。</p><ul><li><p><strong>缺陷</strong>：电信号的传递时需要时间的，因此高位的操作会受到低位的限制  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917673.png" loading="lazy"></p></li></ul><h3 id="7-4-3-并行加法器（并行进位）"><a href="#7-4-3-并行加法器（并行进位）" class="headerlink" title="7.4.3.并行加法器（并行进位）"></a>7.4.3.并行加法器（并行进位）</h3><p><strong>并行加法器（并行进位）：与串行进位的并行加法器相比，并行进位的并行加法器的各级进位信号同时生成，即同时进位</strong>。</p><p>如下，记 $G_{i}&#x3D;A_{i}B_{i} $， $P_{i}&#x3D;A_{i}⊕B_{i} $，则由</p><p>$ C_{i}&#x3D;A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}&#x3D;G_{i}+P_{i}C_{i-1} $</p><p><strong>所以 $G_{i} $和 $P_{i}$会被同时送入加法器，大大提高了效率</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917827.png" loading="lazy"></p><h1 id="8-补码加减运算器和标志位的生成"><a href="#8-补码加减运算器和标志位的生成" class="headerlink" title="8.补码加减运算器和标志位的生成"></a>8.补码加减运算器和标志位的生成</h1><h2 id="8-1-补码加减运算器"><a href="#8-1-补码加减运算器" class="headerlink" title="8.1.补码加减运算器"></a>8.1.补码加减运算器</h2><h3 id="8-1-1-补码加-x2F-减法运算规则回顾（即手算方法）"><a href="#8-1-1-补码加-x2F-减法运算规则回顾（即手算方法）" class="headerlink" title="8.1.1.补码加 &#x2F; 减法运算规则回顾（即手算方法）"></a>8.1.1.补码加 &#x2F; 减法运算规则回顾（即手算方法）</h3><ul><li>n bit 补码 $X$+ $Y$：直接按位相加即可。</li><li>n bit 补码 $X$- $Y$：<strong>将$ [Y]_{补} $​全部按位取反，末位 + 1</strong>，得到$ [-Y]_{补} $​，使<strong>减法变为加法</strong>。</li></ul><p><strong>例如：$X&#x3D;-8 $， $Y&#x3D;7 $，即 $ [X]<em>{补}&#x3D;1000 $， $ [Y]</em>{补}&#x3D;0111$，则</strong></p><ul><li>$X+Y&#x3D;1111$</li><li>$ X-Y&#x3D;1000+(1000+1)&#x3D;0001$（溢出）</li></ul><p><strong>例如： $X&#x3D;3 $，$Y&#x3D;4 $，即$ [X]<em>{补}&#x3D;0011$，$ [Y]</em>{补}&#x3D;0100$，则</strong></p><ul><li>$X+Y&#x3D;0111 $</li><li>$X-Y&#x3D;0011+(1011+1)&#x3D;1111$（溢出）</li></ul><h2 id="8-2-补码加减运算器原理"><a href="#8-2-补码加减运算器原理" class="headerlink" title="8.2.补码加减运算器原理"></a>8.2.补码加减运算器原理</h2><h3 id="8-2-1-普通加法器回顾"><a href="#8-2-1-普通加法器回顾" class="headerlink" title="8.2.1.普通加法器回顾"></a>8.2.1.普通加法器回顾</h3><p><strong>下图是前面讲过的普通加法器原理图，并没有实现补码加减功能，其中</strong>：</p><ul><li>$ A$ 和 $B$：这是两个 n bit 的操作数，它们需要按位相加。</li><li>$Cin$：这是来自低位的进位，该进位需要加在 $ A$ 和 $B$ 的最低位。</li><li>$F$：这是运算后产生的结果。</li><li>$Cout $：这是运算后产生的进位，该进位由 $ A$ 和 $B$ 的最高位运算后给出。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917825.png" loading="lazy"></p><h3 id="8-2-2-补码加减运算器"><a href="#8-2-2-补码加减运算器" class="headerlink" title="8.2.2.补码加减运算器"></a>8.2.2.补码加减运算器</h3><p><strong>如下是补码加减运算器，其中红色线上方和普通的加法器是一样的，下方是为实现补码运算所增加的电路。在进行补码运算时，对加减运算的区分会由信号 Sub 给出（0 为加，1 为减），该信号会传送给多路选择器 MUX，让其接通加法或减法电路</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917852.png" loading="lazy"></p><h4 id="8-2-2-1-加法功能"><a href="#8-2-2-1-加法功能" class="headerlink" title="8.2.2.1.加法功能"></a>8.2.2.1.加法功能</h4><p><strong>实现加法功能时，Sub 为 0，多路选择器直接连接 $Y$ 的一端会被选通，让 cin 为 0，然后进行运算即可。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922277.png" loading="lazy"></p><h4 id="8-2-2-2-减法功能"><a href="#8-2-2-2-减法功能" class="headerlink" title="8.2.2.2.减法功能"></a>8.2.2.2.减法功能</h4><p><strong>实现减法功能时，Sub 为 1， $Y$ 会进入带有非门的一端，经过非门后 $Y$ 会被取反，然后让 cin 为 1，相当于取反后再 + 1，接着完成运算即可。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917448.png" loading="lazy"></p><h2 id="8-3-标志位的生成"><a href="#8-3-标志位的生成" class="headerlink" title="8.3.标志位的生成"></a>8.3.标志位的生成</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917021.png" alt="image-20230413170657697" loading="lazy"></p><p><strong>加法器在产生运算结果 $F$ 的同时，还会产生如下 4 个标志位，用于辅助后续运算判断</strong>：</p><ul><li><strong>$OF $（Overflow Flag 溢出标志）：溢出为 1，否则为 0</strong>，<strong>对于无符号数运算，OF没有意义。</strong></li><li><strong>$ SF $（sign Flag 符号标志）：结果是负为 1，否则为 0</strong>，<strong>对于无符号数运算，SF没有意义。</strong></li><li><strong>$ ZF $（Zero Flag 零标志）：运算结果是 0 位 1，否则为 0</strong>，<strong>无符号数和带符号数运算，ZF都有意义。</strong></li><li><strong>$ CF $（Carry Flag进位 &#x2F; 借位标志）：进位 &#x2F; 借位时为 1，否则为 0</strong>，<strong>判断是否发生溢出。</strong></li></ul><h3 id="8-3-1-OF-硬件产生方法"><a href="#8-3-1-OF-硬件产生方法" class="headerlink" title="8.3.1.OF 硬件产生方法"></a>8.3.1.OF 硬件产生方法</h3><p><strong>OF 硬件产生方法：$最高位产生的进位 C_{s} ⊕ 次高位产生的进位C_{1} $</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917468.png" loading="lazy"></p><p><strong>例如</strong>：$ [A+C]<em>{补}&#x3D;0,0001111+0,1111100&#x3D;1,0001011 $，真值 - 117。由于 $C</em>{s}&#x3D;0 $， $ C_{1}&#x3D;1 $，所以溢出。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917366.png" loading="lazy"></p><h3 id="8-3-2-SF-硬件产生方法"><a href="#8-3-2-SF-硬件产生方法" class="headerlink" title="8.3.2.SF 硬件产生方法"></a>8.3.2.SF 硬件产生方法</h3><p><strong>SF 硬件产生方法：它等于最高位的本位和，注意 SF 对无符号数加减无意义</strong>。</p><h3 id="8-3-3-ZF-硬件产生方法"><a href="#8-3-3-ZF-硬件产生方法" class="headerlink" title="8.3.3. ZF 硬件产生方法"></a>8.3.3. ZF 硬件产生方法</h3><p><strong>ZF 硬件产生方法：只有当运算结果所有比特位全为 0 时，ZF 才等于 1</strong>。</p><h3 id="8-3-4-CF-硬件产生方法"><a href="#8-3-4-CF-硬件产生方法" class="headerlink" title="8.3.4. CF 硬件产生方法"></a>8.3.4. CF 硬件产生方法</h3><p><strong>CF 硬件产生方法：$最高位产生的进位 C_{s} ⊕ sub $信号，注意 CF 对有符号数的加减法无意义</strong>。</p><h3 id="8-4-5-总结"><a href="#8-4-5-总结" class="headerlink" title="8.4.5.总结"></a>8.4.5.总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917217.png" loading="lazy"></p><h1 id="9-定点数的移位运算"><a href="#9-定点数的移位运算" class="headerlink" title="9.定点数的移位运算"></a>9.定点数的移位运算</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917274.png" alt="image-20230413172430011" loading="lazy"></p><p><strong>定点数的移位运算：根据操作对象的不同可以划分为</strong></p><ul><li><p><strong>算数移位：</strong> <strong>有符号数</strong>的移位。</p></li><li><p><strong>逻辑移位：</strong> 操作对象是逻辑代码，可视为<strong>无符号数</strong>。</p></li></ul><p><strong>其实我们很早之前就已经接触过移位运算了</strong>。</p><ul><li>比如 $ 985.211 × 10^{1} &#x3D;9852.11 $就相当于小数点右移 <code>1</code> 位。</li><li>比如 $985.211 \div 10^{1}&#x3D;98.5211 $ 就相当于小数点左移 <code>1</code>位。</li></ul><p><strong>移位的本质：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。</strong></p><h2 id="9-1-算数移位"><a href="#9-1-算数移位" class="headerlink" title="9.1.算数移位"></a>9.1.算数移位</h2><p><strong>算数移位：</strong> 算数移位的对象是<strong>有符号数</strong>，在移位的过程中<strong>符号位保持不变</strong>。</p><h3 id="9-1-1-原码的算数移位"><a href="#9-1-1-原码的算数移位" class="headerlink" title="9.1.1.原码的算数移位"></a>9.1.1.原码的算数移位</h3><p><strong>算数右移：</strong></p><ul><li>如果移出去的是 0，那么算数右移相当于<strong>除以了 2。</strong></li><li>如果移出去的是 1，<strong>会丢失精度。</strong></li></ul><p>如下是 - 20 的原码：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917705.png" loading="lazy">  </p><p>算数右移时：<strong>符号位不动，向右移动 1 位，高位补 0</strong>。</p><ul><li><p>由于移出去的是 0，所以 - 20 变为了 - 10,-10 变为了 - 5 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917782.png" loading="lazy"></p></li></ul><p>此时最低位为 1，再次右移一位，其结果为 - 2。</p><ul><li><p>移出去的是 1，精度丢失  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917943.png" loading="lazy"></p></li></ul><p><strong>算数左移：</strong></p><ul><li>如果移出去的是 0，那么算数左移相当于<strong>乘以了 2。</strong></li><li>如果移出去的是非 0，<strong>会丢失精度。</strong></li></ul><p>算数左移时：<strong>符号位不动，低位补 0</strong>。</p><ul><li><p>由于移出去的是 0，所以 - 20 变为了 - 40，-40 变为了 - 80  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917345.png" loading="lazy"></p></li></ul><p>此时最高位为 1，再次左移一位，出现严重误差。</p><ul><li><p>左移时，要将高位的 1 抛弃，而 7 位二进制表示范围为 - 128~128，理想的结果 - 160，自然超出了范围  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131917641.png" loading="lazy"></p></li></ul><h3 id="9-1-2-反码的算术移位"><a href="#9-1-2-反码的算术移位" class="headerlink" title="9.1.2.反码的算术移位"></a>9.1.2.反码的算术移位</h3><p><strong>正数的反码算数移位和原码相同</strong>。</p><p><strong>负数的反码算数移位</strong>：反码除了符号位外其余各位和原码是一一取反的，因此反码的 1 对应原码的 0，反码的 0 对应原码的 1。<strong>所以反码算数右移时高位补 1，低位舍弃；算数左移时低位补 1，高位舍弃</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918673.png" loading="lazy"></p><h3 id="9-1-3-补码的算数移位"><a href="#9-1-3-补码的算数移位" class="headerlink" title="9.1.3.补码的算数移位"></a>9.1.3.补码的算数移位</h3><p><strong>正数的补码算数移位和原码相同。</strong></p><p><strong>负数的补码算数移位</strong>：负数补码是在反码末位 + 1 后得到的，所以这就导致<strong>反码最右边连续的 1 都会因为进位而变为 0，直到进位碰到第一个 0 为止</strong>。因此，负数补码中，<strong>最右边的（最后一个 1）及其右面与原码相同，而其左面则与反码相同。</strong></p><p>因此，<strong>补码算数右移时和反码相同，也即高位补 1，低位舍弃；而算数左移时又会和原码相同，也就是低位补 0，高位舍弃</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918036.png" loading="lazy"></p><h3 id="9-1-4-总结"><a href="#9-1-4-总结" class="headerlink" title="9.1.4.总结"></a>9.1.4.总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918762.png" loading="lazy"></p><h2 id="9-2-逻辑移位"><a href="#9-2-逻辑移位" class="headerlink" title="9.2.逻辑移位"></a>9.2.逻辑移位</h2><p><strong>逻辑移位：</strong> 逻辑移位比较简单，可以看作是<strong>对 “无符号数” 的算数移位。</strong></p><ul><li><p><strong>逻辑右移时高位补 0，低位舍弃。</strong></p></li><li><p><strong>逻辑左移时低位补 0，高位舍弃</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918072.png" loading="lazy"></p></li></ul><h2 id="9-3-循环移位"><a href="#9-3-循环移位" class="headerlink" title="9.3.循环移位"></a>9.3.循环移位</h2><p><strong>循环移位：循环移位分为如下两种</strong></p><ul><li>带<strong>进位标志位 CF</strong> 的循环移位（大循环）。</li><li><strong>不带进行标志位</strong>的循环移位（小循环）。</li></ul><p><strong>循环移位的特点是：移出的数位又被移入数据中，是否需要进位则看有没有将进位标志加入循环位移。循环位移十分适合将数据的低字节和高字节之间进行互换</strong>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918039.png" loading="lazy"></p><h1 id="10-定点数乘法运算（原码-x2F-补码一位乘法）"><a href="#10-定点数乘法运算（原码-x2F-补码一位乘法）" class="headerlink" title="10.定点数乘法运算（原码&#x2F;补码一位乘法）"></a>10.定点数乘法运算（原码&#x2F;补码一位乘法）</h1><h2 id="10-1-乘法运算基本思想"><a href="#10-1-乘法运算基本思想" class="headerlink" title="10.1.乘法运算基本思想"></a>10.1.乘法运算基本思想</h2><p>关定点数的乘法，其实我们在小学就学习过，就是经典<strong>列竖式相乘</strong>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922278.png" loading="lazy"></p><p>其中，我们印象最深的应该就是计算过程中的<strong>错位问题</strong>了。</p><p>在计算机中，相乘时使用的二进制，其基本逻辑和竖式相乘一致。如下是两个二进制数相乘，其中被乘数为<code>0.1101</code>，乘数为 <code>0.1011</code> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918651.png" loading="lazy"></p><p>我们将乘数看作为位权之和，即$ 0.1011&#x3D;1×2^{-1}+0×2^{-2}+1×2^{-3}+1×2^{-4} $。<br>，被乘数写成 $ A$ 与$ 2^{n} $相乘的形式，即 $ 0.1101&#x3D;1101×2^{-4}$。</p><p>那么此乘法过程可以等价为下面的形式  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918767.png" loading="lazy"> </p><p>把竖式写全也就是下面的这个样子  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918421.png" loading="lazy"></p><p><strong>由于二进制的乘数每一位只可能出现 0 或 1，因此每次运算的结果要么是全 0，要么只是被乘数乘以 $2^{n}$，实际结果只是小数点的不同，而计算机处理小数点位置非常方面，使用移位操作即可完成</strong>。</p><h2 id="10-2-原码一位乘法"><a href="#10-2-原码一位乘法" class="headerlink" title="10.2.原码一位乘法"></a>10.2.原码一位乘法</h2><h3 id="10-2-1-实现原理"><a href="#10-2-1-实现原理" class="headerlink" title="10.2.1.实现原理"></a>10.2.1.实现原理</h3><p>逻辑看似很简单，但是如何让机器实现这是一个问题。如果要实现这一问题，必须解决以下三个问题：</p><ul><li>实际数字有正有负，符号位应当如何处理？</li><li>乘积运算时位数扩大很厉害，如何处理？</li><li>每次运算时的结果都要保存下来，如果相加？</li></ul><p>其中符号位很方便处理，符号位 &#x3D; $s &#x3D;x_{s}⊕y_{s} $即可判断，让数值位取绝对值进行乘法运算即可。</p><p><strong>case：机器字长为 $n+1&#x3D;5$位， $ [x]<em>{原}&#x3D;0.1101，[y]</em>{原}&#x3D;0.1011 $，采用原码一位乘法求 $xy $。</strong></p><p>还记得 <a href="">(计算机组成原理) 第一章计算机系统概述 -计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这一节我们讲到过的运算器的组成吗？其中涉及乘法时会用到 $ACC $， $MQ $， $X$ 这三个寄存器  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918572.png" loading="lazy">  </p><p>接下来我们详细叙述一下这个过程。<strong>开始， $X$ 是被乘数， $Y$ 是乘数，因此 $X$ 位于 X 寄存器中， $Y$ 位于 MQ 寄存器中，并且运算开始前要将 ACC 置为 0</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918982.png" loading="lazy"></p><p>对应我们竖式乘法的逻辑，<strong>此时从低位到高位，依次用乘数的每一位乘被乘数</strong>，因此在这里进行第一次运算时我们把 MQ 寄存器中参与运算的那一位方块的颜色加深  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918842.png" loading="lazy">  </p><p><strong>如果当前参与运算的乘数的这一位是 1，则 $ACC $ 加上被乘数；如果当前位是 0，则 $ACC $ 加上 0</strong>，也即<code>(ACC)+(X)-&gt;(ACC)</code>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918152.png" loading="lazy"></p><p>在进行下一位竖式运算时，必须偏移一个位置，对应于计算机处理时则是<strong>让 ACC 和 MQ 中的数据统一逻辑右移一位</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918274.png" loading="lazy"></p><ul><li>这样做本质实现的就是错位相加。</li></ul><p>接着次低位来到了最低位的位置，再次进行<code>(ACC)+(X)-&gt;(ACC)</code>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918007.png" loading="lazy"></p><p>  <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918789.png" loading="lazy">  </p><p>剩余的步骤均重复上述过程。</p><h3 id="10-2-2-手算模拟"><a href="#10-2-2-手算模拟" class="headerlink" title="10.2.2.手算模拟"></a>10.2.2.手算模拟</h3><p>考试的时候，如果出到这样的题目，<strong>具体步骤如下</strong>  ：</p><p>设 $s [X]<em>{原}&#x3D;x</em>{s}$，$ s [Y]<em>{原}&#x3D;y</em>{s}$</p><ol><li>被乘数和乘数均取绝对值参与运算，符号位为 $ x_{s}⊕y_{s}$。</li><li>部分积的长度同被乘数，取 $n+1 $位，以便存放乘法过程中绝对值大于等于的值，初值为<code> 0</code>。</li><li><strong>从乘数的最低位 $y_{n}$​开始判断：若$y_{n}&#x3D;1$，则部分积加上被乘数 $|x| $，然后右移一位；若 $y_{n}&#x3D;0 $，则部分积加上 0，然后右移一位。</strong></li><li>重复步骤 3，判断 $n$次。</li></ol><p>注意：</p><ul><li>由于乘积的数值部分是两数绝对值相乘的结果，<strong>因此原码一位乘法运算过程中的右移均为逻辑右移</strong>。</li><li>考虑到运算时可能出现绝对值大于 1 的情况（但并非溢出），<strong>所以部分积和被乘数取双符号</strong>。</li></ul><p>**case: 设机器字长为 5 位（n+1）, $ x&#x3D;-0.1101$，$ y&#x3D;0.1011$，采用原码一位乘法求解 $xy $**。</p><p>解： $|x|&#x3D;00.1101 $, $ |y|&#x3D;00.1011$，过程如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918065.png" loading="lazy"></p><p>**因此符号位为 $ P_{s}&#x3D;x_{s}⊕y_{s}&#x3D;1&#x3D;1⊕0&#x3D;1 $，得 $ x·y&#x3D;-0.10001111 $**。</p><h1 id="11-补码一位乘法（-Booth算法，考察重点）"><a href="#11-补码一位乘法（-Booth算法，考察重点）" class="headerlink" title="11.补码一位乘法（ Booth算法，考察重点）"></a>11.补码一位乘法（ Booth算法，考察重点）</h1><p>定点数乘法中最有可能考察的便是补码一位乘法。因为机器做加减法时采用的是补码，倘若做乘法前再将补码转为原码，计算完成之后再转化为补码，那就很麻烦了，还不如直接用补码计算。</p><p>补码一位乘法主要分为<strong>校正法和比较法</strong>，校正法了解即可，而比较法（又叫Booth算法）则是考察的重点。具体规则如下：</p><p>①：<strong>被乘数与部分积一般取双符号位，并且符号位参与运算</strong>。</p><ul><li>一个原因是一旦符号位参与运算就一定要使用多符号位，因为一旦溢出，单符号位就会出错</li><li>另一个原因是，补码的右移时要看符号位而定的，如果采用单符号位，一旦数值部分的进位把符号给移掉了，下次移位就不知道该怎么办了。</li></ul><p>②：<strong>乘数取单符号位以决定最后一步是否需要校正，也即是否需要加$[-x]_{补}$​</strong><br>③：<strong>乘数末尾增设辅助位，$y_{n+1} $，初始值为 0</strong><br>④：<strong>根据 ($y_{n} $，$ y_{n+1} $)判断位，进行运算，步骤和上面原码一位乘法一致</strong><br>⑤：<strong>按上述算法进行 n+1, 其中最后一步也即 n+1 步不再移位，仅根据 $ y_{0},y_{1} $​比较结果决定是否需要加减 $ x_[补] $</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918334.png" loading="lazy">  </p><p>从上面图中大家可以看出 MQ 中的最低位现在是辅助位，这里就和原码乘法的最低位不一致了，<strong>所以这里我们用带有双引号的——“最低位” 表示运算时真正的最低位，而不是辅助位</strong></p><ul><li>辅助位<strong>减</strong> “最低位”&#x3D;1 时，$ (ACC)+[x]_{补}$</li><li>辅助位<strong>减</strong> “最低位”&#x3D;0 时，$ (ACC)+0$</li><li>辅助位<strong>减</strong> “最低位”&#x3D;-1 时， $ (ACC)+[-x]_{补}$</li></ul><p>**$case $: 假设机器字长为 5 位（含 1 位符号位，$n&#x3D;4 $）， $x&#x3D;-0.1101$，$y&#x3D;0.1011$，采用 $Booth$ 算法求 $xy $**。</p><p>解：$[x]<em>{补}&#x3D;11.0011$，$ [-x]</em>{补}&#x3D;00.1101$，$ [y]_{补}&#x3D;0.1011 $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131918042.jpeg" loading="lazy"></p><h1 id="12-定点数除法运算（原码-x2F-补码一位除法）"><a href="#12-定点数除法运算（原码-x2F-补码一位除法）" class="headerlink" title="12.定点数除法运算（原码&#x2F;补码一位除法）"></a>12.定点数除法运算（原码&#x2F;补码一位除法）</h1><h2 id="12-1-除法运算基本思想"><a href="#12-1-除法运算基本思想" class="headerlink" title="12.1.除法运算基本思想"></a>12.1.除法运算基本思想</h2><p>关于定点数的除法，我们在小学其实就已经学习过了，就是<strong>列竖式除法</strong>, 比如 $0.211÷0.985 $，我们首先习惯同时扩大 $n$倍。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919136.png" loading="lazy">  </p><p>在上面的例子中， $ 0.211÷0.985&#x3D;0.214 $ 余 210，<strong>它就等价于</strong> $0.211&#x3D;0.985×0.214+0.000210 $，也就是说这可以转为成乘法的，也即  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919337.png" loading="lazy">  </p><p>在计算机中，运算时使用的是二进制，比如$ x&#x3D;0.1011$（被除数），$y&#x3D;0.1101$（除数)， $ x÷y $ 如下：</p><p><strong>运算时忽略小数点，每确定一位商就进行一次减法，得到 4 位余数，在余数末尾补 0，再确定下一位商，确定 5 位商即可停止（这里机器字长是 5 位）</strong>。</p><ul><li>如果补位后所得余数部分大于除数，那么就商 1。</li><li>如果补位后所得余数部分小于余数，那么就商 0。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919520.png" loading="lazy"></p><p>和乘法一样，补全位数后就是下面这样  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919343.png" loading="lazy"></p><p>因此 $x÷y$ 结果为 0.1101，余数为 $0.00000111$。</p><h2 id="12-2-原码一位除法-恢复余数法"><a href="#12-2-原码一位除法-恢复余数法" class="headerlink" title="12.2.原码一位除法(恢复余数法)"></a>12.2.原码一位除法(恢复余数法)</h2><h3 id="12-2-1-实现原理"><a href="#12-2-1-实现原理" class="headerlink" title="12.2.1.实现原理"></a>12.2.1.实现原理</h3><p>逻辑看似很简单，但是如何让机器实现这是一个问题。其中符号位的处理就不用再强调了，和乘法一样，仍然使用异或完成，于是实际运算时采用两个数的绝对值完成。</p><p>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $x÷y$</p><ul><li>$∣x∣&#x3D;0.1011$</li><li>$ |y|&#x3D;0.1101$</li><li>$ [|y|]_{补}&#x3D;0.1101$</li><li>$[-|y|]_{补}&#x3D;1.0011 $</li></ul><p>还记得 <a href="">(计算机组成原理) 第一章计算机系统概述 - 计算机硬件组成 (存储器、运算器和控制器概述及计算机工作过程详解)</a> 这一节我们讲到过的运算器的组成吗，其中涉及除法时会用到 $ACC $， $MQ $， $X$ 这三个寄存器  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919010.png" loading="lazy"></p><p>开始的时候， <strong>$Y$ 是除数，位于 X 寄存器内，ACC 寄存器存放的是被除数（x）或余数，MQ 中存放商，MQ 中灰色加重的方格表示当前要确定的一位商</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919493.png" loading="lazy"></p><p>前面手算时，每一位商到底取 0 还是 1，<strong>是通过判断当前余数和除数的大小确定的</strong>，因此很显然，我们的 ACC 寄存区和 X 寄存区天然就存储了余数和除数。但实际情况是，<strong>计算机并不会进行比较，它会不管三七二十一直接商 1，如果出错再改为商 0，并恢复余数。</strong></p><ul><li>商 1 时，其实就是余数减去除数, 也即是<code>(ACC)-(X)-&gt;ACC</code>。</li></ul><p>于是，这里首先计算机先商 1（但是本应该先商 0），因此此时就会求余数：<code>(ACC)-(X)-&gt;ACC</code>, 也即$[-|y|]_{补} $（计算机依靠加法实现减法），也即$ 01011+10011&#x3D;11110 $。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919072.jpeg" loading="lazy"></p><p><strong>此时符号位 1，计算机察觉错误，于是改为商 0，同时既然是商 0，那么就不应该减去除数，而应该减去 0（什么也不做），所以这里直接采取逆过程，加上除数即可。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919393.jpeg" loading="lazy"></p><p><strong>所以现在我们就完成了一位的商，在手算中，我们商完一位后会错位一位补位，然后再商下一位，而在这里对应的就是将 ACC 和 MQ 中的内容逻辑左移即可</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919526.png" loading="lazy"></p><p>接着计算机再次商 1，此时检查符号位为 0，说明是正的，说明计算机没有商错误，那么不需要恢复余数  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919777.png" loading="lazy"></p><p>剩下的就是不断左移，运算的过程了。 </p><p>最后我们假定的机器字长为 5 位，因此只能求 5 位的商。<strong>不过需要注意的是，如果最后一位商 1 后，导致了 ACC 出现负数，那么仍然需要改为 0，并恢复余数</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919658.png" loading="lazy">  </p><p><strong>最后，我们这里举的例子是小数，所以其小数点的位置隐含在符号位后面。最后实际的余数是 $2^{-n} $（ $n$为机器字长）</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919947.png" loading="lazy"></p><h3 id="12-2-2-手算模拟"><a href="#12-2-2-手算模拟" class="headerlink" title="12.2.2.手算模拟"></a>12.2.2.手算模拟</h3><p>考试的时候，如果出到这样的题目，<strong>具体步骤如下</strong> 。<br>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $x÷y$</p><ul><li>$∣x∣&#x3D;0.1011$</li><li>$ |y|&#x3D;0.1101$</li><li>$ [|y|]_{补}&#x3D;0.1101$</li><li>$[-|y|]_{补}&#x3D;1.0011 $</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922279.png" loading="lazy"></p><h2 id="12-3-原码一位除法：加减交替法（不恢复余数法）"><a href="#12-3-原码一位除法：加减交替法（不恢复余数法）" class="headerlink" title="12.3.原码一位除法：加减交替法（不恢复余数法）"></a>12.3.原码一位除法：加减交替法（不恢复余数法）</h2><p>可以看出恢复余数法实际还是挺繁琐的，主要是当余数为负时，它还要加上除数，恢复到上一状态再左移。</p><p>而加减交替法是恢复余数的优化，具体规则为：<strong>若余数为负，直接商 0，并让余数左移 1 位再加上除数</strong></p><p>$case$ : 设机器字长为 5 位（$ n&#x3D;4$，一位符号位）， $ x&#x3D;0.1011$， $ y&#x3D;0.1101$，采用恢复余数法求 $X$÷ $Y$</p><ul><li>$∣x∣&#x3D;0.1011$</li><li>$ |y|&#x3D;0.1101$</li><li>$ [|y|]_{补}&#x3D;0.1101$</li><li>$[-|y|]_{补}&#x3D;1.0011 $</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922280.png" loading="lazy"></p><p><strong>注意：最后一步如果出现负数，仍然需要恢复余数！！！</strong></p><h2 id="12-4-补码一位除法"><a href="#12-4-补码一位除法" class="headerlink" title="12.4.补码一位除法"></a>12.4.补码一位除法</h2><p>补码除法采用加减交替法完成，与原码除法的有所区别的是：</p><ul><li><strong>符号位参与运算。</strong></li><li>被除数（余数）、除数采用双符号位。</li></ul><p>运算的具体细节区别如下：</p><ul><li>原码除法，首先一上来就会让被除数减去除数的绝对值的补码；<strong>在补码除法中，若被除数和除数同号，则被除数减去除数，如果异号，则被除数加上除数</strong>。</li><li>得到新的余数后判断：<strong>若余数和除数同号，则商 1，余数左移一位减去除数；若余数和除数异号，则商 0，余数左移一位加上除数。</strong></li><li>在原码除法中如果最后一步余数出现负值，那么需要进行恢复余数；<strong>在补码除法中，我们直接把最后一位商置为 1 即可，这样做很省事，其精度也不会超过 $2^{-n} $。</strong></li></ul><p>$case: $设机器字长为 5 位（$ n&#x3D;4$，一位符号位），$+x&#x3D;0.1000 $， $y&#x3D;-0.1011 $，采用补码加减交替法求 $x÷y$</p><ul><li>$ [x]_{补}&#x3D;00.1000 $</li></ul><ul><li>$ [y]_{补}&#x3D;11.0101 $</li><li>$ [-y]_{补}&#x3D;00.1011 $</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922281.png" loading="lazy"></p><p>因此最后的结果$[x&#x2F;y]_{补}&#x3D;1.0101$，余数为 $0.0111×2^{-4} $。</p><h2 id="12-5-总结"><a href="#12-5-总结" class="headerlink" title="12.5.总结"></a>12.5.总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922282.png" alt="image-20230413183656017" loading="lazy"></p><h1 id="13-详解C语言中的强制类型转换"><a href="#13-详解C语言中的强制类型转换" class="headerlink" title="13.详解C语言中的强制类型转换"></a>13.详解C语言中的强制类型转换</h1><h2 id="13-1-无符号数和有符号数"><a href="#13-1-无符号数和有符号数" class="headerlink" title="13.1.无符号数和有符号数"></a>13.1.无符号数和有符号数</h2><p>有如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">short</span> x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span><span class="token comment">//短整型，顶点负整数</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span><span class="token comment">//无符号短整型</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道在计算机中数据是以<a href="https://so.csdn.net/so/search?q=%E8%A1%A5%E7%A0%81&spm=1001.2101.3001.7020">补码</a>的形式保存的，因此变量<code>x</code>的补码形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0001</span> <span class="token number">1111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二句代码进行强制类型转换，把一个有符号转换为了无符号，并用无符号变量保存；<strong>在这个过程中数据的内容是没有被改变的，只是改变了解释的方式</strong>，也就说说变量 y 的内容依然是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1110</span> <span class="token number">1111</span> <span class="token number">0001</span> <span class="token number">1111</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>但是在解释是计算机会把第一位的符号位当作数值位，因此 y 对应的真值是 61215</strong>。</p><h2 id="13-2-长整数变为短整数"><a href="#13-2-长整数变为短整数" class="headerlink" title="13.2.长整数变为短整数"></a>13.2.长整数变为短整数</h2><p>有如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">165537</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token operator">-</span><span class="token number">34991</span><span class="token punctuation">;</span><span class="token comment">//整形</span><span class="token keyword">short</span> c<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span><span class="token keyword">short</span> d<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token comment">//强制类型转换，长整形转为短整型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个例子中短整型为 16 位，整形为 32 位，因此将长整形转换为短整型，短整型的变量肯定不能完全保存，会丢失精度。具体规则为：<strong>高位截断，保留低位</strong>。</p><p>比如 a 的十六进制为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x000286a1</span><span class="token number">0010</span> <span class="token number">1000</span> <span class="token number">0110</span> <span class="token number">1010</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 c 保存后，值为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x86a1</span><span class="token number">1000</span> <span class="token number">0110</span> <span class="token number">1010</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>1000 0110 1010 0001</code>是 c 的补码，属于有符号数，是一个负数，其原码（负数原码等于补码除符号位按位取反后 + 1）为<code>1111 1001 0101 1111</code>，对应真值 - 31071。</p><p>再比如，b 的十六进制为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0xffff7751</span><span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">0111</span> <span class="token number">0111</span> <span class="token number">0101</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 d 保存后，值为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x7751</span><span class="token number">0111</span> <span class="token number">0111</span> <span class="token number">0101</span> <span class="token number">0001</span><span class="token comment">//二进制形式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>0111 0111 0101 0001</code>是 d 的补码，属于有符号数，是一个正数，其原码（正数原码和补码一致）为<code>0111 0111 0101 0001</code>，对应真值 30545。</p><h2 id="13-3-短整数变为长整数"><a href="#13-3-短整数变为长整数" class="headerlink" title="13.3.短整数变为长整数"></a>13.3.短整数变为长整数</h2><p>有如下代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">short</span> x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">4321</span><span class="token punctuation">;</span><span class="token comment">//短整型</span><span class="token keyword">int</span> m<span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment">//使用整形保存短整型</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> n<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span><span class="token comment">//将x强制转为为无符号，然后复制给无符号短整型</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> p <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token comment">//把无符号短整型n变为无符号整形</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这属于之前讲到过的符号扩展问题。<strong>这里 x 是一个负数，所以会在符号位和原有的数值位之间添上 1</strong>，这样做最后的结果不改变，只是补码的长度发生改变  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922283.png" loading="lazy">  </p><p><code>unsigned short n=(unsigned short)x</code>将 x 这个有符号短整型转换为了无符号短整型，<strong>计算机会将其补码原封不动的赋值给 n，但是会按照无符号的规则解析真值</strong>，真值为 61215。</p><p><code>unsigned int p = n</code>属于无符号到无符号的转换，<strong>直接填 0 即可</strong>。  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922285.png" loading="lazy"></p><h1 id="14-数据的存储和排列"><a href="#14-数据的存储和排列" class="headerlink" title="14.数据的存储和排列"></a>14.数据的存储和排列</h1><h2 id="14-1-大小端模式"><a href="#14-1-大小端模式" class="headerlink" title="14.1.大小端模式"></a>14.1.大小端模式</h2><p>在存储数据的时候，数据从低位到高位可以从左到右排列，也可以按从右到左的方式排列。因此，我们无法用最左或最右来表征数据的最高位或最低位，<strong>通常用最低有效字节（$LSB $）和最高有效字节 ( $ MSB $) 来分别表示数的低位和高位</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922286.png" loading="lazy"></p><p><strong>现代计算机基本采用字节编址，即每个地址编号存放一个字节</strong>。不同类型的数据占用的字节数不同，（int 和 float 的数据占用 4 个字节，double 则占用 8 个字节等），但程序中的每个数据只给定了一个地址。假设变量 i 的地址为 80 00H，字节 01H、23H、45H、67H 应该各有一个内存地址，<strong>那么地址 0800H 对应 4 字节中哪字节的地址呢？这就是字节排列顺序的问题了。</strong></p><p><strong>多字节数据都存放在连续的字节序列当中，根据数据中各字节在连续字节序列中的排列顺序不同，可以有两种方式：大端方式（bid endian）和小端方式 (little endian)</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922287.png" loading="lazy"></p><ul><li><strong>大端方式</strong>：按照最高有效字节到最低有效字节的顺序存储数据，符合人类阅读习惯。</li><li><strong>小端方式</strong>：按照最低有效字节到最高有效字节的顺序存储数据。</li></ul><p>也可以这样描述 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922288.png" loading="lazy"></p><ul><li><strong>大端方式</strong>：数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地中；</li><li><strong>小端方式</strong>：数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中</li></ul><p>我们的计算机一般都是小端机，采用小端方式是有好处的，方便计算机处理。</p><p>例如下面机器代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">400</span>d3<span class="token operator">:</span> <span class="token number">01</span> <span class="token number">05</span> <span class="token number">64</span> <span class="token number">94</span> <span class="token number">04</span> <span class="token number">08</span>       add <span class="token operator">%</span> eax<span class="token punctuation">,</span><span class="token number">0x8049464</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>4004d3</code>：十六进制表示的地址。</li><li><code>01 05 43 0b 20 00</code>：指令的机器代码。</li><li><code>add %eax,0x8049464</code>：指令的汇编形式，该指令的操作数是一个立即数<code>0x8049464。</code></li></ul><p>执行指令时，从指令代码的后 4 字节取出该立即数，立即数存放的字节序列为 64H,94H,04H,08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到 08049464H，去掉开头 0，得到值 0x8049464，<strong>在阅读小端存储方式机器代码时，注意是相反顺序</strong>，比如下面：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131922289.png" loading="lazy"></p><h2 id="14-2-内存（边界）对齐"><a href="#14-2-内存（边界）对齐" class="headerlink" title="14.2.内存（边界）对齐"></a>14.2.内存（边界）对齐</h2><p>假设存储字长为 32 位，<strong>可按照字节、半字节和字寻址</strong>。<strong>对于机器字长为 32 位的计算机，数据以边界对齐方式存储，半字地址一定是 2 的整数倍，子地址一定是 4 的整数倍，这样无论所取的数据是字节、半字还是字，均可以一次取出，当存储的数据不满足上述要求时，通常填充空白字节使其符合要求</strong>，典型的以空间换时间的做法。</p><p>如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919060.png" loading="lazy">  </p><p>更多关于内存对齐的问题，可以移步这篇文章 <a href="https://blog.csdn.net/qq_39183034/article/details/116457144?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162823137816780269873401%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162823137816780269873401&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-116457144.pc_v2_rank_blog_default&utm_term=%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90&spm=1018.2226.3001.4450">C 语言重难点：内存对齐和位段</a></p><h1 id="15-浮点数的表示"><a href="#15-浮点数的表示" class="headerlink" title="15.浮点数的表示"></a>15.浮点数的表示</h1><p><strong>浮点表示法是指以适当的方式将比例因子表示在数据中，让小数点的位置根据需要而浮动</strong> 。<br>这样，在位数有限的情况下，即扩大了数的表示范围，又保持了数的有效精度。例如，用定点数表示电子的质量（$9×10^{-28}g $）或太阳的质量（$ 2×3^{33}g $）是非常不方便的。</p><h2 id="15-1-浮点数的表示格式"><a href="#15-1-浮点数的表示格式" class="headerlink" title="15.1.浮点数的表示格式"></a>15.1.浮点数的表示格式</h2><p>在小学学习科学计数时，我们知道对于： $ +302657264526 $这么长的数字可以用科学计数法表示为：  </p><ul><li>$+3.026×10^{11} $</li></ul><p>而浮点数的表示格式与科学计数法有异曲同工之妙  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919061.png" loading="lazy"></p><ul><li><strong>阶码</strong>：反映浮点数的表示范围及小数点的实际位置。</li><li><strong>尾数</strong>：其数值部分的位数 $n$反映了浮点数的精度  。<br>因此，通常浮点数表示为：<br>$N&#x3D;r^{E}×M$</li></ul><p>其中 <code>r</code> 是浮点数阶码的底（隐含），与尾数的基数相同（二进制中 $ r&#x3D;2$），<strong>E 是阶码，是一个常用补码或移码表示的定点整数，M 是尾数，是一个常用原码或补码表示的定点小数。</strong></p><p>因此，这种格式可以这样理解：<strong>尾数给出了一个小数（数符指明其正负性），同时阶码指明了小数点要向前（阶符为负）还是向后（阶符为正）移动几位</strong>。</p><p>$ case1: $: 例如浮点数 a 的阶码（补码）为 $ 0,01 $，尾数（补码）为$ 1.1001$，空间中存储的方式就是下面这样的  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919062.png" loading="lazy"></p><p>a 的阶码对应的真值为 + 1，$尾数对应的真值为 &#x3D;-(  2^{-2}+2^{-3}+2^{-4})&#x3D;- 0.0111 $，则 a 的真值为：$ 2^{1}×(-0.0111)&#x3D;-0.111 $</p><p>$case2 $：例如 b 的阶码（补码）为 0 , 10 0,10 0,10，尾数（补码）为 $ 0.01001$，空间存储如下  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919063.png" loading="lazy"></p><ul><li>上述后面 1 被抛弃了，精度丢失。</li></ul><p>b 的阶码对应真值为 + 2，尾数对应真值为 $ +(2^{-2}+2^{5})&#x3D;+0.01001 $，因此 b 的真值为： $2^{2}×(+0.01001)&#x3D;+1.001 $。</p><h1 id="15-2-浮点数尾数的规格化"><a href="#15-2-浮点数尾数的规格化" class="headerlink" title="15.2.浮点数尾数的规格化"></a>15.2.浮点数尾数的规格化</h1><h2 id="15-2-1-左规和右规"><a href="#15-2-1-左规和右规" class="headerlink" title="15.2.1.左规和右规"></a>15.2.1.左规和右规</h2><p>可以看到，上面的 $case 2 $ 中，由于尾数位数不够，因此最后一位 1 丢失，<strong>导致该种表示方法下的浮点数精度丢失</strong>。就像我们在学习科学计数法的时候要求过的一样，尽量保证不要有$0.003×10^{13} $ 这样的形式出现，必须保证最高位是一个有效位，因为无效的 0 不但不会增加精度，反而会占用位数。</p><p><strong>因此为了提高运算的精度，需要充分利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高数位必须是一个有效值</strong>。非规格化浮点数<strong>需要进行规格化操作</strong>才能变成规格化浮点数。所谓规格化操作，是指通过调整一个非规划浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高位上保证是一个有效值。</p><p>规格化方法主要有两种：</p><ul><li><strong>左规</strong>：<strong>将尾数算数左移一位，阶码就减 1（基数为 2</strong>），<strong>左规可能要进行多次</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919064.png" loading="lazy"></p><ul><li><strong>右规</strong>：当浮点数运算的结果尾数出现溢出（双符号位为 01 或 10）时，<strong>将尾数算数右移一位，阶码加 1（基数为 2 时）</strong> 的方法称为右规，<strong>右规只需进行一次。</strong></li></ul><p>下面是一个需要右规的例子  ：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919065.png" loading="lazy"></p><h2 id="15-2-2-规格化浮点数的特点"><a href="#15-2-2-规格化浮点数的特点" class="headerlink" title="15.2.2.规格化浮点数的特点"></a>15.2.2.规格化浮点数的特点</h2><p>规格化浮点数的尾数 M M M 的绝对值应该满足 $ \frac{1}{r} \leq |M| \leq 1 $，若 <code>r</code>为 2，则有 $ \frac{1}{2} \leq |M| \leq 1 $。规格化表示的尾数形式如下：</p><p><strong>1：原码规格化后</strong></p><p>_规格化的原码尾数，最高数值位一定是 1_。</p><ul><li><strong>正数</strong>：形式为<code>0.1××...×</code>，其最大值表示为<code>0.111...1</code>，最小值表示为<code>0.100...0</code>，尾数的表示范围为 $ \frac{1}{2} \leq M \leq (1-2^{-n}) $</li><li><strong>负数</strong>：形式为<code>1.1××...×</code>，其最大值表示为<code>1.10×××0</code>，最小值表示为<code>1.111...1</code>，尾数的表示范围为 $ -\frac{1}{2} \geq M \geq -(1-2^{-n}) $</li></ul><p><strong>2：补码规格化后</strong></p><p>_规格化的补码尾数，符号位与最高数值位一定相反_。</p><ul><li><strong>正数</strong>：形式为<code>0.1××...×</code>，其最大值表示为<code>0.111...1</code>，最小值表示为<code>0.100...0</code>，尾数的表示范围为 $ \frac{1}{2} \leq M \leq (1-2^{-n}) $。</li><li><strong>负数</strong>：形式为<code>1.0××...×</code>，其最大值表示为<code>1.01×××1</code>，最小值表示为<code>1.00...0</code>，尾数的表示范围为 $-1 \leq M \leq -(\frac{1}{2}+2^{-n}) $。</li></ul><p>$ case3：$若某浮点数的阶码，尾数用补码表示，共 4+8 位：<code>0.110;1.1110100</code>，问如何规格化？</p><p>答：在这个例子中，阶数为 + 6，前面说过我们规定规格化的补码尾数的负数形式一定为<code>1.0××...×</code>，因此可以将<code>1.1110100</code>算数左移三位（补码的算数左移是低位补 0，算数右移是高位补 1），结果为<code>1.010000</code>，阶码变为 + 3。</p><h2 id="15-3-浮点数表示范围（408-考试大纲已删除）"><a href="#15-3-浮点数表示范围（408-考试大纲已删除）" class="headerlink" title="15.3.浮点数表示范围（408 考试大纲已删除）"></a>15.3.浮点数表示范围（408 考试大纲已删除）</h2><p>如下图所示，运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称为上溢。<strong>数据一旦产生上溢，计算机必须进行中断操作，进行溢出处理</strong>。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919066.png" loading="lazy"></p><p>当运算结果在 0 到最小正数之间时称为正下溢，在 0 到绝对值最小负数之间时称为负下溢，正下溢和负下溢统称为下溢，<strong>数据下溢时，浮点数区域 0，计算机仅将其当做机器零处理</strong>。</p><h1 id="16-IEEE754标准"><a href="#16-IEEE754标准" class="headerlink" title="16.IEEE754标准"></a>16.IEEE754标准</h1><h2 id="16-1移码"><a href="#16-1移码" class="headerlink" title="16.1移码"></a>16.1移码</h2><h3 id="16-1-1-移码回顾"><a href="#16-1-1-移码回顾" class="headerlink" title="16.1.1.移码回顾"></a>16.1.1.移码回顾</h3><p>本节内容涉及移码，有关移码的基础内容请移步</p><blockquote><p><a href="">(计算机组成原理) 第二章数据的表示和运算 - 定点数的表示（原码、反码、补码和移码）</a></p></blockquote><h3 id="16-1-2-偏置值"><a href="#16-1-2-偏置值" class="headerlink" title="16.1.2.偏置值"></a>16.1.2.偏置值</h3><p>前面我们说过：<strong>移码是在补码的基础上将符号位取反得到的。</strong></p><p>其实移码的真正定义为：<strong>移码 &#x3D; 真值 + 偏置值</strong>，只不过前面的讲述中我们的偏置值取定为了$2^{7}&#x3D;128$，也即 1000 0000。所以，假如真值为 - 127，也即 1000 0001，那么其所对应的移码就是 1000 0001+1000 0000&#x3D;0000 0001。其余数值也是这样，从下面的表格中可以看出，移码只是将补码的符号位取反了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131919067.png" loading="lazy"></p><p>其实，偏置值也是可以设置为其他值的。<strong>比如今天我们学习的浮点数当中的 IEEE754 标准中，就用移码表示阶码，其偏置值取$ 2^{n-1}-1$，也即 0111 1111（127）。</strong></p><p>这样的偏置值就导致移码会产生两个非常特殊的状态：<strong>1111 1111 和 0000 0000（真值 - 128 和 - 127），它们都对应无符号数 255；从真值 - 126 开始，对应无符号数 1，一直到无符号数 254</strong>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920163.png" loading="lazy"></p><h2 id="16-2-IEEE-754-标准"><a href="#16-2-IEEE-754-标准" class="headerlink" title="16.2.IEEE 754 标准"></a>16.2.IEEE 754 标准</h2><h3 id="16-2-1-IEEE-754-标准格式"><a href="#16-2-1-IEEE-754-标准格式" class="headerlink" title="16.2.1.IEEE 754 标准格式"></a>16.2.1.IEEE 754 标准格式</h3><p>IEEE 754 将浮点数分为<strong>短浮点数、长浮点数和临时浮点数</strong>三类，C 语言遵循这个标准，因此它们分别对应<code>float</code>、<code>double</code>和<code>long double。</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920765.png" loading="lazy"></p><ul><li><strong>数符</strong>：表示了整个浮点数的正负性。</li><li><strong>阶码</strong>：采用移码表示，<strong>并且短浮点数的偏置值为 127</strong>。所以原本 8 位的移码表示的真值范围为 - 128~127，但是 127 的偏置值会使真值 - 127 和 - 128 较为特殊，其移码是全 0 和全 1，全 0 和全 1 在该标准下具有特殊作用，<strong>所以实际上 8 位的阶码表示真值的范围应该是 - 126 到 127</strong>。</li><li><strong>尾数</strong>：注意采用原码表示。并且我们知道使用原码表示浮点需要进行规格化，也就是最高位格式应该是<code>1.M</code>，<strong>所以短浮点数这里尾数部分写的虽然是 23 位，但是实则是 24 位</strong>，一位暗含。</li></ul><h3 id="16-2-2-转换方法"><a href="#16-2-2-转换方法" class="headerlink" title="16.2.2.转换方法"></a>16.2.2.转换方法</h3><p>我们知道移码等于真值阶码 + 偏置值，那么自然而然阶码真值 &#x3D; 移码 - 偏置值  。<br>因此 IEEE 754 标准中，规格化的短浮点数和长浮点数的真值分别为：<br>$ (-1)^{s}×1.M×2^{E-127} $                                </p><p>$ (-1)^{s}×1.M×2^{E-1023} $</p><p>上式中， $s&#x3D;0$ 表示正数，$ s&#x3D;1$ 表示负数。</p><p><strong>$ case:$ 将十进制数 - 0.75 转化为 IEEE 754 的单精度浮点数格式表示（十进制转换为浮点数）</strong><br>答：转换步骤如下</p><ul><li><strong>将十进制数转化为二进制数并规格化</strong>： $ (-0.75)<em>{10} \xrightarrow{转换为二进制}(-0.11)</em>{2} \xrightarrow{浮点数规格化}(-1.1)_{2}×2^{-1}$</li><li><strong>确定数符号</strong>：可以看出是负数，因此数符为 1。</li><li><strong>确定尾数部分</strong>：前面说过暗含了高位为 1，因此尾数部分是<code>.100000...</code></li><li><strong>确定阶码真值</strong>：基数指数部分是 - 1，因此阶码真值是 - 1。</li><li><strong>确定偏移值</strong>：127</li><li><strong>确定移码</strong>：移码 &#x3D;-1+ 0111 1111&#x3D;0111 1110（126，注意凑够 8 位）。</li><li><strong>最终形式</strong>（红色是数符，蓝色是阶码，绿色是尾数）：1 01111110 10000000000000000000000000000000。</li></ul><p><strong>$case$：IEEE 754 的单精度浮点数 C0 A0 00 00 的值为多少</strong> ?</p><p>答：转换步骤如下：</p><ul><li><strong>将十六进制转化为二进制</strong>（红色是数符，蓝色是阶码，绿色是尾数）：1100 0000 1010 0000 0000 0000 0000 0000</li><li><strong>数符为 1</strong>：这是个负数</li><li><strong>确定尾数部分</strong>：<code>.01000</code>，因此尾数真值为 $1.01_{2} $</li><li><strong>确定移码</strong>：是<code>10000001</code>，可看作无符号数 129</li><li><strong>确定偏移值</strong>：127</li><li><strong>确定阶码真值</strong>：$阶码真值 &#x3D; 移码 - 偏移值 &#x3D; 1000 0001-0111 1111&#x3D;(0000 0010)<em>{2} &#x3D;  (2)</em>{10} $</li><li><strong>确定浮点数真值</strong>：根据公式 $ (-1)^{s}×1.M×2^{E-127} $，可得真值 &#x3D;$ (-1)^{1}×(1.01)_{2}×2^{129-127}$。</li></ul><h3 id="16-2-3-表示范围"><a href="#16-2-3-表示范围" class="headerlink" title="16.2.3.表示范围"></a>16.2.3.表示范围</h3><p>IEEE 754 单精度浮点型表示的最小绝对值和最大绝对值。</p><ul><li><strong>最小绝对值</strong>：尾数全为 0，阶码真值最小为 - 126，对应机器数为 0000 0001，此时整体的真值为 $(1.0)_{2}×2^{-126}$</li><li><strong>最大绝对值</strong>：尾数全为 1，阶码真值最大为 - 127，对应机器数为 1111 1110，此时整体的真值为$ (1.111….11)_{2}×2^{127} $。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920285.png" loading="lazy"></p><p>当然即便这样，还是有溢出的问题的，<strong>因此前面提到的阶码全 0 和全 1 就派上用途了。</strong></p><ul><li>当阶码全为 0，尾数不全为 0 时，表示<strong>非规格化小数</strong>，也即$ (+&#x2F;-)(0.××××)_{2}×2^{-126} $，阶码的隐含最高位为 0。</li><li>当阶码全为 0，尾数全为 0 时，表示<strong>真值正负 0。</strong></li><li>当阶码全为 1，尾数全为 0 时，<strong>表示无穷大（正负）。</strong></li><li>当阶码全为 1，尾数不全为 0 时，<strong>表示非数值 NaN（Not a Number）</strong>，比如 0&#x2F;0。</li></ul><h1 id="17-浮点数加减运算"><a href="#17-浮点数加减运算" class="headerlink" title="17.浮点数加减运算"></a>17.浮点数加减运算</h1><h2 id="17-1-以十进制下的科学计数法的加减运算为例说明浮点数加减运算"><a href="#17-1-以十进制下的科学计数法的加减运算为例说明浮点数加减运算" class="headerlink" title="17.1.以十进制下的科学计数法的加减运算为例说明浮点数加减运算"></a>17.1.以十进制下的科学计数法的加减运算为例说明浮点数加减运算</h2><p>比如有浮点数 $ 9.85211×10^{12}+9.96007×10^{10} $，其运算基本步骤如下：</p><p><strong>1：对阶</strong><br>所谓对阶就是对齐两个浮点数的阶数，由于计算机内部尾数是定点小数，<strong>所以对阶是一律向大阶看齐</strong><br>也即 $ 9.85211×10^{12}+0.0996007×10^{12} $。</p><p><strong>2：尾数相减</strong><br>也即 $ 9.9517107×10^{12} $。</p><p><strong>3：规格化</strong><br>由于我们已经对阶了，所以这里就不用规格化了。</p><ul><li>如果尾加减出现了 $ 0.0099517×10^{12} $，就需要左规；如果尾数加减出现了 $99.517107×10^{12} $时，需要右规。</li></ul><p><strong>4：舍入</strong><br>假如规定了机器只能保持 6 位有效尾数，<strong>则 $ 9.9517107×10^{12}$中多余尾数部分应该砍掉</strong>，也即 $ 9.95171×10^{12} $。</p><ul><li>也可以采用四舍五入，也即 $9.95171×10^{12} $。</li><li>也可以采用 “若砍掉部分非 0，则入 1” 的原则，即 $ 9.95172×10^{12}$。</li></ul><p><strong>5：判溢出</strong><br><strong>假如规定了阶码不能超过两位，若运算后的阶码超出范围则溢出</strong>。比如 $ 9.85211×10^{99}+9.96007×19^{99}&#x3D;19.81218×10^{99} $，规格化后并采用四<br>舍五入原则保留 6 位尾数得：$ 1.98122×10^{100} $，因此这里产生了溢出。</p><ul><li>需要注意的是<strong>尾数溢出并不是真正的溢出</strong>，因为有可能通过规格化来拯救。</li></ul><h2 id="17-2-浮点数的加减运算（不舍入）"><a href="#17-2-浮点数的加减运算（不舍入）" class="headerlink" title="17.2.浮点数的加减运算（不舍入）"></a>17.2.浮点数的加减运算（不舍入）</h2><p><strong>$ case$：已知十进制数 $X&#x3D;-\frac{5}{256}$、 $ Y&#x3D;+\frac{59}{1024} $，按机器补码浮点运算规则计算$ X-Y $，结果用二进制表示，浮点数格式如下</strong>：</p><ul><li>阶符 2 位、阶码 2 位、数符 2 位、尾数 9 位。</li></ul><p><strong>预备步骤 1：格式转换</strong></p><ul><li><strong>对于$ X&#x3D;-\frac{5}{256}$​</strong>：其中分子 $ (101)_{2}$​，而 $ \frac{1}{256}&#x3D;2^{-8} $，因此 $ X&#x3D;-101× 2^{-8}&#x3D;-0.101×2^{-5}&#x3D;-0.101×2^{-101} $</li><li>**对于 $Y&#x3D;+\frac{59}{1024} $**：其中分子 $ 59&#x3D;(111011)_{2} $​，而 $ \frac{1}{1024}&#x3D;2^{-10} $，因此 $ Y&#x3D;+111011×2^{-10}&#x3D;+0.111011×2^{-4}&#x3D;+0.111011×2^{-100} $。</li></ul><p><strong>预备步骤 2：确定浮点数</strong></p><p>题目规定：阶符 2 位、阶码 2 位、数符 2 位、尾数 9 位。</p><p>①：对于 $X$</p><ul><li><strong>阶码</strong>：其阶码部分为 $-5 $，对应原码为 $ 1101 $，对应补码为 $1011 $，因为阶符 2 位、阶码 3 位，因此必须增添 1 位，采用双符号位，<strong>也即补码为 11011 11011 11011;</strong></li><li><strong>尾数</strong>：其尾数部分为$-0.101 $，对应原码为 $ 1.101 $，对应补码为$ 1.011 $, 因为数符 2 位、尾数 9 位，因此必须增添 1 位，采用双符号位，也即补码为$ 11.011 $, 再进行符号扩展，<strong>也即补码为 $11.011000000$。</strong></li></ul><p>因此 $X$ 的浮点数形式为：11011，11.011000000。</p><p>②：对于 $Y$</p><ul><li><strong>阶码</strong>：其阶码部分为 $-4 $，对应原码为 1100，对应补码为 $1100 $，因为阶符 2 位、阶码 3 位，因此必须增添 1 位，采用双符号位，<strong>也即补码为 $11100 $</strong></li><li><strong>尾数</strong>：其尾数部分为$+0.111011$, 对应原码为 $ 0.111011 $，对应补码为$ 0.111011 $，因为数符 2 位、尾数 9 位，因此必须增添 1 位，采用双符号位，也即补码为 $ 00.111011 $，再进行符号扩展，<strong>也即补码为 $00.111011000 $。</strong></li></ul><p>因此 $Y$ 的浮点数形式为：11100，00.111011000。</p><p><strong>第一步：对阶</strong>：<strong>使两个数的阶码相等，小阶向大阶看齐。</strong></p><ul><li><strong>求阶差（减法采用加法实现）</strong>：$ [\Delta E]_{补}&#x3D;11011+00100&#x3D;11111 $，也即 11001 11001 11001，也就是 $− 1 $，这意味着 $X$ 的阶数要比 $Y$ 低一阶。</li><li>**对阶 (小的对齐，尾数每右移一位，阶码就加 1)**：因此 $X$ 尾数部分右移一位，同时注意阶码部分 + 1，也即 11011，11.011000000—–&gt;11100，11.101100000。</li></ul><p><strong>第二步：尾数相减</strong>：</p><ul><li>**先求出 - $Y$**：$ [-Y]_{补}&#x3D;11100,11.000101000$。</li><li><strong>再尾数相减</strong>： 因此尾数部分 $ X-Y&#x3D;11.101100000+11.000101000&#x3D;10.110001000 $（根据之前我们学习的双符号位的运算规则，大家可以发现此时其实已经溢出了），<strong>因此 $ X-Y&#x3D;11100,10.110001000 $。</strong></li></ul><p><strong>第三步：规格化</strong>：</p><p>尾数采用双符号位的好处就是，我们可以通过右规的操作挽救刚才的溢出 <strong>，算数右移时小数点前的 0 会被移动到小数点后面，补多少看双符号位的高位，因为双符号位的高位表示的是正确的本应该得到的符号，因此这里补 1</strong>，同时右移不要忘记啊阶码 + 1。</p><p>因此：11100，10.110001000—–&gt;11101，11.011000100</p><p><strong>第四步：舍入</strong>：</p><p>这个例子中算数右移时, 抛弃了最低位的 0，0 对精度没有任何影响，因此不舍入（后面会有一个需要舍入的例子）。</p><p><strong>第五步：判断溢出</strong>：</p><p>由于阶码采用双符号位，因此我们只需要让其 + 1，如果相同那么没有溢出，在这个例子中很明显没有溢出。</p><p><strong>收尾步骤：翻译真值</strong></p><p>$X-Y&#x3D; 11101,11.011000100$</p><ul><li>阶码：$ 2^{-3} $</li><li>尾数： $ -0.1001111 $</li></ul><p>因此 $ 2 X-Y&#x3D;2^{-3}×(-0.1001111)_{2}$</p><h2 id="17-3-浮点数的加减运算（舍入）"><a href="#17-3-浮点数的加减运算（舍入）" class="headerlink" title="17.3.浮点数的加减运算（舍入）"></a>17.3.浮点数的加减运算（舍入）</h2><p>前面的所有例子中都没有涉及到舍入这个步骤。浮点数加减运算舍入有两种：</p><ul><li><strong>舍 “0” 入“1”</strong>：类似于十进制中的四舍五入，<strong>即在尾数右移时，被移去的最高数位为 0，则舍去；被移去的最高数值位为 1</strong>，则在尾数的末位加 1，这样做可能会使尾数又溢出，此时需要再做一次右规。</li></ul><p>比如某次尾数相减结果：$X-Y&#x3D;11100,10.110001011 $，此时产生溢出，接着进行右规结果为 11101,11.011000101 1(抛弃)，由于这一位抛弃的是 1，因此再继续加 1，正确结果就为 11101,11.011000110 1(抛弃)（如果加上之后还要进位，可能导致又溢出，再进行右规即可）；如果舍弃的是 0 就不用加了。</p><ul><li><strong>恒置 “1” 法</strong>：尾数右移时，<strong>不论丢掉的最高数值位是 “1” 还是“0”，都使右移后的尾数末尾恒置为“1”</strong>。这种方法同样有可能使尾数变大或变小。</li></ul><h2 id="17-4-浮点数强制类型转换"><a href="#17-4-浮点数强制类型转换" class="headerlink" title="17.4.浮点数强制类型转换"></a>17.4.浮点数强制类型转换</h2><p>C 语言中的<code>float</code>和<code>double</code>类型分别对应于 IEEE 754 单精度浮点数和双精度浮点数。<code>long double</code> 类型对应于扩展双精度浮点数，但是<code>long double</code>的长度和格式会随编译器和处理器类型的不同而与所不同。</p><p>在 C 程序中等式的赋值和判断常会强制类型转换，以下两种最为常见，<strong>其最前到后范围和精度都从小到大，转换过程没有损失</strong></p><ul><li><code>char</code>-&gt;<code>int</code>-&gt;<code>long</code>-&gt;<code>double</code></li><li><code>float</code>-&gt;<code>double</code></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304131920412.png" loading="lazy"></p><ul><li>从<code>int</code>转换为<code>float</code>时，虽然不会发生溢出，但是<code>int</code>可以保留 32 位，<code>float</code>保留 24 位，可能有数据舍入；若<code>int</code>转换为<code>double</code>则不会出现这种情况。</li><li>从<code>int</code>或 float 转化为<code>double</code>时，由于<code>double</code>有效位数更多，因此能够保留精度。</li><li>从<code>double</code>转换<code>float</code>时，由于<code>float</code>表示的范围更小，因此可能发生溢出。此外，由于有效位数变少，因此可能被舍入。</li><li>从<code>float</code>或<code>double</code>转换为 int 时，由于<code>int</code>没有小数部分，所以数据可能会向 0 方向被截断（仅保留整数部分），影响精度，同时由于<code>int</code>的表示范围更小，因此可能发生溢出。</li></ul><p>类型转换是一个让人很恼火的话题，如果处理不正确，极容易出现 bug。</p>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组-第一章 计算机发展历程</title>
      <link href="/posts/c441e7e0/"/>
      <url>/posts/c441e7e0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-计算机发展历程"><a href="#1-计算机发展历程" class="headerlink" title="1.计算机发展历程"></a>1.计算机发展历程</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121446238.png" alt="image-20230412144653181" loading="lazy"></p><h2 id="1-1-计算机硬件的发展"><a href="#1-1-计算机硬件的发展" class="headerlink" title="1.1.计算机硬件的发展"></a>1.1.计算机硬件的发展</h2><p><strong>①：电子管时代：第一代计算机（1946-1957 年）</strong></p><p>逻辑元件采用电子管；使用机器语言进行编程；主存用延迟线或磁鼓存储信息，容量极小；体积庞大，成本高；运算速度较低，一般只有几千次到几万次每秒。</p><hr><p><strong>②：晶体管时代：第二代计算机（1958-1964 年）</strong></p><p>逻辑元件采用晶体管；运算速度提高到几万次到几十万次每秒；主存使用磁芯存储器；计算机软件也得到了发展，开始出现了高级语言及其编译程序，有了操作系统的雏形。</p><hr><p><strong>③：中小规模集成电路时代：第三代计算机（1965-1971 年）</strong></p><p>逻辑元件采用中小规模集成电路：半导体存储器开始取代磁芯存储器；高级语言发展迅速，操作系统也进一步发展，开始有了分时操作系统。</p><hr><p><strong>④：超大规模集成电路时代：第四代计算机（1927 年 - 现在）</strong></p><p>逻辑元件采用大规模集成电路和超大规模集成电路，产生了微处理器：诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中。</p><hr><p><strong>⑤：智能计算机</strong></p><p>具备人工智能，运算速度极快，软件系统能够处理知识信息，以<strong>神经网络计算机</strong>为代表。</p><hr><p><strong>⑥：生物计算机和量子计算机</strong></p><ul><li><p>生物计算机是指使用生物分子或细胞作为计算元件的计算机。生物计算机的运算方式与传统的计算机不同，它们利用生物分子的结构和运动来进行计算，从而实现高效的计算能力。生物计算机具有较低的功耗和较长的计算时间，但它们需要更为复杂的技术和材料来实现。</p></li><li><p>量子计算机是指使用量子比特 (qubit) 来进行计算的计算机。与传统计算机使用的二进制比特 (bit) 不同，量子比特可以处于多种状态的叠加态，这种叠加态可以在量子计算机中实现高效的并行计算。量子计算机的运算速度非常快，但目前尚处于研究和开发阶段，需要解决许多技术难题才能实现。</p></li></ul><hr><h2 id="1-2-计算机元件的更新换代"><a href="#1-2-计算机元件的更新换代" class="headerlink" title="1.2.计算机元件的更新换代"></a>1.2.计算机元件的更新换代</h2><p><strong>注意以下三点或概念即可</strong>：</p><ul><li><strong>摩尔定律：</strong> 每平方英寸电路板上的晶体管数量<strong>每 18 个月</strong>翻一番。</li><li><strong>微处理器的出现和发展</strong>：自1971年Intel公司开发出第一个微处理器<code>Intel4004</code>至今，微处理器经历了<code>Intel8008（8位）</code>、<code>Intel8086（16位）</code>、<code>Intel80386（32位）</code>、<code>Pentium（32位）</code>、<code> Pentium III（64位）</code>、<code>Pentium4（64位）</code>、<code>Core i7（64位）</code>等。这里的32位、64位指的是机器字长，是指<strong>计算机进行一次整数运算所能处理的二进制数据的位数</strong>。</li><li><strong>半导体存储器的发展：</strong> 1970年，仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11代：单芯片1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB和现在的1GB。</li></ul><h2 id="1-3-计算机软件的发展"><a href="#1-3-计算机软件的发展" class="headerlink" title="1.3.计算机软件的发展"></a>1.3.计算机软件的发展</h2><p><strong>计算机语言的发展</strong>： 机器语言 - 汇编语言 - 高级语言。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033369.png" alt="image-20230416203359301" loading="lazy"></p><p><strong>操作系统的发展</strong>：例如 DOS，Windows，MAC 等等。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034743.png" alt="image-20230416203429681" loading="lazy"></p><h2 id="1-4-计算机的分类与发展方向"><a href="#1-4-计算机的分类与发展方向" class="headerlink" title="1.4.计算机的分类与发展方向"></a>1.4.计算机的分类与发展方向</h2><h3 id="1-4-1-分类"><a href="#1-4-1-分类" class="headerlink" title="1.4.1.分类"></a>1.4.1.分类</h3><p><strong>电子计算机</strong></p><ul><li>电子模拟计算机</li><li>电子数字计算机</li></ul><p><strong>数字计算机</strong></p><ul><li>专用计算机</li><li>通用计算机</li></ul><p><strong>通用计算机</strong></p><ul><li>巨型机</li><li>大型机</li><li>中型机</li><li>小型机</li><li>微型机</li><li>单片机</li></ul><p><strong>依照指令与数据流划分：</strong></p><ul><li><strong>单指令流与单数据流（SISD）</strong>：冯诺依曼体系结构。</li><li><strong>单指令流与多数据流（SIMD）</strong>：阵列存储器与向量存储器。</li><li><strong>多指令流与单数据流（MISD）</strong>：不存在。</li><li><strong>多指令流与多数据流（MIMD）</strong>：多处理器和计算机系统。</li></ul><h3 id="1-4-2-发展方向"><a href="#1-4-2-发展方向" class="headerlink" title="1.4.2.发展方向"></a>1.4.2.发展方向</h3><p><strong>两极化发展方向</strong></p><ul><li><strong>微型计算机：微型化、网络化、高性能、多用途。</strong></li><li><strong>巨型计算机：巨型化、超高速、并行处理、智能化。</strong></li></ul><h1 id="2-计算机硬件的基本组成"><a href="#2-计算机硬件的基本组成" class="headerlink" title="2.计算机硬件的基本组成"></a>2.计算机硬件的基本组成</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121452420.png" alt="image-20230412145256346" loading="lazy"></p><h2 id="2-1-冯诺依曼机特点"><a href="#2-1-冯诺依曼机特点" class="headerlink" title="2.1.冯诺依曼机特点"></a>2.1.冯诺依曼机特点</h2><ol><li>计算机硬件系统由<strong>运算器、存储器、控制器、输入和输出设备</strong> 5 部分组成。</li><li><strong>指令和数据</strong>以同等地位存储在<strong>存储器</strong>，并可按<strong>地址</strong>寻访。</li><li>指令由<strong>操作码和地址码</strong>组成，操作码用于表示这是一个<strong>什么类型的操作</strong>，地址码用于表示<strong>操作数在存储器中的存放位置。</strong></li><li>指令在存储器内<strong>按顺序存放</strong>（一般情况下是这样的，但在特定条件下也可以进行设定）。</li><li><strong>早期的冯诺依曼机器以运算器为中心</strong>，输入输出设备通过运算器与存储器传送数据。</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450055.png" alt="image-20230412145004989" loading="lazy"></p><ul><li>上图中，<strong>实线是数据线，虚线是控制线</strong>（双向）。</li></ul><p><strong>冯诺依曼机缺陷（早期）</strong></p><p>在控制器的指挥下，输入和输出设备输入一些数据交给运算器进行运算，如果产生中间结果，就会传送给存储器，计算完成后最终结果会给输出设备。<strong>可以发现这种层次结构容易受到输入和输出设备的牵制，因为他们的速度相较于运算器太慢了（短板效应）。</strong></p><h2 id="2-2-现代计算机的组织结构"><a href="#2-2-现代计算机的组织结构" class="headerlink" title="2.2.现代计算机的组织结构"></a>2.2.现代计算机的组织结构</h2><p>为了解决 I&#x2F;O 设备的速度和 CPU 速度差异悬殊的问题，<strong>现如今的计算机则采用以存储器为中心的计算机组织结构</strong>，这种结果使 I&#x2F;O 操作尽可能绕过 CPU，直接<strong>在 I&#x2F;O 设备和存储器之间完成</strong>，以提高系统的整体运行效率。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121450737.png" alt="image-20230412145050674" loading="lazy"></p><h1 id="3-各个硬件的工作原理"><a href="#3-各个硬件的工作原理" class="headerlink" title="3.各个硬件的工作原理"></a>3.各个硬件的工作原理</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532810.png" alt="image-20230412153254738" loading="lazy"></p><h2 id="3-1-存储器（第三章重点学习）"><a href="#3-1-存储器（第三章重点学习）" class="headerlink" title="3.1.存储器（第三章重点学习）"></a>3.1.存储器（第三章重点学习）</h2><h3 id="3-3-1-存储器相关基本定义"><a href="#3-3-1-存储器相关基本定义" class="headerlink" title="3.3.1.存储器相关基本定义"></a>3.3.1.存储器相关基本定义</h3><p><strong>存储器相关基本定义：目前我们采用半导体器件来承担存储任务，一个半导体触发器由于有 0 和 1 两个状态，就可以记忆一个二进制代码，关于存储器有如下五个非常重要的概念</strong>：</p><ul><li><p><strong>存储元</strong>：也可称为存储元件和存储基元，用来存放<strong>一位二进制信息</strong>。</p></li><li><p><strong>存储单元</strong>：由若干个存储元组成，能存放<strong>多位二进制信息。</strong></p></li><li><p><strong>存储体</strong>：许多存储单元可组成存储体，也即<strong>存储矩阵。</strong></p></li><li><p><strong>存储字</strong>：每个存储单元中<strong>二进制代码的组合</strong>即为存储字，可代表数值、指令和地址等。</p></li><li><p><strong>存储字长</strong>：每个存储单元中<strong>二进制代码的位数</strong>就是存储字长。</p></li></ul><p><strong>上述概念可以这样记忆</strong>：主存储器由许多存储单元组成，每个存储单元包含多个存储元，每个存储元存储 1 位二进制代码 0 或 1，故存储单元可存储一串二进制代码，称这串代码为存储字，而这串代码的位数称为存储字长，存储字长一般是一个字节（8 位）或字节的偶数倍。</p><h3 id="3-3-2存储器的基本结构"><a href="#3-3-2存储器的基本结构" class="headerlink" title="3.3.2存储器的基本结构"></a>3.3.2存储器的基本结构</h3><p><strong>存储器基本结构：存储器主要分为</strong>：</p><ul><li><strong>主存（内存）</strong>：CPU <strong>可以直接访问</strong>；主要存放<strong>程序和数据</strong>；是计算机实现 “<strong>存储程序</strong>” 控制的基础；外存中信息必须<strong>加载进主存后</strong> CPU 才可以访问。</li><li><strong>辅存（外存）</strong>：CPU <strong>不可以直接访问。</strong></li></ul><p><strong>主存的基本构成如下图所示</strong></p><ul><li><strong>存储体 M</strong>：存放<strong>二进制信息。</strong></li><li><strong>MAR（地址寄存器）</strong>：存放的是<strong>访存地址</strong>（经过地址译码后找到所选存储单元）。</li><li><strong>MDR（数据寄存器）</strong>：存放的是要从存储器中<strong>读入或写入的信息。</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304171053506.png" alt="image-20230417105309384" loading="lazy"></p><p>内部原理图如下。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121458028.png" loading="lazy"></p><h3 id="3-3-3-存储器相关小考点"><a href="#3-3-3-存储器相关小考点" class="headerlink" title="3.3.3.存储器相关小考点"></a>3.3.3.存储器相关小考点</h3><p><strong>此部分内容将在【第三章：存储系统】学习，所以看不太懂没有关系，其中一些常考考点汇总如下</strong>：</p><ul><li>数据在存储体中是<strong>按照地址存储的，每个地址对应一个存储单元</strong>。</li><li><strong>存储单元数目 &#x3D; $2^{MAR 位数}$<strong>（如果 MAR 为 10 位，则存储单元数目为 $2^{10}&#x3D;1024$）。它用于</strong>寻址</strong>，其长度和 PC（程序计数器）长度一致。</li><li><strong>MDR 的位数表示存储字长</strong>（例如 MDR 为 16，表示存储字长为 16，也表示 1 个字 (word)&#x3D;16bit）。</li><li>注意区分<strong>字（word）和字节（Byte），1 个字节等于 8 个 bit</strong>，而 1 个字的大小取决于机器。</li><li><strong>1B&#x3D;1 个字节，1b &#x3D; 1个bit</strong>。</li></ul><h2 id="3-2-运算器（第五章重点学习）"><a href="#3-2-运算器（第五章重点学习）" class="headerlink" title="3.2.运算器（第五章重点学习）"></a>3.2.运算器（第五章重点学习）</h2><p><strong>运算器：是计算机的执行部件，主要进行</strong>：</p><ul><li><strong>算数运算</strong>：比如加减乘除。</li><li><strong>逻辑运算</strong>：比如与、或、非、异或、比较等等。</li></ul><h3 id="3-2-1-运算器基本结构"><a href="#3-2-1-运算器基本结构" class="headerlink" title="3.2.1.运算器基本结构"></a>3.2.1.运算器基本结构</h3><p><strong>运算器基本结构：由以下四部分构成</strong>：</p><ul><li><strong>ALU（算数逻辑单元）</strong>：运算器中造价最为高昂的部分，本质是一对电路；通过内部复杂的电路实现算数运算、逻辑运算。</li><li><strong>ACC（累加器）</strong>：辅助 ALU，累加器，用于存放操作数，或运算结果。</li><li><strong>MQ（乘商寄存器）</strong>：辅助 ALU，乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。</li><li><strong>X（通用操作数寄存器）</strong>：辅助 ALU，通用的操作数寄存器，用于存放操作数。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121503264.png" alt="image-20230412150310212" loading="lazy"></p><h3 id="3-2-2-运算器过程伪代码描述（了解）"><a href="#3-2-2-运算器过程伪代码描述（了解）" class="headerlink" title="3.2.2.运算器过程伪代码描述（了解）"></a>3.2.2.运算器过程伪代码描述（了解）</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121508014.png" alt="image-20230412150802918" loading="lazy"></p><p>设 M 为主存中的某一个存储单元，<code>(M)</code>表示取 M 中的数据，<code>-&gt;</code>表示将内容送入寄存器。</p><p><strong>加法实现</strong>：假设 ACC 中已经存在一个数，那么首先取 M 的内容送入通用操作数寄存器 X，即<code>(M)-&gt;X</code>；然后两者相加重新送入寄存器 ACC 中，即<code>(ACC)+(M)-&gt;(ACC)。</code></p><p><strong>乘法实现</strong>：假设 ACC 中已经存在一个数，那么首先取 M 的内容送入乘商寄存器 MQ 作为乘数，即<code>(M)-&gt;MQ</code>，再取 ACC 寄存器的内容放入 X 寄存器作为被乘数，即<code>ACC-&gt;X</code>，接着将 ACC 清零，即<code>0-&gt;ACC</code>，然后乘数乘以被乘数，一个送入乘积高位，一个送入乘积低位，即<code>(X)×(MQ)-&gt;ACC//MQ。</code></p><p><strong>除法实现</strong>：假设 ACC 中已经存在一个数，首先取 M 的内容送入 X 作为除数，即<code>(M)-&gt;X</code>，ACC 中的内容作为被除数，结果一个放入 MQ 作为整数部分，即<code>(ACC)/(X)-&gt;MQ</code>，另一个放入 ACC 作为余数，即<code>(ACC)%(X)-&gt;ACC。</code></p><h2 id="3-3-控制器（第四章重点学习）"><a href="#3-3-控制器（第四章重点学习）" class="headerlink" title="3.3.控制器（第四章重点学习）"></a>3.3.控制器（第四章重点学习）</h2><p><strong>运算器：是计算机的指挥中心，由其指挥各部件自动协调地进行工作。</strong></p><h3 id="3-3-1-指令"><a href="#3-3-1-指令" class="headerlink" title="3.3.1.指令"></a>3.3.1.指令</h3><p><strong>指令：是指指挥机器工作的指示和命令。程序本质就是一系列按照一定顺序排列的指令。人们用程序表达自己的意图，控制器则通过指令指挥机器工作。指令 &#x3D; 操作码 + 地址码。</strong></p><ul><li><strong>操作码</strong>：指示计算机要干什么。</li><li><strong>地址码</strong>：干这些事情需要的原材料在哪里。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121510905.png" loading="lazy">  </p><h3 id="3-3-2-控制器基本结构"><a href="#3-3-2-控制器基本结构" class="headerlink" title="3.3.2.控制器基本结构"></a>3.3.2.控制器基本结构</h3><p><strong>控制器基本结构：由以下三部分构成</strong>：</p><ul><li><strong>控制单元（CU）</strong>：分析指令、发出信号、协调操作。</li><li><strong>指令寄存器（IR）</strong>：存放<strong>当前要执行的指令</strong>。注意其内容来源于 MDR，因为指令和数据本质是一样的，都被存放在存储器。</li><li><strong>程序计数器（PC）</strong>：存放<strong>当前要执行的指令地址</strong>。注意其与 MAR 直接连通，并且可以自动 + 1。</li></ul><h3 id="3-3-3-控制器过程伪代码描述（了解）"><a href="#3-3-3-控制器过程伪代码描述（了解）" class="headerlink" title="3.3.3.控制器过程伪代码描述（了解）"></a>3.3.3.控制器过程伪代码描述（了解）</h3><p>完成一条指令的过程为：<strong>取指令（PC）-&gt; 分析指令（IR）-&gt; 执行指令（CU）。</strong></p><p>具体过程：首先取出指令，即<code>(IR)</code>，接着获取指令的操作码，即<code>OP(IR)</code>，然后获取指令的地址码，即<code>AD(IR)</code>，然后将操作码送入控制单元分析，即<code>OP(IR)-&gt;CU</code>，操作码表示需要干什么，但是干活需要原材料，所以再把指令的地址码送入 MAR，<code>AD(IR)-&gt;MAR</code>, 从 MAR 指示的存储体取出原材料即可。</p><p>结合前面的加法，我们可以写出完整的加法运算的过程的： 首要取加法指令，而指令存储在存储体中，想要取出指令必须要知道的指令的地址，而这个地址就存放在 PC 中，PC 又和 MAR 直接相连，即<code>(PC)-&gt;MAR</code>，于是指令此时被放入了 MDR 中，那么接着将指令放入 IR 中，即<code>(MDR)-&gt;IR</code>, 接着取指令的操作码送入控制单元，即<code>OP(IR)-&gt;CU</code>，然后再把原材料（就是一些操作数）的地址码送入 MAR，即<code>AD(IR)-&gt;MAR</code>。接着就可以进行加法操作了，由于上一步已经将操作数的地址码送入了 MDR 中，所以现在送入操作数寄存器，即<code>(MDR)-&gt;X</code>，然后<code>(ACC)+(X)-&gt;ACC</code>，最后 PC 要自增，即<code>(PC)+1-&gt;PC</code>，表示下一条指令。</p><h2 id="3-4-计算机的工作过程"><a href="#3-4-计算机的工作过程" class="headerlink" title="3.4.计算机的工作过程"></a>3.4.计算机的工作过程</h2><p><strong>接下来以一段简单的 C 语言代码为例展示计算机在背后所做的工作。</strong></p><ul><li>以下程序非常简单，声明了 4 个变量并赋值，然后在 main 函数内进行运算。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>y<span class="token operator">=</span>a<span class="token operator">*</span>b<span class="token operator">+</span>c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过编译器编译后，这段程序在主存中就是这样的  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121513033.png" alt="image-20230412151300971" loading="lazy"></p><ul><li>下半部分是定义的变量，上半部分则是对应于高级语言对应的机器指令。</li></ul><p>为了方便演示，我们将控制器、运算器和存储体也放在旁。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520952.png" loading="lazy"></p><p>第一组<br>1：程序开始运行，PC 的值为 0，保存的是第一条指令的地址。然后将 PC 的内容，也就是指令的地址送入到 MAR 中，即 (PC)-&gt;MAR,MAR&#x3D;0。也就是说控制器向存储器指明，我接下来要访问主存 0 号地址处的数据，同时告诉存储器进行读操作 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520320.png" loading="lazy"></p><p>2+3：主存储器会根据 MAR 记录的地址信息，到存储体中找出 0 号地址对应的二进制数据，并将其放入到 MDR 中，此时 MDR 中存放了第一条指令。即 M(MAR)-&gt;MDR，此时 <code>MDR=000001 0000000101</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520452.png" loading="lazy"></p><p>4：接着将 MDR 中的指令放入 IR 中，于是控制器就存放了当前要执行的指令。即 (MDR)-&gt;IR，<code>(IR)=000001 0000000101 </code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520495.png" loading="lazy"></p><p>  5：这条指令的前 6 个比特位是操作码，会被送入到控制单元<code> CU</code> 中，<code>CU </code>分析后，得知这是一条取数命令。即 <code>OP(IR)-&gt;CU </code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520536.png" loading="lazy"></p><p> 6：取数指令会将变量 a 的内容放入寄存器 ACC 中。但是现在变量 a 不知道在哪里，所以现在会把指令的地址码送到 MAR 当中，即<code>(MAR)=5</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520751.png" loading="lazy"></p><p>  7+8：接着主存储器根据 MAR 指明的地址，也就是 a 的地址（5），去存储体中找出 5 号地址的数据，并将其放入 MDR 当中。即<code> M(MAR)-&gt;MDR</code>，<code>(MDR)=0000000000000010</code>，也即 <code>(MDR)=2  </code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520409.png" loading="lazy"></p><p>  9：接着在控制单元的指挥下，MDR 中的数据就被放入到了 ACC 中。至此第一条指令完成  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520639.png" loading="lazy"></p><p>  10：最后 PC 自增 1，进行下一条指令，即 (PC)&#x3D;1  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121520072.png" alt="image-20230412152035976" loading="lazy"></p><p>接下来进行下一组操作  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162032683.png" loading="lazy"> </p><p>1：程序接着运行，PC 的值为 1，保存的是第二条指令的地址。然后将 PC 的内容，也就是指令的地址送入到 MAR 中，即<code> (PC)-&gt;MAR</code>，<code>MAR=1</code>。也就是说控制器向存储器指明，我接下来要访问主存 1 号地址处的数据，同时告诉存储器进行读操作  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034679.png" loading="lazy"></p><p>  2+3：主存储器会根据 MAR 记录的地址信息，到存储体中找出 1 号地址对应的二进制数据，并将其放入到 MDR 中，此时 MDR 中存放了第二条指令。即<code> M(MAR)-&gt;MDR</code>，此时<code>MDR=000100 0000000110 </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033681.png" loading="lazy"></p><p>4：接着将 MDR 中的指令放入 IR 中，于是控制器就存放了当前要执行的指令。即<code> (MDR)-&gt;IR</code>，<code>(IR)=000100 0000000110  </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033562.png" loading="lazy"></p><p>5：这条指令的前 6 个比特位是操作码，会被送入到控制单元 CU 中，CU 分析后，得知这是一条乘法命令。即<code>OP(IR)-&gt;CU </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033265.png" loading="lazy"></p><p>6：接着把指令的地址码送到 MAR 当中，即<code>(MAR)=6 </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033330.png" loading="lazy"></p><p>7+8：接着主存储器根据 MAR 指明的地址，也就是 b 的地址（6），去存储体中找出 6 号地址的数据，并将其放入 MDR 当中。即<code> M(MAR)-&gt;MDR</code>，<code>(MDR)=0000000000000011</code>，也即<code>(MDR)=3</code> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033644.png" loading="lazy"></p><p>9：由于是乘法，所以控制单元将 MDR 中的内容送入到乘商寄存器 MQ 中，即 <code>(MDR)-&gt;MQ</code>，此时 <code>(MQ)=0000000000000011=3 </code> 。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033315.png" loading="lazy"></p><p>10：先把 a 的值放入通用寄存器 X 中，即<code> (ACC)-&gt;X</code>，<code>(X)=2  </code>。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162034823.png" loading="lazy"></p><p>11：CU 告诉 ALU，让其进行乘法运算。即<code> (MQ)×(X)-&gt;ACC</code>，<code>(ACC)=6</code>。注意如果乘积过大，需要 MQ 辅助存储，也就是最上面讲到过的 <code>(X)×(MQ)-&gt;ACC/MQ</code>  。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033141.png" loading="lazy"></p><p>接着进行下一组操作，具体过程就不详细演示了，步骤如下：</p><ul><li><strong>1</strong>:PC 存储 2 号指令的地址，<code>(PC)-&gt;MAR</code>，<code>(MAR)=2</code></li><li><strong>2+3</strong>:<code>M(MAR)-&gt;MDR</code>，<code>(MDR)=000011 0000000111</code></li><li><strong>4</strong>:<code>(MDR)-&gt;IR</code>，<code>(IR)=000011 0000000111</code></li><li><strong>5</strong>:<code>OP(IR)-&gt;CU</code>,CU 分析操作码，得知这是加法执行</li><li><strong>6</strong>:<code>Ad(IR)-&gt;MAR</code>，将指令的地址码送入 MAR，<code>(MAR)=7</code></li><li><strong>7+8</strong>:<code>M(MAR)-&gt;MDR</code>，<code>(MDR)=00000000 00000001=1</code></li><li><strong>9</strong>:<code>(MDR)-&gt;x</code>，<code>(X)= 00000000 00000001=1</code></li><li><strong>10</strong>:<code>(ACC)+(X)-&gt;ACC</code>，<code>(ACC)-&gt;7</code>，由 ALU 实现加法运算</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033988.png" loading="lazy"></p><p>接着进行下一组操作：</p><ul><li><strong>1</strong>:<code>(PC)-&gt;MAR</code>，<code>(MAR)=3</code></li><li><strong>2+3</strong>:<code>M(MAR)-&gt;MDR</code>，<code>MDR=000010 0000001000</code></li><li><strong>4:</strong><code>(MDR)-&gt;IR</code>，<code>(IR)000010 0000001000</code></li><li>**5:<code>**OP(IR)-&gt;CU</code>，CU 分析得知，这是存数指令</li><li><strong>6</strong>:<code>AD(IR)-&gt;MAR</code>，<code>(MAR)=8</code></li><li><strong>7+8</strong>:<code>(ACC)-&gt;MDR</code>，<code>MDR=7</code></li><li><strong>9</strong>:<code>(MDR)-&gt; 地址为 8 的存储单元</code>，导致<code> y=7</code></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304162033504.png" loading="lazy"></p><p>最后再读取到停机指令时，计算机通过中断机制就结束了程序的运行。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121532924.png" alt="image-20230412153204838" loading="lazy"></p><h1 id="4-计算机层次结构"><a href="#4-计算机层次结构" class="headerlink" title="4.计算机层次结构"></a>4.计算机层次结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121547792.png" alt="image-20230412154711717" loading="lazy"></p><h2 id="4-1-计算机系统的多级层次结构"><a href="#4-1-计算机系统的多级层次结构" class="headerlink" title="4.1.计算机系统的多级层次结构"></a>4.1.计算机系统的多级层次结构</h2><p><strong>计算机系统的多级层次结构：现代计算机是一个硬件与软件组成的综合体，自下而上依次为：</strong></p><ul><li><p><strong>第一级是微程序机器层</strong>：这是一个实在的<strong>硬件层</strong>，它由机器硬件直接执行<strong>微指令。</strong></p></li><li><p><strong>第二级是传统机器语言层</strong>：它是一个实际的<strong>机器层</strong>，由<strong>微程序</strong>解释机器指令系统。</p></li><li><p><strong>第三级是操作系统层</strong>：它由<strong>操作系统</strong>实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称为<strong>混合层。</strong></p></li><li><p><strong>第四级是汇编语言层</strong>：他为用户提供一种<strong>符号化的语言</strong>，借此可编写汇编语言源程序。</p></li><li><p><strong>第五级是高级语言层</strong>：它是<strong>面向用户的</strong>，是为方便用户编写应用程序而设置的。</p></li><li><p>在高级语言层之上，还可以<strong>有应用层</strong>，它由解决实际问题的程序组成（比如 word，chrome 等等）。</p></li></ul><p><strong>这样的分层结构，使得本层的使用者无需关心下一层的实现细节。</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121536129.png" alt="image-20230412153640058" loading="lazy"></p><ul><li>注意：在很多情况下，计算机的某些功能既可以由硬件实现，也可以由软件来实现，<strong>因此硬件和软件没有严格的界限</strong>。</li></ul><h2 id="4-2-计算机软件的分类"><a href="#4-2-计算机软件的分类" class="headerlink" title="4.2.计算机软件的分类"></a>4.2.计算机软件的分类</h2><p><strong>软件：软件是人们事先编制的具有各类特殊功能的程序，他们通常存放在计算机的主存或外存中，按其功能可以分为以下两类:</strong></p><ul><li><strong>系统软件</strong>：是一组<strong>保证计算机系统高效，正确运行的基础软件</strong>，通常作为系统资源提供给用户使用。<strong>系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序，分布式软件系统、网络软件系统、标准库程序、服务型程序等。</strong></li><li><strong>应用软件</strong>：是指<strong>用户为解决某个应用领域中的各类问题而编制的程序</strong>、如各种<strong>科学计算类程序，工程设计类程序，数据统计与处理程序等</strong>。</li></ul><h2 id="4-3-解释程序和编译程序"><a href="#4-3-解释程序和编译程序" class="headerlink" title="4.3.解释程序和编译程序"></a>4.3.解释程序和编译程序</h2><ul><li><strong>解释程序</strong>：它将源语言书写的源程序作为输入，<strong>解释一句就提交给计算机执行一句</strong>，并<strong>不形成目标程序</strong>；例如 Python、JavaScript 等都是解释型语言。</li><li><strong>编译程序</strong>：把高级语言源程序作为输入，进行翻译转换，<strong>产生出的机器语言作为目标程序</strong>，然后让计算机去执行这个目标程序，得到计算结果；例如 C&#x2F;C++、Java 等都是编译型语言。</li></ul><p>对于编译程序来说，<strong>其产生目标代码的执行速度要比解释程序的执行速度快</strong>。</p><h2 id="4-4-机器语言、汇编语言和高级语言"><a href="#4-4-机器语言、汇编语言和高级语言" class="headerlink" title="4.4.机器语言、汇编语言和高级语言"></a>4.4.机器语言、汇编语言和高级语言</h2><ul><li><strong>机器语言</strong>：又称二进制代码语言，用 <strong>二进制 “0” 和“1”</strong> 描述不同指令，编程人员需要记忆每一条指令的二进制编码。其优点就是<strong>计算机可以直接识别并执行</strong>。</li><li><strong>汇编语言</strong>：其实质和机器语言是相同的，都是直接对硬件操作，只不过指令<strong>采用了英文缩写的标识符，更容易识别和记忆</strong>。汇编语言的程序必须经过一个称为<strong>汇编程序</strong>的系统软件的翻译，将其转化为机器语言，才能在计算机的硬件系统上运行。</li><li><strong>高级语言</strong>：高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常需要经过<strong>编译程序</strong>编译成汇编语言程序，然后经过<strong>汇编操作</strong>得到机器语言程序。其优点在于<strong>方便编程人员写出解决问题的方案和解题过程。</strong></li></ul><p>由于计算机无法直接理解和执行高级语言程序，需要将高级语言程序转换为机器语言程序，通常把进行这种转换的软件系统称为翻译程序。翻译程序有以下三类：</p><ul><li><strong>汇编程序（汇编器）</strong>。将汇编语言程序翻译成机器语言程序。</li><li><strong>解释程序（解释器）</strong>。将源程序中的语句按执行额序逐条翻译成机器指令并立即执行。</li><li><strong>编译程序（编译器）</strong>。将高级语言程序翻译成汇编语言或机器语言程序。</li></ul><h2 id="4-5-计算机体系结构和计算机组成原理概念区别"><a href="#4-5-计算机体系结构和计算机组成原理概念区别" class="headerlink" title="4.5.计算机体系结构和计算机组成原理概念区别"></a>4.5.计算机体系结构和计算机组成原理概念区别</h2><ul><li><strong>计算机体系结构</strong>：研究的是机器语言程序所见的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O 机理）。<strong>也就是说是如何设计硬件与软件之间的接口</strong>，举例：无乘法指令。</li><li><strong>计算机组成原理</strong>：研究的是计算机体系结构体现出来的属性，对于程序员来说是 “透明的”。<strong>也就是说是如何使用硬件实现所定义的接口</strong>，举例：如何实现乘法指令。</li></ul><h1 id="5-计算机性能指标"><a href="#5-计算机性能指标" class="headerlink" title="5.计算机性能指标"></a>5.计算机性能指标</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121609226.png" alt="image-20230412160927153" loading="lazy"></p><h2 id="5-1-主存容量指标"><a href="#5-1-主存容量指标" class="headerlink" title="5.1.主存容量指标"></a>5.1.主存容量指标</h2><p><strong>主存容量指标：主要有两个</strong></p><ul><li><strong>MAR 位数</strong>：反映<strong>存储单元</strong>的个数。</li><li><strong>MDR 位数</strong>：它等于<strong>存储字长</strong>，等于<strong>每个存储单元的大小</strong>。</li></ul><p>**所以有：存储体总容量 &#x3D; 存储单元个数 × 存储字长 (bit)&#x3D; 存储单元个数 ×(存储字长 &#x2F; 8)(Byte)**。</p><ul><li>例如 MAR 为 32 位，MDR 为 8 位，则总容量为$2^{32}×8bit&#x3D;4GB$。</li></ul><p>为快速计算，请熟记$2^{n}$对应数值：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/202304121550702.png" alt="image-20230412155043652" loading="lazy"></p><blockquote><p>注意：在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如$1Kb&#x3D;2^{10}b$；在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如$1kb&#x2F;s&#x3D;10^{3}b&#x2F;s$。通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。</p></blockquote><h2 id="5-2-运算速度指标"><a href="#5-2-运算速度指标" class="headerlink" title="5.2.运算速度指标"></a>5.2.运算速度指标</h2><h3 id="5-2-1-CPU-主频（时钟频率）"><a href="#5-2-1-CPU-主频（时钟频率）" class="headerlink" title="5.2.1.CPU 主频（时钟频率）"></a>5.2.1.CPU 主频（时钟频率）</h3><ul><li><strong>单位：Hz</strong></li></ul><p><strong>CPU 主频（时钟频率）</strong>：你在买电脑的时候，一定关注过 CPU 的主频。比如我手头的这台电脑就是 Intel Core-i7-7700HQ 2.8GHz，<strong>这里的 2.8GHz 就是电脑的主频（Frequency&#x2F;Clock Rate）</strong>。这个 2.8GHz，<strong>我们可以先粗浅地认为表示：CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条。</strong></p><p>如果想要更准确一点描述，<strong>这个 2.8GHz 就代表，CPU 的一个 “钟表” 能够识别出来的最小的时间间隔</strong>。就像我们挂在墙上的挂钟，都是 “滴答滴答” 一秒一秒地走，所以通过墙上的挂钟能够识别出来的最小时间单位就是秒。</p><p><strong>而在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫晶体振荡（OscillatorCrystal）的东西，简称为晶振</strong>。我们把晶振当成 CPU 内部的电子表来使用。晶振带来的每一次 “滴答”，就是时钟周期时间。</p><h3 id="5-2-2-CPU-时钟周期"><a href="#5-2-2-CPU-时钟周期" class="headerlink" title="5.2.2.CPU 时钟周期"></a>5.2.2.CPU 时钟周期</h3><ul><li><strong>单位：us 或 ns</strong><br><strong>CPU 时钟周期</strong>：接上面，在我这个 2.8GHz 的 CPU 上，<strong>这个时钟周期时间，就是 1&#x2F;2.8G</strong>。我们的 CPU，是按照这个 “时钟” 提示的时间来进行自己的操作。<strong>主频越高，意味着这个表走得越快，我们的 CPU 也就 “被逼” 着走得越快</strong>。</li></ul><p>如果你自己组装过台式机的话，可能听说过 “<strong>超频</strong>” 这个概念，<strong>本质就是把买回来的 CPU 内部的钟给调快了，于是 CPU 的计算跟着这个时钟的节奏</strong>，也就自然变快了。当然这个快不是没有代价的，CPU 跑得越快，散热的压力也就越大。就和人一样，超过生理极限，CPU 就会崩溃了。</p><p><strong>所以：CPU 主频（时钟频率）&#x3D;1&#x2F;CPU 时钟周期</strong>，主频通常以Hz（赫兹）为单位，1Hz表示每秒1次。</p><h3 id="5-2-3-CPI"><a href="#5-2-3-CPI" class="headerlink" title="5.2.3.CPI"></a>5.2.3.CPI</h3><p><strong>CPI</strong>：对于 CPU 时钟周期数，我们可以再做一个分解，<strong>把它变成 “指令数 × 每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）”</strong>。不同的指令需要的指令数是不同的。</p><ul><li>加法和乘法都对应着一条 CPU 指令，但是乘法需要的指令数就比加法要多，自然也就慢。</li></ul><h3 id="5-2-4-CPU-执行时间"><a href="#5-2-4-CPU-执行时间" class="headerlink" title="5.2.4.CPU 执行时间"></a>5.2.4.CPU 执行时间</h3><p><strong>CPU 执行时间</strong>：CPI 会受到很多因素的影响，因此用它衡量 CPU 速度是不合理的，<strong>所以我们把 CPU 执行时间定义为： CPU 执行时间 &#x3D; 指令数 ×CPI× 时钟周期 &#x3D;(指令数 ×CPI)&#x2F; 主频</strong>。</p><ul><li>例如：某 CPU 主频为 1000Hz，某程序包含 100 条指令，平均来看指令的 CPI&#x3D;3，则该程序执行时间为 $100×3×\frac{1}{1000}&#x3D;0.3s $。</li></ul><p>总结一下：</p><ul><li><strong>时钟周期时间，就是计算机主频，这个取决于计算机硬件</strong>：我们所熟知的摩尔定律就一直在不停地提高我们计算机的主频。比如说，我最早使用的 80386 主频只有 33MHz，现在手头的笔记本电脑就有 2.8GHz，在主频层面，就提升了将近 100 倍。</li><li><strong>每条指令的平均时钟周期数 CPI，就是一条指令到底需要多少 CPU Cycle</strong>：现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。因此，对于 CPI 的优化，也是计算机组成和体系结构中的重要一环。</li><li><strong>指令数，代表执行我们的程序到底需要多少条指令、用哪些指令</strong>：这个很多时候就把挑战交给了编译器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。</li></ul><p>我们可以把自己想象成一个 CPU，坐在那里写程序。<strong>计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。CPI 相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少</strong>。如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的 “性能” 从外面来看就是好的。</p><h3 id="5-2-5-IPS-和-FLOPS"><a href="#5-2-5-IPS-和-FLOPS" class="headerlink" title="5.2.5.IPS 和 FLOPS"></a>5.2.5.IPS 和 FLOPS</h3><ul><li><strong>IPS(Instructions Per Second)<strong>：每秒可以执行</strong>多少条指令</strong>，$ IPS&#x3D;\frac{主频}{平均 CPI}$。</li><li><strong>FLOPS(Floating-point Operation Per Second)<strong>：每秒执行</strong>多少次浮点运算。</strong></li></ul><p><strong>IPS 前面可以加入 K 或 M</strong></p><ul><li>KIPS：每秒可以多少千条指令。</li><li>MIPS：每秒可以执行多少百万条指。</li></ul><p><strong>FLOPS 前面加入 M、G 和 T</strong></p><ul><li>MFLOPS：每秒执行多少百万次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $10^{6} $)。</li><li>GFLOPS：每秒执行多少十亿次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $10^{9} $)。</li><li>TFLOPS：每秒执行多少万亿次浮点运算 (浮点操作次数 &#x2F; 执行时间 × $ 10^{12} $)。</li></ul><p><strong>2021考研大纲新增</strong>：PFLOPS，EFLOPS，ZFLOPS，$P&#x3D;10^3T$，$E&#x3D;10^3P$，$Z&#x3D;10^3E$。</p><p><strong>最后需要注意</strong>：</p><ul><li><strong>在描述容量、文件大小时</strong>，K、M、G、T 通常用 <strong>2 的幂次表示</strong>。如 $1Kb&#x3D; 2^{10} b$。</li><li><strong>在描述速率、频率时</strong>，k、M、G、T 通常用 <strong>10 的幂次表示</strong>，如 $1kb&#x2F;s&#x3D;  10^{3} b&#x2F;s$。</li></ul><h2 id="5-3-系统整体性能指标"><a href="#5-3-系统整体性能指标" class="headerlink" title="5.3.系统整体性能指标"></a>5.3.系统整体性能指标</h2><ul><li><strong>数据通路带宽</strong>：是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度有可能不同。</li><li><strong>吞吐量</strong>：指信息流入、处理和流出系统的速率。它取决于 CPU 能够多快的取指令，数据能够多快地从内存取出或存入，以及所得结果能够多块地从内存送到输出设备。这些决定因素中的任何一步都与主存息息相关，<strong>因此吞吐量主要取决于主存的存取周期</strong>。</li><li><strong>响应时间</strong>：指的是用户向计算机发送一个请求，到系统对该请求作出相应并获得所需结果的等待时间。通常包括 CPU 时间（运行程序花费）与等待时间（例如 I&#x2F;O 操作）。</li></ul><h1 id="6-本章总结"><a href="#6-本章总结" class="headerlink" title="6.本章总结"></a>6.本章总结</h1><p>1：冯诺依曼机以<strong>运算器</strong>为核心，最根本的特征是<strong>存储程序原理</strong>，基本方式是<strong>控制流驱动。</strong></p><p>2：<strong>取指阶段</strong>取出的是指令、<strong>执行阶段</strong>取出的是数据。</p><p>3：以下概念易混淆：</p><ul><li>MAR(Memory Adress Regiater)：存放想要访问的存储单元的地址。</li><li>PC：存放下一条指令的地址。</li><li>IR：存放当前执行的指令。</li><li>MDR(Memory Data Regiater)：存放取来的数据。</li></ul><p>4：软件和硬件在逻辑功能上是<strong>等效的而不是等价的</strong>。</p><p>5：计算机的位数指的就是机器字长。</p><p>6：科学计算机主要关注浮点运算性能。</p><p>7：IR、MAR、MDR 是 CPU 内部寄存器，<strong>不可见。</strong></p><p>8：需要注意 CPU 的 <strong>CPI 与主频是没有关系的</strong>，但是主频却会加快指令执行速度。</p><p>9：评价计算机系统的综合参数是<strong>吞吐率</strong>。</p><p>10：当前设计高性能计算机的重要技术途径是<strong>采用并行处理技术</strong>。</p><hr><p><strong>Q:软件和硬件</strong></p><p><strong>A:<strong>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础; 软件是一种信息，看不见、摸不到。</strong>但在逻辑功能上，软件和硬件是等效的</strong>。因此，在计算机系统中，<strong>许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。</strong></p><ul><li>例如，乘法运算既可用专门的乘法器 (主要由加法器和移位器组成) 实现，也可用乘法子程序 (主要由加法指令和移位指令等组成) 来实现。</li></ul><hr><p><strong>Q:计算机由哪儿部分组成？以哪部分为中心？</strong></p><p><strong>A:<strong>计算机由</strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>及<strong>输出设备</strong>五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量I&#x2F;O设备的速度和CPU的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。<strong>现代计算机</strong>已经发展为<strong>以存储器为中心</strong>，使I&#x2F;O操作尽可能地绕过CPU，直接在I&#x2F;O设备和存储器之间完成，以提高系统的整体运行效率。</p><hr><p><strong>Q:主频高的CPU一定比主频低的CPU快吗？为什么？</strong></p><p>**A:**衡量CPU运算速度的指标有很多，不能以单独的某个指标来判断CPU的好坏。CPU的主频，即CPU内核工作的时钟频率。CPU的主频表示CPU内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为CPU的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、Cache大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的CPU实际运算速度较低的现象。</p><hr><p><strong>Q:翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？</strong></p><p><strong>A:<strong>翻译程序有两种：一种是</strong>编译程序</strong>，它<strong>将高级语言源程序一次全部翻译成目标程序</strong>，只要源程序不变，就无须重新翻译。另一种是<strong>解释程序</strong>，它<strong>将源程序的一条语向翻译成对应的机器目标代码，并立即执行</strong>，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。</p><p><strong>汇编程序</strong>也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。</p><p><strong>编译程序与汇编程序的区别</strong>：若源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</p><hr><p><strong>Q:不同级别的语言编写的程序有什么区别？那种语言编写的程序能被硬件直接执行？</strong></p><p>**A:**机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。<br>其中机器语言可以被硬件直接执行。</p><hr><p><strong>Q:什么是透明性？透明是指什么都能看见吗？</strong></p><p><strong>A:<strong>在计算机领域中，</strong>站在某类用户的角度，若感觉不到某个事物或属性的存在</strong>，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。<br>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。<br><strong>在CPU中，IR、MAR和MDR对各类程序员都是透明的。</strong></p><hr><p><strong>Q:字、字长、机器字长、指令字长、存储字长的区别和联系是什么？</strong></p><p><strong>A:<strong>在通常所说的“某16位或32位机器”中，16、32指的是字长，也称</strong>机器字长</strong>。所谓字长通常是指CPU内部用于整数运算的数据通路的宽度，因此<strong>字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度</strong>，它反映了计算机处理信息的能力。字和字长的概念不同。字用来表示被处理信息的单位，用来度量数据类型的宽度，如x86机器中将一个字定义为16位。<br>            <strong>指令字长</strong>：一个指令字中包含的二进制代码的位数。<br>            <strong>存储字长</strong>：一个存储单元存储的二进制代码的长度。<br>            <strong>机器字长</strong>：计算机能直接处理的二进制数据的位数，<strong>机器字长一般等于内部寄存器的大小</strong>，它决定了计算机运算的精度</p><p>​        它们<strong>都必须是字节的整数倍</strong>。<br>​        早期的存储字长一般与指令字长、字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长、字长都可变，但必须都是字节的整数倍。</p><p>注意：<strong>指令字长一般取存储字长的整数倍，若指令字长等于存储字长 2 倍，则需要 2 次访存才能取出一条指令，这导致取指周期就会是机器周期的 2 倍</strong>；<strong>若指令字长等于存储字长，则取指周期等于机器周期。</strong></p><hr><p><strong>Q:计算机体系结构和计算机组成的区别和联系是什么？</strong></p><p><strong>计算机体系结构</strong>：是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性</p><p><strong>计算机组成</strong>：是指<strong>如何实现计算机体系结构所体现的属性</strong>, 它包含对许多对程序员来说透明的硬件细节。例如，<strong>指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题</strong>。因此，<strong>当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的</strong>。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</p><hr><p><strong>Q:基准程序执行得越快说明机器的性能越好吗？</strong></p><p>**A:**一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 考研408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT协议</title>
      <link href="/posts/bd50b816/"/>
      <url>/posts/bd50b816/</url>
      
        <content type="html"><![CDATA[<p>一.什么是MQTT协议</p><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布&#x2F;订阅（publish&#x2F;subscribe）模式的“轻量级”通讯协议，该协议构建于TCP&#x2F;IP协议上，由IBM在1999年发布。</p><p>MQTT最大优点在于，用极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。</p><p>作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><h1 id="二-MQTT协议特点"><a href="#二-MQTT协议特点" class="headerlink" title="二.MQTT协议特点"></a>二.MQTT协议特点</h1><p>MQTT是一个基于客户端-服务器的消息发布&#x2F;订阅传输协议。</p><p>MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。</p><p>其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p><p>MQTT协议当前版本为，2014年发布的MQTT v3.1.1。除标准版外，还有一个简化版MQTT-SN，该协议主要针对嵌入式设备，这些设备一般工作于TCP&#x2F;IP网络，如：ZigBee。</p><p>MQTT 与 HTTP 一样，MQTT 运行在传输控制协议&#x2F;互联网协议 (TCP&#x2F;IP) 堆栈之上。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601001652.png" alt="img" loading="lazy"></p><p>MQTT协议当前版本为，2014年发布的<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">MQTT v3.1.1</a>。除标准版外，还有一个简化版<code>MQTT-SN</code>，该协议主要针对嵌入式设备，这些设备一般工作于TCP&#x2F;IP网络，如：ZigBee。</p><p>MQTT协议运行在<code>TCP/IP</code>或其他网络协议，提供有序、无损、双向连接。其特点包括：</p><ol><li><p>使用的发布&#x2F;订阅消息模式，它提供了一对多消息分发，以实现与应用程序的解耦。</p></li><li><p>对负载内容屏蔽的消息传输机制。</p></li><li><p>对传输消息有三种服务质量（QoS）：</p></li><li><ul><li><p><code>最多一次</code>，这一级别会发生消息丢失或重复，消息发布依赖于底层TCP&#x2F;IP网络。即：&lt;&#x3D;1</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002046.png" alt="img" loading="lazy"></p></li><li><p><code>至多一次</code>，这一级别会确保消息到达，但消息可能会重复。即：&gt;&#x3D;1</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002054.png" alt="img" loading="lazy"></p></li><li><p><code>只有一次</code>，确保消息只有一次到达。即：＝1。在一些要求比较严格的计费系统中，可以使用此级别。为此，带有唯一消息 ID 的消息会存储两次，首先来自发送者，然后是接收者。QoS 级别 2 在网络中具有最高的开销，因为在发送方和接收方之间需要两个流。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002100.png" alt="img" loading="lazy"></p></li></ul></li><li><p>数据传输和协议交换的最小化（协议头部只有2字节），以减少网络流量</p></li><li><p>通知机制，异常中断时通知传输双方</p></li></ol><h1 id="三-MQTT协议原理"><a href="#三-MQTT协议原理" class="headerlink" title="三.MQTT协议原理"></a>三.MQTT协议原理</h1><p>1.<code>MQTT</code>协议实现方式</p><p><code>MQTT</code>使用的发布&#x2F;订阅消息模式，它提供了一对多的消息分发机制，从而实现与应用程序的解耦。</p><p>这是一种消息传递模式，<strong>消息不是直接从发送器发送到接收器</strong>（即点对点），而是由<code>MQTT server</code>（或称为 MQTT Broker）分发的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601002952.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601010213.png" alt="image-20220601010212990" loading="lazy"></p><ul><li>实现<code>MQTT</code>协议需要：<code>客户端</code>和<code>服务器端</code></li><li><code>MQTT</code>协议中有三种身份：<code>发布者（Publish）</code>、<code>代理（Broker）</code>（服务器）、<code>订阅者（Subscribe）</code>。其中，消息的<code>发布者</code>和<code>订阅者</code>都是客户端，消息<code>代理</code>是服务器，消息<code>发布者</code>可以同时是<code>订阅者</code>。</li><li>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分<ul><li><code>Topic</code>，可以理解为消息的类型，<code>订阅者</code>订阅（Subscribe）后，就会收到该主题的消息内容（<code>payload</code>）</li><li><code>payload</code>，可以理解为消息的内容，是指<code>订阅者</code>具体要使用的内容</li></ul></li></ul><h1 id="四-MQTT案例"><a href="#四-MQTT案例" class="headerlink" title="四.MQTT案例"></a>四.MQTT案例</h1><p>光伏发电站是发布者（Publisher）。</p><p>主要主题（Topic）级别是”PV”，这个工厂发布两个子级别”sunshine”和”data”；</p><p>“PV&#x2F;sunshine”是一个布尔值（true&#x2F;false，也可以是 1&#x2F;0），充电站需要它来知道是否应该装载电动汽车（仅在阳光普照时 :)）。</p><p>充电站（EVSE）是订阅者，订阅”PV&#x2F;sunshine”从服务器获取信息。</p><p>“PV&#x2F;data” 另一方面，以 kW 为单位传输工厂产生的瞬时功率，并且该主题可以例如通过计算机或平板电脑订阅，以生成一天内传输功率的图表。</p><p>这就是一个简单的MQTT的应用场景，具体如下图所示；</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220601010123.png" alt="img" loading="lazy"></p><h1 id="五-MQTT的优点"><a href="#五-MQTT的优点" class="headerlink" title="五.MQTT的优点"></a>五.MQTT的优点</h1><ol><li>MQTT的独特功能是每个消息头都可以缩短为2个字节。对于HTTP，为每个新请求消息重新建立HTTP连接会产生可观的开销。 MQ和MQTT使用的持久连接可以大大减少这种开销。</li><li>包容不稳定的网络，MQTT和MQ可以从诸如断开连接之类的故障中恢复，无需进一步的代码要求。但是，HTTP本身无法实现此目标，并且客户端必须重试编码，这会增加身份问题。</li><li>低功耗MQTT专为低功耗目标而设计。 HTTP设计未考虑此因素，这会增加功耗。</li><li>在连接数百万个客户端的情况下，在HTTP堆栈中维护数百万个并发连接需要大量工作才能提供支持。尽管这种支持是可行的，但大多数商业产品都经过优化以处理此订单上的持久连接。 IBM提供了IBM MessageSight，这是一种单机架安装服务器，已经过测试，可以通过MQTT处理多达一百万个并发设备。相反，MQ不是为许多同时进行的客户设计的。</li><li>推送通知。您需要能够及时向客户发送通知。为此，您应该使用常规的轮询或推送方法。就电池，系统负载和带宽而言，推送是最佳解决方案。</li><li>客户端平台的差异。 HTTP和MQTT客户端都在许多平台上实现。 MQTT的简单性可帮助您以最少的努力在其他客户端上实施MQTT。</li><li>防火墙容错能力。某些公司防火墙将出站连接限制到某些预定义的端口，这些端口通常仅限于HTTP（端口80），HTTPS（端口443）等，HTTP在这种情况下显然可以工作。 MQTT封装在WebSockets连接中，并显示为HTTP升级请求，因此可以在这种情况下运行。</li></ol><p><strong>补充</strong>：</p><ul><li><strong>mqtt</strong>：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范</li><li><strong>MQ</strong>：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式</li><li><strong>json</strong>：一种内容格式，类似人类交谈中的排比句等方式</li><li><strong>消息</strong>：信息的载体</li><li><strong>消息协议</strong>：为了让消息发送者和消息接收者都能够明白消息所承载的信息（消息发送者需要知道如何构造消息；消息接收者需要知道如何解析消息），它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。所以，有效的消息一定具有某一种格式；而没有格式的消息是没有意义的。</li><li><strong>消息队列</strong>：消息从发送者到接收者的方式也有两种。<ul><li>一种为即时消息通讯，也就是说消息从一端发出后（消息发送者）立即就可以达到另一端（消息接收者），这种方式的具体实现就是我们已经介绍过的RPC（当然单纯的http通讯也满足这个定义）；</li><li>另一种为延迟消息通讯，即消息从某一端发出后，首先进入一个容器进行临时存储，当达到某种条件后，再由这个容器发送给另一端。 这个容器的一种具体实现就是消息队列，如RabbitMQ。</li></ul></li></ul><p><strong>参考链接</strong>：</p><p><a href="https://itbilu.com/other/relate/4kHBsx_Pg.html">https://itbilu.com/other/relate/4kHBsx_Pg.html</a></p><p><a href="https://blog.csdn.net/u010632165/article/details/118503059">https://blog.csdn.net/u010632165/article/details/118503059</a></p><p><a href="https://blog.csdn.net/hyz529900/article/details/123917756">https://blog.csdn.net/hyz529900/article/details/123917756</a></p><p><a href="https://www.cnblogs.com/111testing/p/11487689.html">https://www.cnblogs.com/111testing/p/11487689.html</a></p>]]></content>
      
      
      <categories>
          
          <category> MQTT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B UART多串口配置通信</title>
      <link href="/posts/54ae1768/"/>
      <url>/posts/54ae1768/</url>
      
        <content type="html"><![CDATA[<p>相比树莓派零、1、2 以及 3 的双串口 UART0（PL011）和 UART1（mini UART），树莓派 4 中新增了 4 个 PL011 串口共计有 6 个 UART，整理此笔记用作记录和配置参考。</p><p>注意，目前搜到的大多数描述树莓派 4 串口的文章，大多数开头都是禁用下蓝牙，这个做法针对树莓派0-3 是必须的，因为本身串口不够用，但对树莓派 4 来说并不需要，因为有额外 4 个串口可以利用，默认配置好的两串口一个用于蓝牙（UART0）另一个是 miniUART 可以保留设置。此方面的文章大多都是一个流程，原因是参考的最初版本是树莓派 3 的设置；树莓派 4 的额外串口设置在树莓派论坛中可以看到相关的介绍，外面的文章不太多。</p><h1 id="1-展示所有串口命令"><a href="#1-展示所有串口命令" class="headerlink" title="1. 展示所有串口命令"></a>1. 展示所有串口命令</h1><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dtoverlay -a | grep uart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>展示 pi4 中所有串口</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ dtoverlay -a | grep uart  midi-uart0  midi-uart1  miniuart-bt  uart0  uart1  uart2  uart3  uart4  uart5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-查看特定串口信息"><a href="#2-查看特定串口信息" class="headerlink" title="2. 查看特定串口信息"></a>2. 查看特定串口信息</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dtoverlay -h uart2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看 UART2 的配置信息等：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ dtoverlay -h uart2Name:   uart2Info:   Enable uart 2 on GPIOs 0-3Usage:  dtoverlay&#x3D;uart2,&lt;param&gt;Params: ctsrts                  Enable CTS&#x2F;RTS on GPIOs 2-3 (default off)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关信息会展现 GPIOs 与新的 UART 串口的分配：0-3 对应 UART2， 4-7 对应 UART3，8-11 对应 UART 4，以及 12-15 对应 GUIO 5</p><p>关于 4 个针脚中后两位对应的 CTS&#x2F;RTS，可参考： <a href="https://blog.csdn.net/zeroboundary/article/details/8966586">https://blog.csdn.net/zeroboundary/article/details/8966586</a></p><h1 id="3-配置开启串口-UART2-5"><a href="#3-配置开启串口-UART2-5" class="headerlink" title="3. 配置开启串口 UART2-5"></a>3. 配置开启串口 UART2-5</h1><p>执行编辑 config.txt 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /boot/config.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件结尾添加如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">dtoverlay&#x3D;uart2dtoverlay&#x3D;uart3dtoverlay&#x3D;uart4dtoverlay&#x3D;uart5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>保存（Write Out）并退出（Exit）</p><p>重启后查看是否生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> /dev/ttyAMA*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果显示如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ ls &#x2F;dev&#x2F;ttyAMA*&#x2F;dev&#x2F;ttyAMA0  &#x2F;dev&#x2F;ttyAMA1  &#x2F;dev&#x2F;ttyAMA2  &#x2F;dev&#x2F;ttyAMA3  &#x2F;dev&#x2F;ttyAMA4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>各 UART 串口与 GPIO 对应关系：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">GPIO14 &#x3D; TXD0 -&gt; ttyAMA0GPIO0  &#x3D; TXD2 -&gt; ttyAMA1GPIO4  &#x3D; TXD3 -&gt; ttyAMA2GPIO8  &#x3D; TXD4 -&gt; ttyAMA3GPIO12 &#x3D; TXD5 -&gt; ttyAMA4GPIO15 &#x3D; RXD0 -&gt; ttyAMA0GPIO1  &#x3D; RXD2 -&gt; ttyAMA1GPIO5  &#x3D; RXD3 -&gt; ttyAMA2GPIO9  &#x3D; RXD4 -&gt; ttyAMA3GPIO13 &#x3D; RXD5 -&gt; ttyAMA4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h1><h3 id="串口自发自收测试"><a href="#串口自发自收测试" class="headerlink" title="串口自发自收测试"></a>串口自发自收测试</h3><p>现在我们先测试 UART2 是否启用成功，比较简单的测试方式是将其 TXD 和 RXD 相连，自发自收。</p><p>根据上方对应关系，UART2 对应 TXD2 和 RXD2，对应 GPIO0 和 GPIO1，对应 ttyAMA1</p><p>注：UART0 对应的 ttyAMA0，UART1 对应的 ttyS0，UART2 到 UART5 对应的 ttyAMA1 到 ttyAMA4。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220525202856.png" alt="树莓派 gpio 针脚" loading="lazy"></p><p>找到对应的 GPIO0 和 GPIO1 针脚连起来：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409093839.png" alt="image-20220409093839015" loading="lazy"></p><p>在树莓派端命令行进入 Python3 环境，通过如下模块和命令自发自收：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ python3Python 3.7.3 (default, Jul 25 2020, 13:03:44) [GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import serial&gt;&gt;&gt; ted &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA1&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted.write(&quot;Hello World&quot;.encode(&quot;gbk&quot;))11&gt;&gt;&gt; ted.read(11)b&#39;Hello World&#39;&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，我们可以继续用跳线帽将 GPIO4 和 5 相连测试 UART3；GPIO8 和 9 相连测试 UART4； GPIO12 和 13 相连测试 UART5。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ python3Python 3.7.3 (default, Jul 25 2020, 13:03:44) [GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import serial&gt;&gt;&gt; ted &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA1&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted.write(&quot;Hello World&quot;.encode(&quot;gbk&quot;))11&gt;&gt;&gt; ted.read(11)b&#39;Hello World&#39;&gt;&gt;&gt; ted3 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA2&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted3.write(&quot;Hello No.3&quot;.encode(&quot;gbk&quot;))10&gt;&gt;&gt; ted3.read(10)b&#39;Hello No.3&#39;&gt;&gt;&gt; ted4 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA3&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted4.write(&quot;Hello No.4&quot;.encode(&quot;gbk&quot;))10&gt;&gt;&gt; ted4.read(10)b&#39;Hello No.4&#39;&gt;&gt;&gt; ted5 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA4&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted5.write(&quot;Hello No.5&quot;.encode(&quot;gbk&quot;))10&gt;&gt;&gt; ted5.read(10)b&#39;Hello No.5&#39;&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="串口间通信测试"><a href="#串口间通信测试" class="headerlink" title="串口间通信测试"></a>串口间通信测试</h3><p>接下来测试 UART2 和 UART3 间的通信，将 TXD2 连接 RXD3 即 GPIO0 与 GPIO5 相连；将 TXD3 与 RXD2 连接即 GPIO4 与 GPIO1 相连。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">GPIO0  &#x3D; TXD2 -&gt; ttyAMA1GPIO4  &#x3D; TXD3 -&gt; ttyAMA2GPIO1  &#x3D; RXD2 -&gt; ttyAMA1GPIO5  &#x3D; RXD3 -&gt; ttyAMA2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ python3Python 3.7.3 (default, Jul 25 2020, 13:03:44) [GCC 8.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import serial&gt;&gt;&gt; ted &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA1&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted3 &#x3D; serial.Serial(port&#x3D;&quot;&#x2F;dev&#x2F;ttyAMA2&quot;, baudrate&#x3D;9600)&gt;&gt;&gt; ted.write(&quot;Msg from UART2...&quot;.encode(&quot;gbk&quot;))17&gt;&gt;&gt; ted3.read(17)b&#39;Msg from UART2...&#39;&gt;&gt;&gt; ted3.write(&quot;Msg from UART3...&quot;.encode(&quot;gbk&quot;))17&gt;&gt;&gt; ted.read(17)b&#39;Msg from UART3...&#39;&gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK 挺顺利，UART2 和 UART3 间通信正常。</p><p>参考：</p><p>官方 UART 配置文档：<br><a href="https://www.raspberrypi.org/documentation/configuration/uart.md">https://www.raspberrypi.org/documentation/configuration/uart.md</a></p><p>论坛关于多串口的命令与指引：<br><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=244827#p1493698">https://www.raspberrypi.org/forums/viewtopic.php?t=244827#p1493698</a></p><p>树莓派 4 UART 多串口配置通信<br><a href="https://blog.csdn.net/weixin_40796925/article/details/107907991?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946453016781683948237%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164946453016781683948237&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107907991.142">https://blog.csdn.net/weixin_40796925/article/details/107907991?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946453016781683948237%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164946453016781683948237&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107907991.142</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 串口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino Json串口</title>
      <link href="/posts/84233d6d/"/>
      <url>/posts/84233d6d/</url>
      
        <content type="html"><![CDATA[<h1 id="Arduino-串口接受字符串操作"><a href="#Arduino-串口接受字符串操作" class="headerlink" title="Arduino 串口接受字符串操作"></a>Arduino 串口接受字符串操作</h1><h2 id="自定义函数操作方式"><a href="#自定义函数操作方式" class="headerlink" title="自定义函数操作方式"></a>自定义函数操作方式</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*使用自定函数，将字符转化为字符串，再进行操作*&#x2F; String comdata &#x3D; &quot;&quot;;&#x2F;&#x2F;声明字符串变量 void setup() &#123;  Serial.begin(9600);      &#x2F;&#x2F;设定的波特率&#125; void loop() &#123;   while (Serial.available() &gt; 0)      &#123;        comdata +&#x3D; char(Serial.read());        delay(2);    &#125;       if (comdata.length() &gt; 0)    &#123;       Serial.println(comdata);       comdata &#x3D; &quot;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法使用自定函数实现了字符到字符串的转换再进行操作，使用起来还不错，推荐大家使用。</p><h2 id="采用库函数Serial-readString-；"><a href="#采用库函数Serial-readString-；" class="headerlink" title="采用库函数Serial.readString()；"></a>采用库函数Serial.readString()；</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void setup() &#123;  Serial.begin(9600);      &#x2F;&#x2F;设定的波特率&#125; void loop() &#123;  String rx_buffer;  rx_buffer&#x3D;Serial.readString();  Serial.print(rx_buffer);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法使用简单暴力，但是有个缺点，官方库函数默认的参数使得读取串口操作必须要阻塞1s的时间，实时性较差；</p><p>在这里，提供一种修改方法：</p><p>在Arduino IDE 安装路径下找到<code> stream.h</code> 文件修改参数</p><p>①文件路径：<code>C:\Program Files\arduino-1.8.19\hardware\arduino\avr\cores\arduino</code></p><p>②找到文件 <code>stream.h</code>，修改参数：<code>Stream() &#123;_timeout=200;&#125;</code>，红色数值单位为毫秒，根据需要修改然后保存编译即可生效；</p><p>附<code>stream.h</code>文件内容（突出显示 要修改的地方：Stream() {_timeout&#x3D;200;}）：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*  Stream.h - base class for character-based streams.  Copyright (c) 2010 David A. Mellis.  All right reserved.  This library is free software; you can redistribute it and&#x2F;or  modify it under the terms of the GNU Lesser General Public  License as published by the Free Software Foundation; either  version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public  License along with this library; if not, write to the Free Software  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  parsing functions based on TextFinder library by Michael Margolis*&#x2F;#ifndef Stream_h#define Stream_h#include &lt;inttypes.h&gt;#include &quot;Print.h&quot;&#x2F;&#x2F; compatability macros for testing&#x2F;*#define   getInt()            parseInt()#define   getInt(ignore)    parseInt(ignore)#define   getFloat()          parseFloat()#define   getFloat(ignore)  parseFloat(ignore)#define   getString( pre_string, post_string, buffer, length)readBytesBetween( pre_string, terminator, buffer, length)*&#x2F;&#x2F;&#x2F; This enumeration provides the lookahead options for parseInt(), parseFloat()&#x2F;&#x2F; The rules set out here are used until either the first valid character is found&#x2F;&#x2F; or a time out occurs due to lack of input.enum LookaheadMode&#123;    SKIP_ALL,       &#x2F;&#x2F; All invalid characters are ignored.    SKIP_NONE,      &#x2F;&#x2F; Nothing is skipped, and the stream is not touched unless the first waiting character is valid.    SKIP_WHITESPACE &#x2F;&#x2F; Only tabs, spaces, line feeds &amp; carriage returns are skipped.&#125;;#define NO_IGNORE_CHAR  &#39;\x01&#39; &#x2F;&#x2F; a char not found in a valid ASCII numeric fieldclass Stream : public Print&#123;  protected:    unsigned long _timeout;      &#x2F;&#x2F; number of milliseconds to wait for the next char before aborting timed read    unsigned long _startMillis;  &#x2F;&#x2F; used for timeout measurement    int timedRead();    &#x2F;&#x2F; read stream with timeout    int timedPeek();    &#x2F;&#x2F; peek stream with timeout    int peekNextDigit(LookaheadMode lookahead, bool detectDecimal); &#x2F;&#x2F; returns the next numeric digit in the stream or -1 if timeout  public:    virtual int available() &#x3D; 0;    virtual int read() &#x3D; 0;    virtual int peek() &#x3D; 0;    Stream() &#123;_timeout&#x3D;100;&#125;&#x2F;&#x2F; parsing methods  void setTimeout(unsigned long timeout);  &#x2F;&#x2F; sets maximum milliseconds to wait for stream data, default is 1 second  unsigned long getTimeout(void) &#123; return _timeout; &#125;    bool find(char *target);   &#x2F;&#x2F; reads data from the stream until the target string is found  bool find(uint8_t *target) &#123; return find ((char *)target); &#125;  &#x2F;&#x2F; returns true if target string is found, false if timed out (see setTimeout)  bool find(char *target, size_t length);   &#x2F;&#x2F; reads data from the stream until the target string of given length is found  bool find(uint8_t *target, size_t length) &#123; return find ((char *)target, length); &#125;  &#x2F;&#x2F; returns true if target string is found, false if timed out  bool find(char target) &#123; return find (&amp;target, 1); &#125;  bool findUntil(char *target, char *terminator);   &#x2F;&#x2F; as find but search ends if the terminator string is found  bool findUntil(uint8_t *target, char *terminator) &#123; return findUntil((char *)target, terminator); &#125;  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   &#x2F;&#x2F; as above but search ends if the terminate string is found  bool findUntil(uint8_t *target, size_t targetLen, char *terminate, size_t termLen) &#123;return findUntil((char *)target, targetLen, terminate, termLen); &#125;  long parseInt(LookaheadMode lookahead &#x3D; SKIP_ALL, char ignore &#x3D; NO_IGNORE_CHAR);  &#x2F;&#x2F; returns the first valid (long) integer value from the current position.  &#x2F;&#x2F; lookahead determines how parseInt looks ahead in the stream.  &#x2F;&#x2F; See LookaheadMode enumeration at the top of the file.  &#x2F;&#x2F; Lookahead is terminated by the first character that is not a valid part of an integer.  &#x2F;&#x2F; Once parsing commences, &#39;ignore&#39; will be skipped in the stream.  float parseFloat(LookaheadMode lookahead &#x3D; SKIP_ALL, char ignore &#x3D; NO_IGNORE_CHAR);  &#x2F;&#x2F; float version of parseInt  size_t readBytes( char *buffer, size_t length); &#x2F;&#x2F; read chars from stream into buffer  size_t readBytes( uint8_t *buffer, size_t length) &#123; return readBytes((char *)buffer, length); &#125;  &#x2F;&#x2F; terminates if length characters have been read or timeout (see setTimeout)  &#x2F;&#x2F; returns the number of characters placed in the buffer (0 means no valid data found)  size_t readBytesUntil( char terminator, char *buffer, size_t length); &#x2F;&#x2F; as readBytes with terminator character  size_t readBytesUntil( char terminator, uint8_t *buffer, size_t length) &#123; return readBytesUntil(terminator, (char *)buffer, length); &#125;  &#x2F;&#x2F; terminates if length characters have been read, timeout, or if the terminator character  detected  &#x2F;&#x2F; returns the number of characters placed in the buffer (0 means no valid data found)  &#x2F;&#x2F; Arduino String functions to be added here  String readString();  String readStringUntil(char terminator);  protected:  long parseInt(char ignore) &#123; return parseInt(SKIP_ALL, ignore); &#125;  float parseFloat(char ignore) &#123; return parseFloat(SKIP_ALL, ignore); &#125;  &#x2F;&#x2F; These overload exists for compatibility with any class that has derived  &#x2F;&#x2F; Stream and used parseFloat&#x2F;Int with a custom ignore character. To keep  &#x2F;&#x2F; the public API simple, these overload remains protected.  struct MultiTarget &#123;    const char *str;  &#x2F;&#x2F; string you&#39;re searching for    size_t len;       &#x2F;&#x2F; length of string you&#39;re searching for    size_t index;     &#x2F;&#x2F; index used by the search routine.  &#125;;  &#x2F;&#x2F; This allows you to search for an arbitrary number of strings.  &#x2F;&#x2F; Returns index of the target that is found first or -1 if timeout occurs.  int findMulti(struct MultiTarget *targets, int tCount);&#125;;#undef NO_IGNORE_CHAR#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用ArdunioJson发送Json数据包"><a href="#使用ArdunioJson发送Json数据包" class="headerlink" title="使用ArdunioJson发送Json数据包"></a>使用ArdunioJson发送Json数据包</h1><p>注意：这里使用的<strong>ArduinoJson的V6版本</strong>，关于V6和V5版本的切换，可以按照报错网站查询并修改。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;ArduinoJson.h&gt;void setup() &#123;  &#x2F;&#x2F; put your setup code here, to run once:  Serial.begin(115200);  Serial.println(&quot;begin now&quot;);&#125;void loop() &#123;  &#x2F;&#x2F; put your main code here, to run repeatedly:   DynamicJsonDocument data(256);   data[&quot;temp&quot;]&#x3D;25;   data[&quot;hum&quot;]&#x3D;110;   char json_string[256];   serializeJson(data,json_string);   Serial.println(json_string);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220430205543.png" alt="在这里插入图片描述" loading="lazy"></p><h2 id="解析Json数据包（int，char型）"><a href="#解析Json数据包（int，char型）" class="headerlink" title="解析Json数据包（int，char型）"></a>解析Json数据包（int，char型）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 电源属性修改的回调函数void powerCallback(JsonVariant p)&#123;    extern int a;    int PowerSwitch &#x3D; p[&quot;PowerSwitch&quot;];    if (PowerSwitch &#x3D;&#x3D; 2)    &#123;       digitalWrite(LED_BUILTIN,HIGH);  &#x2F;&#x2F; 启动设备       a&#x3D;2;    &#125;     if (PowerSwitch &#x3D;&#x3D; 3)    &#123;       digitalWrite(LED_BUILTIN,LOW); &#x2F;&#x2F; 启动设备       a&#x3D;3;    &#125;&#125;&#x2F;&#x2F;字符回调函数void Receive_Zi_Fu_Callback(JsonVariant p)&#123;      const char* Zi_Fu &#x3D; p[&quot;Receive_Zi_Fu&quot;];&#x2F;      String S(Zi_Fu);&#x2F;&#x2F;const char*转String      S &#x3D; S.substring(2,6);&#x2F;&#x2F;截取字符串的一部分，可以去掉,比如123456,就是3456      extern char *c;      const int len&#x3D;S.length();      c &#x3D; new char[len+1];      strcpy(c,S.c_str());&#x2F;&#x2F;Strinf转char* ，是为了OLED_ShowString      OLED_ShowString(0,0,c,16);      Serial.println(S);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于char和String"><a href="#关于char和String" class="headerlink" title="关于char和String"></a>关于char和String</h2><ul><li>char表示的是字符，定义用单引号；</li><li>String表示字符串，定义用双引号。</li><li>string的内存管理是由系统处理，除非系统内存池用完，不然不会出现这种内存问题。</li><li>char *的内存管理由用户自己处理，很容易出现内存不足的问题。</li></ul><p>当我们要存一个串，但是不知道其他需要多少内存时， 用<code>string</code>来处理就最好不过了。当你知道了存储的内存的时候，可以用<code>char *</code>，但是不如用<code>string</code>的好，用指针总会有隐患。</p><h1 id="使用ArdunioJson解析Json数据包"><a href="#使用ArdunioJson解析Json数据包" class="headerlink" title="使用ArdunioJson解析Json数据包"></a>使用ArdunioJson解析Json数据包</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ArduinoJson.h></span></span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   DynamicJsonDocument  <span class="token function">jsonBuffer</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String json <span class="token operator">=</span>      <span class="token string">"&#123;\"sensor\":\"gps\",\"time\":1351824120,\"data\":[48.756080,2.302038]&#125;"</span><span class="token punctuation">;</span>   <span class="token function">deserializeJson</span><span class="token punctuation">(</span>jsonBuffer<span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span>    JsonObject root <span class="token operator">=</span> jsonBuffer<span class="token punctuation">.</span>as<span class="token operator">&lt;</span>JsonObject<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> sensor <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"sensor"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> time <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"time"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> latitude <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> longitude <span class="token operator">=</span> root<span class="token punctuation">[</span><span class="token string">"data"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sensor<span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>latitude<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>longitude<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解析Arduino串口Json包"><a href="#解析Arduino串口Json包" class="headerlink" title="解析Arduino串口Json包"></a>解析Arduino串口Json包</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&#123;&quot;state&quot;:1,&quot;LeftMotor&quot;:100,&quot;RightMotor&quot;:100,&quot;UpServo&quot;:10,&quot;DownServo&quot;:10,&quot;Light&quot;:0,&quot;Pump&quot;:0&#125;#include &lt;ArduinoJson.h&gt;String rx_buffer &#x3D; &quot;&quot;;&#x2F;&#x2F;声明字符串变量void setup()&#123;  Serial.begin(9600);      &#x2F;&#x2F;设定的波特率&#125;void loop()&#123;  while (Serial.available() &gt; 0)  &#123;    rx_buffer +&#x3D; char(Serial.read());    delay(2);  &#125;  if (rx_buffer.length() &gt; 0)  &#123;    DynamicJsonDocument  jsonBuffer(400);    deserializeJson(jsonBuffer, rx_buffer);    JsonObject root &#x3D; jsonBuffer.as&lt;JsonObject&gt;();    int state &#x3D; root[&quot;state&quot;];    int LeftMotor &#x3D; root[&quot;LeftMotor&quot;];    int RightMotor &#x3D; root[&quot;RightMotor&quot;];    int UpServo &#x3D; root[&quot;UpServo&quot;];    int DownServo &#x3D; root[&quot;DownServo&quot;];    int Light &#x3D; root[&quot;Light&quot;];    int Pump &#x3D; root[&quot;Pump&quot;];    Serial.println(state);    Serial.println(LeftMotor);    Serial.println(RightMotor);    Serial.println(UpServo);    Serial.println(DownServo);    Serial.println(Light);    Serial.println(Pump);    Serial.print(rx_buffer);    rx_buffer &#x3D; &quot;&quot;;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Arduino修改Serial接收缓冲区大小"><a href="#Arduino修改Serial接收缓冲区大小" class="headerlink" title="Arduino修改Serial接收缓冲区大小"></a>Arduino修改Serial接收缓冲区大小</h1><blockquote><p>  向Arduino发送一个90字节的字符串，不管怎么样都只能收到63个字节的数据，感觉应该是串口缓冲区大小的限制，修改完后，串口收发数据正常。</p></blockquote><p>看到网上有资料说，直接添加以下宏定义就可以了：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define SERIAL_RX_BUFFER_SIZE 2048 &#x2F;&#x2F;修改串口发送缓冲区大小为2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是由于Arduino的编译器是先导入其他头文件，再编译用户区代码的，所以会提示已经被重定义。</p><p>那么我们就只能根据提示，去修改<code>C:\Program Files (x86)\Arduino\hardware\arduino\avr\cores\arduino\HardwareSerial.h</code>的代码了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220430225817.png" alt="image-20220430225817140" loading="lazy"></p><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/huanzx/article/details/79596855">https://blog.csdn.net/huanzx/article/details/79596855</a></li><li><a href="https://blog.csdn.net/weixin_43475628/article/details/118925979">https://blog.csdn.net/weixin_43475628/article/details/118925979</a></li><li><a href="https://blog.csdn.net/qq_27508477/article/details/105419505">https://blog.csdn.net/qq_27508477/article/details/105419505</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串口 </tag>
            
            <tag> Arduino </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino IO口使用方法</title>
      <link href="/posts/514fc85a/"/>
      <url>/posts/514fc85a/</url>
      
        <content type="html"><![CDATA[<h1 id="数字输入输出"><a href="#数字输入输出" class="headerlink" title="数字输入输出"></a>数字输入输出</h1><p>在使用输入或输出功能前，你需要先通过<code>pinMode()</code> 函数配置引脚的模式为输入模式或输出模式。</p><h2 id="端口初始化函数"><a href="#端口初始化函数" class="headerlink" title="端口初始化函数"></a>端口初始化函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//端口初始化</span><span class="token function">pinMode</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">pinMode</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p><strong>pin:</strong> 为指定配置的引脚编号</p></li><li><p>mode:</p><p> 为指定的配置模式 通常可用模式有三种:</p><ul><li><strong>INPUT:</strong> 输入模式 (DDRx&#x3D;0xFF)</li><li><strong>OUTPUT:</strong> 输出模式 (DDRx&#x3D;0x00)</li><li><strong>INPUT_PULLUP:</strong> 输入上拉模式 (DDRx&#x3D;0xFF;PORTx&#x3D;0xFF)</li></ul></li></ul><h2 id="输出电平函数"><a href="#输出电平函数" class="headerlink" title="输出电平函数"></a>输出电平函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//输出电平函数</span><span class="token function">digitalWrite</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">digitalWrite</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">,</span> <span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 为指定输出的引脚编号；</li><li><strong>value:</strong> 为你要指定输出的电平<ul><li><strong>HIGH:</strong> 指定输出高电平(1)</li><li><strong>LOW:</strong> 指定输出低电平(0)(PORTx)</li></ul></li></ul><h2 id="读取电平函数"><a href="#读取电平函数" class="headerlink" title="读取电平函数"></a>读取电平函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//读取输入电平函数</span><span class="token function">digitalRead</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">digitalRead</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 为指定读取状态的引脚编号。(PINx)</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>获取到的信号状态，1为高电平，0为低电平。</li></ul><h1 id="模拟输入输出"><a href="#模拟输入输出" class="headerlink" title="模拟输入输出"></a>模拟输入输出</h1><p>模拟输入引脚是带有ADC（Analog-to-Digital Converter，模数转换器）功能的引脚。<br>它可以将外部输入的模拟信号转换为芯片运算时可以识别的数字信号，从而实现读入模拟值的功能。</p><h2 id="模拟信号输入函数"><a href="#模拟信号输入函数" class="headerlink" title="模拟信号输入函数"></a>模拟信号输入函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//模拟信号输入函数</span><span class="token function">analogRead</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">analogRead</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 是指定要读取模拟值的引脚，被指定的引脚必须是模拟输入引脚。<br>如<code>analogRead(A0)</code>，即是读取<code>A0</code>引脚上的模拟值。</li></ul><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p><code>Arduino Uno</code>模拟输入功能有10位精度，即可以将0～5V的电压信号转换为0～1023的整数形式表示。</p><h2 id="模拟信号输出（PWM）函数"><a href="#模拟信号输出（PWM）函数" class="headerlink" title="模拟信号输出（PWM）函数"></a>模拟信号输出（PWM）函数</h2><p>在<code>Arduino Uno</code>中，提供PWM功能的引脚为3、5、6、9、10、11。<br>在<code>analogWrite()</code> 和<code>analogRead() </code>函数内部，已经完成了引脚的初始化，因此不用在Setup() 函数中进行初始化操作。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//模拟信号输出函数</span><span class="token function">analogWrite</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">analogWrite</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 是指定要输出PWM波的引脚；</li><li><strong>value:</strong> 指定是PWM的脉冲宽度，范围为0～255。</li></ul><h2 id="模拟电压输出函数"><a href="#模拟电压输出函数" class="headerlink" title="模拟电压输出函数"></a>模拟电压输出函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//模拟电压输出函数</span><span class="token function">analogReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">analogReference</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>为模拟电压输入设置参考值；</li></ul><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><ul><li>analogReference(type)</li></ul><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><p>type有以下几个选项：</p><ul><li>DEFAULT: 默认参考值5v (在5V的 板子上 ) 或者 3.3 v (在3.3V 的Arduino板子上)；</li><li>INTERNAL: 内置参考值, 在 ATmega168 或者ATmega328板子上为1.1v；在ATmega8 板子上为2.56v (在Arduino Mega板子上不可获得)。</li><li>INTERNAL1V1: 内置的1.1V 参考值 (只在Arduino Mega板子上有效 )</li><li>INTERNAL2V56: 内置的2.56V 参考值 (只在Arduino Mega板子上有效)</li><li>EXTERNAL: 在AREF引脚加的电压(0 ~ 5V)将作为参考值 。 AREF外接电源后不能使用其他的基准源,使用时会引起片内基准源与外部参考源短路</li></ul><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><ul><li>-none</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>改变参考值的时候，刚开始的读数可能不准确。<br>不要用低于0v或高于5v的电压加在AREF引脚。如果使用加在AREF的外部电压作为参考那一定要在调用<code>analogRead()</code>之前设置<code>analogReference</code>为<code>EXTERNAL</code>，否则可能毁坏芯片。<br>也可以使用一个5千欧的电阻连接外部参考电压到AREF引脚，这样可以方便地在内外参考电压间转换，不过请注意电阻将改变原先你想要的参考值，因为在AREF引脚内部有个32千欧的内置电阻。这样两个电阻就可以分压了，例如：加的是2.5v，那么在AREF引脚的电压就是：2.5 * 32 &#x2F; (32 + 5) &#x3D; ~2.2V 。</p><h1 id="高级输入输出"><a href="#高级输入输出" class="headerlink" title="高级输入输出"></a>高级输入输出</h1><h2 id="输出50-方波函数"><a href="#输出50-方波函数" class="headerlink" title="输出50%方波函数"></a>输出50%方波函数</h2><p><code>tone() </code>主要用于<code>Arduino</code>连接蜂鸣器或扬声器发声。可以让指定引脚产生一个占空比为<code>50%</code>的指定频率的方波。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//输出50%方波函数</span><span class="token function">tone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">tone</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> _pin<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> frequency<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> duration <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">tone</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> frequency<span class="token punctuation">)</span> <span class="token function">tone</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> frequency<span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 需要输出方波的引脚</li><li><strong>frequency:</strong> 输出的频率，unsigned int型</li><li><strong>duration:</strong> 方波持续的时间，单位毫秒。如果没有该参数，Arduino将持续发出设定的音调，直到你改变发声频率或者使用<code>noTone()</code> 函数停止发声。</li></ul><h2 id="停止输出50-方波函数"><a href="#停止输出50-方波函数" class="headerlink" title="停止输出50%方波函数"></a>停止输出50%方波函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//停止输出50%方波函数</span><span class="token function">noTone</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">noTone</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> _pin<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><ul><li><strong>noTone(pin)</strong></li></ul><h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 需要停止方波输出的引脚</li></ul><h2 id="检测脉冲宽度函数"><a href="#检测脉冲宽度函数" class="headerlink" title="检测脉冲宽度函数"></a>检测脉冲宽度函数</h2><p>例如当要检测高电平脉冲时，<code>pulseIn()</code> 会等待指定引脚输入的电平变高，当变高后开始记时，直到输入电平变低，停止计时。<br><code>pulseln() </code>函数会返回这个脉冲信号持续的时间，即这个脉冲的宽度。<br>函数还可以设定超时时间。如果超过设定时间，仍未检测到脉冲，则会退出<code>pulseIn()</code>函数并返回0。<br>当没有设定超时时间时，<code>pulseIn() </code>会默认1秒钟的超时时间。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//检测脉冲宽度函数</span><span class="token function">pulseIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">pulseIn</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> pin<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> state<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> timeout <span class="token operator">=</span> <span class="token number">1000000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><ul><li>pulseIn(pin, value)</li><li>pulseIn(pin, value, timeout)</li></ul><h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><ul><li>pin：需要读取脉冲的引脚</li><li>value：需要读取的脉冲类型，HIGH或LOW</li><li>timeout：超时时间，单位微秒，数据类型为无符号长整型。</li></ul><h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回脉冲宽度，单位微秒，数据类型为无符号长整型。如果在指定时间内没有检测到脉冲，则返回0。</li></ul><h2 id="外部中断函数"><a href="#外部中断函数" class="headerlink" title="外部中断函数"></a>外部中断函数</h2><p>对中断引脚进行初始化配置，以开启Arduino的外部中断功能</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//中断配置函数</span><span class="token function">attachInterrupt</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> ISR<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><ul><li>pin：中断引脚,部分为中断源标号</li></ul><table><thead><tr><th align="center">型号 编号</th><th align="center">int.0</th><th align="center">int.1</th><th align="center">int.2</th><th align="center">int.3</th><th align="center">int.4</th><th align="center">int.5</th></tr></thead><tbody><tr><td align="center">UNO\Ethernet</td><td align="center">2</td><td align="center">3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Mega2560</td><td align="center">2</td><td align="center">3</td><td align="center">21</td><td align="center">20</td><td align="center">19</td><td align="center">18</td></tr><tr><td align="center">Leonardo</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">1</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Due</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td><td align="center">所有IO口均可</td></tr></tbody></table><ul><li><strong>ISR:</strong> 中断函数名</li><li><strong>mode:</strong> 中断模式<ul><li><strong>LOW:</strong> 低电平触发</li><li><strong>CHANGE:</strong> 变化时触发</li><li><strong>RISING:</strong> 低电平变为高电平时触发</li><li><strong>FALLING:</strong> 高电平变低电平时触发</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">attachInterrupt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> Hello<span class="token punctuation">,</span> LOW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该语句会开启Arduino Uno的 2号引脚（中断编号0）的外部中断功能，并指定下降沿时触发该中断。<br>当2号引脚上电平由高变低后，该中断会被触发，Arduino即会运行Hello() 函数中的语句。</p><h2 id="关闭中断函数"><a href="#关闭中断函数" class="headerlink" title="关闭中断函数"></a>关闭中断函数</h2><p>中断分离函数,关闭中断功能。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">detachInterrupt</span><span class="token punctuation">(</span>pin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h3><ul><li><strong>pin:</strong> 需要禁用中断的引脚。<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3></li></ul> <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">detachInterrupt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="外部中断寄存器模式"><a href="#外部中断寄存器模式" class="headerlink" title="外部中断寄存器模式"></a>外部中断寄存器模式</h1><p>外部中断控制寄存器- <strong>EICRA</strong></p><table><thead><tr><th></th><th></th><th></th><th></th><th>ISC11</th><th>ISC10</th><th>ISC01</th><th>ISC00</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>INT0:(ISC11&amp;ISC10) </p><p>INT1:(ISC01&amp;ISC00)</p><ul><li>00:低电平触发</li><li>01:逻辑变化触发</li><li>10:下降沿触发</li><li>11:上升沿触发</li></ul><p>外部中断屏蔽寄存器- <strong>EIMSK</strong></p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th>INT1</th><th>INT0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>0:中断关闭</li><li>1:中断使能外部中断标志位寄存器- <strong>EIFR</strong></li></ul><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th>INTF1</th><th>INTF0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>当中断触发标志位置高,执行ISR或向标志位写’1’时标志位重置</p><h3 id="中断函数总结"><a href="#中断函数总结" class="headerlink" title="中断函数总结"></a>中断函数总结</h3><p>单片机的中断可以描述为：由于某一随机事件的发生，单片机暂停在原程序的运行，转而执行另一个程序（随机事件），处理完毕之后又自动回到断点处继续执行。</p><p>其中， 中断源、主程序、中断服务程序简述如下：</p><ul><li>中断源：引起中断的原因，或能够发生中断请求的来源。</li><li>主程序：单片机现在运行的程序。</li><li>中断服务程序：处理中断请求的程序。</li><li><code>interrupts()</code>和<code>noInterrupts()</code>在Arduino中，<code>interrupts</code>函数和<code>noInterrupts</code>函数分别负责打开与关闭中断，这两个函数均为无返回值的函数，无参数。</li><li><code>attachInterrrupt(interrupt，function，mode)</code>该函数用于设置外部中断，有三个参数，分别表示中断源、中断处理函数和触发模式，它们的具体含义如下：<ul><li>中断源：可选0、1，对应2或3号数字引脚。</li><li>中断处理函数：指定中断的处理函数，是一段程序，当中断发生时执行该子程序部分，其中参数为函数的指针。</li><li>触发模式：有四种类型-LOW（低电平触发）、CHANGE（跳变时触发）、RISING(上升沿触发）、FALLING（下降沿触发）。</li><li><code>detachInterrupt(interrupt)</code>用于取消中断。</li></ul></li></ul><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_LOW</span><span class="token expression"><span class="token number">0</span>b00</span><span class="token comment">//低电平触发</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_CHANGE</span><span class="token expression"><span class="token number">0</span>b01</span><span class="token comment">//逻辑变化触发</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_FALL</span><span class="token expression"><span class="token number">0</span>b10</span><span class="token comment">//下降沿触发</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXINT_RISE</span><span class="token expression"><span class="token number">0</span>b11</span><span class="token comment">//上升沿触发</span></span><span class="token keyword">void</span> <span class="token function">SetInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//外部中断</span><span class="token punctuation">&#123;</span><span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Set EXINT0(pin->PD2), EXINT1(pin->PD3) to Mode INPUT_PULLUP </span>DDRD <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PORTD <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD2<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> PD3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Set EXINT Mode to catch FALLING EDGE 下降沿触发中断</span>EICRA <span class="token operator">|=</span> <span class="token punctuation">(</span>EXINT_FALL <span class="token operator">&lt;&lt;</span> ISC00<span class="token punctuation">)</span><span class="token punctuation">;</span>EICRA <span class="token operator">|=</span> <span class="token punctuation">(</span>EXINT_FALL <span class="token operator">&lt;&lt;</span> ISC10<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Enable EXINT</span>EIMSK <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INT1<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> INT0<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启用外部中断</span><span class="token function">sei</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// EXINT0(p2)</span><span class="token function">ISR</span><span class="token punctuation">(</span>INT0_vect<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// EXINT1(p3)</span><span class="token function">ISR</span><span class="token punctuation">(</span>INT1_vect<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h1><h2 id="串口设置"><a href="#串口设置" class="headerlink" title="串口设置"></a>串口设置</h2><h3 id="Serial-begin"><a href="#Serial-begin" class="headerlink" title="Serial.begin();"></a>Serial.begin();</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>开启串口，通常置于setup()函数中。</li></ul><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><ul><li><p>Serial.begin(speed);  </p></li><li><p>Serial.begin(speed,config);</p></li></ul><h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4><ul><li><p>speed: 波特率，一般取值300, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600,115200</p></li><li><p>config: 设置数据位、校验位和停止位。例如Serial.begin(speed,Serial_8N1);  Serial_8N1中：8表示8个数据位，N表示没有校验，1表示有1个停止位。</p></li></ul><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// opensserial port, sets data rate to 9600 bps </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Serial-end"><a href="#Serial-end" class="headerlink" title="Serial.end();"></a>Serial.end();</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li>禁止串口传输函数。此时串口传输的pin脚可以作为数字IO脚使用。</li></ul><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.end()</li></ul><h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-1"><a href="#返回-1" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h2 id="清空串口缓存"><a href="#清空串口缓存" class="headerlink" title="清空串口缓存"></a>清空串口缓存</h2><h3 id="Serial-flush"><a href="#Serial-flush" class="headerlink" title="Serial.flush();"></a>Serial.flush();</h3><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul><li>1.0版本之前为清空串口缓存，现在该函数作用为等待输出数据传送完毕。如果要清空串口缓存的话，可以使用：while(Serial.read() &gt;&#x3D; 0)来代替。</li></ul><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.flush ()</li></ul><h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-2"><a href="#返回-2" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h3 id="while-Serial-read-gt-x3D-0"><a href="#while-Serial-read-gt-x3D-0" class="headerlink" title="while(Serial.read()&gt;&#x3D; 0){}"></a>while(Serial.read()&gt;&#x3D; 0){}</h3><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ul><li>因Serial.read()函数读取串口缓存中的一个字符，并删除已读字符。因此可以用这句代码来清空串口缓存。实验代码详见下文代码。</li></ul><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><ul><li>while(Serial.read() &gt;&#x3D;0){}</li></ul><h4 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-3"><a href="#返回-3" class="headerlink" title="返回"></a>返回</h4><ul><li>None</li></ul><h2 id="输出串口数据"><a href="#输出串口数据" class="headerlink" title="输出串口数据"></a>输出串口数据</h2><h3 id="Serial-print"><a href="#Serial-print" class="headerlink" title="Serial.print();"></a>Serial.print();</h3><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ul><li>串口输出数据函数，写入字符串数据到串口。</li></ul><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><ul><li><p>Serial.print(val)</p></li><li><p>Serial.print(val,format)</p></li></ul><h4 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h4><ul><li><p>val: 打印的值，任意数据类型</p></li><li><p>format: 输出的数据格式，包括整数类型和浮点型数据的小数点位数。</p></li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> BIN<span class="token punctuation">)</span> 得到 <span class="token string">"1001110"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> OCT<span class="token punctuation">)</span> 得到 <span class="token string">"116"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> DEC<span class="token punctuation">)</span> 得到 <span class="token string">"78"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">78</span><span class="token punctuation">,</span> HEX<span class="token punctuation">)</span> 得到 <span class="token string">"4E"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1.23456</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> 得到 <span class="token string">"1"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1.23456</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> 得到 <span class="token string">"1.23"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1.23456</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> 得到 <span class="token string">"1.2346"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token char">'N'</span><span class="token punctuation">)</span> 得到 <span class="token string">"N"</span>Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello world."</span><span class="token punctuation">)</span> 得到 <span class="token string">"Hello world."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Serial-println"><a href="#Serial-println" class="headerlink" title="Serial.println();"></a>Serial.println();</h3><h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p>写入字符串数据，并换行。实验代码详见下文。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.println(val) </li><li>Serial.println(val,format)</li></ul><h4 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h4><ul><li><p>val: 打印的值，任意数据类型 </p></li><li><p>format: 输出的数据格式，包括整数类型和浮点型数据的小数点位数。</p></li></ul><h4 id="返回-4"><a href="#返回-4" class="headerlink" title="返回"></a>返回</h4><ul><li>字节</li></ul><h3 id="Serial-SerialEvent"><a href="#Serial-SerialEvent" class="headerlink" title="Serial.SerialEvent();"></a>Serial.SerialEvent();</h3><h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><ul><li>串口数据准备好时触发的事件函数，即串口数据准备好调用该函数。</li></ul><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.serialEvent{&#x2F;&#x2F;statements}</li></ul><h4 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h4><ul><li>statements: 任何有效的语句。</li></ul><h2 id="读串口缓存区数据"><a href="#读串口缓存区数据" class="headerlink" title="读串口缓存区数据"></a>读串口缓存区数据</h2><h3 id="Serial-available"><a href="#Serial-available" class="headerlink" title="Serial.available();"></a>Serial.available();</h3><h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><ul><li>判断串口缓冲器的状态函数，用以判断数据是否送达串口。注意使用时通常用delay(100)以保证串口字符接收完毕，即保证Serial.available()返回的是缓冲区准确的可读字节数。</li></ul><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.available();</li></ul><h4 id="参数-18"><a href="#参数-18" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-5"><a href="#返回-5" class="headerlink" title="返回"></a>返回</h4><ul><li>返回缓冲区可读字节数目</li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待数据传完</span>    <span class="token keyword">int</span> numdata <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.available = :"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>numdata<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//清空串口缓存</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225354.jpeg" alt="img" loading="lazy"></p><h3 id="Serial-read"><a href="#Serial-read" class="headerlink" title="Serial.read();"></a>Serial.read();</h3><h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><ul><li>读取串口数据，一次读一个字符，读完后删除已读数据。</li></ul><h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.read();</li></ul><h4 id="参数-19"><a href="#参数-19" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-6"><a href="#返回-6" class="headerlink" title="返回"></a>返回</h4><ul><li>返回串口缓存中第一个可读字节，当没有可读数据时返回-1，整数类型。</li></ul><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> comchar<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token operator">/</span> <span class="token operator">/</span>clear serialbuffer<span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    comchar <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读串口第一个字节</span>    Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.read: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comchar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225507.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial.read()每次从串口缓存中读取第一个字符，并将读过的字符删除。</p><h3 id="Serial-peek"><a href="#Serial-peek" class="headerlink" title="Serial.peek();"></a>Serial.peek();</h3><h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h4><ul><li>读串口缓存中下一字节的数据（字符型），但不从内部缓存中删除该数据。也就是说，连续的调用peek()将返回同一个字符。而调用read()则会返回下一个字符。</li></ul><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.peek();</li></ul><h4 id="参数-20"><a href="#参数-20" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-7"><a href="#返回-7" class="headerlink" title="返回"></a>返回</h4><ul><li>返回串口缓存中下一字节（字符）的数据，如果没有返回-1，整数int型</li></ul><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> comchar<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    comchar <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.peek: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comchar<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225600.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial.peek()每次从串口缓存中读取一个字符，并不会将读过的字符删除。第二次读取时仍然为同一个字符。</p><h3 id="Serial-readBytes-buffer-length"><a href="#Serial-readBytes-buffer-length" class="headerlink" title="Serial.readBytes(buffer,length);"></a>Serial.readBytes(buffer,length);</h3><h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口读取指定长度length的字符到缓存数组buffer。</li></ul><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readBytes(buffer,length);</li></ul><h4 id="参数-21"><a href="#参数-21" class="headerlink" title="参数"></a>参数</h4><ul><li><p>buffer: 缓存变量</p></li><li><p>length:设定的读取长度</p></li></ul><h4 id="返回-8"><a href="#返回-8" class="headerlink" title="返回"></a>返回</h4><ul><li>返回存入缓存的字符数，0表示没有有效数据。</li></ul><h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> numdata<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serial port</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      numdata <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">readBytes</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readBytes:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">18</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225657.jpeg" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225703.jpeg" alt="img" loading="lazy"></p><p>从串口缓存读取指定长度为3的字节。</p><h3 id="Serial-readBytesUntil-character-buffer-length"><a href="#Serial-readBytesUntil-character-buffer-length" class="headerlink" title="Serial.readBytesUntil(character,buffer,length);"></a>Serial.readBytesUntil(character,buffer,length);</h3><h4 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存读取指定长度的字符到数组buffer，遇到终止字符character后停止。</li></ul><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readBytesUntil(character ,buffer,length);</li></ul><h4 id="参数-22"><a href="#参数-22" class="headerlink" title="参数"></a>参数</h4><ul><li><p>character : 查找的字符 (char)</p></li><li><p>buffer: 存储读取数据的缓存(char[] 或byte[])</p></li><li><p>length:设定的读取长度</p></li></ul><h4 id="返回-9"><a href="#返回-9" class="headerlink" title="返回"></a>返回</h4><ul><li>返回存入缓存的字符数，0表示没有有效数据。</li></ul><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> character <span class="token operator">=</span> <span class="token char">','</span><span class="token punctuation">;</span> <span class="token comment">//终止字符</span><span class="token keyword">int</span> numdata<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialport</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      numdata <span class="token operator">=</span>Serial<span class="token punctuation">.</span><span class="token function">readBytesUntil</span><span class="token punctuation">(</span>character<span class="token punctuation">,</span>buffer<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readBytes:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">18</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        buffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230024.jpeg" loading="lazy"></p><p>从串口缓存中读取3个字符，当遇到”,”时终止读取。</p><h3 id="Serial-readString-；"><a href="#Serial-readString-；" class="headerlink" title="Serial.readString()；"></a>Serial.readString()；</h3><h4 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取全部数据到一个字符串型变量。</li></ul><h4 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readString();</li></ul><h4 id="参数-23"><a href="#参数-23" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-10"><a href="#返回-10" class="headerlink" title="返回"></a>返回</h4><ul><li>返回从串口缓存区中读取的一个字符串。</li></ul><h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">String comdata <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comdata <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">readString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readString:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    comdata <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230024.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial.readString()从串口缓存中读取字符至字符串。</p><h3 id="Serial-readStringUntil"><a href="#Serial-readStringUntil" class="headerlink" title="Serial.readStringUntil();"></a>Serial.readStringUntil();</h3><h4 id="说明-13"><a href="#说明-13" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取字符到一个字符串型变量，直至读完或遇到某终止字符。</li></ul><h4 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.readStringUntil(terminator)</li></ul><h4 id="参数-24"><a href="#参数-24" class="headerlink" title="参数"></a>参数</h4><ul><li>terminator:终止字符(cha型)</li></ul><h4 id="返回-11"><a href="#返回-11" class="headerlink" title="返回"></a>返回</h4><ul><li>从串口缓存区中读取的整个字符串，直至检测到终止字符。</li></ul><h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">String comdata <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">char</span> terminator <span class="token operator">=</span> <span class="token char">','</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comdata <span class="token operator">=</span>Serial<span class="token punctuation">.</span><span class="token function">readStringUntil</span><span class="token punctuation">(</span>terminator<span class="token punctuation">)</span><span class="token punctuation">;</span>     Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.readStringUntil: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-3"><a href="#实验结果-3" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409225902.jpeg" alt="img" loading="lazy"></p><p>从串口读取所有字符存放于字符串comdata，直至遇到字符”,”时终止读取。</p><h3 id="Serial-parseFloat"><a href="#Serial-parseFloat" class="headerlink" title="Serial.parseFloat();"></a>Serial.parseFloat();</h3><h4 id="说明-14"><a href="#说明-14" class="headerlink" title="说明"></a>说明</h4><ul><li>读串口缓存区第一个有效的浮点型数据，数字将被跳过。当读到第一个非浮点数时函数结束。</li></ul><h4 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.parseFloat()</li></ul><h4 id="参数-25"><a href="#参数-25" class="headerlink" title="参数"></a>参数</h4><ul><li>None</li></ul><h4 id="返回-12"><a href="#返回-12" class="headerlink" title="返回"></a>返回</h4><ul><li>返回串口缓存区第一个有效的浮点型数据，数字将被跳过。</li></ul><h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> comfloat<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comfloat <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.parseFloat:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comfloat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-4"><a href="#实验结果-4" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230045.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial. parseFloat()从串口缓存中读取第一个有效的浮点数，第一个有效数字之前的负号也将被读取，独立的负号将被舍弃。</p><h3 id="Serial-parseInt"><a href="#Serial-parseInt" class="headerlink" title="Serial.parseInt()"></a>Serial.parseInt()</h3><h4 id="说明-15"><a href="#说明-15" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口接收数据流中读取第一个有效整数（包括负数）。</li></ul><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>非数字的首字符或者负号将被跳过</p></li><li><p>当可配置的超时值没有读到有效字符时，或者读不到有效整数时，分析停止</p></li><li><p>如果超时且读不到有效整数时，返回0</p></li></ul><h4 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h4><p>Serial.parseInt()</p><p>Serial.parseInt(charskipChar)</p><h4 id="参数-26"><a href="#参数-26" class="headerlink" title="参数"></a>参数</h4><ul><li>skipChar用于在搜索中跳过指定字符（此用法未知）</li></ul><h4 id="返回-13"><a href="#返回-13" class="headerlink" title="返回"></a>返回</h4><ul><li>返回下一个有效整型值。</li></ul><h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> comInt<span class="token punctuation">;</span> <span class="token function">voidsetup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      comInt <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Serial.parseInt:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-5"><a href="#实验结果-5" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409230007.jpeg" alt="img" loading="lazy"></p><p>从实验结果可以看出：Serial. parseInt()从串口缓存中读取第一个有效整数，第一个有效数字之前的负号也将被读取，独立的负号将被舍弃。</p><h2 id="串口查找指定字符串"><a href="#串口查找指定字符串" class="headerlink" title="串口查找指定字符串"></a>串口查找指定字符串</h2><h3 id="Serial-find"><a href="#Serial-find" class="headerlink" title="Serial.find()"></a>Serial.find()</h3><h4 id="说明-16"><a href="#说明-16" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取数据，寻找目标字符串target(char型)</li></ul><h4 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h4><ul><li><p>char target[] &#x3D; ”目标字符串”;</p></li><li><p>Serial.find(target);</p></li></ul><h4 id="参数-27"><a href="#参数-27" class="headerlink" title="参数"></a>参数</h4><ul><li>target: 目标字符串（char型）</li></ul><h4 id="返回-14"><a href="#返回-14" class="headerlink" title="返回"></a>返回</h4><ul><li>找到目标字符串返回真，否则为假</li></ul><h4 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> target<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"test"</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span> Serial<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"find traget:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-6"><a href="#实验结果-6" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://img-blog.csdn.net/20151216230204010" alt="img" loading="lazy"></p><p>串口输入字符中只要有test,函数返回真，打印出目标字符串”test”，否则返回假，不打印任何值。</p><h3 id="Serial-findUntil-target-terminal"><a href="#Serial-findUntil-target-terminal" class="headerlink" title="Serial.findUntil(target,terminal);"></a>Serial.findUntil(target,terminal);</h3><h4 id="说明-17"><a href="#说明-17" class="headerlink" title="说明"></a>说明</h4><ul><li>从串口缓存区读取数据，寻找目标字符串target(char型数组)，直到出现给定字符串terminal(char型)，找到为真，否则为假。</li></ul><h4 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h4><ul><li>Serial.findUntil(target,terminal);</li></ul><h4 id="参数-28"><a href="#参数-28" class="headerlink" title="参数"></a>参数</h4><ul><li><p>target : 目标字符串（char型）</p></li><li><p>terminal : 结束搜索字符串（char型）</p></li></ul><h4 id="返回-15"><a href="#返回-15" class="headerlink" title="返回"></a>返回</h4><ul><li>如果在找到终止字符terminal之前找到目标字符target，返回真，否则返回假。</li></ul><h4 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> target<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"test"</span><span class="token punctuation">;</span><span class="token keyword">char</span> terminal<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"end"</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//clear serialbuffer</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// read data from serial port</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span> Serial<span class="token punctuation">.</span><span class="token function">findUntil</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>terminal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         Serial<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"find traget:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Serial<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// clear serial buffer</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>Serial<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验结果-7"><a href="#实验结果-7" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://img-blog.csdn.net/20151216230345691" alt="img" loading="lazy"></p><p>如果串口缓存中有目标字符”test”，返回真，但如果先遇到终止字符串”end”则函数立即终止，不论字符串后面有没有目标字符”test”。</p><h2 id="向串口写数据"><a href="#向串口写数据" class="headerlink" title="向串口写数据"></a>向串口写数据</h2><h3 id="Serial-write"><a href="#Serial-write" class="headerlink" title="Serial.write();"></a>Serial.write();</h3><h4 id="说明-18"><a href="#说明-18" class="headerlink" title="说明"></a>说明</h4><ul><li>串口输出数据函数。写二进制数据到串口。</li></ul><h4 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h4><ul><li><p>Serial.write(val) </p></li><li><p>Serial.write(str) </p></li><li><p>Serial.write(buf, len)</p></li></ul><h4 id="参数-29"><a href="#参数-29" class="headerlink" title="参数"></a>参数</h4><ul><li><p>val: 字节 </p></li><li><p>str: 一串字节 </p></li><li><p>buf: 字节数组 </p></li><li><p>len: buf的长度</p></li></ul><h4 id="返回-16"><a href="#返回-16" class="headerlink" title="返回"></a>返回</h4><ul><li>字节长度</li></ul><h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> Serial<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token number">9600</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   Serial<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// send a byte with thevalue 45 </span>  <span class="token keyword">int</span> bytesSent <span class="token operator">=</span> Serial<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>“hello”<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//sendthe string “hello” and return the length of the string. </span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_42863355/article/details/102759709">https://blog.csdn.net/qq_42863355/article/details/102759709</a></p><p><a href="https://blog.csdn.net/iracer/article/details/50334041">https://blog.csdn.net/iracer/article/details/50334041</a></p><p><a href="https://blog.csdn.net/GuanFuXinCSDN/article/details/104144362">https://blog.csdn.net/GuanFuXinCSDN/article/details/104144362</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPIO </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino uno介绍</title>
      <link href="/posts/c3972d29/"/>
      <url>/posts/c3972d29/</url>
      
        <content type="html"><![CDATA[<h1 id="Arduino介绍"><a href="#Arduino介绍" class="headerlink" title="Arduino介绍"></a>Arduino介绍</h1><p>官网链接 <a href="https://www.arduino.cc/">Arduino</a></p><p>Arduino是源自意大利的一个开放源代码的硬件项目平台，该平台包括一块具备简单I&#x2F;O功能的电路板以及一套程序开发环境软件。Arduino可以用来开发交互产品，比如它可以读取大量的开关和传感器信号，并且可以控制电灯、电机和其他各式各样的物理设备；Arduino也可以开发出与PC相连的周边装置，能在运行时与PC上的软件进行通信。Arduino的硬件电路板可以自行焊接组装，也可以购买已经组装好的模块，而程序开发环境的软件则可以从网上免费下载并使用。</p><h1 id="Arduino-Uno引脚分配图"><a href="#Arduino-Uno引脚分配图" class="headerlink" title="Arduino Uno引脚分配图"></a><strong>Arduino Uno引脚分配图</strong></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409212401.png" alt="img" loading="lazy"></p><table><thead><tr><th>引脚</th><th>作用</th></tr></thead><tbody><tr><td>0和1接口</td><td>串口输出输入（入门很少用到，如无必要尽量不用这两个接口）</td></tr><tr><td>2到13接口</td><td>可作为数字输入输出 (输出or输入，可自己定义) 其中带 ~ 符号的可作为模拟输出</td></tr><tr><td>A0到A5</td><td>模拟输入</td></tr><tr><td>GND</td><td>接地线</td></tr><tr><td>5V</td><td>输出5V电压</td></tr><tr><td>3.3V</td><td>输出3.3V电压</td></tr><tr><td>Vin</td><td>外部电源给arduino供电 ，电压要在7~12V之间</td></tr><tr><td>SCL与SDA</td><td>I2c接口，初学者很少用</td></tr></tbody></table><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>数字输入输出：只有0和1两种状态，表示开或关（高电平或低电平）</li><li>模拟输入输出：就是将电信号转化为一系列数值，有一系列的量，如可设置灯泡百分之几的亮度，而不是只有开关。</li><li>模拟输入：0-5V的电压转换为0-1023的整数来表示</li><li>模拟输出：PWM （脉宽调制）输出 （0~255）</li><li>高电平低电平：Arduino一般用的是5V的电压，超过3V就算是高电平，低于1.5V就是低电平啦，一般来说高电平就是5V上下，低电平就是指的0V。</li><li>PWM ：（脉宽调制）输出，带PWM功能的引脚标有波浪线 ‘~’。</li><li>拉高：给Arduino的引脚设定了模式之后，有时并未指定引脚的状态，引脚会悬空，状态忽高忽低，拉高就是说让引脚保持高电平的状态</li><li>拉低：相反</li></ul><h1 id="Arduino-Uno-R3-详细参数"><a href="#Arduino-Uno-R3-详细参数" class="headerlink" title="Arduino Uno R3 - 详细参数"></a><em><strong>Arduino Uno R3 - 详细参数</strong></em></h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213026.png" alt="img" loading="lazy"></p><h1 id="Arduino-Uno-R3-存储"><a href="#Arduino-Uno-R3-存储" class="headerlink" title="Arduino Uno R3 - 存储"></a><em><strong>Arduino Uno R3 - 存储</strong></em></h1><p>Arduino的存储空间即是其主控芯片所集成的存储空间。也可以通过使用外设芯片的方式来扩展Arduino的存储空间。</p><p>　　Arduino UNO的存储空间分三种：</p><ul><li>Flash，容量为32 KB。其中0. 5 KB作为BOOT区用于储存引导程序，实现通过串口下载程序的功能；另外的31.5 KB作为用户储存程序的空间。相对于现在动辄几百GB的硬盘，可能觉得32 KB太小了，但是在单片机上，32 KB已经可以存储很大的程序了。</li><li>SRAM，容量为2 KB。SRAM相当于计算机的内存，当CPU进行运算时，需要在其中开辟一定的存储空间。当Arduino 断电或复位后，其中的数据都会丢失。</li><li>EEPROM，容量为1 KB。EEPROM的全称为电可擦写的可编程只读存储器，是一种用户可更改的只读存储器，其特点是在Arduino断电或复位后，其中的数据不会丢失。</li></ul><h1 id="Arduino-Uno引脚分配-电源"><a href="#Arduino-Uno引脚分配-电源" class="headerlink" title="Arduino Uno引脚分配 - 电源"></a><strong>Arduino Uno引脚分配 - 电源</strong></h1><p>　　<strong>Arduino UNO可以通过3种方式供电：</strong></p><h2 id="1、直流电源插孔"><a href="#1、直流电源插孔" class="headerlink" title="1、直流电源插孔"></a>1、直流电源插孔</h2><p>　　可以使用直流电源插孔为Arduino开发板供电。电源插孔通常连接到一个适配器。</p><p>　　开发板的供电范围可以是6-20V，但制造商建议将其保持在7-12V之间。高于12V时，稳压芯片可能会过热，低于7V可能会供电不足。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213108.png" alt="img" loading="lazy"></p><h2 id="2、VIN引脚"><a href="#2、VIN引脚" class="headerlink" title="2、VIN引脚"></a>2、VIN引脚</h2><p>​        该引脚用于使用外部电源为Arduino Uno开发板供电。电压应控制在上述提到的范围内。</p><p><img src="https://img2020.cnblogs.com/blog/2103481/202009/2103481-20200907110948426-1333579329.png" alt="img" loading="lazy"></p><h2 id="3、USB接口"><a href="#3、USB接口" class="headerlink" title="3、USB接口"></a>3、USB接口</h2><p>​            连接到计算机时，提供500mA&#x2F;5V电压。</p><p><strong>所使用的供电方式决定了可用于电路的功率：</strong></p><ul><li>使用USB为电路供电时，电流最大限制在500mA。（考虑到该电源也用于为MCU、外围设备、板载稳压器和与其连接的组件供电。）</li><li>当通过电源插座或VIN为电路供电时，可用的最大电流取决于Arduino开发板上的5V和3.3V稳压器。</li></ul><p>　　<strong>电源引脚说明：</strong></p><p>　　<strong><img src="https://img2020.cnblogs.com/blog/2103481/202009/2103481-20200907111909648-418280813.png" alt="img" loading="lazy"></strong></p><ul><li>VIN — 可以通过此引脚向UNO供电；VIN有电时将忽略从USB或者其他引脚接入的电源</li><li>5V — 提供稳压的3.3V，为外部电子元件供电</li><li>3.3V — 提供稳压的3.3V，为外部电子元件供电</li><li>GND — GND引脚与设备外壳相接（接地），用于闭合电路回路，并在整个电路中提供一个公共逻辑参考电平。</li></ul><p><strong>Arduino Uno引脚分配 - 数字引脚</strong></p><p>Arduino Uno的引脚0-13用作数字输入&#x2F;输出引脚。其中，引脚13连接到板载的LED指示灯；引脚3、5、6、9、10、11具有PWM功能。</p><p>需要注意的是：</p><p>●  每个引脚可提供&#x2F;接收最高40 mA的电流。但推荐的电流是20毫安。</p><p>●  所有引脚提供的绝对最大电流为200mA。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213245.png" alt="img" loading="lazy"></p><h2 id="数字电平意味着什么？"><a href="#数字电平意味着什么？" class="headerlink" title="数字电平意味着什么？"></a><strong>数字电平意味着什么？</strong></h2><p>数字是一种表示1位电压的方式：0或1。Arduino上的数字引脚是根据用户需求设计为输入或输出的引脚。数字引脚可以打开或关闭。开启时，它们处于5V的高电平状态，当关闭时，它们处于0V的低电平状态。</p><p>在Arduino上，当数字引脚配置为输出时，它们设置为0或5V。</p><p>当数字引脚配置为输入时，电压由外部设备提供。该电压可以在0-5V之间变化，并转换成数字表示（0或1）。为了确定这一点，有2个阈值：</p><p>●  低于0.8v - 视为0。</p><p>●  高于2.0v - 视为1。</p><p>将组件连接到数字引脚时，确保逻辑电平匹配。如果电压在阈值之间，则返回值将不确定。</p><h1 id="Arduino-Uno引脚分配-模拟输入"><a href="#Arduino-Uno引脚分配-模拟输入" class="headerlink" title="Arduino Uno引脚分配 - 模拟输入"></a><em><strong>Arduino Uno引脚分配 - 模拟输入</strong></em></h1><p><img src="https://img2020.cnblogs.com/blog/2103481/202009/2103481-20200907112952054-1679928809.png" alt="img" loading="lazy"></p><p>Arduino uno r3 有6个模拟输入引脚（Analog In），可以用于接收模拟输入、用来测定0~5v的电压，但也可用作数字输入或数字输出。</p><p>　　我们看到上图中每一个模拟输入引脚前面都标注了一个ADC，这是什么含义呢？这里就涉及到了模拟输入的原理。</p><h2 id="ADC是什么？"><a href="#ADC是什么？" class="headerlink" title="ADC是什么？"></a><strong>ADC是什么？</strong></h2><p>ADC表示模拟到数字转换器。 ADC是用于将模拟信号转换为数字信号的电路。将输入的模拟信号通过ADC转换为数字信号，处理器才能对其进行处理。</p><p>　　这里讲的模拟输入是指0 ~ 5v的电压值。在Arduino上，ADC具有10位分辨率，这意味着它可以通过1,024个数字电平表示模拟电压。相当于将连续的电压值0 ~ 5v映射到离散的数值0<del>1023。将0 ~ 5 V的电压分成1024份（2^10^），算出来即为4.882mV的测量精度。即：0 ~ 4.882mV之间的电压值映射到数字0，4.883mV</del>9.764mV之间的电压值映射到数字1……</p><h1 id="Arduino-Uno引脚分配-关于模拟输出"><a href="#Arduino-Uno引脚分配-关于模拟输出" class="headerlink" title="Arduino Uno引脚分配 - 关于模拟输出"></a><em><strong>Arduino Uno引脚分配 - 关于模拟输出</strong></em></h1><p>Arduino控制板没有模拟输出引脚，但是数字引脚3、5、6、9、10、11具有PWM功能。</p><h2 id="PWM是什么？"><a href="#PWM是什么？" class="headerlink" title="PWM是什么？"></a><strong>PWM是什么？</strong></h2><p>　　脉冲宽带调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。</p><p>　　PWM是一种对模拟信号电平进行数字编码的方法。</p><p>　　PWM有两个关键组成部分：频率和占空比。频率决定了单个周期所用的时间。占空比 &#x3D; 一个周期中高电平所占的时间&#x2F;整个周期的时间。</p><p>　　<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409213801.png" alt="img" loading="lazy"></p><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a><em><strong>LED</strong></em></h2><ul><li>ON：电源指示灯，灯亮时表示Arduino已经通电</li><li>TX：串口发送指示灯。当使用USB连接到计算机且Arduino向计算机传输数据时，TX灯会点亮。</li><li>RX：串口接收指示灯。当使用USB连接到计算机且Arduino接收到计算机传来的数据时，RX灯会点亮。</li><li>L：可编程控制指示灯。该LED通过特殊电路连接到Arduino的13 号引脚，当13号引脚为高电平或高阻态时，该LED 会点亮；当为低电平时，不会点亮。因此可以通过程序或者外部输入信号来控制该LED的亮灭。可以用来测试板子是否正常：如果运行Blink程序时，L灯一闪一闪说明板子是好的。</li></ul><h1 id="RESET"><a href="#RESET" class="headerlink" title="RESET"></a><em><strong>RESET</strong></em></h1><p>　　按下该按键可以使Arduino重新启动，从头开始运行程序。</p><p>　　复位引脚接低电平会使Arduino复位。当复位键被按下时，会使该端口接到低电平，从而使Arduino复位。</p><h1 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a><strong>通信协议</strong></h1><p>串行（TTL） - 数字引脚0和1是Arduino Uno的串行引脚。</p><p>它们由板载USB模块使用。</p><h2 id="什么是串行通信？"><a href="#什么是串行通信？" class="headerlink" title="什么是串行通信？"></a><strong>什么是串行通信？</strong></h2><p>串行通信用于在Arduino板和其他串行设备（如计算机，显示器，传感器等）之间交换数据。每块Arduino板至少有一个串口。串行通信发生在数字引脚0（RX）和1（TX）以及USB上。 Arduino也支持通过数字引脚与<code>SoftwareSerial Library</code>进行串行通信。这允许用户连接多个支持串行的设备，并保留主串行端口可用于USB。</p><p>软件串行和硬件串行 - 大多数微控制器都具有用于与其他串行设备进行通信的硬件。软件串行端口使用引脚更改中断系统进行通信。有一个用于软件串行通信的内置库。处理器使用软件串行来模拟额外的串行端口。软件串行唯一的缺点是它需要更多的处理，并且不能支持与硬件串行相同的高速。</p><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a><strong>SPI</strong></h2><p> SS &#x2F; SCK &#x2F; MISO &#x2F; MOSI引脚是SPI通信的专用引脚。它们可以在Arduino Uno的数字引脚10-13和ICSP插头上找到。</p><p>串行外设接口（Serial Peripheral Interface，SPI）是一种串行数据协议，由微控制器用来与总线中的一个或多个外部设备进行通信，如连接。 SPI也可以用来连接2个微控制器。在SPI总线上，总是有一个设备表示为主设备，其余所有设备都表示为从设备。在大多数情况下，微控制器是主设备。 SS（从选择）引脚确定主器件当前正在与哪个器件通信。</p><p>启用SPI的器件始终具有以下引脚：</p><p>●  MISO（主从输出） - 用于向主设备发送数据的线路</p><p>●  MOSI（主机输出从机输入） - 发送数据到外围设备的主机线</p><p>●  SCK（串行时钟） - 由主设备生成的用于同步数据传输的时钟信号。</p><h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a><strong>I2C</strong></h2><p>SCL &#x2F; SDA引脚是I2C通信的专用引脚。在Arduino Uno上，它们可以在模拟引脚A4和A5上找到。</p><p>I2C通信协议通常称为“I2C总线”。 I2C协议旨在实现单个电路板上组件之间的通信。使用I2C时，有2条通信线，称为SCL和SDA。</p><p>●  SCL是用于同步数据传输的时钟线。</p><p>●  SDA是用于传输数据的通讯线。</p><p>I2C总线上的每个器件都有一个唯一的地址，最多可以在同一条总线上连接255个器件。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.yiboard.com/thread-831-1-1.html">https://www.yiboard.com/thread-831-1-1.html</a></p><p><a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/113663176">https://blog.csdn.net/chenhuanqiangnihao/article/details/113663176</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐迪AT9SPro连接双电机双电调车船调参</title>
      <link href="/posts/eeeaf652/"/>
      <url>/posts/eeeaf652/</url>
      
        <content type="html"><![CDATA[<h1 id="连接双电机双电调车船调参教程"><a href="#连接双电机双电调车船调参教程" class="headerlink" title="连接双电机双电调车船调参教程"></a>连接双电机双电调车船调参教程</h1><p>左边电机和右边电机分别接<code>二通道</code>和<code>四通道</code>，在可编程混控里面设置混控，对应摇杆如下图所示</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408020931.png" alt="image-20220408020931476" loading="lazy"></p><p>设置两个普通模式的混控</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021230.png" alt="image-20220408021229825" loading="lazy"></p><p>四通控制右边电机，用来控制方向，主控设置为<code>四通</code>，被控设置为<code>二通</code>，正反比例都是-100%</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021450.png" alt="image-20220408021450340" loading="lazy"></p><p>二通控制右边电机，用来控制前进后退，主控设置为<code>二通</code>，被控设置为<code>四通</code>，正反比例都是+100%</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021531.png" alt="image-20220408021531628" loading="lazy"></p><p>同时设置<code>SWE</code>为控制混控的打开和关闭</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408020509.png" alt="按键定义" loading="lazy"></p><p>这时候就可以自由控制船的前进后退与转向了</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220408021956.png" alt="image-20220408021955698" loading="lazy"></p><blockquote><p>  Tip：在接线的时候确保摇杆向左或者向上拨动螺旋桨的推力是向后的，这样就不用再在遥控器上面改变电机方向了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AT9SPro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/2f57a694/"/>
      <url>/posts/2f57a694/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式概述"><a href="#正则表达式概述" class="headerlink" title="正则表达式概述"></a>正则表达式概述</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h4 id="场景1：在一个文件中，查找出itcast开头的语句"><a href="#场景1：在一个文件中，查找出itcast开头的语句" class="headerlink" title="场景1：在一个文件中，查找出itcast开头的语句"></a>场景1：在一个文件中，查找出itcast开头的语句</h4><p>测试文件</p><pre class="line-numbers language-none"><code class="language-none">itcast hello pythonitcast c++itheima iositheima php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="场景：在一个文件中，找到含有itcast的语句"><a href="#场景：在一个文件中，找到含有itcast的语句" class="headerlink" title="场景：在一个文件中，找到含有itcast的语句"></a>场景：在一个文件中，找到含有itcast的语句</h4><p>测试文件</p><pre class="line-numbers language-none"><code class="language-none">hello itcast pythonwww.itcast.cn c++itheima iositheima php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="场景：在一个文件中，找到邮箱为163或者126的所有邮件地址"><a href="#场景：在一个文件中，找到邮箱为163或者126的所有邮件地址" class="headerlink" title="场景：在一个文件中，找到邮箱为163或者126的所有邮件地址"></a>场景：在一个文件中，找到邮箱为163或者126的所有邮件地址</h4><h1 id="re模块操作"><a href="#re模块操作" class="headerlink" title="re模块操作"></a>re模块操作</h1><p>在Python中需要通过正则表达式对字符串进行匹配的时候，可以使用一个模块，名字为re</p><h2 id="1-re模块的使用过程"><a href="#1-re模块的使用过程" class="headerlink" title="1. re模块的使用过程"></a>1. re模块的使用过程</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token comment"># 导入re模块</span><span class="token keyword">import</span> re<span class="token comment"># 使用match方法进行匹配操作</span>result <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span>正则表达式<span class="token punctuation">,</span>要匹配的字符串<span class="token punctuation">)</span><span class="token comment"># 如果上一步匹配到数据的话，可以使用group方法来提取数据</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-re模块示例-匹配以itcast开头的语句"><a href="#2-re模块示例-匹配以itcast开头的语句" class="headerlink" title="2. re模块示例(匹配以itcast开头的语句)"></a>2. re模块示例(匹配以itcast开头的语句)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reresult <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">,</span><span class="token string">"itcast.cn"</span><span class="token punctuation">)</span>result<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre class="line-numbers language-none"><code class="language-none">itcast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-说明"><a href="#3-说明" class="headerlink" title="3. 说明"></a>3. 说明</h2><ul><li>re.match() 能够匹配出以xxx开头的字符串</li></ul><h1 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h1><p>在上一小节中，了解到通过re模块能够完成使用正则表达式来匹配字符串</p><p>本小节，将要讲解正则表达式的单字符匹配</p><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">.</td><td align="left">匹配任意1个字符（除了\n）</td></tr><tr><td align="center">[ ]</td><td align="left">匹配[ ]中列举的字符</td></tr><tr><td align="center">\d</td><td align="left">匹配数字，即0-9</td></tr><tr><td align="center">\D</td><td align="left">匹配非数字，即不是数字</td></tr><tr><td align="center">\s</td><td align="left">匹配空白，即 空格，tab键</td></tr><tr><td align="center">\S</td><td align="left">匹配非空白</td></tr><tr><td align="center">\w</td><td align="left">匹配单词字符，即a-z、A-Z、0-9、_</td></tr><tr><td align="center">\W</td><td align="left">匹配非单词字符</td></tr></tbody></table><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1： ."></a>示例1： .</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"t.o"</span><span class="token punctuation">,</span><span class="token string">"too"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"t.o"</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Mtootwo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2：[ ]"></a>示例2：[ ]</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token comment"># 如果hello的首字符小写，那么正则表达式需要小写的h</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">,</span><span class="token string">"hello Python"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 如果hello的首字符大写，那么正则表达式需要大写的H</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"H"</span><span class="token punctuation">,</span><span class="token string">"Hello Python"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 大小写h都可以的情况</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[hH]"</span><span class="token punctuation">,</span><span class="token string">"hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[hH]"</span><span class="token punctuation">,</span><span class="token string">"Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[hH]ello Python"</span><span class="token punctuation">,</span><span class="token string">"Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 匹配0到9第一种写法</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0123456789]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"7Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 匹配0到9第二种写法</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0-9]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"7Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 匹配0到3 5到9</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0-35-9]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"7Hello Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 下面这个正则不能够匹配到数字4，因此ret为None</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[0-35-9]Hello Python"</span><span class="token punctuation">,</span><span class="token string">"4Hello Python"</span><span class="token punctuation">)</span><span class="token comment"># print(ret.group())</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">hHhHHello Python7Hello Python7Hello Python7Hello Python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例3：-d"><a href="#示例3：-d" class="headerlink" title="示例3：\d"></a>示例3：\d</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token comment"># 普通的匹配方式</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥1号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥1号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥2号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥2号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥3号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥3号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 使用\d进行匹配</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥\d号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥1号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥\d号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥2号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"嫦娥\d号"</span><span class="token punctuation">,</span><span class="token string">"嫦娥3号发射成功"</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">嫦娥<span class="token number">1</span>号嫦娥<span class="token number">2</span>号嫦娥<span class="token number">3</span>号嫦娥<span class="token number">1</span>号嫦娥<span class="token number">2</span>号嫦娥<span class="token number">3</span>号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>其他的匹配符参见后面章节的讲解</li></ul><h1 id="匹配多个字符"><a href="#匹配多个字符" class="headerlink" title="匹配多个字符"></a>匹配多个字符</h1><p>匹配多个字符的相关格式</p><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">匹配前一个字符出现0次或者无限次，即可有可无</td></tr><tr><td align="center">+</td><td align="left">匹配前一个字符出现1次或者无限次，即至少有1次</td></tr><tr><td align="center">?</td><td align="left">匹配前一个字符出现1次或者0次，即要么有1次，要么没有</td></tr><tr><td align="center">{m}</td><td align="left">匹配前一个字符出现m次</td></tr><tr><td align="center">{m,n}</td><td align="left">匹配前一个字符出现从m到n次</td></tr></tbody></table><h2 id="示例1：-1"><a href="#示例1：-1" class="headerlink" title="示例1：*"></a>示例1：*</h2><p>需求：匹配出，一个字符串第一个字母为大小字符，后面都是小写字母并且这些小写字母可有可无</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[A-Z][a-z]*"</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[A-Z][a-z]*"</span><span class="token punctuation">,</span><span class="token string">"MnnM"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[A-Z][a-z]*"</span><span class="token punctuation">,</span><span class="token string">"Aabcdef"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">MMnnAabcdef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="示例2：-1"><a href="#示例2：-1" class="headerlink" title="示例2：+"></a>示例2：+</h2><p>需求：匹配出，变量名是否有效</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> renames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"name1"</span><span class="token punctuation">,</span> <span class="token string">"_name"</span><span class="token punctuation">,</span> <span class="token string">"2_name"</span><span class="token punctuation">,</span> <span class="token string">"__name__"</span><span class="token punctuation">]</span><span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z_]+[\w]*"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"变量名 %s 符合要求"</span> <span class="token operator">%</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"变量名 %s 非法"</span> <span class="token operator">%</span> name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">变量名 name1 符合要求变量名 _name 符合要求变量名 2_name 非法变量名 __name__ 符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3：?"></a>示例3：?</h2><p>需求：匹配出，0到99之间的数字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?[0-9]"</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"33"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"09"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token number">7</span><span class="token number">33</span><span class="token number">0</span> <span class="token comment"># 这个结果并不是想要的，利用$才能解决</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="示例4：-m"><a href="#示例4：-m" class="headerlink" title="示例4：{m}"></a>示例4：{m}</h2><p>需求：匹配出，8到20位的密码，可以是大小写英文字母、数字、下划线</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z0-9_]&#123;6&#125;"</span><span class="token punctuation">,</span><span class="token string">"12a3g45678"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[a-zA-Z0-9_]&#123;8,20&#125;"</span><span class="token punctuation">,</span><span class="token string">"1ad12f23s34455ff66"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">12a3g41ad12f23s34455ff66<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="练一练"><a href="#练一练" class="headerlink" title="练一练"></a>练一练</h2><h3 id="题目1：匹配出163的邮箱地址，且-符号之前有4到20位，例如-x68-x65-108-x6c-111-64-x31-54-51-46-x63-111-x6d"><a href="#题目1：匹配出163的邮箱地址，且-符号之前有4到20位，例如-x68-x65-108-x6c-111-64-x31-54-51-46-x63-111-x6d" class="headerlink" title="题目1：匹配出163的邮箱地址，且@符号之前有4到20位，例如&#x68;&#x65;&#108;&#x6c;&#111;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;"></a>题目1：匹配出163的邮箱地址，且@符号之前有4到20位，例如<a href="mailto:&#x68;&#x65;&#108;&#x6c;&#111;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;">&#x68;&#x65;&#108;&#x6c;&#111;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;</a></h3><h1 id="匹配开头结尾"><a href="#匹配开头结尾" class="headerlink" title="匹配开头结尾"></a>匹配开头结尾</h1><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">^</td><td align="left">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="left">匹配字符串结尾</td></tr></tbody></table><h2 id="示例1：-2"><a href="#示例1：-2" class="headerlink" title="示例1：$"></a>示例1：$</h2><p>需求：匹配163.com的邮箱地址</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reemail_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"xiaoWang@163.com"</span><span class="token punctuation">,</span> <span class="token string">"xiaoWang@163.comheihei"</span><span class="token punctuation">,</span> <span class="token string">".com.xiaowang@qq.com"</span><span class="token punctuation">]</span><span class="token keyword">for</span> email <span class="token keyword">in</span> email_list<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[\w]&#123;4,20&#125;@163\.com"</span><span class="token punctuation">,</span> email<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是符合规定的邮件地址,匹配后的结果是:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>email<span class="token punctuation">,</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不符合要求"</span> <span class="token operator">%</span> email<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>com 是符合规定的邮件地址<span class="token punctuation">,</span>匹配后的结果是<span class="token punctuation">:</span>xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comxiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comheihei 是符合规定的邮件地址<span class="token punctuation">,</span>匹配后的结果是<span class="token punctuation">:</span>xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>com<span class="token punctuation">.</span>com<span class="token punctuation">.</span>xiaowang@qq<span class="token punctuation">.</span>com 不符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="完善后"><a href="#完善后" class="headerlink" title="完善后"></a>完善后</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">email_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"xiaoWang@163.com"</span><span class="token punctuation">,</span> <span class="token string">"xiaoWang@163.comheihei"</span><span class="token punctuation">,</span> <span class="token string">".com.xiaowang@qq.com"</span><span class="token punctuation">]</span><span class="token keyword">for</span> email <span class="token keyword">in</span> email_list<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[\w]&#123;4,20&#125;@163\.com$"</span><span class="token punctuation">,</span> email<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是符合规定的邮件地址,匹配后的结果是:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>email<span class="token punctuation">,</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不符合要求"</span> <span class="token operator">%</span> email<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>com 是符合规定的邮件地址<span class="token punctuation">,</span>匹配后的结果是<span class="token punctuation">:</span>xiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comxiaoWang@<span class="token number">163</span><span class="token punctuation">.</span>comheihei 不符合要求<span class="token punctuation">.</span>com<span class="token punctuation">.</span>xiaowang@qq<span class="token punctuation">.</span>com 不符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h1><table><thead><tr><th align="center">字符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="left">匹配左右任意一个表达式</td></tr><tr><td align="center">(ab)</td><td align="left">将括号中字符作为一个分组</td></tr><tr><td align="center"><code>\num</code></td><td align="left">引用分组num匹配到的字符串</td></tr><tr><td align="center"><code>(?P&lt;name&gt;)</code></td><td align="left">分组起别名</td></tr><tr><td align="center">(?P&#x3D;name)</td><td align="left">引用别名为name分组匹配到的字符串</td></tr></tbody></table><h2 id="示例1：-3"><a href="#示例1：-3" class="headerlink" title="示例1：|"></a>示例1：|</h2><p>需求：匹配出0-100之间的数字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 8</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"78"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 78</span><span class="token comment"># 不正确的情况</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d"</span><span class="token punctuation">,</span><span class="token string">"08"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 0</span><span class="token comment"># 修正之后的</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$"</span><span class="token punctuation">,</span><span class="token string">"08"</span><span class="token punctuation">)</span><span class="token keyword">if</span> ret<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不在0-100之间"</span><span class="token punctuation">)</span><span class="token comment"># 添加|</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"8"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 8</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"78"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 78</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"08"</span><span class="token punctuation">)</span><span class="token comment"># print(ret.group())  # 不是0-100之间</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"[1-9]?\d$|100"</span><span class="token punctuation">,</span><span class="token string">"100"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例2：-2"><a href="#示例2：-2" class="headerlink" title="示例2：( )"></a>示例2：( )</h2><p>需求：匹配出163、126、qq邮箱</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@163\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@163.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># test@163.com</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@(163|126|qq)\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@126.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># test@126.com</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@(163|126|qq)\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@qq.com"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># test@qq.com</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"\w&#123;4,20&#125;@(163|126|qq)\.com"</span><span class="token punctuation">,</span> <span class="token string">"test@gmail.com"</span><span class="token punctuation">)</span><span class="token keyword">if</span> ret<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不是163、126、qq邮箱"</span><span class="token punctuation">)</span>  <span class="token comment"># 不是163、126、qq邮箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不是以4、7结尾的手机号码-11位"><a href="#不是以4、7结尾的手机号码-11位" class="headerlink" title="不是以4、7结尾的手机号码(11位)"></a>不是以4、7结尾的手机号码(11位)</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> retels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"13100001234"</span><span class="token punctuation">,</span> <span class="token string">"18912344321"</span><span class="token punctuation">,</span> <span class="token string">"10086"</span><span class="token punctuation">,</span> <span class="token string">"18800007777"</span><span class="token punctuation">]</span><span class="token keyword">for</span> tel <span class="token keyword">in</span> tels<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"1\d&#123;9&#125;[0-35-68-9]"</span><span class="token punctuation">,</span> tel<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不是想要的手机号"</span> <span class="token operator">%</span> tel<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="提取区号和电话号码"><a href="#提取区号和电话号码" class="headerlink" title="提取区号和电话号码"></a>提取区号和电话号码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"([^-]*)-(\d+)"</span><span class="token punctuation">,</span><span class="token string">"010-12345678"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'010-12345678'</span><span class="token operator">>></span><span class="token operator">></span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'010'</span><span class="token operator">>></span><span class="token operator">></span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token string">'12345678'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例3：-1"><a href="#示例3：-1" class="headerlink" title="示例3：\"></a>示例3：\</h2><p>需求：匹配出<code>&lt;html&gt;hh&lt;/html&gt;</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token comment"># 能够完成对正确的字符串的匹配</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"&lt;[a-zA-Z]*>\w*&lt;/[a-zA-Z]*>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>hh&lt;/html>"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 如果遇到非正常的html格式字符串，匹配出错</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"&lt;[a-zA-Z]*>\w*&lt;/[a-zA-Z]*>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>hh&lt;/htmlbalabala>"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 正确的理解思路：如果在第一对&lt;>中是什么，按理说在后面的那对&lt;>中就应该是什么</span><span class="token comment"># 通过引用分组中匹配到的数据即可，但是要注意是元字符串，即类似 r""这种格式</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;([a-zA-Z]*)>\w*&lt;/\1>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>hh&lt;/html>"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 因为2对&lt;>中的数据不一致，所以没有匹配出来</span>test_label <span class="token operator">=</span> <span class="token string">"&lt;html>hh&lt;/htmlbalabala>"</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;([a-zA-Z]*)>\w*&lt;/\1>"</span><span class="token punctuation">,</span> test_label<span class="token punctuation">)</span><span class="token keyword">if</span> ret<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 这是一对不正确的标签"</span> <span class="token operator">%</span> test_label<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>htmlbalabala</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>hh<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>htmlbalabala</span><span class="token punctuation">></span></span> 这是一对不正确的标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例4：-number"><a href="#示例4：-number" class="headerlink" title="示例4：\number"></a>示例4：\number</h2><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> relabels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h1>&lt;/html>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h2>&lt;/html>"</span><span class="token punctuation">]</span><span class="token keyword">for</span> label <span class="token keyword">in</span> labels<span class="token punctuation">:</span>    ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;(\w*)>&lt;(\w*)>.*&lt;/\2>&lt;/\1>"</span><span class="token punctuation">,</span> label<span class="token punctuation">)</span>    <span class="token keyword">if</span> ret<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是符合要求的标签"</span> <span class="token operator">%</span> ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 不符合要求"</span> <span class="token operator">%</span> label<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>www.itcast.cn<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> 是符合要求的标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>www.itcast.cn<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> 不符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="示例5：-P-lt-name-gt-P-name"><a href="#示例5：-P-lt-name-gt-P-name" class="headerlink" title="示例5：(?P&lt;name&gt;) (?P=name)"></a>示例5：<code>(?P&lt;name&gt;)</code> <code>(?P=name)</code></h2><p>需求：匹配出<code>&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;(?P&lt;name1>\w*)>&lt;(?P&lt;name2>\w*)>.*&lt;/(?P=name2)>&lt;/(?P=name1)>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h1>&lt;/html>"</span><span class="token punctuation">)</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"&lt;(?P&lt;name1>\w*)>&lt;(?P&lt;name2>\w*)>.*&lt;/(?P=name2)>&lt;/(?P=name1)>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;html>&lt;h1>www.itcast.cn&lt;/h2>&lt;/html>"</span><span class="token punctuation">)</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意：-P-lt-name-gt-和-P-name-中的字母p大写"><a href="#注意：-P-lt-name-gt-和-P-name-中的字母p大写" class="headerlink" title="注意：(?P&lt;name&gt;)和(?P=name)中的字母p大写"></a>注意：<code>(?P&lt;name&gt;)</code>和<code>(?P=name)</code>中的字母p大写</h3><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321230906.png" alt="img" loading="lazy"></p><h1 id="re模块的高级用法"><a href="#re模块的高级用法" class="headerlink" title="re模块的高级用法"></a>re模块的高级用法</h1><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>需求：匹配出文章阅读的次数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> <span class="token string">"阅读次数为 9999"</span><span class="token punctuation">)</span>ret<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token string">'9999'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h2><p>需求：统计出python、c、c++相应文章阅读的次数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> <span class="token string">"python = 9999, c = 7890, c++ = 12345"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span><span class="token string">'9999'</span><span class="token punctuation">,</span> <span class="token string">'7890'</span><span class="token punctuation">,</span> <span class="token string">'12345'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="sub-将匹配到的数据进行替换"><a href="#sub-将匹配到的数据进行替换" class="headerlink" title="sub 将匹配到的数据进行替换"></a>sub 将匹配到的数据进行替换</h2><p>需求：将匹配到的阅读次数加1</p><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> <span class="token string">'998'</span><span class="token punctuation">,</span> <span class="token string">"python = 997"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python <span class="token operator">=</span> <span class="token number">998</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> re<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">:</span>    strNum <span class="token operator">=</span> temp<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>    num <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>strNum<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> add<span class="token punctuation">,</span> <span class="token string">"python = 997"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>ret <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"\d+"</span><span class="token punctuation">,</span> add<span class="token punctuation">,</span> <span class="token string">"python = 99"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python <span class="token operator">=</span> <span class="token number">998</span>python <span class="token operator">=</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321230920.png" alt="img" loading="lazy"></p><p>从下面的字符串中取出文本</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>岗位职责：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>完成推荐算法、数据统计、接口、后台等服务器端相关工作<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>必备要求：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>良好的自我驱动力和职业素养，工作积极主动、结果导向<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>技术要求：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>1、一年以上 Python 开发经验，掌握面向对象分析和设计，了解设计模式<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>2、掌握HTTP协议，熟悉MVC、MVVM等概念以及相关WEB开发框架<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>3、掌握关系数据库开发设计，掌握 SQL，熟练使用 MySQL/PostgreSQL 中的一种<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>4、掌握NoSQL、MQ，熟练使用对应技术解决方案<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>5、熟悉 Javascript/CSS/HTML5，JQuery、React、Vue.js<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>加分项：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>大数据，数理统计，机器学习，sklearn，高性能，大并发。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考答案:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">r"&lt;[^>]*>|&amp;nbsp;|\n"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> test_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="split-根据匹配进行切割字符串，并返回一个列表"><a href="#split-根据匹配进行切割字符串，并返回一个列表" class="headerlink" title="split 根据匹配进行切割字符串，并返回一个列表"></a>split 根据匹配进行切割字符串，并返回一个列表</h2><p>需求：切割字符串“info:xiaoZhang 33 shandong”</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> reret <span class="token operator">=</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">r":| "</span><span class="token punctuation">,</span><span class="token string">"info:xiaoZhang 33 shandong"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span><span class="token string">'info'</span><span class="token punctuation">,</span> <span class="token string">'xiaoZhang'</span><span class="token punctuation">,</span> <span class="token string">'33'</span><span class="token punctuation">,</span> <span class="token string">'shandong'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="python贪婪和非贪婪"><a href="#python贪婪和非贪婪" class="headerlink" title="python贪婪和非贪婪"></a>python贪婪和非贪婪</h1><p>Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；</p><p>非贪婪则相反，总是尝试匹配尽可能少的字符。</p><p>在”*”,”?”,”+”,”{m,n}”后面加上？，使贪婪变成非贪婪。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s<span class="token operator">=</span><span class="token string">"This is a number 234-235-22-423"</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token operator">=</span>re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">".+(\d+-\d+-\d+-\d+)"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'4-235-22-423'</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token operator">=</span>re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">".+?(\d+-\d+-\d+-\d+)"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'234-235-22-423'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。</p><p>解决方式：非贪婪操作符“？”，这个操作符可以用在”*”,”+”,”?”的后面，要求正则匹配的越少越好。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+)"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'2343'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+?)"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'2'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+)ddd"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">'2343'</span><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"aa(\d+?)ddd"</span><span class="token punctuation">,</span><span class="token string">"aa2343ddd"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token string">'2343'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练一练-1"><a href="#练一练-1" class="headerlink" title="练一练"></a>练一练</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321230940.png" alt="img" loading="lazy"></p><p>字符串为:</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">data-original</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">display</span><span class="token punctuation">:</span> inline<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请提取url地址</p><p>参考答案</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">r"https://.*?\.jpg"</span><span class="token punctuation">,</span> test_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="r的作用"><a href="#r的作用" class="headerlink" title="r的作用"></a>r的作用</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> mm <span class="token operator">=</span> <span class="token string">"c:\\a\\b\\c"</span><span class="token operator">>></span><span class="token operator">></span> mm<span class="token string">'c:\\a\\b\\c'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>mm<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a\b\c<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"c:\\\\"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'c:\\'</span><span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"c:\\\\"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\<span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"c:\\\\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a<span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"c:\\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a<span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"c:\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>AttributeError<span class="token punctuation">:</span> <span class="token string">'NoneType'</span> <span class="token builtin">object</span> has no attribute <span class="token string">'group'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明</p><p><code>Python中字符串前面加上 r 表示原生字符串</code>，</p><p>与大多数编程语言相同，<code>正则表达式里使用&quot;\&quot;作为转义字符</code>，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。</p><p>Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ret <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">r"c:\\a"</span><span class="token punctuation">,</span>mm<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>c<span class="token punctuation">:</span>\a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透</title>
      <link href="/posts/bd50b816/"/>
      <url>/posts/bd50b816/</url>
      
        <content type="html"><![CDATA[<p>通过<code>frp</code>开源代码进行内网穿透，需要准备一台带宽高有官网IP的服务器</p><p>下载地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321003851.png" alt="image-20220321003850923" loading="lazy"></p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>下载<code>frp_0.40.0_linux_amd64.tar.gz</code>，可以通过命令行，也可以直接在github下载</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 下载frpwget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.40.0&#x2F;frp_0.40.0_linux_amd64.tar.gz# 解压tar -zvxf frp_0.40.0_linux_amd64.tar.gz# 重命名mv frp_0.40.0_linux_amd64.tar.gz frp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321004249.png" alt="image-20220321004249532" loading="lazy"></p><p>修改<code>frps.ini</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[common]bind_port &#x3D; 7000# frp使用的端口dashboard_user &#x3D; admin# 流量监控的账户dashboard_pwd &#x3D; admin  # 流量监控的密码dashboard_port &#x3D; 6443# 流量监控程序的端口，搭建完成之后用服务器IP:6443就可以打开流量监控网页程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给文件夹<code>frp</code>赋权</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo chmod 755 frp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动<code>frp</code></p><pre class="line-numbers language-SH" data-language="SH"><code class="language-SH">.&#x2F;frps -c .&#x2F;frps.ini <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005150.png" alt="image-20220321005150643" loading="lazy"></p><p>打开流量监控网页，<code>服务器IP地址:7000</code></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321004800.png" alt="image-20220321004800570" loading="lazy"></p><h1 id="树莓派端"><a href="#树莓派端" class="headerlink" title="树莓派端"></a>树莓派端</h1><p>下载<code>frp_0.40.0_linux_amd64.tar.gz</code>，可以通过命令行，也可以直接在github下载</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 下载frpwget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.40.0&#x2F;frp_0.40.0_linux_amd64.tar.gz# 解压tar -zvxf frp_0.40.0_linux_amd64.tar.gz# 重命名mv frp_0.40.0_linux_amd64.tar.gz frp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321004249.png" alt="image-20220321004249532" loading="lazy"></p><p>修改<code>frpc.ini</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[common]server_addr &#x3D; 服务器IPserver_port &#x3D; 7000[ssh]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 22remote_port &#x3D; 6000[cream]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 8880remote_port &#x3D; 8880[vnc]type &#x3D; tcplocal_ip &#x3D; 127.0.0.1local_port &#x3D; 5900# vnc端口是5900remote_port &#x3D; 5900<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给文件夹<code>frp</code>赋权</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo chmod 755 frp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动<code>frp</code></p><pre class="line-numbers language-SH" data-language="SH"><code class="language-SH">.&#x2F;frpc -c .&#x2F;frpc.ini <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005206.png" alt="image-20220321005206495" loading="lazy"></p><p>查看<code>frp</code>后台，可以看见服务</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005256.png" alt="image-20220321005256292" loading="lazy"></p><blockquote><p>  <code>frps.ini</code>是服务端的配置文件，<code>frpc.ini</code>是客户端的配置文件，注意不要混淆</p></blockquote><h1 id="配置frp自启动"><a href="#配置frp自启动" class="headerlink" title="配置frp自启动"></a>配置frp自启动</h1><p>使用systemctl来控制启动，将<code>/frp/systemd/frps.service</code>拷贝到<code>/lib/systemd/system/</code>目录下，在<code>frps.service</code>里写入以下内容</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[Unit]Description&#x3D;fraps serviceAfter&#x3D;network.target syslog.targetWants&#x3D;network.target[Service]Type&#x3D;simple#启动服务的命令（此处写你的frps的实际安装目录）ExecStart&#x3D;&#x2F;your&#x2F;path&#x2F;frps -c &#x2F;your&#x2F;path&#x2F;frps.ini[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就启动<code>frps</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo systemctl start frps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再打开自启动</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo systemctl enable frps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要重启应用，可以这样，<code>sudo systemctl restart frps</code><br>如果要停止应用，可以输入，<code>sudo systemctl stop frps</code><br>如果要查看应用的日志，可以输入，<code>sudo systemctl status frps</code></p><p>实测树莓派远程监控延时为0.5s左右，这个时候可以通过公网地址和端口访问树莓派，通过<code>ssh</code>或者<code>vnc</code>都可以</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220321005459.png" alt="image-20220321005459457" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派实现远程监控</title>
      <link href="/posts/108619c9/"/>
      <url>/posts/108619c9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  python实现opencv+scoket网络实时图传</p></blockquote><h1 id="服务器分析"><a href="#服务器分析" class="headerlink" title="服务器分析"></a><strong>服务器分析</strong></h1><p>1.　先通过在服务器端利用OpenCV捕获到视频的每一帧图片</p><p>2.　将这些图片进行压缩成JPEG格式，这样能减小图片大小，便于传输</p><p>3.　按照提前协商好的分辨率和帧数进行打包编码传输</p><p>4.　利用服务器端打开端口8880，此时客户端连接后，便可以在客户端中捕获到服务器端的视频。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#服务端</span><span class="token keyword">import</span> socket<span class="token keyword">import</span> threading<span class="token keyword">import</span> struct<span class="token keyword">import</span> time<span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy<span class="token keyword">import</span> warningswarnings<span class="token punctuation">.</span>filterwarnings<span class="token punctuation">(</span><span class="token string">"ignore"</span><span class="token punctuation">,</span>category<span class="token operator">=</span>DeprecationWarning<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Carame_Accept_Object</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>S_addr_port<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">8880</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>resolution<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">)</span>    <span class="token comment">#分辨率</span>    self<span class="token punctuation">.</span>img_fps<span class="token operator">=</span><span class="token number">30</span>         <span class="token comment">#每秒传输多少帧数</span>    self<span class="token punctuation">.</span>addr_port<span class="token operator">=</span>S_addr_port    self<span class="token punctuation">.</span>Set_Socket<span class="token punctuation">(</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">)</span>  <span class="token comment">#设置套接字</span>  <span class="token keyword">def</span> <span class="token function">Set_Socket</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>S_addr_port<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>server<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>server<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#端口可复用</span>    self<span class="token punctuation">.</span>server<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>S_addr_port<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>server<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment">#print("the process work in the port:%d" % S_addr_port[1])</span><span class="token keyword">def</span> <span class="token function">check_option</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">,</span>client<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#按格式解码，确定帧数和分辨率</span>  info<span class="token operator">=</span>struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'lhh'</span><span class="token punctuation">,</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> info<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">888</span><span class="token punctuation">:</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>img_fps<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>info<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">888</span>     <span class="token comment">#获取帧数</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">)</span>    <span class="token comment"># 获取分辨率</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>info<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>info<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>resolution <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">RT_Image</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">,</span>client<span class="token punctuation">,</span>D_addr<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>check_option<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">,</span>client<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span>  camera<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token comment">#从摄像头中获取视频</span>  img_param<span class="token operator">=</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>IMWRITE_JPEG_QUALITY<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>img_fps<span class="token punctuation">]</span> <span class="token comment">#设置传送图像格式、帧数</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>       <span class="token comment">#推迟线程运行0.1s</span>    ret<span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token operator">=</span>camera<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#读取视频每一帧</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">)</span>   <span class="token comment">#按要求调整图像大小(resolution必须为元组)</span>    _<span class="token punctuation">,</span>img_encode<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imencode<span class="token punctuation">(</span><span class="token string">'.jpg'</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>img<span class="token punctuation">,</span>img_param<span class="token punctuation">)</span> <span class="token comment">#按格式生成图片</span>    img_code<span class="token operator">=</span>numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span>img_encode<span class="token punctuation">)</span>            <span class="token comment">#转换成矩阵</span>    <span class="token builtin">object</span><span class="token punctuation">.</span>img_data<span class="token operator">=</span>img_code<span class="token punctuation">.</span>tostring<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">#生成相应的字符串</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>      <span class="token comment">#按照相应的格式进行打包发送图片</span>      client<span class="token punctuation">.</span>send<span class="token punctuation">(</span>struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"lhh"</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">.</span>img_data<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token builtin">object</span><span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">object</span><span class="token punctuation">.</span>img_data<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>      camera<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#释放资源</span>      <span class="token keyword">return</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  camera<span class="token operator">=</span>Carame_Accept_Object<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    client<span class="token punctuation">,</span>D_addr<span class="token operator">=</span>camera<span class="token punctuation">.</span>server<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    clientThread<span class="token operator">=</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span>target<span class="token operator">=</span>RT_Image<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>camera<span class="token punctuation">,</span>client<span class="token punctuation">,</span>D_addr<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    clientThread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="客户端分析"><a href="#客户端分析" class="headerlink" title="客户端分析"></a><strong>客户端分析</strong></h1><p>1.　客户端连接端口后，首先发送需要协商的分辨率和帧数，以致能够使传输“协议”一致</p><p>2.　客户端使用线程，对图片进行收集</p><ol start="3"><li>对收到的每一张图片进行解码，并利用OpenCV播放出来，即可实现C&#x2F;S两端实时视频传输。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding: utf-8 -*-</span><span class="token comment"># @Time : 2022/3/20 22:57</span><span class="token comment"># @Author : WuShuai</span><span class="token comment"># @Email : wu_shuai_2000@163.com</span><span class="token comment"># @File : test.py</span><span class="token comment"># @blog : https://blog.csdn.net/Dumbking</span><span class="token comment">#客户端</span><span class="token keyword">import</span> socket<span class="token keyword">import</span> cv2<span class="token keyword">import</span> threading<span class="token keyword">import</span> struct<span class="token keyword">import</span> numpy<span class="token keyword">class</span> <span class="token class-name">Camera_Connect_Object</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>D_addr_port<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">8880</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>resolution<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">640</span><span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>addr_port<span class="token operator">=</span>D_addr_port    self<span class="token punctuation">.</span>src<span class="token operator">=</span><span class="token number">888</span><span class="token operator">+</span><span class="token number">15</span>         <span class="token comment">#双方确定传输帧数，（888）为校验值</span>    self<span class="token punctuation">.</span>interval<span class="token operator">=</span><span class="token number">0</span>         <span class="token comment">#图片播放时间间隔</span>    self<span class="token punctuation">.</span>img_fps<span class="token operator">=</span><span class="token number">30</span>         <span class="token comment">#每秒传输多少帧数</span>  <span class="token keyword">def</span> <span class="token function">Set_socket</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>client<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">Socket_Connect</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>Set_socket<span class="token punctuation">(</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"IP is %s:%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">RT_Image</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#按照格式打包发送帧数和分辨率</span>    self<span class="token punctuation">.</span>name<span class="token operator">=</span>self<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">" Camera"</span>    self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>send<span class="token punctuation">(</span>struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"lhh"</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>src<span class="token punctuation">,</span> self<span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>resolution<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      info<span class="token operator">=</span>struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">"lhh"</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      buf_size<span class="token operator">=</span>info<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>          <span class="token comment">#获取读的图片总长度</span>      <span class="token keyword">if</span> buf_size<span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>          self<span class="token punctuation">.</span>buf<span class="token operator">=</span><span class="token string">b""</span>        <span class="token comment">#代表bytes类型</span>          temp_buf<span class="token operator">=</span>self<span class="token punctuation">.</span>buf          <span class="token keyword">while</span><span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment">#读取每一张图片的长度</span>            temp_buf<span class="token operator">=</span>self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span>            buf_size<span class="token operator">-=</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp_buf<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>buf<span class="token operator">+=</span>temp_buf   <span class="token comment">#获取图片</span>            data <span class="token operator">=</span> numpy<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>self<span class="token punctuation">.</span>buf<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'uint8'</span><span class="token punctuation">)</span>  <span class="token comment">#按uint8转换为图像矩阵</span>            self<span class="token punctuation">.</span>image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imdecode<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>         <span class="token comment">#图像解码</span>            cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>image<span class="token punctuation">)</span>          <span class="token comment">#展示图片</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>          <span class="token keyword">pass</span><span class="token punctuation">;</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#每10ms刷新一次图片，按‘ESC'（27）退出</span>            self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>  <span class="token keyword">def</span> <span class="token function">Get_Data</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>interval<span class="token punctuation">)</span><span class="token punctuation">:</span>    showThread<span class="token operator">=</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>self<span class="token punctuation">.</span>RT_Image<span class="token punctuation">)</span>    showThread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  camera<span class="token operator">=</span>Camera_Connect_Object<span class="token punctuation">(</span><span class="token punctuation">)</span>  camera<span class="token punctuation">.</span>addr_port<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"服务端的ip"</span>  camera<span class="token punctuation">.</span>addr_port<span class="token operator">=</span><span class="token builtin">tuple</span><span class="token punctuation">(</span>camera<span class="token punctuation">.</span>addr_port<span class="token punctuation">)</span>  camera<span class="token punctuation">.</span>Socket_Connect<span class="token punctuation">(</span><span class="token punctuation">)</span>  camera<span class="token punctuation">.</span>Get_Data<span class="token punctuation">(</span>camera<span class="token punctuation">.</span>interval<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  服务端放在树莓派上面运行，在局域网内可以直接访问，想要远程访问还需要让树莓派进行内网穿透。</p><p>  原本的思路是树莓派通过<code>opencv</code>获取视频帧，传给有公网IP的服务器，服务器再进行转发到客户端，这样的话需要多写服务器上面的代码，利用内网穿透可以很好地避免这个过程，减少开发的工作量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多任务-进程</title>
      <link href="/posts/b23c6bbe/"/>
      <url>/posts/b23c6bbe/</url>
      
        <content type="html"><![CDATA[<h1 id="进程以及状态"><a href="#进程以及状态" class="headerlink" title="进程以及状态"></a>进程以及状态</h1><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>程序：例如xxx.py这是程序，是一个静态的</p><p>进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。</p><p>不仅可以通过线程完成多任务，进程也是可以的</p><h3 id="2-进程的状态"><a href="#2-进程的状态" class="headerlink" title="2. 进程的状态"></a>2. 进程的状态</h3><p>工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319220239.png" alt="img" loading="lazy"></p><ul><li>就绪态：运行的条件都已经慢去，正在等在cpu执行</li><li>执行态：cpu正在执行其功能</li><li>等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态</li></ul><h1 id="进程的创建-multiprocessing"><a href="#进程的创建-multiprocessing" class="headerlink" title="进程的创建-multiprocessing"></a>进程的创建-multiprocessing</h1><p>multiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情</p><h3 id="1-2个while循环一起执行"><a href="#1-2个while循环一起执行" class="headerlink" title="1. 2个while循环一起执行"></a>1. 2个while循环一起执行</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">run_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----2----"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>run_proc<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----1----"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动</li></ul><h3 id="2-进程pid"><a href="#2-进程pid" class="headerlink" title="2. 进程pid"></a>2. 进程pid</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">run_proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程运行中，pid=%d...'</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># os.getpid获取当前进程的进程号</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程将要结束...'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父进程pid: %d'</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># os.getpid获取当前进程的进程号</span>    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>run_proc<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Process语法结构如下："><a href="#3-Process语法结构如下：" class="headerlink" title="3. Process语法结构如下："></a>3. Process语法结构如下：</h3><p>Process([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>target：如果传递了函数的引用，可以任务这个子进程就执行这里的代码</li><li>args：给target指定的函数传递的参数，以元组的方式传递</li><li>kwargs：给target指定的函数传递命名参数</li><li>name：给进程设定一个名字，可以不设定</li><li>group：指定进程组，大多数情况下用不到</li></ul><p>Process创建的实例对象的常用方法：</p><ul><li>start()：启动子进程实例（创建子进程）</li><li>is_alive()：判断进程子进程是否还在活着</li><li>join([timeout])：是否等待子进程执行结束，或等待多少秒</li><li>terminate()：不管任务是否完成，立即终止子进程</li></ul><p>Process创建的实例对象的常用属性：</p><ul><li>name：当前进程的别名，默认为Process-N，N为从1开始递增的整数</li><li>pid：当前进程的pid（进程号）</li></ul><h3 id="4-给子进程指定的函数传递参数"><a href="#4-给子进程指定的函数传递参数" class="headerlink" title="4. 给子进程指定的函数传递参数"></a>4. 给子进程指定的函数传递参数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token keyword">def</span> <span class="token function">run_proc</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程运行中，name= %s,age=%d ,pid=%d...'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>run_proc<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span> kwargs<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"m"</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 1秒中之后，立即结束子进程</span>    p<span class="token punctuation">.</span>terminate<span class="token punctuation">(</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span>子进程运行中，name<span class="token operator">=</span> test<span class="token punctuation">,</span>age<span class="token operator">=</span><span class="token number">18</span> <span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">45097.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span><span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-进程间不同享全局变量"><a href="#5-进程间不同享全局变量" class="headerlink" title="5. 进程间不同享全局变量"></a>5. 进程间不同享全局变量</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">import</span> timenums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"in process1 pid=%d ,nums=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"in process1 pid=%d ,nums=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""子进程要执行的代码"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"in process2 pid=%d ,nums=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    p1 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">)</span>    p1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    p1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    p2 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">)</span>    p2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果:"></a>运行结果:</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">in</span> process1 pid<span class="token operator">=</span><span class="token number">11349</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">in</span> process2 pid<span class="token operator">=</span><span class="token number">11350</span> <span class="token punctuation">,</span>nums<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="进程、线程对比"><a href="#进程、线程对比" class="headerlink" title="进程、线程对比"></a>进程、线程对比</h1><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ</li><li>线程，能够完成多任务，比如 一个QQ中的多个聊天窗口</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319221932.jpg" alt="img" loading="lazy"></p><h3 id="定义的不同"><a href="#定义的不同" class="headerlink" title="定义的不同"></a>定义的不同</h3><ul><li>进程是系统进行资源分配和调度的一个独立单位.</li><li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319221950.png" alt="img" loading="lazy"></p><ul><li>线线程不能够独立执行，必须依存在进程中</li><li>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319222001.gif" alt="img" loading="lazy"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h1 id="进程间通信-Queue"><a href="#进程间通信-Queue" class="headerlink" title="进程间通信-Queue"></a>进程间通信-Queue</h1><p>Process之间有时需要通信，操作系统提供了很多机制来实现进程间的通信。</p><h3 id="1-Queue的使用"><a href="#1-Queue的使用" class="headerlink" title="1. Queue的使用"></a>1. Queue的使用</h3><p>可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Queueq<span class="token operator">=</span>Queue<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">#初始化一个Queue对象，最多可接收三条put消息</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息1"</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息2"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">#False</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息3"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#True</span><span class="token comment">#因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常</span><span class="token keyword">try</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"消息4"</span><span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"消息列队已满，现有消息数量:%s"</span><span class="token operator">%</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put_nowait<span class="token punctuation">(</span><span class="token string">"消息4"</span><span class="token punctuation">)</span><span class="token keyword">except</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"消息列队已满，现有消息数量:%s"</span><span class="token operator">%</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#推荐的方式，先判断消息列队是否已满，再写入</span><span class="token keyword">if</span> <span class="token keyword">not</span> q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    q<span class="token punctuation">.</span>put_nowait<span class="token punctuation">(</span><span class="token string">"消息4"</span><span class="token punctuation">)</span><span class="token comment">#读取消息时，先判断消息列队是否为空，再读取</span><span class="token keyword">if</span> <span class="token keyword">not</span> q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>get_nowait<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token boolean">False</span><span class="token boolean">True</span>消息列队已满，现有消息数量<span class="token punctuation">:</span><span class="token number">3</span>消息列队已满，现有消息数量<span class="token punctuation">:</span><span class="token number">3</span>消息<span class="token number">1</span>消息<span class="token number">2</span>消息<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>初始化Queue()对象时（例如：q&#x3D;Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；</p><ul><li>Queue.qsize()：返回当前队列包含的消息数量；</li><li>Queue.empty()：如果队列为空，返回True，反之False ；</li><li>Queue.full()：如果队列满了，返回True,反之False；</li><li>Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；</li></ul><p>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常；</p><p>2）如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常；</p><ul><li>Queue.get_nowait()：相当Queue.get(False)；</li><li>Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；</li></ul><p>1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常；</p><p>2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常；</p><ul><li>Queue.put_nowait(item)：相当Queue.put(item, False)；</li></ul><h3 id="2-Queue实例"><a href="#2-Queue实例" class="headerlink" title="2. Queue实例"></a>2. Queue实例</h3><p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue<span class="token keyword">import</span> os<span class="token punctuation">,</span> time<span class="token punctuation">,</span> random<span class="token comment"># 写数据进程执行的代码:</span><span class="token keyword">def</span> <span class="token function">write</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> value <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Put %s to queue...'</span> <span class="token operator">%</span> value<span class="token punctuation">)</span>        q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 读数据进程执行的代码:</span><span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            value <span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get %s from queue.'</span> <span class="token operator">%</span> value<span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># 父进程创建Queue，并传给各个子进程：</span>    q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    pw <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>write<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    pr <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>read<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 启动子进程pw，写入:</span>    pw<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 等待pw结束:</span>    pw<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 启动子进程pr，读取:</span>    pr<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    pr<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'所有数据都写入并且读完'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319222345.gif" alt="img" loading="lazy"></p><h1 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h1><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。</p><p>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool<span class="token keyword">import</span> os<span class="token punctuation">,</span> time<span class="token punctuation">,</span> random<span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    t_start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s开始执行,进程号为%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>msg<span class="token punctuation">,</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># random.random()随机生成0~1之间的浮点数</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>     t_stop <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span><span class="token string">"执行完毕，耗时%0.2f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>t_stop<span class="token operator">-</span>t_start<span class="token punctuation">)</span><span class="token punctuation">)</span>po <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment"># 定义一个进程池，最大进程数3</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))</span>    <span class="token comment"># 每次循环将会用空闲出来的子进程去调用目标</span>    po<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>worker<span class="token punctuation">,</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----start----"</span><span class="token punctuation">)</span>po<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭进程池，关闭后po不再接收新的请求</span>po<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 等待po中所有子进程执行完成，必须放在close语句之后</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-----end-----"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>start<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">0</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">1</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21468</span><span class="token number">2</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21467</span><span class="token number">0</span> 执行完毕，耗时<span class="token number">1.01</span><span class="token number">3</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">2</span> 执行完毕，耗时<span class="token number">1.24</span><span class="token number">4</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21467</span><span class="token number">3</span> 执行完毕，耗时<span class="token number">0.56</span><span class="token number">5</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">1</span> 执行完毕，耗时<span class="token number">1.68</span><span class="token number">6</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21468</span><span class="token number">4</span> 执行完毕，耗时<span class="token number">0.67</span><span class="token number">7</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21467</span><span class="token number">5</span> 执行完毕，耗时<span class="token number">0.83</span><span class="token number">8</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21466</span><span class="token number">6</span> 执行完毕，耗时<span class="token number">0.75</span><span class="token number">9</span>开始执行<span class="token punctuation">,</span>进程号为<span class="token number">21468</span><span class="token number">7</span> 执行完毕，耗时<span class="token number">1.03</span><span class="token number">8</span> 执行完毕，耗时<span class="token number">1.05</span><span class="token number">9</span> 执行完毕，耗时<span class="token number">1.69</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>end<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>multiprocessing.Pool常用函数解析：</p><ul><li>apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；</li><li>close()：关闭Pool，使其不再接受新的任务；</li><li>terminate()：不管任务是否完成，立即终止；</li><li>join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；</li></ul><h2 id="进程池中的Queue"><a href="#进程池中的Queue" class="headerlink" title="进程池中的Queue"></a>进程池中的Queue</h2><p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：</p><p>RuntimeError: Queue objects should only be shared between processes through inheritance.</p><p>下面的实例演示了进程池中的进程如何通信：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token comment"># 修改import中的Queue为Manager</span><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Manager<span class="token punctuation">,</span>Pool<span class="token keyword">import</span> os<span class="token punctuation">,</span>time<span class="token punctuation">,</span>random<span class="token keyword">def</span> <span class="token function">reader</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"reader启动(%s),父进程为(%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"reader从Queue获取到消息：%s"</span> <span class="token operator">%</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">writer</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"writer启动(%s),父进程为(%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token string">"itcast"</span><span class="token punctuation">:</span>        q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"(%s) start"</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    q <span class="token operator">=</span> Manager<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 使用Manager中的Queue</span>    po <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token punctuation">)</span>    po<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>writer<span class="token punctuation">,</span> <span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据</span>    po<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>reader<span class="token punctuation">,</span> <span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    po<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    po<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"(%s) End"</span> <span class="token operator">%</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span> startwriter启动<span class="token punctuation">(</span><span class="token number">11097</span><span class="token punctuation">)</span><span class="token punctuation">,</span>父进程为<span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span>reader启动<span class="token punctuation">(</span><span class="token number">11098</span><span class="token punctuation">)</span><span class="token punctuation">,</span>父进程为<span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span>reader从Queue获取到消息：ireader从Queue获取到消息：treader从Queue获取到消息：creader从Queue获取到消息：areader从Queue获取到消息：sreader从Queue获取到消息：t<span class="token punctuation">(</span><span class="token number">11095</span><span class="token punctuation">)</span> End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用：文件夹copy器（多进程版）"><a href="#应用：文件夹copy器（多进程版）" class="headerlink" title="应用：文件夹copy器（多进程版）"></a>应用：文件夹copy器（多进程版）</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> multiprocessing<span class="token keyword">import</span> os<span class="token keyword">import</span> time<span class="token keyword">import</span> random<span class="token keyword">def</span> <span class="token function">copy_file</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> file_name<span class="token punctuation">,</span>source_folder_name<span class="token punctuation">,</span>  dest_folder_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""copy文件到指定的路径"""</span>    f_read <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>source_folder_name <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> file_name<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span>    f_write <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>dest_folder_name <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> file_name<span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        content <span class="token operator">=</span> f_read<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> content<span class="token punctuation">:</span>            f_write<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    f_read<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_write<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 发送已经拷贝完毕的文件名字</span>    queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 获取要复制的文件夹</span>    source_folder_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入要复制文件夹名字:"</span><span class="token punctuation">)</span>    <span class="token comment"># 整理目标文件夹</span>    dest_folder_name <span class="token operator">=</span> source_folder_name <span class="token operator">+</span> <span class="token string">"[副本]"</span>    <span class="token comment"># 创建目标文件夹</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>dest_folder_name<span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>  <span class="token comment"># 如果文件夹已经存在，那么创建会失败</span>    <span class="token comment"># 获取这个文件夹中所有的普通文件名</span>    file_names <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>source_folder_name<span class="token punctuation">)</span>    <span class="token comment"># 创建Queue</span>    queue <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Manager<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 创建进程池</span>    pool <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> file_name <span class="token keyword">in</span> file_names<span class="token punctuation">:</span>        <span class="token comment"># 向进程池中添加任务</span>        pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>copy_file<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> file_name<span class="token punctuation">,</span> source_folder_name<span class="token punctuation">,</span> dest_folder_name<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 主进程显示进度</span>    pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    all_file_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>file_names<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        file_name <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> file_name <span class="token keyword">in</span> file_names<span class="token punctuation">:</span>            file_names<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span>        copy_rate <span class="token operator">=</span> <span class="token punctuation">(</span>all_file_num<span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>file_names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token operator">/</span>all_file_num        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\r%.2f...(%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>copy_rate<span class="token punctuation">,</span> file_name<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token operator">*</span><span class="token number">50</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> copy_rate <span class="token operator">>=</span> <span class="token number">100</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多任务-线程</title>
      <link href="/posts/a4da6e72/"/>
      <url>/posts/a4da6e72/</url>
      
        <content type="html"><![CDATA[<h1 id="多任务介绍"><a href="#多任务介绍" class="headerlink" title="多任务介绍"></a>多任务介绍</h1><h2 id="现实生活中"><a href="#现实生活中" class="headerlink" title="现实生活中"></a>现实生活中</h2><p>有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的；</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205200.jpg" alt="img" loading="lazy"></p><p>试想，如果把唱歌和跳舞这2件事情分开依次完成的话，估计就没有那么好的效果了（想一下场景：先唱歌，然后在跳舞，O(∩_∩)O哈哈~）</p><h2 id="程序中"><a href="#程序中" class="headerlink" title="程序中"></a>程序中</h2><p>如下程序，来模拟“唱歌跳舞”这件事情</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在唱歌...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在跳舞...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sing<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#唱歌</span>    dance<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#跳舞</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205249.png" alt="image-20220319205249393" loading="lazy"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>很显然刚刚的程序并没有完成唱歌和跳舞同时进行的要求</li><li>如果想要实现“唱歌跳舞”同时进行，那么就需要一个新的方法，叫做：<strong>多任务</strong></li></ul><h1 id="多任务的概念"><a href="#多任务的概念" class="headerlink" title="多任务的概念"></a>多任务的概念</h1><p>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205356.png" alt="img" loading="lazy"></p><p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p><p>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p><p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205411.jpg" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205417.gif" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205426.gif" alt="img" loading="lazy"></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>**&#x3D;&#x3D;并发&#x3D;&#x3D;**：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</li><li>**&#x3D;&#x3D;并行&#x3D;&#x3D;**：指的是任务数小于等于cpu核数，即任务真的是一起执行的</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用</p><h3 id="1-使用threading模块"><a href="#1-使用threading模块" class="headerlink" title="1. 使用threading模块"></a>1. 使用threading模块</h3><h4 id="单线程执行"><a href="#单线程执行" class="headerlink" title="单线程执行"></a>单线程执行</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">saySorry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"亲爱的，我错了，我能吃饭了吗？"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        saySorry<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205623.gif" alt="img" loading="lazy"></p><h4 id="多线程执行"><a href="#多线程执行" class="headerlink" title="多线程执行"></a>多线程执行</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">saySorry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"亲爱的，我错了，我能吃饭了吗？"</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>saySorry<span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#启动线程，即让线程开始执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205706.gif" alt="img" loading="lazy"></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>可以明显看出使用了多线程并发的操作，花费时间要短很多</li><li>当调用<code>start()</code>时，才会真正的创建线程，并且开始执行</li></ol><h3 id="2-主线程会等待所有的子线程结束后才结束"><a href="#2-主线程会等待所有的子线程结束后才结束" class="headerlink" title="2. 主线程会等待所有的子线程结束后才结束"></a>2. 主线程会等待所有的子线程结束后才结束</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token punctuation">,</span>ctime<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在唱歌...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在跳舞...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---开始---:%s'</span><span class="token operator">%</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>sing<span class="token punctuation">)</span>    t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>dance<span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">#sleep(5) # 屏蔽此行代码，试试看，程序是否会立马结束？</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---结束---:%s'</span><span class="token operator">%</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319205759.gif" alt="img" loading="lazy"></p><h3 id="3-查看线程数量"><a href="#3-查看线程数量" class="headerlink" title="3. 查看线程数量"></a>3. 查看线程数量</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token punctuation">,</span>ctime<span class="token keyword">def</span> <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在唱歌...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在跳舞...%d"</span><span class="token operator">%</span>i<span class="token punctuation">)</span>        sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---开始---:%s'</span><span class="token operator">%</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>sing<span class="token punctuation">)</span>    t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>dance<span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        length <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前运行的线程数为：%d'</span><span class="token operator">%</span>length<span class="token punctuation">)</span>        <span class="token keyword">if</span> length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319210210.gif" alt="img" loading="lazy"></p><h1 id="线程-注意点"><a href="#线程-注意点" class="headerlink" title="线程-注意点"></a>线程-注意点</h1><h4 id="1-线程执行代码的封装"><a href="#1-线程执行代码的封装" class="headerlink" title="1. 线程执行代码的封装"></a>1. 线程执行代码的封装</h4><p>通过上一小节，能够看出，通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承<code>threading.Thread</code>就可以了，然后重写<code>run</code>方法</p><p>示例如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            msg <span class="token operator">=</span> <span class="token string">"I'm "</span><span class="token operator">+</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">' @ '</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">#name属性中保存的是当前线程的名字</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> MyThread<span class="token punctuation">(</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319210233.gif" alt="img" loading="lazy"></p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li>python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。</li></ul><h4 id="2-线程的执行顺序"><a href="#2-线程的执行顺序" class="headerlink" title="2. 线程的执行顺序"></a>2. 线程的执行顺序</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            msg <span class="token operator">=</span> <span class="token string">"I'm "</span><span class="token operator">+</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">' @ '</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> MyThread<span class="token punctuation">(</span><span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：(运行的结果可能不一样，但是大体是一致的)</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">I&#39;m Thread-1 @ 0I&#39;m Thread-2 @ 0I&#39;m Thread-5 @ 0I&#39;m Thread-3 @ 0I&#39;m Thread-4 @ 0I&#39;m Thread-3 @ 1I&#39;m Thread-4 @ 1I&#39;m Thread-5 @ 1I&#39;m Thread-1 @ 1I&#39;m Thread-2 @ 1I&#39;m Thread-4 @ 2I&#39;m Thread-5 @ 2I&#39;m Thread-2 @ 2I&#39;m Thread-1 @ 2I&#39;m Thread-3 @ 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ol><li>每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。</li><li>当线程的run()方法结束时该线程完成。</li><li>无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</li></ol><h1 id="多线程-共享全局变量"><a href="#多线程-共享全局变量" class="headerlink" title="多线程-共享全局变量"></a>多线程-共享全局变量</h1><p>在一个函数中对全局变屋进行修改的时候，到底是香需要使用<code>global</code>进行说明要看是否对全局变量的执行指向进行了修改如果修改了执行，即上全局变量指向了一个新的地方，那么必须使用<code>global</code>如果，仅仅是修改了指向的空间中的数据，此时不用必须使用<code>global</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---线程创建之前g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span>t1 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#延时一会，保证t1线程中的事情做完</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>线程创建之前g_num <span class="token keyword">is</span> <span class="token number">100</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">103</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">103</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="列表当做实参传递到线程中"><a href="#列表当做实参传递到线程中" class="headerlink" title="列表当做实参传递到线程中"></a>列表当做实参传递到线程中</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1---"</span><span class="token punctuation">,</span>nums<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#延时一会，保证t1线程中的事情做完</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2---"</span><span class="token punctuation">,</span>nums<span class="token punctuation">)</span>g_nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">]</span>t1 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>g_nums<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>g_nums<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据</li><li>缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）</li></ul><h1 id="多线程-共享全局变量问题"><a href="#多线程-共享全局变量问题" class="headerlink" title="多线程-共享全局变量问题"></a>多线程-共享全局变量问题</h1><h3 id="多线程开发可能遇到的问题"><a href="#多线程开发可能遇到的问题" class="headerlink" title="多线程开发可能遇到的问题"></a>多线程开发可能遇到的问题</h3><p>假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。</p><p>但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li>在g_num&#x3D;0时，t1取得g_num&#x3D;0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num&#x3D;0</li><li>然后t2对得到的值进行加1并赋给g_num，使得g_num&#x3D;1</li><li>然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</li><li>这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num&#x3D;1</li></ol><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---线程创建之前g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span>t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2个线程对同一个全局变量操作之后的最终结果是:%s"</span> <span class="token operator">%</span> g_num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>线程创建之前g_num <span class="token keyword">is</span> <span class="token number">0</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">100</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">200</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">2</span>个线程对同一个全局变量操作之后的最终结果是<span class="token punctuation">:</span><span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">work1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work1, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">work2</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"----in work2, g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---线程创建之前g_num is %d---"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span>t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>work2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2个线程对同一个全局变量操作之后的最终结果是:%s"</span> <span class="token operator">%</span> g_num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>线程创建之前g_num <span class="token keyword">is</span> <span class="token number">0</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work1<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">1088005</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">in</span> work2<span class="token punctuation">,</span> g_num <span class="token keyword">is</span> <span class="token number">1286202</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token number">2</span>个线程对同一个全局变量操作之后的最终结果是<span class="token punctuation">:</span><span class="token number">1286202</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>&#x3D;&#x3D;如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确&#x3D;&#x3D;</li></ul><h1 id="同步的概念"><a href="#同步的概念" class="headerlink" title="同步的概念"></a>同步的概念</h1><p>同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。</p><p>“同”字从字面上容易理解为一起动作</p><p>其实不是，”同”字应是指协同、协助、互相配合。</p><p>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。</p><h4 id="解决线程同时修改全局变量的方式"><a href="#解决线程同时修改全局变量的方式" class="headerlink" title="解决线程同时修改全局变量的方式"></a>解决线程同时修改全局变量的方式</h4><p>对于上一小节提出的那个计算错误的问题，可以通过线程同步来进行解决</p><p>思路，如下:</p><ol><li>系统调用t1，然后获取到g_num的值为0，此时上一把锁，即不允许其他线程操作g_num</li><li>t1对g_num的值进行+1</li><li>t1解锁，此时g_num的值为1，其他的线程就可以使用g_num了，而且是g_num的值不是0而是1</li><li>同理其他线程在对g_num进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性</li></ol><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</p><p>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。</p><p>互斥锁为资源引入一个状态：锁定&#x2F;非锁定</p><p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319213103.png" alt="img" loading="lazy"></p><p>threading模块中定义了Lock类，可以方便的处理锁定：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建锁</span>mutex <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 锁定</span>mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 释放</span>mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><ul><li>如果这个锁之前是没有上锁的，那么acquire不会堵塞</li><li>如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止</li></ul><h4 id="使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"><a href="#使用互斥锁完成2个线程对同一个全局变量各加100万次的操作" class="headerlink" title="使用互斥锁完成2个线程对同一个全局变量各加100万次的操作"></a>使用互斥锁完成2个线程对同一个全局变量各加100万次的操作</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timeg_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 上锁</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>        mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 解锁</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---test1---g_num=%d"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> g_num    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        mutex<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 上锁</span>        g_num <span class="token operator">+=</span> <span class="token number">1</span>        mutex<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 解锁</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"---test2---g_num=%d"</span><span class="token operator">%</span>g_num<span class="token punctuation">)</span><span class="token comment"># 创建一个互斥锁</span><span class="token comment"># 默认是未上锁的状态</span>mutex <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 创建2个线程，让他们各自对g_num加1000000次</span>p1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>test1<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>p2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>test2<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 等待计算完成</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span><span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2个线程对同一个全局变量操作之后的最终结果是:%s"</span> <span class="token operator">%</span> g_num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>test1<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>g_num<span class="token operator">=</span><span class="token number">1909909</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>test2<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>g_num<span class="token operator">=</span><span class="token number">2000000</span><span class="token number">2</span>个线程对同一个全局变量操作之后的最终结果是<span class="token punctuation">:</span><span class="token number">2000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到最后的结果，加入互斥锁后，其结果与预期相符。</p><h2 id="上锁解锁过程"><a href="#上锁解锁过程" class="headerlink" title="上锁解锁过程"></a>上锁解锁过程</h2><p>当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。</p><p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</p><p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>锁的好处：</p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li></ul><p>锁的坏处：</p><ul><li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li><li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>现实社会中，男女双方都在等待对方先道歉</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215542.png" alt="img" loading="lazy"></p><p>如果双方都这样固执的等待对方先开口，弄不好，就分搜了</p><h3 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p><p>尽管死锁很少发生，但一旦发生就会造成应用的停止响应。下面看一个死锁的例子</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#coding=utf-8</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对mutexA上锁</span>        mutexA<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># mutexA上锁后，延时1秒，等待另外那个线程 把mutexB上锁</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do1---up----'</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了</span>        mutexB<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do1---down----'</span><span class="token punctuation">)</span>        mutexB<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 对mutexA解锁</span>        mutexA<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对mutexB上锁</span>        mutexB<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># mutexB上锁后，延时1秒，等待另外那个线程 把mutexA上锁</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do2---up----'</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment"># 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了</span>        mutexA<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">'----do2---down----'</span><span class="token punctuation">)</span>        mutexA<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 对mutexB解锁</span>        mutexB<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>mutexA <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>mutexB <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    t1 <span class="token operator">=</span> MyThread1<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2 <span class="token operator">=</span> MyThread2<span class="token punctuation">(</span><span class="token punctuation">)</span>    t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果： </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215630.gif" alt="img" loading="lazy"></p><p>此时已经进入到了死锁状态，可以使用ctrl-c退出</p><h3 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2. 避免死锁"></a>2. 避免死锁</h3><ul><li>程序设计时要尽量避免（银行家算法）</li><li>添加超时时间等</li></ul><h3 id="附录-银行家算法"><a href="#附录-银行家算法" class="headerlink" title="附录-银行家算法"></a>附录-银行家算法</h3><p>[背景知识]</p><p>一个银行家如何将一定数目的资金安全地借给若干个客户，使这些客户既能借到钱完成要干的事，同时银行家又能收回全部资金而不至于破产，这就是银行家问题。这个问题同操作系统中资源分配问题十分相似：银行家就像一个操作系统，客户就像运行的进程，银行家的资金就是系统的资源。</p><p>[问题的描述]</p><p>一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。客户贷款是以每次一个资金单位（如1万RMB等）的方式进行的，客户在借满所需的全部单位款额之前可能会等待，但银行家须保证这种等待是有限的，可完成的。</p><p>例如：有三个客户C1，C2，C3，向银行家借款，该银行家的资金总额为10个资金单位，其中C1客户要借9各资金单位，C2客户要借3个资金单位，C3客户要借8个资金单位，总计20个资金单位。某一时刻的状态如图所示。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215638.png" alt="img" loading="lazy"></p><p>对于a图的状态，按照安全序列的要求，我们选的第一个客户应满足该客户所需的贷款小于等于银行家当前所剩余的钱款，可以看出只有C2客户能被满足：C2客户需1个资金单位，小银行家手中的2个资金单位，于是银行家把1个资金单位借给C2客户，使之完成工作并归还所借的3个资金单位的钱，进入b图。同理，银行家把4个资金单位借给C3客户，使其完成工作，在c图中，只剩一个客户C1，它需7个资金单位，这时银行家有8个资金单位，所以C1也能顺利借到钱并完成工作。最后（见图d）银行家收回全部10个资金单位，保证不赔本。那麽客户序列{C1，C2，C3}就是个安全序列，按照这个序列贷款，银行家才是安全的。否则的话，若在图b状态时，银行家把手中的4个资金单位借给了C1，则出现不安全状态：这时C1，C3均不能完成工作，而银行家手中又没有钱了，系统陷入僵持局面，银行家也不能收回投资。</p><p>综上所述，银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，……。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。</p><h1 id="案例：多任务版udp聊天器"><a href="#案例：多任务版udp聊天器" class="headerlink" title="案例：多任务版udp聊天器"></a>案例：多任务版udp聊天器</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319215802.png" alt="img" loading="lazy"></p><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><blockquote><ul><li>编写一个有2个线程的程序</li><li>线程1用来接收数据然后显示</li><li>线程2用来检测键盘数据然后通过udp发送数据</li></ul></blockquote><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><blockquote><ol><li>实现上述要求</li><li>总结多任务程序的特点</li></ol></blockquote><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码:"></a>参考代码:</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">send_msg</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""获取键盘数据，并将其发送给对方"""</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 1. 从键盘输入数据</span>        msg <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"\n请输入要发送的数据:"</span><span class="token punctuation">)</span>        <span class="token comment"># 2. 输入对方的ip地址</span>        dest_ip <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"\n请输入对方的ip地址:"</span><span class="token punctuation">)</span>        <span class="token comment"># 3. 输入对方的port</span>        dest_port <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"\n请输入对方的port:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 4. 发送数据</span>        udp_socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>msg<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>dest_ip<span class="token punctuation">,</span> dest_port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">recv_msg</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""接收数据并显示"""</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 1. 接收数据</span>        recv_msg <span class="token operator">=</span> udp_socket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>        <span class="token comment"># 2. 解码</span>        recv_ip <span class="token operator">=</span> recv_msg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        recv_msg <span class="token operator">=</span> recv_msg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>        <span class="token comment"># 3. 显示接收到的数据</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>%s:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>recv_ip<span class="token punctuation">)</span><span class="token punctuation">,</span> recv_msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 1. 创建套接字</span>    udp_socket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span>    <span class="token comment"># 2. 绑定本地信息</span>    udp_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">7890</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 3. 创建一个子线程用来接收数据</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>recv_msg<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>udp_socket<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 4. 让主线程用来检测键盘数据并且发送</span>    send_msg<span class="token punctuation">(</span>udp_socket<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/posts/65cd929b/"/>
      <url>/posts/65cd929b/</url>
      
        <content type="html"><![CDATA[<h1 id="PyCharm-的初始设置（知道）"><a href="#PyCharm-的初始设置（知道）" class="headerlink" title="PyCharm 的初始设置（知道）"></a>PyCharm 的初始设置（知道）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>恢复 PyCharm 的初始设置</li><li>第一次启动 PyCharm</li><li>新建一个 Python 项目</li><li>设置 PyCharm 的字体显示</li><li>PyCharm 的升级以及其他</li></ul><p>PyCharm 的官方网站地址是：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p><h2 id="01-恢复-PyCharm-的初始设置"><a href="#01-恢复-PyCharm-的初始设置" class="headerlink" title="01. 恢复 PyCharm 的初始设置"></a>01. 恢复 PyCharm 的初始设置</h2><p><code>PyCharm</code> 的 <strong>配置信息</strong> 是保存在 <strong>用户家目录下</strong> 的 <code>.PyCharmxxxx.x</code> 目录下的，<code>xxxx.x</code> 表示当前使用的 <code>PyCharm</code> 的版本号</p><p>如果要恢复 <code>PyCharm</code> 的初始设置，可以按照以下步骤进行：</p><ul><li><ol><li>关闭正在运行的 <code>PyCharm</code></li></ol></li><li><ol start="2"><li>在终端中执行以下终端命令，删除 <code>PyCharm</code> 的配置信息目录：</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>重新启动 <code>PyCharm</code></li></ol></li></ul><h2 id="02-第一次启动-PyCharm"><a href="#02-第一次启动-PyCharm" class="headerlink" title="02. 第一次启动 PyCharm"></a>02. 第一次启动 PyCharm</h2><ol><li>导入配置信息</li><li>选择许可协议</li><li>配置初始界面</li></ol><h3 id="2-1-导入配置信息"><a href="#2-1-导入配置信息" class="headerlink" title="2.1 导入配置信息"></a>2.1 导入配置信息</h3><ul><li>在第一次启动 <code>PyCharm</code> 时，会首先提示用户是否导入 <strong>之前的配置信息</strong></li><li>如果是第一次使用，直接点击 <strong>OK</strong> 按钮</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025501.png" alt="001_PyCharm导入配置信息-w603" loading="lazy"></p><h3 id="2-2-选择许可协议"><a href="#2-2-选择许可协议" class="headerlink" title="2.2 选择许可协议"></a>2.2 选择许可协议</h3><ul><li>PyCharm 是一个付费软件，购买费用为 <strong>199$ &#x2F; 年</strong> 或者 <strong>19.90$ ／ 月</strong></li><li>不过 PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong><ul><li>下载地址是：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li></ul></li><li>商业版本会提示输入注册信息，或者选择免费评估</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025502.png" alt="002_激活许可证-w495" loading="lazy"></p><h3 id="2-3-PyCharm-的配置初始界面"><a href="#2-3-PyCharm-的配置初始界面" class="headerlink" title="2.3 PyCharm 的配置初始界面"></a>2.3 PyCharm 的配置初始界面</h3><ul><li>在初始配置界面，可以通过 <code>Editor colors and fonts</code> 选择 <strong>编辑器的配色方案</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025503.png" alt="003_PyCharm初始配置界面-w491" loading="lazy"></p><h3 id="2-4-欢迎界面"><a href="#2-4-欢迎界面" class="headerlink" title="2.4 欢迎界面"></a>2.4 欢迎界面</h3><ul><li>所有基础配置工作结束之后，就可以看到 <code>PyCharm</code> 的 <strong>欢迎界面</strong>了，通过 <strong>欢迎界面</strong> 就可以开始开发 Python 项目了</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025504.png" alt="004_PyCharm欢迎页面-w664" loading="lazy"></p><h2 id="03-新建-x2F-打开一个-Python-项目"><a href="#03-新建-x2F-打开一个-Python-项目" class="headerlink" title="03. 新建&#x2F;打开一个 Python 项目"></a>03. 新建&#x2F;打开一个 Python 项目</h2><h3 id="3-1-项目简介"><a href="#3-1-项目简介" class="headerlink" title="3.1 项目简介"></a>3.1 项目简介</h3><ul><li>开发 <strong>项目</strong> 就是开发一个 <strong>专门解决一个复杂业务功能的软件</strong></li><li>通常每 <strong>一个项目</strong> 就具有一个 <strong>独立专属的目录</strong>，用于保存 <strong>所有和项目相关的文件</strong><ul><li>一个项目通常会包含 <strong>很多源文件</strong></li></ul></li></ul><h3 id="3-2-打开-Python-项目"><a href="#3-2-打开-Python-项目" class="headerlink" title="3.2 打开 Python 项目"></a>3.2 打开 Python 项目</h3><ul><li>直接点击 <strong>Open</strong> 按钮，然后浏览到之前保存 <strong>Python 文件的目录</strong>，既可以打开项目</li><li>打开之后，会在目录下新建一个 <code>.idea</code> 的目录，用于保存 <strong>项目相关的信息</strong>，例如：<strong>解释器版本</strong>、<strong>项目包含的文件</strong>等等</li><li>第一次打开项目，需要耐心等待 <code>PyCharm</code> 对项目<strong>进行初始设置</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025505.png" alt="005_打开已有Python项目-w423" loading="lazy"></p><h4 id="设置项目使用的解释器版本"><a href="#设置项目使用的解释器版本" class="headerlink" title="设置项目使用的解释器版本"></a>设置项目使用的解释器版本</h4><ul><li>打开的目录如果不是由 <code>PyCharm</code> 建立的项目目录，<strong>有的时候</strong> 使用的解释器版本是 <code>Python 2.x</code> 的，需要<strong>单独设置解释器的版本</strong></li><li>通过 <strong>File</strong> &#x2F; <strong>Settings…</strong> 可以打开设置窗口，如下图所示：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025506.png" alt="006_选择项目的解释器版本-w975" loading="lazy"></p><h3 id="3-3-新建项目"><a href="#3-3-新建项目" class="headerlink" title="3.3 新建项目"></a>3.3 新建项目</h3><h4 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1) 命名规则"></a>1) 命名规则</h4><ul><li><p>以后 <strong>项目名</strong> 前面都以 <strong>数字编号</strong>，<strong>随着知识点递增，编号递增</strong></p><ul><li>例如：<strong>01_Python 基础</strong>、<strong>02_分支</strong>、<strong>03_循环</strong>…</li></ul></li><li><p>每个项目下的 <strong>文件名</strong> 都以 <code>hm_xx_知识点</code> 方式来命名</p><ul><li>其中 <strong>xx</strong> 是演练文件的序号</li></ul></li><li><p>注意</p><ul><li><ol><li>命名文件名时建议只使用 <strong>小写字母</strong>、<strong>数字</strong> 和 <strong>下划线</strong></li></ol></li><li><ol start="2"><li><strong>文件名不能以数字开始</strong></li></ol></li></ul></li><li><p>通过 <strong>欢迎界面</strong> 或者菜单 <strong>File</strong> &#x2F; <strong>New Project</strong> 可以新建项目</p></li></ul><h4 id="2-演练步骤"><a href="#2-演练步骤" class="headerlink" title="2) 演练步骤"></a>2) 演练步骤</h4><ul><li>新建 <code>01_Python基础</code> 项目，使用 <strong>Python 3.x 解释器</strong></li><li>在项目下新建 <code>hm_01_hello.py</code> Python 文件</li><li>编写 <code>print(&quot;Hello Python&quot;)</code> 代码</li></ul><h2 id="04-设置-PyCharm-的字体显示"><a href="#04-设置-PyCharm-的字体显示" class="headerlink" title="04. 设置 PyCharm 的字体显示"></a>04. 设置 PyCharm 的字体显示</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025507.png" alt="007_PyCharm设置编辑器字体-w500" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025508.png" alt="008_PyCharm设置控制台字体-w500" loading="lazy"></p><h2 id="05-PyCharm-的升级以及其他"><a href="#05-PyCharm-的升级以及其他" class="headerlink" title="05. PyCharm 的升级以及其他"></a>05. PyCharm 的升级以及其他</h2><blockquote><p>PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong></p></blockquote><ul><li>教育版下载地址：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li><li>专业版下载地址：<a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></li></ul><h3 id="5-1-安装和启动步骤"><a href="#5-1-安装和启动步骤" class="headerlink" title="5.1 安装和启动步骤"></a>5.1 安装和启动步骤</h3><ul><li><ol><li>执行以下终端命令，解压缩下载后的安装包</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">tar</span> -zxvf pycharm-professional-2017.1.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>将解压缩后的目录移动到 <code>/opt</code> 目录下，可以方便其他用户使用</li></ol></li></ul><blockquote><p><code>/opt</code> 目录用户存放给主机额外安装的软件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-2017.1.3/ /opt/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>切换工作目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /opt/pycharm-2017.1.3/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="4"><li>启动 <code>PyCharm</code></li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-设置专业版启动图标"><a href="#5-2-设置专业版启动图标" class="headerlink" title="5.2 设置专业版启动图标"></a>5.2 设置专业版启动图标</h3><ul><li>在<strong>专业版</strong>中，选择菜单 <strong>Tools</strong> &#x2F; <strong>Create Desktop Entry…</strong> 可以设置任务栏启动图标<ul><li>注意：设置图标时，需要勾选 <code>Create the entry for all users</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025509.png" alt="009_创建桌面图标-w657" loading="lazy"></p><h3 id="5-3-卸载之前版本的-PyCharm"><a href="#5-3-卸载之前版本的-PyCharm" class="headerlink" title="5.3 卸载之前版本的 PyCharm"></a>5.3 卸载之前版本的 PyCharm</h3><h4 id="1-程序安装"><a href="#1-程序安装" class="headerlink" title="1) 程序安装"></a>1) 程序安装</h4><ul><li><ol><li><p><strong>程序文件目录</strong> </p><ul><li>将安装包解压缩，并且移动到 <code>/opt</code> 目录下</li><li><strong>所有的相关文件都保存在解压缩的目录中</strong></li></ul></li></ol></li><li><ol start="2"><li><p><strong>配置文件目录</strong></p><ul><li>启动 <code>PyCharm</code> 后，会在用户家目录下建立一个 <code>.PyCharmxxx</code> 的隐藏目录</li><li><strong>保存 <code>PyCharm</code> 相关的配置信息</strong></li></ul></li></ol></li><li><ol start="3"><li><p><strong>快捷方式文件</strong></p><ul><li><code>/usr/share/applications/jetbrains-pycharm.desktop</code></li></ul></li></ol></li></ul><blockquote><p>在 <code>ubuntu</code> 中，应用程序启动的快捷方式通常都保存在 <code>/usr/share/applications</code> 目录下</p></blockquote><h4 id="2-程序卸载"><a href="#2-程序卸载" class="headerlink" title="2) 程序卸载"></a>2) 程序卸载</h4><ul><li><p>要卸载 <code>PyCharm</code> 只需要做以下两步工作：</p></li><li><ol><li>删除解压缩目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">rm</span> -r /opt/pycharm-2016.3.1/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>删除家目录下用于保存配置信息的隐藏目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果不再使用 PyCharm 还需要将 <code>/usr/share/applications/</code> 下的 <code>jetbrains-pycharm.desktop</code> 删掉</p></blockquote><h3 id="5-4-教育版安装演练"><a href="#5-4-教育版安装演练" class="headerlink" title="5.4 教育版安装演练"></a>5.4 教育版安装演练</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 解压缩下载后的安装包</span>$ <span class="token function">tar</span> -zxvf pycharm-edu-3.5.1.tar.gz<span class="token comment"># 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用</span>$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-edu-3.5.1/ /opt/<span class="token comment"># 3. 启动 `PyCharm`</span>/opt/pycharm-edu-3.5.1/bin/pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>后续课程<strong>都使用专业版本演练</strong></p></blockquote><h4 id="设置启动图标"><a href="#设置启动图标" class="headerlink" title="设置启动图标"></a>设置启动图标</h4><ul><li><ol><li>编辑快捷方式文件</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> gedit /usr/share/applications/jetbrains-pycharm.desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>按照以下内容修改文件内容，需要注意<strong>指定正确的 <code>pycharm</code> 目录</strong></li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">[Desktop Entry]Version&#x3D;1.0Type&#x3D;ApplicationName&#x3D;PyCharmIcon&#x3D;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.pngExec&#x3D;&quot;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.sh&quot; %fComment&#x3D;The Drive to DevelopCategories&#x3D;Development;IDE;Terminal&#x3D;falseStartupWMClass&#x3D;jetbrains-pycharm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="认识-Python"><a href="#认识-Python" class="headerlink" title="认识 Python"></a>认识 Python</h1><blockquote><p>人生苦短，我用 Python —— Life is short, you need Python</p></blockquote><p><img src="J:/02-%25E6%25AF%2595%25E8%25AE%25BE/2018%25E5%25B9%25B4%25E4%25BC%25A0%25E6%2599%25BA%25E6%2592%25AD%25E5%25AE%25A2%25E9%25BB%2591%25E9%25A9%25ACpython+%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD%252015%25E6%259C%259F/%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD-%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD%25E8%25AF%25BE%25E4%25BB%25B6%25E8%25B5%2584%25E6%2596%2599%2520-1-4%25E4%25BD%258D%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD%2520%25205-14%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD/02python%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BC%2596%25E7%25A8%258B%25E9%2598%25B6%25E6%25AE%25B5-python%25E5%259F%25BA%25E7%25A1%2580/%25E8%25AF%25BE%25E4%25BB%25B6/day02_markdown/media/14950329208518/001_%25E4%25BA%25BA%25E7%2594%259F%25E8%258B%25A6%25E7%259F%25AD%25E6%2588%2591%25E7%2594%25A8python.jpg" alt="001_人生苦短我用python" loading="lazy"></p><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li>Python 的起源</li><li>为什么要用 Python？</li><li>Python 的特点</li><li>Python 的优缺点</li></ul><h2 id="01-Python-的起源"><a href="#01-Python-的起源" class="headerlink" title="01. Python 的起源"></a>01. Python 的起源</h2><blockquote><p>Python 的创始人为吉多·范罗苏姆（Guido van Rossum）</p></blockquote><p><img src="J:/02-%25E6%25AF%2595%25E8%25AE%25BE/2018%25E5%25B9%25B4%25E4%25BC%25A0%25E6%2599%25BA%25E6%2592%25AD%25E5%25AE%25A2%25E9%25BB%2591%25E9%25A9%25ACpython+%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD%252015%25E6%259C%259F/%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD-%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD%25E8%25AF%25BE%25E4%25BB%25B6%25E8%25B5%2584%25E6%2596%2599%2520-1-4%25E4%25BD%258D%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD%2520%25205-14%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD/02python%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BC%2596%25E7%25A8%258B%25E9%2598%25B6%25E6%25AE%25B5-python%25E5%259F%25BA%25E7%25A1%2580/%25E8%25AF%25BE%25E4%25BB%25B6/day02_markdown/media/14950329208518/002_%25E5%2590%2589%25E5%25A4%259A.jpg" alt="002_吉多-w256" loading="lazy"></p><ol><li>1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的<strong>解释程序</strong>，作为 ABC 语言的一种继承（<strong>感觉下什么叫牛人</strong>）</li><li>ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是<strong>专门为非专业程序员设计的</strong>。但是 ABC 语言并没有成功，究其原因，吉多认为是<strong>非开放</strong>造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果</li><li>之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）的爱好者</li><li>1991 年，第一个 Python <strong>解释器</strong> 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件</li></ol><h3 id="1-1-解释器（科普）"><a href="#1-1-解释器（科普）" class="headerlink" title="1.1 解释器（科普）"></a>1.1 解释器（科普）</h3><p><strong>计算机不能直接理解任何除机器语言以外的语言</strong>，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。<strong>将其他语言翻译成机器语言的工具，被称为编译器</strong></p><p>编译器翻译的方式有两种：一个是<strong>编译</strong>，另外一个是<strong>解释</strong>。两种方式之间的区别在于<strong>翻译时间点的不同</strong>。当编译器<strong>以解释方式运行的时候</strong>，也称之为<strong>解释器</strong></p><p><img src="J:/02-%25E6%25AF%2595%25E8%25AE%25BE/2018%25E5%25B9%25B4%25E4%25BC%25A0%25E6%2599%25BA%25E6%2592%25AD%25E5%25AE%25A2%25E9%25BB%2591%25E9%25A9%25ACpython+%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD%252015%25E6%259C%259F/%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD-%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD%25E8%25AF%25BE%25E4%25BB%25B6%25E8%25B5%2584%25E6%2596%2599%2520-1-4%25E4%25BD%258D%25E5%259F%25BA%25E7%25A1%2580%25E7%258F%25AD%2520%25205-14%25E5%25B0%25B1%25E4%25B8%259A%25E7%258F%25AD/02python%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BC%2596%25E7%25A8%258B%25E9%2598%25B6%25E6%25AE%25B5-python%25E5%259F%25BA%25E7%25A1%2580/%25E8%25AF%25BE%25E4%25BB%25B6/day02_markdown/media/14950329208518/001_%25E7%25BC%2596%25E8%25AF%2591%25E5%259E%258B%25E5%2592%258C%25E8%25A7%25A3%25E9%2587%258A%25E5%259E%258B%25E8%25AF%25AD%25E8%25A8%2580%25E5%25B7%25A5%25E4%25BD%259C%25E5%25AF%25B9%25E6%25AF%2594.png" alt="001_编译型和解释型语言工作对比-w360" loading="lazy"></p><ul><li><strong>编译型语言</strong>：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++</li><li><strong>解释型语言</strong>：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行</li></ul><h4 id="编译型语言和解释型语言对比"><a href="#编译型语言和解释型语言对比" class="headerlink" title="编译型语言和解释型语言对比"></a>编译型语言和解释型语言对比</h4><ul><li><strong>速度</strong> —— 编译型语言比解释型语言执行速度快</li><li><strong>跨平台性</strong> —— 解释型语言比编译型语言跨平台性好</li></ul><h3 id="1-2-Python-的设计目标"><a href="#1-2-Python-的设计目标" class="headerlink" title="1.2 Python 的设计目标"></a>1.2 Python 的设计目标</h3><p>1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标：</p><ul><li>一门<strong>简单直观的语言</strong>并与主要竞争者一样强大</li><li><strong>开源</strong>，以便任何人都可以为它做贡献</li><li>代码<strong>像纯英语那样容易理解</strong></li><li>适用于<strong>短期</strong>开发的日常任务</li></ul><p>这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言</p><h3 id="1-3-Python-的设计哲学"><a href="#1-3-Python-的设计哲学" class="headerlink" title="1.3 Python 的设计哲学"></a>1.3 Python 的设计哲学</h3><ol><li>优雅</li><li>明确</li><li>简单</li></ol><p>在 Python 解释器内运行 <code>import this</code> 可以获得完整的列表 </p><ul><li>Python 开发者的哲学是：<strong>用一种方法，最好是只有一种方法来做一件事</strong></li><li>如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择<strong>明确没有或者很少有歧义的语法</strong></li></ul><blockquote><p>在 Python 社区，吉多被称为“仁慈的独裁者”</p></blockquote><h2 id="02-为什么选择-Python？"><a href="#02-为什么选择-Python？" class="headerlink" title="02. 为什么选择 Python？"></a>02. 为什么选择 Python？</h2><ul><li>代码量少</li><li>……</li></ul><blockquote><p>同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 <code>Python</code> 是 <code>Java</code> 的 <strong>1&#x2F;5</strong>，所以说 <strong>人生苦短，我用 Python</strong></p></blockquote><h2 id="03-Python-特点"><a href="#03-Python-特点" class="headerlink" title="03. Python 特点"></a>03. Python 特点</h2><ul><li>Python 是<strong>完全面向对象的语言</strong><ul><li><strong>函数</strong>、<strong>模块</strong>、<strong>数字</strong>、<strong>字符串</strong>都是对象，<strong>在 Python 中一切皆对象</strong></li><li>完全支持继承、重载、多重继承</li><li>支持重载运算符，也支持泛型设计</li></ul></li><li>Python <strong>拥有一个强大的标准库</strong>，Python 语言的核心只包含 <strong>数字</strong>、<strong>字符串</strong>、<strong>列表</strong>、<strong>字典</strong>、<strong>文件</strong> 等常见类型和函数，而由 Python 标准库提供了 <strong>系统管理</strong>、<strong>网络通信</strong>、<strong>文本处理</strong>、<strong>数据库接口</strong>、<strong>图形系统</strong>、<strong>XML 处理</strong> 等额外的功能</li><li>Python 社区提供了<strong>大量的第三方模块</strong>，使用方式与标准库类似。它们的功能覆盖 <strong>科学计算</strong>、<strong>人工智能</strong>、<strong>机器学习</strong>、<strong>Web 开发</strong>、<strong>数据库接口</strong>、<strong>图形系统</strong> 多个领域</li></ul><h3 id="面向对象的思维方式"><a href="#面向对象的思维方式" class="headerlink" title="面向对象的思维方式"></a>面向对象的思维方式</h3><ul><li><strong>面向对象</strong> 是一种 <strong>思维方式</strong>，也是一门 <strong>程序设计技术</strong></li><li>要解决一个问题前，首先考虑 <strong>由谁</strong> 来做，怎么做事情是 <strong>谁</strong> 的职责，最后把事情做好就行！<ul><li><strong>对象</strong> 就是 <strong>谁</strong></li></ul></li><li>要解决复杂的问题，就可以找<strong>多个不同的对象</strong>，<strong>各司其职</strong>，共同实现，最终完成需求</li></ul><h2 id="04-Python-的优缺点"><a href="#04-Python-的优缺点" class="headerlink" title="04. Python 的优缺点"></a>04. Python 的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><ul><li>简单、易学</li><li>免费、开源</li><li><strong>面向对象</strong></li><li>丰富的库</li><li>可扩展性<ul><li>如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 <code>C</code> 或 <code>C++</code> 编写，然后在 <code>Python</code> 程序中使用它们</li></ul></li><li>……</li></ul><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><ul><li>运行速度</li><li>国内市场较小</li><li>中文资料匮乏</li></ul><h1 id="第一个-Python-程序"><a href="#第一个-Python-程序" class="headerlink" title="第一个 Python 程序"></a>第一个 Python 程序</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ul><li>第一个 <code>HelloPython</code> 程序</li><li><code>Python 2.x</code> 与 <code>3​​.x</code> 版本简介</li><li>执行 <code>Python</code> 程序的三种方式<ul><li>解释器 —— <code>python</code> &#x2F; <code>python3</code></li><li>交互式 —— <code>ipython</code></li><li>集成开发环境 —— <code>PyCharm</code></li></ul></li></ul><h2 id="01-第一个-HelloPython-程序"><a href="#01-第一个-HelloPython-程序" class="headerlink" title="01. 第一个 HelloPython 程序"></a>01. 第一个 <code>HelloPython</code> 程序</h2><h3 id="1-1-Python-源程序的基本概念"><a href="#1-1-Python-源程序的基本概念" class="headerlink" title="1.1 Python 源程序的基本概念"></a>1.1 Python 源程序的基本概念</h3><ol><li>Python 源程序就是<strong>一个特殊格式的文本文件</strong>，可以<strong>使用任意文本编辑软件</strong>做 <code>Python</code> 的开发</li><li>Python 程序的 <strong>文件扩展名</strong> 通常都是 <code>.py</code></li></ol><h3 id="1-2-演练步骤"><a href="#1-2-演练步骤" class="headerlink" title="1.2 演练步骤"></a>1.2 演练步骤</h3><ul><li>在桌面下，新建 <code>认识Python</code> 目录</li><li>在 <code>认识Python</code> 目录下新建 <code>01-HelloPython.py</code> 文件</li><li>使用 <strong>gedit</strong> 编辑 <code>01-HelloPython.py</code> 并且输入以下内容：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在终端中输入以下命令执行 <code>01-HelloPython.py</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python 01-HelloPython.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>print</code> 是 <code>python</code> 中我们学习的第一个 <strong>函数</strong></p><p><code>print</code> 函数的作用，可以把 <strong>“”</strong> 内部的内容，输出到屏幕上</p></blockquote><h3 id="1-3-演练扩展-——-认识错误（BUG）"><a href="#1-3-演练扩展-——-认识错误（BUG）" class="headerlink" title="1.3 演练扩展 —— 认识错误（BUG）"></a>1.3 演练扩展 —— 认识错误（BUG）</h3><h4 id="关于错误"><a href="#关于错误" class="headerlink" title="关于错误"></a>关于错误</h4><ul><li>编写的程序<strong>不能正常执行</strong>，或者<strong>执行的结果不是我们期望的</strong></li><li>俗称 <code>BUG</code>，是程序员在开发时非常常见的，初学者常见错误的原因包括：<ol><li>手误</li><li>对已经学习过的知识理解还存在不足</li><li>对语言还有需要学习和提升的内容</li></ol></li><li>在学习语言时，不仅要<strong>学会语言的语法</strong>，而且还要<strong>学会如何认识错误和解决错误的方法</strong></li></ul><blockquote><p>每一个程序员都是在不断地修改错误中成长的</p></blockquote><h4 id="第一个演练中的常见错误"><a href="#第一个演练中的常见错误" class="headerlink" title="第一个演练中的常见错误"></a>第一个演练中的常见错误</h4><ul><li>1&gt; <strong>手误</strong>，例如使用 <code>pirnt(&quot;Hello world&quot;)</code></li></ul><pre class="line-numbers language-none"><code class="language-none">NameError: name &#39;pirnt&#39; is not defined名称错误：&#39;pirnt&#39; 名字没有定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>2&gt; 将多条 <code>print</code> 写在一行</li></ul><pre class="line-numbers language-none"><code class="language-none">SyntaxError: invalid syntax语法错误：语法无效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>每行代码负责完成一个动作</p></blockquote><ul><li>3&gt; 缩进错误</li></ul><pre class="line-numbers language-none"><code class="language-none">IndentationError: unexpected indent缩进错误：不期望出现的缩进<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>Python 是一个格式非常严格的程序设计语言</li><li>目前而言，大家记住每行代码前面都不要增加空格</li></ul></blockquote><ul><li>4&gt; <strong>python 2.x 默认不支持中文</strong></li></ul><p>目前市场上有两个 Python 的版本并存着，分别是 <code>Python 2.x</code> 和 <code>Python 3.x</code></p><ul><li><strong>Python 2.x 默认不支持中文</strong>，具体原因，等到介绍 <strong>字符编码</strong> 时给大家讲解</li><li>Python 2.x 的解释器名称是 <strong>python</strong></li><li>Python 3.x 的解释器名称是 <strong>python3</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">SyntaxError: Non-ASCII character &#39;\xe4&#39; in file 01-HelloPython.py on line 3, but no encoding declared; see http:&#x2F;&#x2F;python.org&#x2F;dev&#x2F;peps&#x2F;pep-0263&#x2F; for details语法错误： 在 01-HelloPython.py 中第 3 行出现了非 ASCII 字符 &#39;\xe4&#39;，但是没有声明文件编码请访问 http:&#x2F;&#x2F;python.org&#x2F;dev&#x2F;peps&#x2F;pep-0263&#x2F; 了解详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><code>ASCII</code> 字符只包含 <code>256</code> 个字符，不支持中文</li><li>有关字符编码的问题，后续会讲</li></ul></blockquote><h4 id="单词列表"><a href="#单词列表" class="headerlink" title="单词列表"></a>单词列表</h4><pre class="line-numbers language-none"><code class="language-none">* error 错误* name 名字* defined 已经定义* syntax 语法* invalid 无效* Indentation 索引* unexpected 意外的，不期望的* character 字符* line 行* encoding 编码* declared 声明* details 细节，详细信息* ASCII 一种字符编码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-Python-2-x-与-3​​-x-版本简介"><a href="#02-Python-2-x-与-3​​-x-版本简介" class="headerlink" title="02. Python 2.x 与 3​​.x 版本简介"></a>02. <code>Python 2.x</code> 与 <code>3​​.x</code> 版本简介</h2><p>目前市场上有两个 Python 的版本并存着，分别是 <code>Python 2.x</code> 和 <code>Python 3.x</code></p><blockquote><p>新的 Python 程序建议使用 <code>Python 3.0</code> 版本的语法</p></blockquote><ul><li>Python 2.x 是 <strong>过去的版本</strong><ul><li>解释器名称是 <strong>python</strong></li></ul></li><li>Python 3.x 是 <strong>现在和未来 主流的版本</strong><ul><li>解释器名称是 <strong>python3</strong></li><li>相对于 <code>Python</code> 的早期版本，这是一个 <strong>较大的升级</strong></li><li>为了不带入过多的累赘，<code>Python 3.0</code> 在设计的时候 <strong>没有考虑向下兼容</strong><ul><li>许多早期 <code>Python</code> 版本设计的程序都无法在 <code>Python 3.0</code> 上正常执行</li></ul></li><li>Python 3.0 发布于 <strong>2008 年</strong></li><li>到目前为止，Python 3.0 的稳定版本已经有很多年了<ul><li>Python 3.3 发布于 2012</li><li>Python 3.4 发布于 2014</li><li>Python 3.5 发布于 2015</li><li>Python 3.6 发布于 2016</li></ul></li></ul></li><li>为了照顾现有的程序，官方提供了一个过渡版本 —— <strong>Python 2.6</strong><ul><li>基本使用了 <code>Python 2.x</code> 的语法和库</li><li>同时考虑了向 <code>Python 3.0</code> 的迁移，<strong>允许使用部分</strong> <code>Python 3.0</code> 的语法与函数</li><li>2010 年中推出的 <code>Python 2.7</code> 被确定为 <strong>最后一个Python 2.x 版本</strong></li></ul></li></ul><blockquote><p>提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议</p><ul><li>先使用 <code>Python 3.0</code> 版本进行开发</li><li>然后使用 <code>Python 2.6</code>、<code>Python 2.7</code> 来执行，并且做一些兼容性的处理</li></ul></blockquote><h2 id="03-执行-Python-程序的三种方式"><a href="#03-执行-Python-程序的三种方式" class="headerlink" title="03. 执行 Python 程序的三种方式"></a>03. 执行 Python 程序的三种方式</h2><h3 id="3-1-解释器-python-x2F-python3"><a href="#3-1-解释器-python-x2F-python3" class="headerlink" title="3.1. 解释器 python &#x2F; python3"></a>3.1. 解释器 <code>python</code> &#x2F; <code>python3</code></h3><h4 id="Python-的解释器"><a href="#Python-的解释器" class="headerlink" title="Python 的解释器"></a>Python 的解释器</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 python 2.x 解释器</span>$ python xxx.py<span class="token comment"># 使用 python 3.x 解释器</span>$ python3 xxx.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="其他解释器（知道）"><a href="#其他解释器（知道）" class="headerlink" title="其他解释器（知道）"></a>其他解释器（知道）</h5><p><strong>Python 的解释器</strong> 如今有多个语言的实现，包括：</p><ul><li><code>CPython</code> —— 官方版本的 C 语言实现</li><li><code>Jython</code> —— 可以运行在 Java 平台</li><li><code>IronPython</code> —— 可以运行在 .NET 和 Mono 平台</li><li><code>PyPy</code> —— Python 实现的，支持 JIT 即时编译</li></ul><h3 id="3-2-交互式运行-Python-程序"><a href="#3-2-交互式运行-Python-程序" class="headerlink" title="3.2. 交互式运行 Python 程序"></a>3.2. 交互式运行 Python 程序</h3><ul><li>直接在终端中运行解释器，而不输入要执行的文件名</li><li>在 Python 的 <code>Shell</code> 中直接输入 <strong>Python 的代码</strong>，会立即看到程序执行结果</li></ul><h4 id="1-交互式运行-Python-的优缺点"><a href="#1-交互式运行-Python-的优缺点" class="headerlink" title="1) 交互式运行 Python 的优缺点"></a>1) 交互式运行 Python 的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>适合于学习&#x2F;验证 Python 语法或者局部代码</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>代码不能保存</li><li>不适合运行太大的程序</li></ul><h4 id="2-退出-官方的解释器"><a href="#2-退出-官方的解释器" class="headerlink" title="2) 退出 官方的解释器"></a>2) 退出 官方的解释器</h4><h5 id="1-gt-直接输入-exit"><a href="#1-gt-直接输入-exit" class="headerlink" title="1&gt; 直接输入 exit()"></a>1&gt; 直接输入 <code>exit()</code></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> exit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-gt-使用热键退出"><a href="#2-gt-使用热键退出" class="headerlink" title="2&gt; 使用热键退出"></a>2&gt; 使用热键退出</h5><p>在 python 解释器中，按热键 <code>ctrl + d</code> 可以退出解释器</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000129.jpg" alt="001_积跬步以至千里" loading="lazy"></p><h4 id="3-IPython"><a href="#3-IPython" class="headerlink" title="3) IPython"></a>3) IPython</h4><ul><li>IPython 中 的 “I” 代表 <strong>交互 interactive</strong></li></ul><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>IPython 是一个 python 的 <strong>交互式 shell</strong>，比默认的 <code>python shell</code> 好用得多<ul><li>支持自动补全</li><li>自动缩进</li><li>支持 <code>bash shell</code> 命令</li><li>内置了许多很有用的功能和函数</li></ul></li><li>IPython 是基于 BSD 开源的</li></ul><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><ul><li><p>Python 2.x 使用的解释器是 <strong>ipython</strong></p></li><li><p>Python 3.x 使用的解释器是 <strong>ipython3</strong></p></li><li><p>要退出解释器可以有以下两种方式：</p></li></ul><h5 id="1-gt-直接输入-exit-1"><a href="#1-gt-直接输入-exit-1" class="headerlink" title="1&gt; 直接输入 exit"></a>1&gt; 直接输入 <code>exit</code></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-gt-使用热键退出-1"><a href="#2-gt-使用热键退出-1" class="headerlink" title="2&gt; 使用热键退出"></a>2&gt; 使用热键退出</h5><p>在 IPython 解释器中，按热键 <code>ctrl + d</code>，<code>IPython</code> 会询问是否退出解释器</p><h4 id="IPython-的安装"><a href="#IPython-的安装" class="headerlink" title="IPython 的安装"></a>IPython 的安装</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ipython<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-3-Python-的-IDE-——-PyCharm"><a href="#3-3-Python-的-IDE-——-PyCharm" class="headerlink" title="3.3. Python 的 IDE —— PyCharm"></a>3.3. Python 的 IDE —— <code>PyCharm</code></h2><h3 id="1）-集成开发环境（IDE）"><a href="#1）-集成开发环境（IDE）" class="headerlink" title="1） 集成开发环境（IDE）"></a>1） 集成开发环境（IDE）</h3><p>集成开发环境（<code>IDE</code>，Integrated Development Environment）—— <strong>集成了开发软件需要的所有工具</strong>，一般包括以下工具：</p><ul><li>图形用户界面</li><li>代码编辑器（支持 <strong>代码补全</strong>／<strong>自动缩进</strong>）</li><li>编译器／解释器</li><li>调试器（<strong>断点</strong>／<strong>单步执行</strong>）</li><li>……</li></ul><h3 id="2）PyCharm-介绍"><a href="#2）PyCharm-介绍" class="headerlink" title="2）PyCharm 介绍"></a>2）PyCharm 介绍</h3><ul><li><code>PyCharm</code> 是 Python 的一款非常优秀的集成开发环境</li><li><code>PyCharm</code> 除了具有一般 IDE 所必备功能外，还可以在 <code>Windows</code>、<code>Linux</code>、<code>macOS</code> 下使用</li><li><code>PyCharm</code> 适合开发大型项目<ul><li>一个项目通常会包含 <strong>很多源文件</strong></li><li>每个 <strong>源文件</strong> 的代码行数是有限的，通常在几百行之内</li><li>每个 <strong>源文件</strong> 各司其职，共同完成复杂的业务功能</li></ul></li></ul><h3 id="3）PyCharm-快速体验"><a href="#3）PyCharm-快速体验" class="headerlink" title="3）PyCharm 快速体验"></a>3）PyCharm 快速体验</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000130.png" alt="001_PyCharm的界面结构" loading="lazy"></p><ul><li><strong>文件导航区域</strong> 能够 <strong>浏览</strong>／<strong>定位</strong>／<strong>打开</strong> 项目文件</li><li><strong>文件编辑区域</strong> 能够 <strong>编辑</strong> 当前打开的文件</li><li><strong>控制台区域</strong> 能够：<ul><li>输出程序执行内容</li><li>跟踪调试代码的执行</li></ul></li><li>右上角的 <strong>工具栏</strong> 能够 <strong>执行(SHIFT + F10)</strong> &#x2F; <strong>调试(SHIFT + F9)</strong> 代码</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000131.png" alt="002_PyCharm运行工具栏" loading="lazy"></p><ul><li>通过控制台上方的**单步执行按钮(F8)**，可以单步执行代码</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220319000132.png" alt="003_PyCharm调试器" loading="lazy"></p><h1 id="PyCharm-的初始设置（知道）-1"><a href="#PyCharm-的初始设置（知道）-1" class="headerlink" title="PyCharm 的初始设置（知道）"></a>PyCharm 的初始设置（知道）</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><ul><li>恢复 PyCharm 的初始设置</li><li>第一次启动 PyCharm</li><li>新建一个 Python 项目</li><li>设置 PyCharm 的字体显示</li><li>PyCharm 的升级以及其他</li></ul><p>PyCharm 的官方网站地址是：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p><h2 id="01-恢复-PyCharm-的初始设置-1"><a href="#01-恢复-PyCharm-的初始设置-1" class="headerlink" title="01. 恢复 PyCharm 的初始设置"></a>01. 恢复 PyCharm 的初始设置</h2><p><code>PyCharm</code> 的 <strong>配置信息</strong> 是保存在 <strong>用户家目录下</strong> 的 <code>.PyCharmxxxx.x</code> 目录下的，<code>xxxx.x</code> 表示当前使用的 <code>PyCharm</code> 的版本号</p><p>如果要恢复 <code>PyCharm</code> 的初始设置，可以按照以下步骤进行：</p><ul><li><ol><li>关闭正在运行的 <code>PyCharm</code></li></ol></li><li><ol start="2"><li>在终端中执行以下终端命令，删除 <code>PyCharm</code> 的配置信息目录：</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>重新启动 <code>PyCharm</code></li></ol></li></ul><h2 id="02-第一次启动-PyCharm-1"><a href="#02-第一次启动-PyCharm-1" class="headerlink" title="02. 第一次启动 PyCharm"></a>02. 第一次启动 PyCharm</h2><ol><li>导入配置信息</li><li>选择许可协议</li><li>配置初始界面</li></ol><h3 id="2-1-导入配置信息-1"><a href="#2-1-导入配置信息-1" class="headerlink" title="2.1 导入配置信息"></a>2.1 导入配置信息</h3><ul><li>在第一次启动 <code>PyCharm</code> 时，会首先提示用户是否导入 <strong>之前的配置信息</strong></li><li>如果是第一次使用，直接点击 <strong>OK</strong> 按钮</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235746.png" alt="001_PyCharm导入配置信息-w603" loading="lazy"></p><h3 id="2-2-选择许可协议-1"><a href="#2-2-选择许可协议-1" class="headerlink" title="2.2 选择许可协议"></a>2.2 选择许可协议</h3><ul><li>PyCharm 是一个付费软件，购买费用为 <strong>199$ &#x2F; 年</strong> 或者 <strong>19.90$ ／ 月</strong></li><li>不过 PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong><ul><li>下载地址是：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li></ul></li><li>商业版本会提示输入注册信息，或者选择免费评估</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235747.png" alt="002_激活许可证-w495" loading="lazy"></p><h3 id="2-3-PyCharm-的配置初始界面-1"><a href="#2-3-PyCharm-的配置初始界面-1" class="headerlink" title="2.3 PyCharm 的配置初始界面"></a>2.3 PyCharm 的配置初始界面</h3><ul><li>在初始配置界面，可以通过 <code>Editor colors and fonts</code> 选择 <strong>编辑器的配色方案</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235748.png" alt="003_PyCharm初始配置界面-w491" loading="lazy"></p><h3 id="2-4-欢迎界面-1"><a href="#2-4-欢迎界面-1" class="headerlink" title="2.4 欢迎界面"></a>2.4 欢迎界面</h3><ul><li>所有基础配置工作结束之后，就可以看到 <code>PyCharm</code> 的 <strong>欢迎界面</strong>了，通过 <strong>欢迎界面</strong> 就可以开始开发 Python 项目了</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235749.png" alt="004_PyCharm欢迎页面-w664" loading="lazy"></p><h2 id="03-新建-x2F-打开一个-Python-项目-1"><a href="#03-新建-x2F-打开一个-Python-项目-1" class="headerlink" title="03. 新建&#x2F;打开一个 Python 项目"></a>03. 新建&#x2F;打开一个 Python 项目</h2><h3 id="3-1-项目简介-1"><a href="#3-1-项目简介-1" class="headerlink" title="3.1 项目简介"></a>3.1 项目简介</h3><ul><li>开发 <strong>项目</strong> 就是开发一个 <strong>专门解决一个复杂业务功能的软件</strong></li><li>通常每 <strong>一个项目</strong> 就具有一个 <strong>独立专属的目录</strong>，用于保存 <strong>所有和项目相关的文件</strong><ul><li>一个项目通常会包含 <strong>很多源文件</strong></li></ul></li></ul><h3 id="3-2-打开-Python-项目-1"><a href="#3-2-打开-Python-项目-1" class="headerlink" title="3.2 打开 Python 项目"></a>3.2 打开 Python 项目</h3><ul><li>直接点击 <strong>Open</strong> 按钮，然后浏览到之前保存 <strong>Python 文件的目录</strong>，既可以打开项目</li><li>打开之后，会在目录下新建一个 <code>.idea</code> 的目录，用于保存 <strong>项目相关的信息</strong>，例如：<strong>解释器版本</strong>、<strong>项目包含的文件</strong>等等</li><li>第一次打开项目，需要耐心等待 <code>PyCharm</code> 对项目<strong>进行初始设置</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235750.png" alt="005_打开已有Python项目-w423" loading="lazy"></p><h4 id="设置项目使用的解释器版本-1"><a href="#设置项目使用的解释器版本-1" class="headerlink" title="设置项目使用的解释器版本"></a>设置项目使用的解释器版本</h4><ul><li>打开的目录如果不是由 <code>PyCharm</code> 建立的项目目录，<strong>有的时候</strong> 使用的解释器版本是 <code>Python 2.x</code> 的，需要<strong>单独设置解释器的版本</strong></li><li>通过 <strong>File</strong> &#x2F; <strong>Settings…</strong> 可以打开设置窗口，如下图所示：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235751.png" alt="006_选择项目的解释器版本-w975" loading="lazy"></p><h3 id="3-3-新建项目-1"><a href="#3-3-新建项目-1" class="headerlink" title="3.3 新建项目"></a>3.3 新建项目</h3><h4 id="1-命名规则-1"><a href="#1-命名规则-1" class="headerlink" title="1) 命名规则"></a>1) 命名规则</h4><ul><li><p>以后 <strong>项目名</strong> 前面都以 <strong>数字编号</strong>，<strong>随着知识点递增，编号递增</strong></p><ul><li>例如：<strong>01_Python 基础</strong>、<strong>02_分支</strong>、<strong>03_循环</strong>…</li></ul></li><li><p>每个项目下的 <strong>文件名</strong> 都以 <code>hm_xx_知识点</code> 方式来命名</p><ul><li>其中 <strong>xx</strong> 是演练文件的序号</li></ul></li><li><p>注意</p><ul><li><ol><li>命名文件名时建议只使用 <strong>小写字母</strong>、<strong>数字</strong> 和 <strong>下划线</strong></li></ol></li><li><ol start="2"><li><strong>文件名不能以数字开始</strong></li></ol></li></ul></li><li><p>通过 <strong>欢迎界面</strong> 或者菜单 <strong>File</strong> &#x2F; <strong>New Project</strong> 可以新建项目</p></li></ul><h4 id="2-演练步骤-1"><a href="#2-演练步骤-1" class="headerlink" title="2) 演练步骤"></a>2) 演练步骤</h4><ul><li>新建 <code>01_Python基础</code> 项目，使用 <strong>Python 3.x 解释器</strong></li><li>在项目下新建 <code>hm_01_hello.py</code> Python 文件</li><li>编写 <code>print(&quot;Hello Python&quot;)</code> 代码</li></ul><h2 id="04-设置-PyCharm-的字体显示-1"><a href="#04-设置-PyCharm-的字体显示-1" class="headerlink" title="04. 设置 PyCharm 的字体显示"></a>04. 设置 PyCharm 的字体显示</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235752.png" alt="007_PyCharm设置编辑器字体-w500" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235753.png" alt="008_PyCharm设置控制台字体-w500" loading="lazy"></p><h2 id="05-PyCharm-的升级以及其他-1"><a href="#05-PyCharm-的升级以及其他-1" class="headerlink" title="05. PyCharm 的升级以及其他"></a>05. PyCharm 的升级以及其他</h2><blockquote><p>PyCharm 提供了对 <strong>学生和教师免费使用的版本</strong></p></blockquote><ul><li>教育版下载地址：<a href="https://www.jetbrains.com/pycharm-edu/download/#section=linux">https://www.jetbrains.com/pycharm-edu/download/#section=linux</a></li><li>专业版下载地址：<a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></li></ul><h3 id="5-1-安装和启动步骤-1"><a href="#5-1-安装和启动步骤-1" class="headerlink" title="5.1 安装和启动步骤"></a>5.1 安装和启动步骤</h3><ul><li><ol><li>执行以下终端命令，解压缩下载后的安装包</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">tar</span> -zxvf pycharm-professional-2017.1.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>将解压缩后的目录移动到 <code>/opt</code> 目录下，可以方便其他用户使用</li></ol></li></ul><blockquote><p><code>/opt</code> 目录用户存放给主机额外安装的软件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-2017.1.3/ /opt/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>切换工作目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /opt/pycharm-2017.1.3/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="4"><li>启动 <code>PyCharm</code></li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-设置专业版启动图标-1"><a href="#5-2-设置专业版启动图标-1" class="headerlink" title="5.2 设置专业版启动图标"></a>5.2 设置专业版启动图标</h3><ul><li>在<strong>专业版</strong>中，选择菜单 <strong>Tools</strong> &#x2F; <strong>Create Desktop Entry…</strong> 可以设置任务栏启动图标<ul><li>注意：设置图标时，需要勾选 <code>Create the entry for all users</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220318235754.png" alt="009_创建桌面图标-w657" loading="lazy"></p><h3 id="5-3-卸载之前版本的-PyCharm-1"><a href="#5-3-卸载之前版本的-PyCharm-1" class="headerlink" title="5.3 卸载之前版本的 PyCharm"></a>5.3 卸载之前版本的 PyCharm</h3><h4 id="1-程序安装-1"><a href="#1-程序安装-1" class="headerlink" title="1) 程序安装"></a>1) 程序安装</h4><ul><li><ol><li><p><strong>程序文件目录</strong> </p><ul><li>将安装包解压缩，并且移动到 <code>/opt</code> 目录下</li><li><strong>所有的相关文件都保存在解压缩的目录中</strong></li></ul></li></ol></li><li><ol start="2"><li><p><strong>配置文件目录</strong></p><ul><li>启动 <code>PyCharm</code> 后，会在用户家目录下建立一个 <code>.PyCharmxxx</code> 的隐藏目录</li><li><strong>保存 <code>PyCharm</code> 相关的配置信息</strong></li></ul></li></ol></li><li><ol start="3"><li><p><strong>快捷方式文件</strong></p><ul><li><code>/usr/share/applications/jetbrains-pycharm.desktop</code></li></ul></li></ol></li></ul><blockquote><p>在 <code>ubuntu</code> 中，应用程序启动的快捷方式通常都保存在 <code>/usr/share/applications</code> 目录下</p></blockquote><h4 id="2-程序卸载-1"><a href="#2-程序卸载-1" class="headerlink" title="2) 程序卸载"></a>2) 程序卸载</h4><ul><li><p>要卸载 <code>PyCharm</code> 只需要做以下两步工作：</p></li><li><ol><li>删除解压缩目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">rm</span> -r /opt/pycharm-2016.3.1/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>删除家目录下用于保存配置信息的隐藏目录</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">rm</span> -r ~/.PyCharm2016.3/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果不再使用 PyCharm 还需要将 <code>/usr/share/applications/</code> 下的 <code>jetbrains-pycharm.desktop</code> 删掉</p></blockquote><h3 id="5-4-教育版安装演练-1"><a href="#5-4-教育版安装演练-1" class="headerlink" title="5.4 教育版安装演练"></a>5.4 教育版安装演练</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 解压缩下载后的安装包</span>$ <span class="token function">tar</span> -zxvf pycharm-edu-3.5.1.tar.gz<span class="token comment"># 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用</span>$ <span class="token function">sudo</span> <span class="token function">mv</span> pycharm-edu-3.5.1/ /opt/<span class="token comment"># 3. 启动 `PyCharm`</span>/opt/pycharm-edu-3.5.1/bin/pycharm.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>后续课程<strong>都使用专业版本演练</strong></p></blockquote><h4 id="设置启动图标-1"><a href="#设置启动图标-1" class="headerlink" title="设置启动图标"></a>设置启动图标</h4><ul><li><ol><li>编辑快捷方式文件</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> gedit /usr/share/applications/jetbrains-pycharm.desktop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>按照以下内容修改文件内容，需要注意<strong>指定正确的 <code>pycharm</code> 目录</strong></li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">[Desktop Entry]Version&#x3D;1.0Type&#x3D;ApplicationName&#x3D;PyCharmIcon&#x3D;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.pngExec&#x3D;&quot;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.sh&quot; %fComment&#x3D;The Drive to DevelopCategories&#x3D;Development;IDE;Terminal&#x3D;falseStartupWMClass&#x3D;jetbrains-pycharm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="多文件项目的演练"><a href="#多文件项目的演练" class="headerlink" title="多文件项目的演练"></a>多文件项目的演练</h1><ul><li>开发 <strong>项目</strong> 就是开发一个 <strong>专门解决一个复杂业务功能的软件</strong></li><li>通常每 <strong>一个项目</strong> 就具有一个 <strong>独立专属的目录</strong>，用于保存 <strong>所有和项目相关的文件</strong><ul><li>一个项目通常会包含 <strong>很多源文件</strong></li></ul></li></ul><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h2><ul><li>在项目中添加多个文件，并且设置文件的执行</li></ul><h2 id="多文件项目演练"><a href="#多文件项目演练" class="headerlink" title="多文件项目演练"></a>多文件项目演练</h2><ol><li>在 <code>01_Python基础</code> 项目中新建一个 <code>hm_02_第2个Python程序.py</code> </li><li>在 <code>hm_02_第2个Python程序.py</code> 文件中添加一句 <code>print(&quot;hello&quot;)</code></li><li><strong>点击右键执行</strong> <code>hm_02_第2个Python程序.py</code></li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025811.png" alt="001_让选中的程序可以执行-w662" loading="lazy"></p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li>在 <code>PyCharm</code> 中，要想让哪一个 <code>Python</code> 程序能够执行，必须首先通过 <strong>鼠标右键的方式执行</strong> 一下</li><li>对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试</li><li>对于商业项目而言，通常在一个项目中，只有一个 <strong>可以直接执行的 Python 源程序</strong></li></ul><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h2><ul><li>注释的作用</li><li>单行注释（行注释）</li><li>多行注释（块注释）</li></ul><h2 id="01-注释的作用"><a href="#01-注释的作用" class="headerlink" title="01. 注释的作用"></a>01. 注释的作用</h2><blockquote><p>使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025819.gif" alt="001_未使用注释的python程序" loading="lazy"></p><h2 id="02-单行注释-行注释"><a href="#02-单行注释-行注释" class="headerlink" title="02. 单行注释(行注释)"></a>02. 单行注释(行注释)</h2><ul><li><p>以 <code>#</code> 开头，<code>#</code> 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用</p></li><li><p>示例代码如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这是第一个单行注释</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>为了保证代码的可读性，<code>#</code> 后面建议先添加一个空格，然后再编写相应的说明文字</p></blockquote><h3 id="在代码后面增加的单行注释"><a href="#在代码后面增加的单行注释" class="headerlink" title="在代码后面增加的单行注释"></a>在代码后面增加的单行注释</h3><ul><li><p>在程序开发时，同样可以使用 <code>#</code> 在代码的后面（旁边）增加说明性的文字</p></li><li><p>但是，需要注意的是，<strong>为了保证代码的可读性</strong>，<strong>注释和代码之间</strong> 至少要有 <strong>两个空格</strong></p></li><li><p>示例代码如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span>  <span class="token comment"># 输出 `hello python`</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="03-多行注释（块注释）"><a href="#03-多行注释（块注释）" class="headerlink" title="03. 多行注释（块注释）"></a>03. 多行注释（块注释）</h2><ul><li><p>如果希望编写的 <strong>注释信息很多，一行无法显示</strong>，就可以使用多行注释</p></li><li><p>要在 Python 程序中使用多行注释，可以用 <strong>一对 连续的 三个 引号</strong>(单引号和双引号都可以)</p></li><li><p>示例代码如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""这是一个多行注释在多行注释之间，可以写很多很多的内容……"""</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello python"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="什么时候需要使用注释？"><a href="#什么时候需要使用注释？" class="headerlink" title="什么时候需要使用注释？"></a>什么时候需要使用注释？</h3><ol><li><strong>注释不是越多越好</strong>，对于一目了然的代码，不需要添加注释</li><li>对于 <strong>复杂的操作</strong>，应该在操作开始前写上若干行注释</li><li>对于 <strong>不是一目了然的代码</strong>，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格）</li><li>绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么</li></ol><blockquote><p>在一些正规的开发团队，通常会有 <strong>代码审核</strong> 的惯例，就是一个团队中彼此阅读对方的代码</p></blockquote><h3 id="关于代码规范"><a href="#关于代码规范" class="headerlink" title="关于代码规范"></a>关于代码规范</h3><ul><li><code>Python</code> 官方提供有一系列 PEP（Python Enhancement Proposals） 文档</li><li>其中第 8 篇文档专门针对 <strong>Python 的代码格式</strong> 给出了建议，也就是俗称的 <strong>PEP 8</strong></li><li>文档地址：<a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></li><li>谷歌有对应的中文文档：<a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/">http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/</a></li></ul><blockquote><p>任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步</p></blockquote><h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><p><strong>计算机</strong>，顾名思义就是负责进行 <strong>数学计算</strong> 并且 <strong>存储计算结果</strong> 的电子设备</p><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h2><ul><li>算术运算符的基本使用</li></ul><h2 id="01-算数运算符"><a href="#01-算数运算符" class="headerlink" title="01. 算数运算符"></a>01. 算数运算符</h2><ul><li>算数运算符是 <strong>运算符的一种</strong></li><li>是完成基本的算术运算使用的符号，用来处理四则运算</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td>10 + 20 &#x3D; 30</td></tr><tr><td align="center">-</td><td align="center">减</td><td>10 - 20 &#x3D; -10</td></tr><tr><td align="center">*</td><td align="center">乘</td><td>10 * 20 &#x3D; 200</td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td><td>10 &#x2F; 20 &#x3D; 0.5</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td align="center">取整除</td><td>返回除法的整数部分（商） 9 &#x2F;&#x2F; 2 输出结果 4</td></tr><tr><td align="center">%</td><td align="center">取余数</td><td>返回除法的余数 9 % 2 &#x3D; 1</td></tr><tr><td align="center">**</td><td align="center">幂</td><td>又称次方、乘方，2 ** 3 &#x3D; 8</td></tr></tbody></table><ul><li>在 Python 中 <code>*</code> 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'----------------------------------------'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="02-算数运算符的优先级"><a href="#02-算数运算符的优先级" class="headerlink" title="02. 算数运算符的优先级"></a>02. 算数运算符的优先级</h2><ul><li><p>和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是：</p><ul><li><strong>先乘除后加减</strong></li><li>同级运算符是 <strong>从左至右</strong> 计算</li><li>可以使用 <code>()</code> 调整计算的优先级</li></ul></li><li><p>以下表格的算数优先级由高到最低顺序排列</p></li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>幂 (最高优先级)</td></tr><tr><td>* &#x2F; % &#x2F;&#x2F;</td><td>乘、除、取余数、取整除</td></tr><tr><td>+ -</td><td>加法、减法</td></tr></tbody></table><ul><li>例如：<ul><li><code>2 + 3 * 5 = 17</code></li><li><code>(2 + 3) * 5 = 25</code></li><li><code>2 * 3 + 5 = 11</code></li><li><code>2 * (3 + 5) = 16</code></li></ul></li></ul><h1 id="程序执行原理（科普）"><a href="#程序执行原理（科普）" class="headerlink" title="程序执行原理（科普）"></a>程序执行原理（科普）</h1><h2 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h2><ul><li>计算机中的 <strong>三大件</strong></li><li>程序执行的原理</li><li>程序的作用</li></ul><h2 id="01-计算机中的三大件"><a href="#01-计算机中的三大件" class="headerlink" title="01. 计算机中的三大件"></a>01. 计算机中的三大件</h2><p>计算机中包含有较多的硬件，但是一个程序要运行，有 <strong>三个</strong> 核心的硬件，分别是：</p><ol><li><strong>CPU</strong> <ul><li>中央处理器，是一块超大规模的集成电路</li><li>负责 <strong>处理数据</strong>／<strong>计算</strong></li></ul></li><li><strong>内存</strong><ul><li><strong>临时</strong> 存储数据（断电之后，数据会消失）</li><li>速度快</li><li>空间小（单位价格高）</li></ul></li><li><strong>硬盘</strong> <ul><li><strong>永久</strong> 存储数据</li><li>速度慢</li><li>空间大（单位价格低）</li></ul></li></ol><table><thead><tr><th align="center">CPU</th><th align="center">内存</th><th align="center">硬盘</th></tr></thead><tbody><tr><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025841.jpg" alt="CPU-w200" loading="lazy"></td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025842.png" alt="内存条-w200" loading="lazy"></td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025843.jpg" alt="硬盘-w200" loading="lazy"></td></tr></tbody></table><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol><li>计算机中哪一个硬件设备负责执行程序？<ul><li><strong>CPU</strong></li></ul></li><li><strong>内存</strong> 的速度快还是 <strong>硬盘</strong> 的速度快？<ul><li><strong>内存</strong></li></ul></li><li>我们的程序是安装在内存中的，还是安装在硬盘中的？<ul><li>硬盘</li></ul></li><li><strong>我买了一个内存条，有 500G 的空间！！！</strong>，这句话对吗？<ul><li>不对，内存条通常只有 <code>4G</code> &#x2F; <code>8G</code> &#x2F; <code>16G</code> &#x2F; <code>32G</code></li></ul></li><li><strong>计算机关机之后，内存中的数据都会消失</strong>，这句话对吗？<ul><li>正确</li></ul></li></ol><h2 id="02-程序执行的原理"><a href="#02-程序执行的原理" class="headerlink" title="02. 程序执行的原理"></a>02. 程序执行的原理</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025844.png" alt="001_程序执行示意图-w" loading="lazy"></p><ol><li>程序 <strong>运行之前</strong>，程序是 <strong>保存在硬盘</strong> 中的</li><li>当要运行一个程序时<ul><li>操作系统会首先让 <strong>CPU</strong> 把程序复制到 <strong>内存</strong> 中</li><li><strong>CPU</strong> 执行 <strong>内存</strong> 中的 <strong>程序代码</strong></li></ul></li></ol><blockquote><p><strong>程序要执行，首先要被加载到内存</strong></p></blockquote><h3 id="2-1-Python-程序执行原理"><a href="#2-1-Python-程序执行原理" class="headerlink" title="2.1 Python 程序执行原理"></a>2.1 Python 程序执行原理</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025845.png" alt="003_Python程序执行示意图" loading="lazy"></p><ol><li>操作系统会首先让 <strong>CPU</strong> 把 <strong>Python 解释器</strong> 的程序复制到 <strong>内存</strong> 中</li><li><strong>Python 解释器</strong> 根据语法规则，<strong>从上向下</strong> 让 <strong>CPU</strong> 翻译 <strong>Python 程序中的代码</strong></li><li><strong>CPU</strong> 负责执行翻译完成的代码</li></ol><h4 id="Python-的解释器有多大？"><a href="#Python-的解释器有多大？" class="headerlink" title="Python 的解释器有多大？"></a>Python 的解释器有多大？</h4><ul><li>执行以下终端命令可以查看 Python 解释器的大小</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 确认解释器所在位置</span>$ <span class="token function">which</span> python<span class="token comment"># 2. 查看 python 文件大小(只是一个软链接)</span>$ <span class="token function">ls</span> -lh /usr/bin/python<span class="token comment"># 3. 查看具体文件大小</span>$ <span class="token function">ls</span> -lh /usr/bin/python2.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：建立 <strong>软链接</strong> 的目的，是为了方便使用者不用记住使用的解释器是 <strong>哪一个具体版本</strong></p></blockquote><h2 id="03-程序的作用"><a href="#03-程序的作用" class="headerlink" title="03. 程序的作用"></a>03. 程序的作用</h2><blockquote><p>程序就是 <strong>用来处理数据</strong> 的！</p></blockquote><ul><li><strong>新闻软件</strong> 提供的 <strong>新闻内容、评论……</strong> 是数据</li><li><strong>电商软件</strong> 提供的 <strong>商品信息、配送信息……</strong> 是数据</li><li><strong>运动类软件</strong> 提供的 <strong>运动数据……</strong> 是数据</li><li><strong>地图类软件</strong> 提供的 <strong>地图信息、定位信息、车辆信息……</strong> 是数据</li><li><strong>即时通讯软件</strong> 提供的 <strong>聊天信息、好友信息……</strong> 是数据</li><li>……</li></ul><h3 id="3-1-思考-QQ-程序的启动过程"><a href="#3-1-思考-QQ-程序的启动过程" class="headerlink" title="3.1 思考 QQ 程序的启动过程"></a>3.1 思考 QQ 程序的启动过程</h3><ol><li>QQ 在<strong>运行之前</strong>，是保存在 <strong>硬盘</strong> 中的</li><li><strong>运行之后</strong>，QQ 程序就会被加载到 <strong>内存</strong> 中了</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025846.png" alt="003_QQ登陆界面-w248" loading="lazy"></p><h3 id="3-2-思考-QQ-程序的-登录-过程"><a href="#3-2-思考-QQ-程序的-登录-过程" class="headerlink" title="3.2 思考 QQ 程序的 登录 过程"></a>3.2 思考 QQ 程序的 <strong>登录</strong> 过程</h3><ol><li>读取用户输入的 <strong>QQ 号码</strong></li><li>读取用户输入的 <strong>QQ 密码</strong></li><li>将 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 发送给腾讯的服务器，等待服务器确认用户信息</li></ol><h4 id="思考-1"><a href="#思考-1" class="headerlink" title="思考 1"></a>思考 1</h4><blockquote><p>在 QQ 这个程序将 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 发送给服务器之前，<strong>是否需要先存储一下 QQ 号码 和 密码?</strong></p></blockquote><p><strong>答案</strong></p><p>肯定需要！—— 否则 QQ 这个程序就不知道把什么内容发送给服务器了！</p><h4 id="思考-2"><a href="#思考-2" class="headerlink" title="思考 2"></a>思考 2</h4><blockquote><p>QQ 这个程序把 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 保存在哪里？</p></blockquote><p><strong>答案</strong></p><p>保存在 <strong>内存</strong> 中，因为 QQ 程序自己就在内存中</p><h4 id="思考-3"><a href="#思考-3" class="headerlink" title="思考 3"></a>思考 3</h4><blockquote><p>QQ 这个程序是怎么保存用户的 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 的？</p></blockquote><p><strong>答案</strong></p><ol><li>在内存中为 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 各自分配一块空间<ul><li>在 QQ 程序结束之前，这两块空间是由 QQ 程序负责管理的，其他任何程序都不允许使用</li><li>在 QQ 自己使用完成之前，这两块空间始终都只负责保存 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong></li></ul></li><li>使用一个 <strong>别名</strong> 标记 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 在内存中的位置</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127025847.png" alt="004_QQ号码和密码内存示意图" loading="lazy"></p><blockquote><ul><li>在程序内部，为 <strong>QQ 号码</strong> 和 <strong>QQ 密码</strong> 在内存中分配的空间就叫做 <strong>变量</strong></li><li><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></li></ul></blockquote><h1 id="变量的基本使用"><a href="#变量的基本使用" class="headerlink" title="变量的基本使用"></a>变量的基本使用</h1><blockquote><p><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></p></blockquote><h2 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h2><ul><li>变量定义</li><li>变量的类型</li><li>变量的命名</li></ul><h2 id="01-变量定义"><a href="#01-变量定义" class="headerlink" title="01. 变量定义"></a>01. 变量定义</h2><ul><li>在 Python 中，每个变量 <strong>在使用前都必须赋值</strong>，变量 <strong>赋值以后</strong> 该变量 <strong>才会被创建</strong></li><li>等号（&#x3D;）用来给变量赋值<ul><li><code>=</code> 左边是一个变量名</li><li><code>=</code> 右边是存储在变量中的值</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">变量名 <span class="token operator">=</span> 值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>变量定义之后，后续就可以直接使用了</p></blockquote><h3 id="1-变量演练1-——-iPython"><a href="#1-变量演练1-——-iPython" class="headerlink" title="1) 变量演练1 —— iPython"></a>1) 变量演练1 —— iPython</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义 qq_number 的变量用来保存 qq 号码</span>In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_number <span class="token operator">=</span> <span class="token string">"1234567"</span><span class="token comment"># 输出 qq_number 中保存的内容</span>In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_numberOut<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'1234567'</span><span class="token comment"># 定义 qq_password 的变量用来保存 qq 密码</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_password <span class="token operator">=</span> <span class="token string">"123"</span><span class="token comment"># 输出 qq_password 中保存的内容</span>In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> qq_passwordOut<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'123'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 <code>print</code> 函数</p></blockquote><h3 id="2-变量演练-2-——-PyCharm"><a href="#2-变量演练-2-——-PyCharm" class="headerlink" title="2) 变量演练 2 —— PyCharm"></a>2) 变量演练 2 —— PyCharm</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义 qq 号码变量</span>qq_number <span class="token operator">=</span> <span class="token string">"1234567"</span><span class="token comment"># 定义 qq 密码变量</span>qq_password <span class="token operator">=</span> <span class="token string">"123"</span><span class="token comment"># 在程序中，如果要输出变量的内容，需要使用 print 函数</span><span class="token keyword">print</span><span class="token punctuation">(</span>qq_number<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>qq_password<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用解释器执行，如果要输出变量的内容，必须要要使用 <code>print</code> 函数</p></blockquote><h3 id="3-变量演练-3-——-超市买苹果"><a href="#3-变量演练-3-——-超市买苹果" class="headerlink" title="3) 变量演练 3 —— 超市买苹果"></a>3) 变量演练 3 —— 超市买苹果</h3><blockquote><ul><li>可以用 <strong>其他变量的计算结果</strong> 来定义变量</li><li>变量定义之后，后续就可以直接使用了</li></ul></blockquote><p><strong>需求</strong></p><ul><li>苹果的价格是 <strong>8.5 元&#x2F;斤</strong></li><li>买了 <strong>7.5 斤</strong> 苹果</li><li>计算付款金额</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义苹果价格变量</span>price <span class="token operator">=</span> <span class="token number">8.5</span><span class="token comment"># 定义购买重量</span>weight <span class="token operator">=</span> <span class="token number">7.5</span><span class="token comment"># 计算金额</span>money <span class="token operator">=</span> price <span class="token operator">*</span> weight<span class="token keyword">print</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h4><ul><li>如果 <strong>只要买苹果，就返 5 块钱</strong></li><li>请重新计算购买金额</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义苹果价格变量</span>price <span class="token operator">=</span> <span class="token number">8.5</span><span class="token comment"># 定义购买重量</span>weight <span class="token operator">=</span> <span class="token number">7.5</span><span class="token comment"># 计算金额</span>money <span class="token operator">=</span> price <span class="token operator">*</span> weight<span class="token comment"># 只要买苹果就返 5 元</span>money <span class="token operator">=</span> money <span class="token operator">-</span> <span class="token number">5</span><span class="token keyword">print</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提问</strong></p><ul><li>上述代码中，一共定义有几个变量？<ul><li>三个：<code>price</code>／<code>weight</code>／<code>money</code></li></ul></li><li><code>money = money - 5</code> 是在定义新的变量还是在使用变量？<ul><li>直接使用之前已经定义的变量</li><li>变量名 只有在 <strong>第一次出现</strong> 才是 <strong>定义变量</strong></li><li>变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量</li></ul></li><li>在程序开发中，可以修改之前定义变量中保存的值吗？<ul><li>可以</li><li>变量中存储的值，就是可以 <strong>变</strong> 的</li></ul></li></ul><h2 id="02-变量的类型"><a href="#02-变量的类型" class="headerlink" title="02. 变量的类型"></a>02. 变量的类型</h2><ul><li>在内存中创建一个变量，会包括：<ol><li>变量的名称</li><li>变量保存的数据</li><li>变量存储数据的类型</li><li>变量的地址（标示）</li></ol></li></ul><h3 id="2-1-变量类型的演练-——-个人信息"><a href="#2-1-变量类型的演练-——-个人信息" class="headerlink" title="2.1 变量类型的演练 —— 个人信息"></a>2.1 变量类型的演练 —— 个人信息</h3><p><strong>需求</strong></p><ul><li>定义变量保存小明的个人信息</li><li>姓名：<strong>小明</strong></li><li>年龄：<strong>18</strong> 岁</li><li>性别：<strong>是</strong>男生</li><li>身高：<strong>1.75</strong> 米</li><li>体重：<strong>75.0</strong> 公斤</li></ul><blockquote><p>利用 <strong>单步调试</strong> 确认变量中保存数据的类型</p></blockquote><p><strong>提问</strong></p><ol><li>在演练中，一共有几种数据类型？<ul><li>4 种</li><li><code>str</code> —— 字符串</li><li><code>bool</code> —— 布尔（真假）</li><li><code>int</code> —— 整数</li><li><code>float</code> —— 浮点数（小数）</li></ul></li><li>在 <code>Python</code> 中定义变量时需要指定类型吗？<ul><li>不需要</li><li><code>Python</code> 可以根据 <code>=</code> 等号右侧的值，自动推导出变量中存储数据的类型</li></ul></li></ol><h3 id="2-2-变量的类型"><a href="#2-2-变量的类型" class="headerlink" title="2.2 变量的类型"></a>2.2 变量的类型</h3><ul><li>在 <code>Python</code> 中定义变量是 <strong>不需要指定类型</strong>（在其他很多高级语言中都需要）</li><li>数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></li><li>数字型<ul><li>整型 (<code>int</code>)</li><li>浮点型（<code>float</code>）</li><li>布尔型（<code>bool</code>） <ul><li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 (<code>complex</code>)<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li>非数字型<ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li></ul><blockquote><p>提示：在 Python 2.x 中，<strong>整数</strong> 根据保存数值的长度还分为：</p><ul><li><code>int</code>（整数）</li><li><code>long</code>（长整数）</li></ul></blockquote><ul><li>使用 <code>type</code> 函数可以查看一个变量的类型</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token builtin">type</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-不同类型变量之间的计算"><a href="#2-3-不同类型变量之间的计算" class="headerlink" title="2.3 不同类型变量之间的计算"></a>2.3 不同类型变量之间的计算</h3><h4 id="1-数字型变量-之间可以直接计算"><a href="#1-数字型变量-之间可以直接计算" class="headerlink" title="1) 数字型变量 之间可以直接计算"></a>1) <strong>数字型变量</strong> 之间可以直接计算</h4><ul><li>在 Python 中，两个数字型变量是可以直接进行 算数运算的</li><li>如果变量是 <code>bool</code> 型，在计算时<ul><li><code>True</code> 对应的数字是 <code>1</code></li><li><code>False</code> 对应的数字是 <code>0</code></li></ul></li></ul><p><strong>演练步骤</strong></p><ol><li>定义整数 <code>i = 10</code></li><li>定义浮点数 <code>f = 10.5</code></li><li>定义布尔型 <code>b = True</code></li></ol><ul><li>在 iPython 中，使用上述三个变量相互进行算术运算</li></ul><h4 id="2-字符串变量-之间使用-拼接字符串"><a href="#2-字符串变量-之间使用-拼接字符串" class="headerlink" title="2) 字符串变量 之间使用 + 拼接字符串"></a>2) <strong>字符串变量</strong> 之间使用 <code>+</code> 拼接字符串</h4><ul><li>在 Python 中，字符串之间可以使用 <code>+</code> 拼接生成新的字符串</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> first_name <span class="token operator">=</span> <span class="token string">"三"</span>In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> last_name <span class="token operator">=</span> <span class="token string">"张"</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> first_name <span class="token operator">+</span> last_nameOut<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'三张'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-字符串变量-可以和-整数-使用-重复拼接相同的字符串"><a href="#3-字符串变量-可以和-整数-使用-重复拼接相同的字符串" class="headerlink" title="3) 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串"></a>3) <strong>字符串变量</strong> 可以和 <strong>整数</strong> 使用 <code>*</code> 重复拼接相同的字符串</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'--------------------------------------------------'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-数字型变量-和-字符串-之间-不能进行其他计算"><a href="#4-数字型变量-和-字符串-之间-不能进行其他计算" class="headerlink" title="4) 数字型变量 和 字符串 之间 不能进行其他计算"></a>4) <strong>数字型变量</strong> 和 <strong>字符串</strong> 之间 <strong>不能进行其他计算</strong></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> first_name <span class="token operator">=</span> <span class="token string">"zhang"</span>In <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">=</span> <span class="token number">10</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> x <span class="token operator">+</span> first_name<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>TypeError<span class="token punctuation">:</span> unsupported operand <span class="token builtin">type</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token operator">+</span><span class="token punctuation">:</span> <span class="token string">'int'</span> <span class="token keyword">and</span> <span class="token string">'str'</span>类型错误：`<span class="token operator">+</span>` 不支持的操作类型：`<span class="token builtin">int</span>` 和 `<span class="token builtin">str</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-变量的输入"><a href="#2-4-变量的输入" class="headerlink" title="2.4 变量的输入"></a>2.4 变量的输入</h3><ul><li>所谓 <strong>输入</strong>，就是 <strong>用代码</strong> <strong>获取</strong> 用户通过 <strong>键盘</strong> 输入的信息</li><li>例如：去银行取钱，在 ATM 上输入密码</li><li>在 Python 中，如果要获取用户在 <strong>键盘</strong> 上的输入信息，需要使用到 <code>input</code> 函数</li></ul><h4 id="1-关于函数"><a href="#1-关于函数" class="headerlink" title="1) 关于函数"></a>1) 关于函数</h4><ul><li>一个 <strong>提前准备好的功能</strong>(别人或者自己写的代码)，<strong>可以直接使用</strong>，而 <strong>不用关心内部的细节</strong></li><li>目前已经学习过的函数</li></ul><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>print(x)</td><td>将 x 输出到控制台</td></tr><tr><td>type(x)</td><td>查看 x 的变量类型</td></tr></tbody></table><h4 id="2-input-函数实现键盘输入"><a href="#2-input-函数实现键盘输入" class="headerlink" title="2) input 函数实现键盘输入"></a>2) input 函数实现键盘输入</h4><ul><li>在 Python 中可以使用 <code>input</code> 函数从键盘等待用户的输入</li><li>用户输入的 <strong>任何内容</strong> Python 都认为是一个 <strong>字符串</strong></li><li>语法如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">字符串变量 <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"提示信息："</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-类型转换函数"><a href="#3-类型转换函数" class="headerlink" title="3) 类型转换函数"></a>3) 类型转换函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>int(x)</td><td>将 x 转换为一个整数</td></tr><tr><td>float(x)</td><td>将 x 转换到一个浮点数</td></tr></tbody></table><h4 id="4-变量输入演练-——-超市买苹果增强版"><a href="#4-变量输入演练-——-超市买苹果增强版" class="headerlink" title="4) 变量输入演练 —— 超市买苹果增强版"></a>4) 变量输入演练 —— 超市买苹果增强版</h4><p><strong>需求</strong></p><ul><li><strong>收银员输入</strong> 苹果的价格，单位：<strong>元／斤</strong></li><li><strong>收银员输入</strong> 用户购买苹果的重量，单位：<strong>斤</strong></li><li>计算并且 <strong>输出</strong> 付款金额</li></ul><h5 id="演练方式-1"><a href="#演练方式-1" class="headerlink" title="演练方式 1"></a>演练方式 1</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 输入苹果单价</span>price_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入苹果价格："</span><span class="token punctuation">)</span><span class="token comment"># 2. 要求苹果重量</span>weight_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入苹果重量："</span><span class="token punctuation">)</span><span class="token comment"># 3. 计算金额</span><span class="token comment"># 1> 将苹果单价转换成小数</span>price <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>price_str<span class="token punctuation">)</span><span class="token comment"># 2> 将苹果重量转换成小数</span>weight <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>weight_str<span class="token punctuation">)</span><span class="token comment"># 3> 计算付款金额</span>money <span class="token operator">=</span> price <span class="token operator">*</span> weight<span class="token keyword">print</span><span class="token punctuation">(</span>money<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提问</strong></p><ol><li>演练中，针对 <strong>价格</strong> 定义了几个变量？<ul><li><strong>两个</strong></li><li><code>price_str</code> 记录用户输入的价格字符串</li><li><code>price</code> 记录转换后的价格数值</li></ul></li><li><strong>思考</strong> —— 如果开发中，需要用户通过控制台 输入 <strong>很多个 数字</strong>，针对每一个数字都要定义两个变量，<strong>方便吗</strong>？</li></ol><h5 id="演练方式-2-——-买苹果改进版"><a href="#演练方式-2-——-买苹果改进版" class="headerlink" title="演练方式 2 —— 买苹果改进版"></a>演练方式 2 —— 买苹果改进版</h5><ol><li><strong>定义</strong> 一个 <strong>浮点变量</strong> 接收用户输入的同时，就使用 <code>float</code> 函数进行转换</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">price <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入价格:"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>改进后的好处：</li></ul><ol><li>节约空间，只需要为一个变量分配空间</li><li>起名字方便，不需要为中间变量起名字</li></ol><ul><li>改进后的“缺点”：</li></ul><ol><li>初学者需要知道，两个函数能够嵌套使用，稍微有一些难度</li></ol><p><strong>提示</strong></p><ul><li>如果输入的不是一个数字，程序执行时会出错，有关数据转换的高级话题，后续会讲！</li></ul><h3 id="2-5-变量的格式化输出"><a href="#2-5-变量的格式化输出" class="headerlink" title="2.5 变量的格式化输出"></a>2.5 变量的格式化输出</h3><blockquote><p>苹果单价 <code>9.00</code> 元／斤，购买了 <code>5.00</code> 斤，需要支付 <code>45.00</code> 元</p></blockquote><ul><li>在 Python 中可以使用 <code>print</code> 函数将信息输出到控制台</li><li>如果希望输出文字信息的同时，<strong>一起输出</strong> <strong>数据</strong>，就需要使用到 <strong>格式化操作符</strong></li><li><code>%</code> 被称为 <strong>格式化操作符</strong>，专门用于处理字符串中的格式<ul><li>包含 <code>%</code> 的字符串，被称为 <strong>格式化字符串</strong></li><li><code>%</code> 和不同的 <strong>字符</strong> 连用，<strong>不同类型的数据</strong> 需要使用 <strong>不同的格式化字符</strong></li></ul></li></ul><table><thead><tr><th>格式化字符</th><th>含义</th></tr></thead><tbody><tr><td>%s</td><td>字符串</td></tr><tr><td>%d</td><td>有符号十进制整数，<code>%06d</code> 表示输出的整数显示位数，不足的地方使用 <code>0</code> 补全</td></tr><tr><td>%f</td><td>浮点数，<code>%.2f</code> 表示小数点后只显示两位</td></tr><tr><td>%%</td><td>输出 <code>%</code></td></tr></tbody></table><ul><li>语法格式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span> <span class="token operator">%</span> 变量<span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"格式化字符串"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>变量<span class="token number">1</span><span class="token punctuation">,</span> 变量<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="格式化输出演练-——-基本练习"><a href="#格式化输出演练-——-基本练习" class="headerlink" title="格式化输出演练 —— 基本练习"></a>格式化输出演练 —— 基本练习</h4><p><strong>需求</strong></p><ol><li>定义字符串变量 <code>name</code>，输出 <strong>我的名字叫 小明，请多多关照！</strong></li><li>定义整数变量 <code>student_no</code>，输出 <strong>我的学号是 000001</strong></li><li>定义小数 <code>price</code>、<code>weight</code>、<code>money</code>，输出 <strong>苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元</strong></li><li>定义一个小数 <code>scale</code>，输出 <strong>数据比例是 10.00%</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我的名字叫 %s，请多多关照！"</span> <span class="token operator">%</span> name<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我的学号是 %06d"</span> <span class="token operator">%</span> student_no<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>price<span class="token punctuation">,</span> weight<span class="token punctuation">,</span> money<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据比例是 %.02f%%"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>scale <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="课后练习-——-个人名片"><a href="#课后练习-——-个人名片" class="headerlink" title="课后练习 —— 个人名片"></a>课后练习 —— 个人名片</h4><p><strong>需求</strong></p><ul><li>在控制台依次提示用户输入：<strong>姓名</strong>、<strong>公司</strong>、<strong>职位</strong>、<strong>电话</strong>、<strong>邮箱</strong></li><li>按照以下格式输出：</li></ul><pre class="line-numbers language-none"><code class="language-none">**************************************************公司名称姓名 (职位)电话：电话邮箱：邮箱**************************************************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""在控制台依次提示用户输入：姓名、公司、职位、电话、电子邮箱"""</span>name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入姓名："</span><span class="token punctuation">)</span>company <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入公司："</span><span class="token punctuation">)</span>title <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入职位："</span><span class="token punctuation">)</span>phone <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入电话："</span><span class="token punctuation">)</span>email <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入邮箱："</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>company<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s (%s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"电话：%s"</span> <span class="token operator">%</span> phone<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"邮箱：%s"</span> <span class="token operator">%</span> email<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h1><h2 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h2><ul><li>标识符和关键字</li><li>变量的命名规则</li></ul><h2 id="0-1-标识符和关键字"><a href="#0-1-标识符和关键字" class="headerlink" title="0.1 标识符和关键字"></a>0.1 标识符和关键字</h2><h3 id="1-1-标识符"><a href="#1-1-标识符" class="headerlink" title="1.1 标识符"></a>1.1 标识符</h3><blockquote><p>标示符就是程序员定义的 <strong>变量名</strong>、<strong>函数名</strong></p><p><strong>名字</strong> 需要有 <strong>见名知义</strong> 的效果，见下图：</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030129.jpg" alt="001_中国山东找蓝翔" loading="lazy"></p><ul><li>标示符可以由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li></ul><p>思考：下面的标示符哪些是正确的，哪些不正确为什么？</p><pre class="line-numbers language-none"><code class="language-none">fromNo12from#12my_Booleanmy-BooleanObj22ndObjmyIntMy_tExt_testtest!32haha(da)ttjack_rosejack&amp;roseGUIG.U.I<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h3><ul><li><strong>关键字</strong> 就是在 <code>Python</code> 内部已经使用的标识符</li><li><strong>关键字</strong> 具有特殊的功能和含义</li><li>开发者 <strong>不允许定义和关键字相同的名字的标示符</strong></li></ul><p>通过以下命令可以查看 <code>Python</code> 中的关键字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">import</span> keywordIn <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>提示：<strong>关键字的学习及使用</strong>，会在后面的课程中不断介绍</p><ul><li><p><code>import</code> <strong>关键字</strong> 可以导入一个 <strong>“工具包”</strong></p></li><li><p>在 <code>Python</code> 中不同的工具包，提供有不同的工具</p></li></ul></blockquote><h2 id="02-变量的命名规则"><a href="#02-变量的命名规则" class="headerlink" title="02. 变量的命名规则"></a>02. 变量的命名规则</h2><blockquote><p><strong>命名规则</strong> 可以被视为一种 <strong>惯例</strong>，并无绝对与强制<br>目的是为了 <strong>增加代码的识别和可读性</strong></p></blockquote><p><strong>注意</strong> <code>Python</code> 中的 <strong>标识符</strong> 是 <strong>区分大小写的</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030130.jpg" alt="002_标识符区分大小写" loading="lazy"></p><ol><li><p>在定义变量时，为了保证代码格式，<code>=</code> 的左右应该各保留一个空格</p></li><li><p>在 <code>Python</code> 中，如果 <strong>变量名</strong> 需要由 <strong>二个</strong> 或 <strong>多个单词</strong> 组成时，可以按照以下方式命名</p><ol><li>每个单词都使用小写字母</li><li>单词与单词之间使用 <strong><code>_</code>下划线</strong> 连接</li></ol><ul><li>例如：<code>first_name</code>、<code>last_name</code>、<code>qq_number</code>、<code>qq_password</code></li></ul></li></ol><h3 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h3><ul><li>当 <strong>变量名</strong> 是由二个或多个单词组成时，还可以利用驼峰命名法来命名</li><li><strong>小驼峰式命名法</strong><ul><li>第一个单词以小写字母开始，后续单词的首字母大写</li><li>例如：<code>firstName</code>、<code>lastName</code></li></ul></li><li><strong>大驼峰式命名法</strong><ul><li>每一个单词的首字母都采用大写字母</li><li>例如：<code>FirstName</code>、<code>LastName</code>、<code>CamelCase</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030131.jpg" alt="003_驼峰命名法" loading="lazy"></p><h1 id="判断（if）语句"><a href="#判断（if）语句" class="headerlink" title="判断（if）语句"></a>判断（if）语句</h1><h2 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h2><ul><li>开发中的应用场景</li><li>if 语句体验</li><li>if 语句进阶</li><li>综合应用</li></ul><h2 id="01-开发中的应用场景"><a href="#01-开发中的应用场景" class="headerlink" title="01. 开发中的应用场景"></a>01. 开发中的应用场景</h2><p>生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？……</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030138.jpg" alt="001_未成年人禁止入内-w400" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030139.png" alt="002_火车站安检-w400" loading="lazy"></p><h3 id="程序中的判断"><a href="#程序中的判断" class="headerlink" title="程序中的判断"></a>程序中的判断</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030140.png" alt="003_判断示意图-w600" loading="lazy"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 今天发工资<span class="token punctuation">:</span>    先还信用卡的钱    <span class="token keyword">if</span> 有剩余<span class="token punctuation">:</span>        又可以happy了，O<span class="token punctuation">(</span>∩_∩<span class="token punctuation">)</span>O哈哈<span class="token operator">~</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        噢，no。。。还的等<span class="token number">30</span>天<span class="token keyword">else</span><span class="token punctuation">:</span>    盼着发工资<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断的定义"><a href="#判断的定义" class="headerlink" title="判断的定义"></a>判断的定义</h3><ul><li>如果 <strong>条件满足</strong>，才能做某件事情，</li><li>如果 <strong>条件不满足</strong>，就做另外一件事情，或者什么也不做</li></ul><blockquote><p>正是因为有了判断，才使得程序世界丰富多彩，充满变化！</p><p><strong>判断语句</strong> 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支</p></blockquote><h2 id="02-if-语句体验"><a href="#02-if-语句体验" class="headerlink" title="02. if 语句体验"></a>02. if 语句体验</h2><h3 id="2-1-if-判断语句基本语法"><a href="#2-1-if-判断语句基本语法" class="headerlink" title="2.1 if 判断语句基本语法"></a>2.1 if 判断语句基本语法</h3><p>在 <code>Python</code> 中，<strong>if 语句</strong> 就是用来进行判断的，格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 要判断的条件<span class="token punctuation">:</span>    条件成立时，要做的事情    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：代码的缩进为一个 <code>tab</code> 键，或者 <strong>4</strong> 个空格 —— <strong>建议使用空格</strong></p><ul><li>在 Python 开发中，Tab 和空格不要混用！</li></ul></blockquote><p><strong>我们可以把整个 if 语句看成一个完整的代码块</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030141.png" alt="004_if语句是一个完整的代码块1-w400" loading="lazy"></p><h3 id="2-2-判断语句演练-——-判断年龄"><a href="#2-2-判断语句演练-——-判断年龄" class="headerlink" title="2.2 判断语句演练 —— 判断年龄"></a>2.2 判断语句演练 —— 判断年龄</h3><p><strong>需求</strong></p><ol><li>定义一个整数变量记录年龄</li><li>判断是否满 18 岁 （**&gt;&#x3D;**）</li><li>如果满 18 岁，允许进网吧嗨皮</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 定义年龄变量</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token comment"># 2. 判断是否满 18 岁</span><span class="token comment"># if 语句以及缩进部分的代码是一个完整的代码块</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">18</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"可以进网吧嗨皮……"</span><span class="token punctuation">)</span><span class="token comment"># 3. 思考！- 无论条件是否满足都会执行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这句代码什么时候执行?"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li><code>if</code> 语句以及缩进部分是一个 <strong>完整的代码块</strong></li></ul><h3 id="2-3-else-处理条件不满足的情况"><a href="#2-3-else-处理条件不满足的情况" class="headerlink" title="2.3 else 处理条件不满足的情况"></a>2.3 else 处理条件不满足的情况</h3><p><strong>思考</strong></p><p>在使用 <code>if</code> 判断时，只能做到满足条件时要做的事情。那如果需要在 <strong>不满足条件的时候</strong>，做某些事情，该如何做呢？</p><p><strong>答案</strong></p><p><code>else</code>，格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 要判断的条件<span class="token punctuation">:</span>    条件成立时，要做的事情    ……<span class="token keyword">else</span><span class="token punctuation">:</span>    条件不成立时，要做的事情    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li><code>if</code> 和 <code>else</code> 语句以及各自的缩进部分共同是一个 <strong>完整的代码块</strong></li></ul><h3 id="2-4-判断语句演练-——-判断年龄改进"><a href="#2-4-判断语句演练-——-判断年龄改进" class="headerlink" title="2.4 判断语句演练 —— 判断年龄改进"></a>2.4 判断语句演练 —— 判断年龄改进</h3><p><strong>需求</strong></p><ol><li>输入用户年龄</li><li>判断是否满 18 岁 （**&gt;&#x3D;**）</li><li>如果满 18 岁，允许进网吧嗨皮</li><li>如果未满 18 岁，提示回家写作业</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 输入用户年龄</span>age <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"今年多大了？"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 2. 判断是否满 18 岁</span><span class="token comment"># if 语句以及缩进部分的代码是一个完整的语法块</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">18</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"可以进网吧嗨皮……"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"你还没长大，应该回家写作业！"</span><span class="token punctuation">)</span><span class="token comment"># 3. 思考！- 无论条件是否满足都会执行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这句代码什么时候执行?"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030142.png" alt="005_ifelse语句是一个完整的代码块1-w400" loading="lazy"></p><h2 id="03-逻辑运算"><a href="#03-逻辑运算" class="headerlink" title="03. 逻辑运算"></a>03. 逻辑运算</h2><ul><li>在程序开发中，通常 <strong>在判断条件时</strong>，会需要同时判断多个条件</li><li>只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 <strong>逻辑运算符</strong></li><li><strong>逻辑运算符</strong> 可以把 <strong>多个条件</strong> 按照 <strong>逻辑</strong> 进行 <strong>连接</strong>，变成 <strong>更复杂的条件</strong></li><li>Python 中的 <strong>逻辑运算符</strong> 包括：<strong>与 and</strong>／<strong>或 or</strong>／<strong>非 not</strong> 三种</li></ul><h3 id="3-1-and"><a href="#3-1-and" class="headerlink" title="3.1 and"></a>3.1 <code>and</code></h3><pre class="line-numbers language-none"><code class="language-none">条件1 and 条件2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>与</strong>／<strong>并且</strong></li><li>两个条件同时满足，返回 <code>True</code></li><li>只要有一个不满足，就返回 <code>False</code></li></ul><table><thead><tr><th align="center">条件 1</th><th align="center">条件 2</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">成立</td><td align="center">成立</td><td align="center">成立</td></tr><tr><td align="center">成立</td><td align="center">不成立</td><td align="center">不成立</td></tr><tr><td align="center">不成立</td><td align="center">成立</td><td align="center">不成立</td></tr><tr><td align="center">不成立</td><td align="center">不成立</td><td align="center">不成立</td></tr></tbody></table><h3 id="3-2-or"><a href="#3-2-or" class="headerlink" title="3.2 or"></a>3.2 <code>or</code></h3><pre class="line-numbers language-none"><code class="language-none">条件1 or 条件2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>或</strong>／<strong>或者</strong></li><li>两个条件只要有一个满足，返回 <code>True</code></li><li>两个条件都不满足，返回 <code>False</code></li></ul><table><thead><tr><th align="center">条件 1</th><th align="center">条件 2</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">成立</td><td align="center">成立</td><td align="center">成立</td></tr><tr><td align="center">成立</td><td align="center">不成立</td><td align="center">成立</td></tr><tr><td align="center">不成立</td><td align="center">成立</td><td align="center">成立</td></tr><tr><td align="center">不成立</td><td align="center">不成立</td><td align="center">不成立</td></tr></tbody></table><h3 id="3-3-not"><a href="#3-3-not" class="headerlink" title="3.3 not"></a>3.3 <code>not</code></h3><pre class="line-numbers language-none"><code class="language-none">not 条件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>非</strong>／<strong>不是</strong></li></ul><table><thead><tr><th align="center">条件</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">成立</td><td align="center">不成立</td></tr><tr><td align="center">不成立</td><td align="center">成立</td></tr></tbody></table><h4 id="逻辑运算演练"><a href="#逻辑运算演练" class="headerlink" title="逻辑运算演练"></a>逻辑运算演练</h4><ol><li>练习1: 定义一个整数变量 <code>age</code>，编写代码判断年龄是否正确<ul><li>要求人的年龄在 0-120 之间</li></ul></li><li>练习2: 定义两个整数变量 <code>python_score</code>、<code>c_score</code>，编写代码判断成绩<ul><li>要求只要有一门成绩 &gt; 60 分就算合格</li></ul></li><li>练习3: 定义一个布尔型变量 <code>is_employee</code>，编写代码判断是否是本公司员工<ul><li>如果不是提示不允许入内</li></ul></li></ol><p>答案 1：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确</span>age <span class="token operator">=</span> <span class="token number">100</span><span class="token comment"># 要求人的年龄在 0-120 之间</span><span class="token keyword">if</span> age <span class="token operator">>=</span> <span class="token number">0</span> <span class="token keyword">and</span> age <span class="token operator">&lt;=</span> <span class="token number">120</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"年龄正确"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"年龄不正确"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案 2：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩</span>python_score <span class="token operator">=</span> <span class="token number">50</span>c_score <span class="token operator">=</span> <span class="token number">50</span><span class="token comment"># 要求只要有一门成绩 > 60 分就算合格</span><span class="token keyword">if</span> python_score <span class="token operator">></span> <span class="token number">60</span> <span class="token keyword">or</span> c_score <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"考试通过"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"再接再厉！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案 3：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工</span>is_employee <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment"># 如果不是提示不允许入内</span><span class="token keyword">if</span> <span class="token keyword">not</span> is_employee<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"非公勿内"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="04-if-语句进阶"><a href="#04-if-语句进阶" class="headerlink" title="04. if 语句进阶"></a>04. if 语句进阶</h2><h3 id="4-1-elif"><a href="#4-1-elif" class="headerlink" title="4.1 elif"></a>4.1 <code>elif</code></h3><ul><li>在开发中，使用 <code>if</code> 可以 <strong>判断条件</strong></li><li>使用 <code>else</code> 可以处理 <strong>条件不成立</strong> 的情况</li><li>但是，如果希望 <strong>再增加一些条件</strong>，<strong>条件不同，需要执行的代码也不同</strong> 时，就可以使用 <code>elif</code> </li><li>语法格式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 条件<span class="token number">1</span><span class="token punctuation">:</span>    条件<span class="token number">1</span>满足执行的代码    ……<span class="token keyword">elif</span> 条件<span class="token number">2</span><span class="token punctuation">:</span>    条件<span class="token number">2</span>满足时，执行的代码    ……<span class="token keyword">elif</span> 条件<span class="token number">3</span><span class="token punctuation">:</span>    条件<span class="token number">3</span>满足时，执行的代码    ……<span class="token keyword">else</span><span class="token punctuation">:</span>    以上条件都不满足时，执行的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对比逻辑运算符的代码</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 条件<span class="token number">1</span> <span class="token keyword">and</span> 条件<span class="token number">2</span><span class="token punctuation">:</span>    条件<span class="token number">1</span>满足 并且 条件<span class="token number">2</span>满足 执行的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li><code>elif</code> 和 <code>else</code> 都必须和 <code>if</code> 联合使用，而不能单独使用</li><li>可以将 <code>if</code>、<code>elif</code> 和 <code>else</code> 以及各自缩进的代码，看成一个 <strong>完整的代码块</strong></li></ol><h4 id="elif-演练-——-女友的节日"><a href="#elif-演练-——-女友的节日" class="headerlink" title="elif 演练 —— 女友的节日"></a>elif 演练 —— 女友的节日</h4><p><strong>需求</strong></p><ol><li>定义 <code>holiday_name</code> 字符串变量记录节日名称</li><li>如果是 <strong>情人节</strong> 应该 <strong>买玫瑰</strong>／<strong>看电影</strong></li><li>如果是 <strong>平安夜</strong> 应该 <strong>买苹果</strong>／<strong>吃大餐</strong></li><li>如果是 <strong>生日</strong> 应该 <strong>买蛋糕</strong></li><li>其他的日子每天都是节日啊……</li></ol><pre class="line-numbers language-none"><code class="language-none">holiday_name &#x3D; &quot;平安夜&quot;if holiday_name &#x3D;&#x3D; &quot;情人节&quot;:    print(&quot;买玫瑰&quot;)    print(&quot;看电影&quot;)elif holiday_name &#x3D;&#x3D; &quot;平安夜&quot;:    print(&quot;买苹果&quot;)    print(&quot;吃大餐&quot;)elif holiday_name &#x3D;&#x3D; &quot;生日&quot;:    print(&quot;买蛋糕&quot;)else:    print(&quot;每天都是节日啊……&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-if-的嵌套"><a href="#4-2-if-的嵌套" class="headerlink" title="4.2 if 的嵌套"></a>4.2 <code>if</code> 的嵌套</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030139.png" alt="002_火车站安检-w400" loading="lazy"></p><blockquote><p><strong>elif</strong> 的应用场景是：<strong>同时</strong> 判断 <strong>多个条件</strong>，所有的条件是 <strong>平级</strong> 的</p></blockquote><ul><li>在开发中，使用 <code>if</code> 进行条件判断，如果希望 <strong>在条件成立的执行语句中</strong> 再 <strong>增加条件判断</strong>，就可以使用 <strong>if 的嵌套</strong></li><li><strong>if 的嵌套</strong> 的应用场景就是：<strong>在之前条件满足的前提下，再增加额外的判断</strong></li><li><strong>if 的嵌套</strong> 的语法格式，<strong>除了缩进之外</strong> 和之前的没有区别</li><li>语法格式如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> 条件 <span class="token number">1</span><span class="token punctuation">:</span>    条件 <span class="token number">1</span> 满足执行的代码    ……        <span class="token keyword">if</span> 条件 <span class="token number">1</span> 基础上的条件 <span class="token number">2</span><span class="token punctuation">:</span>        条件 <span class="token number">2</span> 满足时，执行的代码        ……                <span class="token comment"># 条件 2 不满足的处理</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        条件 <span class="token number">2</span> 不满足时，执行的代码        <span class="token comment"># 条件 1 不满足的处理</span><span class="token keyword">else</span><span class="token punctuation">:</span>    条件<span class="token number">1</span> 不满足时，执行的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="if-的嵌套-演练-——-火车站安检"><a href="#if-的嵌套-演练-——-火车站安检" class="headerlink" title="if 的嵌套 演练 —— 火车站安检"></a>if 的嵌套 演练 —— 火车站安检</h4><p><strong>需求</strong></p><ol><li>定义布尔型变量 <code>has_ticket</code> 表示是否有车票</li><li>定义整型变量 <code>knife_length</code> 表示刀的长度，单位：厘米</li><li>首先检查是否有车票，如果有，才允许进行 <strong>安检</strong></li><li>安检时，需要检查刀的长度，判断是否超过 20 厘米<ul><li>如果超过 20 厘米，提示刀的长度，不允许上车</li><li>如果不超过 20 厘米，安检通过</li></ul></li><li>如果没有车票，不允许进门</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义布尔型变量 has_ticket 表示是否有车票</span>has_ticket <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment"># 定义整数型变量 knife_length 表示刀的长度，单位：厘米</span>knife_length <span class="token operator">=</span> <span class="token number">20</span><span class="token comment"># 首先检查是否有车票，如果有，才允许进行 安检</span><span class="token keyword">if</span> has_ticket<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"有车票，可以开始安检..."</span><span class="token punctuation">)</span>    <span class="token comment"># 安检时，需要检查刀的长度，判断是否超过 20 厘米</span>    <span class="token comment"># 如果超过 20 厘米，提示刀的长度，不允许上车</span>    <span class="token keyword">if</span> knife_length <span class="token operator">>=</span> <span class="token number">20</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不允许携带 %d 厘米长的刀上车"</span> <span class="token operator">%</span> knife_length<span class="token punctuation">)</span>    <span class="token comment"># 如果不超过 20 厘米，安检通过</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"安检通过，祝您旅途愉快……"</span><span class="token punctuation">)</span><span class="token comment"># 如果没有车票，不允许进门</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"大哥，您要先买票啊"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="05-综合应用-——-石头剪刀布"><a href="#05-综合应用-——-石头剪刀布" class="headerlink" title="05. 综合应用 —— 石头剪刀布"></a>05. 综合应用 —— 石头剪刀布</h2><p><strong>目标</strong></p><ol><li>强化 <strong>多个条件</strong> 的 <strong>逻辑运算</strong></li><li>体会 <code>import</code> 导入模块（“工具包”）的使用</li></ol><p><strong>需求</strong></p><ol><li>从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）</li><li>电脑 <strong>随机</strong> 出拳 —— 先假定电脑只会出石头，完成整体代码功能</li><li>比较胜负</li></ol><table><thead><tr><th align="center">序号</th><th align="center">规则</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">石头 胜 剪刀</td></tr><tr><td align="center">2</td><td align="center">剪刀 胜 布</td></tr><tr><td align="center">3</td><td align="center">布 胜 石头</td></tr></tbody></table><h3 id="5-1-基础代码实现"><a href="#5-1-基础代码实现" class="headerlink" title="5.1 基础代码实现"></a>5.1 基础代码实现</h3><ul><li>先 <strong>假定电脑就只会出石头</strong>，完成整体代码功能</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）</span>player <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请出拳 石头（1）／剪刀（2）／布（3）："</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 电脑 随机 出拳 - 假定电脑永远出石头</span>computer <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># 比较胜负</span><span class="token comment"># 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号</span><span class="token comment"># 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>player <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> computer <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">or</span>        <span class="token punctuation">(</span>player <span class="token operator">==</span> <span class="token number">2</span> <span class="token keyword">and</span> computer <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">or</span>        <span class="token punctuation">(</span>player <span class="token operator">==</span> <span class="token number">3</span> <span class="token keyword">and</span> computer <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"噢耶！！！电脑弱爆了！！！"</span><span class="token punctuation">)</span><span class="token keyword">elif</span> player <span class="token operator">==</span> computer<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"心有灵犀，再来一盘！"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不行，我要和你决战到天亮！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-随机数的处理"><a href="#5-2-随机数的处理" class="headerlink" title="5.2 随机数的处理"></a>5.2 随机数的处理</h3><ul><li>在 <code>Python</code> 中，要使用随机数，首先需要导入 <strong>随机数</strong> 的 <strong>模块</strong> —— “工具包”</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>导入模块后，可以直接在 <strong>模块名称</strong> 后面敲一个 <code>.</code> 然后按 <code>Tab</code> 键，会提示该模块中包含的所有函数</p></li><li><p><code>random.randint(a, b)</code> ，返回 <code>[a, b]</code> 之间的整数，包含 <code>a</code> 和 <code>b</code></p></li><li><p>例如：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment"># 生成的随机数n: 12 &lt;= n &lt;= 20   </span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>  <span class="token comment"># 结果永远是 20   </span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment"># 该语句是错误的，下限必须小于上限</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h2><ul><li>算数运算符</li><li>比较（关系）运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>运算符的优先级</li></ul><p>数学符号表链接：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8">https://zh.wikipedia.org/wiki/数学符号表</a></p><h2 id="01-算数运算符-1"><a href="#01-算数运算符-1" class="headerlink" title="01. 算数运算符"></a>01. 算数运算符</h2><ul><li>是完成基本的算术运算使用的符号，用来处理四则运算</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td>10 + 20 &#x3D; 30</td></tr><tr><td align="center">-</td><td align="center">减</td><td>10 - 20 &#x3D; -10</td></tr><tr><td align="center">*</td><td align="center">乘</td><td>10 * 20 &#x3D; 200</td></tr><tr><td align="center">&#x2F;</td><td align="center">除</td><td>10 &#x2F; 20 &#x3D; 0.5</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td align="center">取整除</td><td>返回除法的整数部分（商） 9 &#x2F;&#x2F; 2 输出结果 4</td></tr><tr><td align="center">%</td><td align="center">取余数</td><td>返回除法的余数 9 % 2 &#x3D; 1</td></tr><tr><td align="center">**</td><td align="center">幂</td><td>又称次方、乘方，2 ** 3 &#x3D; 8</td></tr></tbody></table><ul><li>在 Python 中 <code>*</code> 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span>Out<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'----------------------------------------'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="02-比较（关系）运算符"><a href="#02-比较（关系）运算符" class="headerlink" title="02. 比较（关系）运算符"></a>02. 比较（关系）运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>检查两个操作数的值是否 <strong>相等</strong>，如果是，则条件成立，返回 True</td></tr><tr><td>!&#x3D;</td><td>检查两个操作数的值是否 <strong>不相等</strong>，如果是，则条件成立，返回 True</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否 <strong>大于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否 <strong>小于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr><tr><td>&gt;&#x3D;</td><td>检查左操作数的值是否 <strong>大于或等于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr><tr><td>&lt;&#x3D;</td><td>检查左操作数的值是否 <strong>小于或等于</strong> 右操作数的值，如果是，则条件成立，返回 True</td></tr></tbody></table><blockquote><p>Python 2.x 中判断 <strong>不等于</strong> 还可以使用 <code>&lt;&gt;</code> 运算符</p><p><code>!=</code> 在 Python 2.x 中同样可以用来判断 <strong>不等于</strong></p></blockquote><h2 id="03-逻辑运算符"><a href="#03-逻辑运算符" class="headerlink" title="03. 逻辑运算符"></a>03. 逻辑运算符</h2><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>只有 x 和 y 的值都为 True，才会返回 True<br />否则只要 x 或者 y 有一个值为 False，就返回 False</td></tr><tr><td>or</td><td>x or y</td><td>只要 x 或者 y 有一个值为 True，就返回 True<br />只有 x 和 y 的值都为 False，才会返回 False</td></tr><tr><td>not</td><td>not x</td><td>如果 x 为 True，返回 False<br />如果 x 为 False，返回 True</td></tr></tbody></table><h2 id="04-赋值运算符"><a href="#04-赋值运算符" class="headerlink" title="04. 赋值运算符"></a>04. 赋值运算符</h2><ul><li>在 Python 中，使用 <code>=</code> 可以给变量赋值</li><li>在算术运算时，为了简化代码的编写，<code>Python</code> 还提供了一系列的 与 <strong>算术运算符</strong> 对应的 <strong>赋值运算符</strong></li><li>注意：<strong>赋值运算符中间不能使用空格</strong></li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取 <strong>模</strong> (余数)赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr></tbody></table><h2 id="05-运算符的优先级"><a href="#05-运算符的优先级" class="headerlink" title="05. 运算符的优先级"></a>05. 运算符的优先级</h2><ul><li>以下表格的算数优先级由高到最低顺序排列</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>幂 (最高优先级)</td></tr><tr><td>* &#x2F; % &#x2F;&#x2F;</td><td>乘、除、取余数、取整除</td></tr><tr><td>+ -</td><td>加法、减法</td></tr><tr><td>&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td>比较运算符</td></tr><tr><td>&#x3D;&#x3D; !&#x3D;</td><td>等于运算符</td></tr><tr><td>&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td>赋值运算符</td></tr><tr><td>not or and</td><td>逻辑运算符</td></tr></tbody></table><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h2><ul><li>程序的三大流程</li><li>while 循环基本使用</li><li>break 和 continue</li><li>while 循环嵌套</li></ul><h2 id="01-程序的三大流程"><a href="#01-程序的三大流程" class="headerlink" title="01. 程序的三大流程"></a>01. 程序的三大流程</h2><ul><li><p>在程序开发中，一共有三种流程方式：</p><ul><li><strong>顺序</strong> —— <strong>从上向下</strong>，顺序执行代码</li><li><strong>分支</strong> —— 根据条件判断，决定执行代码的 <strong>分支</strong></li><li><strong>循环</strong> —— 让 <strong>特定代码 重复</strong> 执行</li></ul><p>  <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030157.png" alt="001_程序三大流程" loading="lazy"></p></li></ul><h2 id="02-while-循环基本使用"><a href="#02-while-循环基本使用" class="headerlink" title="02. while 循环基本使用"></a>02. <code>while</code> 循环基本使用</h2><ul><li><p>循环的作用就是让 <strong>指定的代码</strong> 重复的执行</p></li><li><p><code>while</code> 循环最常用的应用场景就是 <strong>让执行的代码</strong> 按照 <strong>指定的次数</strong> <strong>重复</strong> 执行</p></li><li><p>需求 —— 打印 5 遍 <code>Hello Python</code></p></li><li><p>思考 —— 如果要求打印 100 遍怎么办？</p></li></ul><h3 id="2-1-while-语句基本语法"><a href="#2-1-while-语句基本语法" class="headerlink" title="2.1 while 语句基本语法"></a>2.1 <code>while</code> 语句基本语法</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">初始条件设置 —— 通常是重复执行的 计数器<span class="token keyword">while</span> 条件<span class="token punctuation">(</span>判断 计数器 是否达到 目标次数<span class="token punctuation">)</span><span class="token punctuation">:</span>    条件满足时，做的事情<span class="token number">1</span>    条件满足时，做的事情<span class="token number">2</span>    条件满足时，做的事情<span class="token number">3</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>省略<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        处理条件<span class="token punctuation">(</span>计数器 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li><code>while</code> 语句以及缩进部分是一个 <strong>完整的代码块</strong></li></ul><h4 id="第一个-while-循环"><a href="#第一个-while-循环" class="headerlink" title="第一个 while 循环"></a>第一个 while 循环</h4><p><strong>需求</strong></p><ul><li>打印 5 遍 Hello Python</li></ul><pre class="line-numbers language-while" data-language="while"><code class="language-while"># 1. 定义重复次数计数器i &#x3D; 1# 2. 使用 while 判断条件while i &lt;&#x3D; 5:    # 要重复执行的代码    print(&quot;Hello Python&quot;)    # 处理计数器 i    i &#x3D; i + 1print(&quot;循环结束后的 i &#x3D; %d&quot; % i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：循环结束后，之前定义的计数器条件的数值是依旧存在的</p></blockquote><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><blockquote><p>由于程序员的原因，<strong>忘记</strong> 在循环内部 <strong>修改循环的判断条件</strong>，导致循环持续执行，程序无法终止！</p></blockquote><h3 id="2-2-赋值运算符"><a href="#2-2-赋值运算符" class="headerlink" title="2.2 赋值运算符"></a>2.2 赋值运算符</h3><ul><li>在 Python 中，使用 <code>=</code> 可以给变量赋值</li><li>在算术运算时，为了简化代码的编写，<code>Python</code> 还提供了一系列的 与 <strong>算术运算符</strong> 对应的 <strong>赋值运算符</strong></li><li>注意：<strong>赋值运算符中间不能使用空格</strong></li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符</td><td>c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+&#x3D;</td><td>加法赋值运算符</td><td>c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td>-&#x3D;</td><td>减法赋值运算符</td><td>c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td>*&#x3D;</td><td>乘法赋值运算符</td><td>c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值运算符</td><td>c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td>&#x2F;&#x2F;&#x3D;</td><td>取整除赋值运算符</td><td>c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr><tr><td>%&#x3D;</td><td>取 <strong>模</strong> (余数)赋值运算符</td><td>c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td>**&#x3D;</td><td>幂赋值运算符</td><td>c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr></tbody></table><h3 id="2-3-Python-中的计数方法"><a href="#2-3-Python-中的计数方法" class="headerlink" title="2.3 Python 中的计数方法"></a>2.3 Python 中的计数方法</h3><p>常见的计数方法有两种，可以分别称为：</p><ul><li><strong>自然计数法</strong>（从 <code>1</code> 开始）—— 更符合人类的习惯</li><li><strong>程序计数法</strong>（从 <code>0</code> 开始）—— 几乎所有的程序语言都选择从 0 开始计数</li></ul><p>因此，大家在编写程序时，应该尽量养成习惯：<strong>除非需求的特殊要求，否则 循环 的计数都从 0 开始</strong></p><h3 id="2-4-循环计算"><a href="#2-4-循环计算" class="headerlink" title="2.4 循环计算"></a>2.4 循环计算</h3><blockquote><p>在程序开发中，通常会遇到 <strong>利用循环</strong> <strong>重复计算</strong> 的需求</p></blockquote><p>遇到这种需求，可以：</p><ol><li>在 <code>while</code> 上方定义一个变量，用于 <strong>存放最终计算结果</strong></li><li>在循环体内部，每次循环都用 <strong>最新的计算结果</strong>，<strong>更新</strong> 之前定义的变量</li></ol><p><strong>需求</strong></p><ul><li>计算 0 ~ 100 之间所有数字的累计求和结果</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 计算 0 ~ 100 之间所有数字的累计求和结果</span><span class="token comment"># 0. 定义最终结果的变量</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 1. 定义一个整数的变量记录循环的次数</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 2. 开始循环</span><span class="token keyword">while</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token comment"># 每一次循环，都让 result 这个变量和 i 这个计数器相加</span>    result <span class="token operator">+=</span> i    <span class="token comment"># 处理计数器</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"0~100之间的数字求和结果 = %d"</span> <span class="token operator">%</span> result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="需求进阶"><a href="#需求进阶" class="headerlink" title="需求进阶"></a>需求进阶</h4><ul><li>计算 0 ~ 100 之间 所有 <strong>偶数</strong> 的累计求和结果</li></ul><p>开发步骤</p><ol><li>编写循环 <strong>确认</strong> <strong>要计算的数字</strong></li><li>添加 <strong>结果</strong> 变量，在循环内部 <strong>处理计算结果</strong></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 0. 最终结果</span>result <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 1. 计数器</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 2. 开始循环</span><span class="token keyword">while</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">:</span>    <span class="token comment"># 判断偶数</span>    <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        result <span class="token operator">+=</span> i    <span class="token comment"># 处理计数器</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"0~100之间偶数求和结果 = %d"</span> <span class="token operator">%</span> result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="03-break-和-continue"><a href="#03-break-和-continue" class="headerlink" title="03. break 和 continue"></a>03. break 和 continue</h2><blockquote><p><code>break</code> 和 <code>continue</code> 是专门在循环中使用的关键字</p></blockquote><ul><li><code>break</code> <strong>某一条件满足时</strong>，退出循环，不再执行后续重复的代码</li><li><code>continue</code> <strong>某一条件满足时</strong>，不执行后续重复的代码</li></ul><blockquote><p><code>break</code> 和 <code>continue</code> 只针对 <strong>当前所在循环</strong> 有效</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030158.png" alt="002_循环流程图-w400" loading="lazy"></p><h3 id="3-1-break"><a href="#3-1-break" class="headerlink" title="3.1 break"></a>3.1 break</h3><ul><li><strong>在循环过程中</strong>，如果 <strong>某一个条件满足后</strong>，<strong>不</strong> 再希望 <strong>循环继续执行</strong>，可以使用 <code>break</code> 退出循环</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>    <span class="token comment"># break 某一条件满足时，退出循环，不再执行后续重复的代码</span>    <span class="token comment"># i == 3</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>break</code> 只针对当前所在循环有效</p></blockquote><h3 id="3-2-continue"><a href="#3-2-continue" class="headerlink" title="3.2 continue"></a>3.2 continue</h3><ul><li><strong>在循环过程中</strong>，如果 <strong>某一个条件满足后</strong>，<strong>不</strong> 希望 <strong>执行循环代码，但是又不希望退出循环</strong>，可以使用 <code>continue</code></li><li>也就是：在整个循环中，<strong>只有某些条件</strong>，不需要执行循环代码，而其他条件都需要执行</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>    <span class="token comment"># 当 i == 7 时，不希望执行需要重复执行的代码</span>    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">:</span>        <span class="token comment"># 在使用 continue 之前，同样应该修改计数器</span>        <span class="token comment"># 否则会出现死循环</span>        i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">continue</span>    <span class="token comment"># 重复执行的代码</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>需要注意：使用 <code>continue</code> 时，<strong>条件处理部分的代码，需要特别注意</strong>，不小心会出现 <strong>死循环</strong></li></ul><blockquote><p><code>continue</code> 只针对当前所在循环有效</p></blockquote><h2 id="04-while-循环嵌套"><a href="#04-while-循环嵌套" class="headerlink" title="04. while 循环嵌套"></a>04. <code>while</code> 循环嵌套</h2><h3 id="4-1-循环嵌套"><a href="#4-1-循环嵌套" class="headerlink" title="4.1 循环嵌套"></a>4.1 循环嵌套</h3><ul><li><code>while</code> 嵌套就是：<code>while</code> 里面还有 <code>while</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> 条件 <span class="token number">1</span><span class="token punctuation">:</span>    条件满足时，做的事情<span class="token number">1</span>    条件满足时，做的事情<span class="token number">2</span>    条件满足时，做的事情<span class="token number">3</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>省略<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">while</span> 条件 <span class="token number">2</span><span class="token punctuation">:</span>        条件满足时，做的事情<span class="token number">1</span>        条件满足时，做的事情<span class="token number">2</span>        条件满足时，做的事情<span class="token number">3</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>省略<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            处理条件 <span class="token number">2</span>        处理条件 <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-循环嵌套演练-——-九九乘法表"><a href="#4-2-循环嵌套演练-——-九九乘法表" class="headerlink" title="4.2 循环嵌套演练 —— 九九乘法表"></a>4.2 循环嵌套演练 —— 九九乘法表</h3><h4 id="第-1-步：用嵌套打印小星星"><a href="#第-1-步：用嵌套打印小星星" class="headerlink" title="第 1 步：用嵌套打印小星星"></a>第 1 步：用嵌套打印小星星</h4><p><strong>需求</strong></p><ul><li>在控制台连续输出五行 <code>*</code>，每一行星号的数量依次递增</li></ul><pre class="line-numbers language-none"><code class="language-none">***************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用字符串 * 打印</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 1. 定义一个计数器变量，从数字1开始，循环会比较方便</span>row <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">while</span> row <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> row<span class="token punctuation">)</span>    row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第-2-步：使用循环嵌套打印小星星"><a href="#第-2-步：使用循环嵌套打印小星星" class="headerlink" title="第 2 步：使用循环嵌套打印小星星"></a>第 2 步：使用循环嵌套打印小星星</h4><p><strong>知识点</strong> 对 <code>print</code> 函数的使用做一个增强</p><ul><li><p>在默认情况下，<code>print</code> 函数输出内容之后，会自动在内容末尾增加换行</p></li><li><p>如果不希望末尾增加换行，可以在 <code>print</code> 函数输出内容的后面增加 <code>, end=&quot;&quot;</code></p></li><li><p>其中 <code>&quot;&quot;</code> 中间可以指定 <code>print</code> 函数输出内容之后，继续希望显示的内容</p></li><li><p>语法格式如下：</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 向控制台输出内容结束之后，不会换行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token comment"># 单纯的换行</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>end=&quot;&quot;</code> 表示向控制台输出内容结束之后，不会换行</p></blockquote><p><strong>假设</strong> <code>Python</code> <strong>没有提供</strong> 字符串的 <code>*</code> 操作 <strong>拼接字符串</strong></p><p><strong>需求</strong></p><ul><li>在控制台连续输出五行 <code>*</code>，每一行星号的数量依次递增</li></ul><pre class="line-numbers language-none"><code class="language-none">***************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>开发步骤</strong></p><ul><li>1&gt; 完成 5 行内容的简单输出</li><li>2&gt; 分析每行内部的 <code>*</code> 应该如何处理？<ul><li>每行显示的星星和当前所在的行数是一致的</li><li>嵌套一个小的循环，专门处理每一行中 <code>列</code> 的星星显示</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">row <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">while</span> row <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">:</span>    <span class="token comment"># 假设 python 没有提供字符串 * 操作</span>    <span class="token comment"># 在循环内部，再增加一个循环，实现每一行的 星星 打印</span>    col <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> col <span class="token operator">&lt;=</span> row<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        col <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 每一行星号输出完成后，再增加一个换行</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第-3-步：-九九乘法表"><a href="#第-3-步：-九九乘法表" class="headerlink" title="第 3 步： 九九乘法表"></a>第 3 步： 九九乘法表</h4><p><strong>需求</strong> 输出 九九乘法表，格式如下：</p><pre class="line-numbers language-none"><code class="language-none">1 * 1 &#x3D; 11 * 2 &#x3D; 22 * 2 &#x3D; 41 * 3 &#x3D; 32 * 3 &#x3D; 63 * 3 &#x3D; 91 * 4 &#x3D; 42 * 4 &#x3D; 83 * 4 &#x3D; 124 * 4 &#x3D; 161 * 5 &#x3D; 52 * 5 &#x3D; 103 * 5 &#x3D; 154 * 5 &#x3D; 205 * 5 &#x3D; 251 * 6 &#x3D; 62 * 6 &#x3D; 123 * 6 &#x3D; 184 * 6 &#x3D; 245 * 6 &#x3D; 306 * 6 &#x3D; 361 * 7 &#x3D; 72 * 7 &#x3D; 143 * 7 &#x3D; 214 * 7 &#x3D; 285 * 7 &#x3D; 356 * 7 &#x3D; 427 * 7 &#x3D; 491 * 8 &#x3D; 82 * 8 &#x3D; 163 * 8 &#x3D; 244 * 8 &#x3D; 325 * 8 &#x3D; 406 * 8 &#x3D; 487 * 8 &#x3D; 568 * 8 &#x3D; 641 * 9 &#x3D; 92 * 9 &#x3D; 183 * 9 &#x3D; 274 * 9 &#x3D; 365 * 9 &#x3D; 456 * 9 &#x3D; 547 * 9 &#x3D; 638 * 9 &#x3D; 729 * 9 &#x3D; 81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>开发步骤</strong></p><ul><li><ol><li>打印 9 行小星星</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">*********************************************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><ol start="2"><li>将每一个 <code>*</code> 替换成对应的行与列相乘</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义起始行</span>row <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># 最大打印 9 行</span><span class="token keyword">while</span> row <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">:</span>    <span class="token comment"># 定义起始列</span>    col <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment"># 最大打印 row 列</span>    <span class="token keyword">while</span> col <span class="token operator">&lt;=</span> row<span class="token punctuation">:</span>        <span class="token comment"># end = ""，表示输出结束后，不换行</span>        <span class="token comment"># "\t" 可以在控制台输出一个制表符，协助在输出文本时对齐</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d * %d = %d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>col<span class="token punctuation">,</span> row<span class="token punctuation">,</span> row <span class="token operator">*</span> col<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"\t"</span><span class="token punctuation">)</span>        <span class="token comment"># 列数 + 1</span>        col <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 一行打印完成的换行</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token comment"># 行数 + 1</span>    row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>字符串中的转义字符</strong></p><ul><li><code>\t</code> 在控制台输出一个 <strong>制表符</strong>，协助在输出文本时 <strong>垂直方向</strong> 保持对齐</li><li><code>\n</code> 在控制台输出一个 <strong>换行符</strong></li></ul><blockquote><p><strong>制表符</strong> 的功能是在不使用表格的情况下在 <strong>垂直方向</strong> 按列对齐文本</p></blockquote><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>\\</td><td>反斜杠符号</td></tr><tr><td>\‘</td><td>单引号</td></tr><tr><td>\“</td><td>双引号</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\r</td><td>回车</td></tr></tbody></table><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h2><ul><li>函数的快速体验</li><li>函数的基本使用</li><li>函数的参数</li><li>函数的返回值</li><li>函数的嵌套调用</li><li>在模块中定义函数</li></ul><h2 id="01-函数的快速体验"><a href="#01-函数的快速体验" class="headerlink" title="01. 函数的快速体验"></a>01. 函数的快速体验</h2><h3 id="1-1-快速体验"><a href="#1-1-快速体验" class="headerlink" title="1.1 快速体验"></a>1.1 快速体验</h3><ul><li>所谓<strong>函数</strong>，就是把 <strong>具有独立功能的代码块</strong> 组织为一个小模块，在需要的时候 <strong>调用</strong></li><li>函数的使用包含两个步骤：<ol><li>定义函数 —— <strong>封装</strong> 独立的功能</li><li>调用函数 —— 享受 <strong>封装</strong> 的成果</li></ol></li><li><strong>函数的作用</strong>，在开发程序时，使用函数可以提高编写的效率以及代码的 <strong>重用</strong></li></ul><p><strong>演练步骤</strong></p><ol><li>新建 <code>04_函数</code> 项目</li><li>复制之前完成的 <strong>乘法表</strong> 文件</li><li>修改文件，增加函数定义 <code>multiple_table():</code></li><li>新建另外一个文件，使用 <code>import</code> 导入并且调用函数</li></ol><h2 id="02-函数基本使用"><a href="#02-函数基本使用" class="headerlink" title="02. 函数基本使用"></a>02. 函数基本使用</h2><h3 id="2-1-函数的定义"><a href="#2-1-函数的定义" class="headerlink" title="2.1 函数的定义"></a>2.1 函数的定义</h3><p>定义函数的格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> 函数名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    函数封装的代码    ……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>def</code> 是英文 <code>define</code> 的缩写</li><li><strong>函数名称</strong> 应该能够表达 <strong>函数封装代码</strong> 的功能，方便后续的调用</li><li><strong>函数名称</strong> 的命名应该 <strong>符合</strong> <strong>标识符的命名规则</strong><ul><li>可以由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li></ul></li></ol><h3 id="2-2-函数调用"><a href="#2-2-函数调用" class="headerlink" title="2.2 函数调用"></a>2.2 函数调用</h3><p>调用函数很简单的，通过 <code>函数名()</code> 即可完成对函数的调用</p><h3 id="2-3-第一个函数演练"><a href="#2-3-第一个函数演练" class="headerlink" title="2.3 第一个函数演练"></a>2.3 第一个函数演练</h3><p><strong>需求</strong></p><ul><li><ol><li>编写一个打招呼 <code>say_hello</code> 的函数，封装三行打招呼的代码</li></ol></li><li><ol start="2"><li>在函数下方调用打招呼的代码</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">"小明"</span><span class="token comment"># 解释器知道这里定义了一个函数</span><span class="token keyword">def</span> <span class="token function">say_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello 1"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello 2"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello 3"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token comment"># 只有在调用函数时，之前定义的函数才会被执行</span><span class="token comment"># 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码</span>say_hello<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>用 <strong>单步执行 F8 和 F7</strong> 观察以下代码的执行过程</p></blockquote><ul><li>定义好函数之后，只表示这个函数封装了一段代码而已</li><li>如果不主动调用函数，函数是不会主动执行的</li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul><li><p>能否将 <strong>函数调用</strong> 放在 <strong>函数定义</strong> 的上方？</p><ul><li>不能！</li><li>因为在 <strong>使用函数名</strong> 调用函数之前，必须要保证 <code>Python</code> 已经知道函数的存在</li><li>否则控制台会提示 <code>NameError: name &#39;say_hello&#39; is not defined</code> (<strong>名称错误：say_hello 这个名字没有被定义</strong>)</li></ul></li></ul><h3 id="2-4-PyCharm-的调试工具"><a href="#2-4-PyCharm-的调试工具" class="headerlink" title="2.4 PyCharm 的调试工具"></a>2.4 PyCharm 的调试工具</h3><ul><li><strong>F8 Step Over</strong> 可以单步执行代码，会把函数调用看作是一行代码直接执行</li><li><strong>F7 Step Into</strong> 可以单步执行代码，如果是函数，会进入函数内部</li></ul><h3 id="2-5-函数的文档注释"><a href="#2-5-函数的文档注释" class="headerlink" title="2.5 函数的文档注释"></a>2.5 函数的文档注释</h3><ul><li>在开发中，如果希望给函数添加注释，应该在 <strong>定义函数</strong> 的下方，使用 <strong>连续的三对引号</strong></li><li>在 <strong>连续的三对引号</strong> 之间编写对函数的说明文字</li><li>在 <strong>函数调用</strong> 位置，使用快捷键 <code>CTRL + Q</code> 可以查看函数的说明信息</li></ul><blockquote><p>注意：因为 <strong>函数体相对比较独立</strong>，<strong>函数定义的上方</strong>，应该和其他代码（包括注释）保留 <strong>两个空行</strong></p></blockquote><h2 id="03-函数的参数"><a href="#03-函数的参数" class="headerlink" title="03. 函数的参数"></a>03. 函数的参数</h2><p><strong>演练需求</strong></p><ol><li>开发一个 <code>sum_2_num</code> 的函数</li><li>函数能够实现 <strong>两个数字的求和</strong> 功能</li></ol><p>演练代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_2_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    num1 <span class="token operator">=</span> <span class="token number">10</span>    num2 <span class="token operator">=</span> <span class="token number">20</span>    result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span>sum_2_num<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>思考一下存在什么问题</strong></p><blockquote><p>函数只能处理 <strong>固定数值</strong> 的相加</p></blockquote><p><strong>如何解决？</strong></p><ul><li>如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！</li></ul><h3 id="3-1-函数参数的使用"><a href="#3-1-函数参数的使用" class="headerlink" title="3.1 函数参数的使用"></a>3.1 函数参数的使用</h3><ul><li>在函数名的后面的小括号内部填写 <strong>参数</strong></li><li>多个参数之间使用 <code>,</code> 分隔</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_2_num</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span>sum_2_num<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-参数的作用"><a href="#3-2-参数的作用" class="headerlink" title="3.2 参数的作用"></a>3.2 参数的作用</h3><ul><li><strong>函数</strong>，把 <strong>具有独立功能的代码块</strong> 组织为一个小模块，在需要的时候 <strong>调用</strong></li><li><strong>函数的参数</strong>，增加函数的 <strong>通用性</strong>，针对 <strong>相同的数据处理逻辑</strong>，能够 <strong>适应更多的数据</strong><ol><li>在函数 <strong>内部</strong>，把参数当做 <strong>变量</strong> 使用，进行需要的数据处理</li><li>函数调用时，按照函数定义的<strong>参数顺序</strong>，把 <strong>希望在函数内部处理的数据</strong>，<strong>通过参数</strong> 传递</li></ol></li></ul><h3 id="3-3-形参和实参"><a href="#3-3-形参和实参" class="headerlink" title="3.3 形参和实参"></a>3.3 形参和实参</h3><ul><li><strong>形参</strong>：<strong>定义</strong> 函数时，小括号中的参数，是用来接收参数用的，在函数内部 <strong>作为变量使用</strong></li><li><strong>实参</strong>：<strong>调用</strong> 函数时，小括号中的参数，是用来把数据传递到 <strong>函数内部</strong> 用的</li></ul><h2 id="04-函数的返回值"><a href="#04-函数的返回值" class="headerlink" title="04. 函数的返回值"></a>04. 函数的返回值</h2><ul><li>在程序开发中，有时候，会希望 <strong>一个函数执行结束后，告诉调用者一个结果</strong>，以便调用者针对具体的结果做后续的处理</li><li><strong>返回值</strong> 是函数 <strong>完成工作</strong>后，<strong>最后</strong> 给调用者的 <strong>一个结果</strong></li><li>在函数中使用 <code>return</code> 关键字可以返回结果</li><li>调用函数一方，可以 <strong>使用变量</strong> 来 <strong>接收</strong> 函数的返回结果</li></ul><blockquote><p>注意：<code>return</code> 表示返回，后续的代码都不会被执行</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_2_num</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""对两个数字的求和"""</span>    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token comment"># 调用函数，并使用 result 变量接收计算结果</span>result <span class="token operator">=</span> sum_2_num<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"计算结果是 %d"</span> <span class="token operator">%</span> result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="05-函数的嵌套调用"><a href="#05-函数的嵌套调用" class="headerlink" title="05. 函数的嵌套调用"></a>05. 函数的嵌套调用</h2><ul><li>一个函数里面 <strong>又调用</strong> 了 <strong>另外一个函数</strong>，这就是 <strong>函数嵌套调用</strong></li><li>如果函数 <code>test2</code> 中，调用了另外一个函数 <code>test1</code><ul><li>那么执行到调用 <code>test1</code> 函数时，会先把函数 <code>test1</code> 中的任务都执行完</li><li>才会回到 <code>test2</code> 中调用函数 <code>test1</code> 的位置，继续执行后续的代码</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test 1"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test 2"</span><span class="token punctuation">)</span>        test1<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>test2<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数嵌套的演练-——-打印分隔线"><a href="#函数嵌套的演练-——-打印分隔线" class="headerlink" title="函数嵌套的演练 —— 打印分隔线"></a>函数嵌套的演练 —— 打印分隔线</h3><blockquote><p>体会一下工作中 <strong>需求是多变</strong> 的</p></blockquote><p><strong>需求 1</strong></p><ul><li>定义一个 <code>print_line</code> 函数能够打印 <code>*</code> 组成的 <strong>一条分隔线</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>需求 2</strong></p><ul><li>定义一个函数能够打印 <strong>由任意字符组成</strong> 的分隔线</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>char <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需求 3</strong></p><ul><li>定义一个函数能够打印 <strong>任意重复次数</strong> 的分隔线</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>char <span class="token operator">*</span> times<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>需求 4</strong></p><ul><li>定义一个函数能够打印 <strong>5 行</strong> 的分隔线，分隔线要求符合<strong>需求 3</strong></li></ul><blockquote><p>提示：工作中针对需求的变化，应该冷静思考，<strong>不要轻易修改之前已经完成的，能够正常执行的函数</strong>！</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_line</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>char <span class="token operator">*</span> times<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">print_lines</span><span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">:</span>    row <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> row <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>        print_line<span class="token punctuation">(</span>char<span class="token punctuation">,</span> times<span class="token punctuation">)</span>        row <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="06-使用模块中的函数"><a href="#06-使用模块中的函数" class="headerlink" title="06. 使用模块中的函数"></a>06. 使用模块中的函数</h2><blockquote><p><strong>模块是 Python 程序架构的一个核心概念</strong></p></blockquote><ul><li><strong>模块</strong> 就好比是 <strong>工具包</strong>，要想使用这个工具包中的工具，就需要 <strong>导入 import</strong> 这个模块</li><li>每一个以扩展名 <code>py</code> 结尾的 <code>Python</code> 源代码文件都是一个 <strong>模块</strong></li><li>在模块中定义的 <strong>全局变量</strong> 、 <strong>函数</strong> 都是模块能够提供给外界直接使用的工具</li></ul><h3 id="6-1-第一个模块体验"><a href="#6-1-第一个模块体验" class="headerlink" title="6.1 第一个模块体验"></a>6.1 第一个模块体验</h3><p><strong>步骤</strong></p><ul><li>新建 <code>hm_10_分隔线模块.py</code><ul><li>复制 <code>hm_09_打印多条分隔线.py</code> 中的内容，<strong>最后一行 <code>print</code> 代码除外</strong></li><li>增加一个字符串变量</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">name <span class="token operator">=</span> <span class="token string">"黑马程序员"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>新建 <code>hm_10_体验模块.py</code> 文件，并且编写以下代码：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> hm_10_分隔线模块hm_10_分隔线模块<span class="token punctuation">.</span>print_line<span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hm_10_分隔线模块<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="体验小结"><a href="#体验小结" class="headerlink" title="体验小结"></a>体验小结</h4><ul><li>可以 <strong>在一个 Python 文件</strong> 中 <strong>定义 变量 或者 函数</strong></li><li>然后在 <strong>另外一个文件中</strong> 使用 <code>import</code> 导入这个模块</li><li>导入之后，就可以使用 <code>模块名.变量</code> &#x2F; <code>模块名.函数</code> 的方式，使用这个模块中定义的变量或者函数</li></ul><blockquote><p><strong>模块</strong>可以让 <strong>曾经编写过的代码</strong> 方便的被 <strong>复用</strong>！</p></blockquote><h3 id="6-2-模块名也是一个标识符"><a href="#6-2-模块名也是一个标识符" class="headerlink" title="6.2 模块名也是一个标识符"></a>6.2 模块名也是一个标识符</h3><ul><li>标示符可以由 <strong>字母</strong>、<strong>下划线</strong> 和 <strong>数字</strong> 组成</li><li><strong>不能以数字开头</strong></li><li><strong>不能与关键字重名</strong></li></ul><blockquote><p>注意：如果在给 Python 文件起名时，<strong>以数字开头</strong> 是无法在 <code>PyCharm</code> 中通过导入这个模块的</p></blockquote><h3 id="6-3-Pyc-文件（了解）"><a href="#6-3-Pyc-文件（了解）" class="headerlink" title="6.3 Pyc 文件（了解）"></a>6.3 Pyc 文件（了解）</h3><blockquote><p><code>C</code> 是 <code>compiled</code> <strong>编译过</strong> 的意思</p></blockquote><p><strong>操作步骤</strong></p><ol><li>浏览程序目录会发现一个 <code>__pycache__</code> 的目录</li><li>目录下会有一个 <code>hm_10_分隔线模块.cpython-35.pyc</code> 文件，<code>cpython-35</code> 表示 <code>Python</code> 解释器的版本</li><li>这个 <code>pyc</code> 文件是由 Python 解释器将 <strong>模块的源码</strong> 转换为 <strong>字节码</strong><ul><li><code>Python</code> 这样保存 <strong>字节码</strong> 是作为一种启动 <strong>速度的优化</strong></li></ul></li></ol><p><strong>字节码</strong></p><ul><li><p><code>Python</code> 在解释源程序时是分成两个步骤的</p><ol><li>首先处理源代码，<strong>编译</strong> 生成一个二进制 <strong>字节码</strong></li><li>再对 <strong>字节码</strong> 进行处理，才会生成 CPU 能够识别的 <strong>机器码</strong></li></ol></li><li><p>有了模块的字节码文件之后，下一次运行程序时，如果在 <strong>上次保存字节码之后</strong> 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤</p></li><li><p>当 <code>Python</code> 重编译时，它会自动检查源文件和字节码文件的时间戳</p></li><li><p>如果你又修改了源代码，下次程序运行时，字节码将自动重新创建</p></li></ul><blockquote><p>提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！</p><p><strong>模块是 Python 程序架构的一个核心概念</strong></p></blockquote><h1 id="高级变量类型"><a href="#高级变量类型" class="headerlink" title="高级变量类型"></a>高级变量类型</h1><h2 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h2><ul><li>列表</li><li>元组</li><li>字典</li><li>字符串</li><li>公共方法</li><li>变量高级</li></ul><h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><ul><li><p>Python 中数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></p></li><li><p>数字型</p><ul><li>整型 (<code>int</code>)</li><li>浮点型（<code>float</code>）</li><li>布尔型（<code>bool</code>） <ul><li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 (<code>complex</code>)<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li><p>非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li><li><p>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong> 都支持以下特点：</p><ol><li>都是一个 <strong>序列</strong> <code>sequence</code>，也可以理解为 <strong>容器</strong></li><li><strong>取值</strong> <code>[]</code></li><li><strong>遍历</strong> <code>for in</code></li><li><strong>计算长度</strong>、<strong>最大&#x2F;最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li><li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong> <code>*</code></li><li><strong>切片</strong></li></ol></li></ul><h2 id="01-列表"><a href="#01-列表" class="headerlink" title="01. 列表"></a>01. 列表</h2><h3 id="1-1-列表的定义"><a href="#1-1-列表的定义" class="headerlink" title="1.1 列表的定义"></a>1.1 列表的定义</h3><ul><li><code>List</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型，在其他语言中通常叫做 <strong>数组</strong></li><li>专门用于存储 <strong>一串 信息</strong></li><li>列表用 <code>[]</code> 定义，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>列表的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>列表</strong> 中的位置编号，<strong>索引</strong> 又可以被称为 <strong>下标</strong></li></ul></li></ul><blockquote><p>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">name_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">,</span> <span class="token string">"wangwu"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030308.png" alt="001_列表示意图" loading="lazy"></p><h3 id="1-2-列表常用操作"><a href="#1-2-列表常用操作" class="headerlink" title="1.2 列表常用操作"></a>1.2 列表常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li><li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">In [1]: name_list.name_list.append   name_list.count    name_list.insert   name_list.reversename_list.clear    name_list.extend   name_list.pop      name_list.sortname_list.copy     name_list.index    name_list.remove <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>序号</th><th>分类</th><th>关键字 &#x2F; 函数 &#x2F; 方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>增加</td><td>列表.insert(索引, 数据)</td><td>在指定位置插入数据</td></tr><tr><td></td><td></td><td>列表.append(数据)</td><td>在末尾追加数据</td></tr><tr><td></td><td></td><td>列表.extend(列表2)</td><td>将列表2 的数据追加到列表</td></tr><tr><td>2</td><td>修改</td><td>列表[索引] &#x3D; 数据</td><td>修改指定索引的数据</td></tr><tr><td>3</td><td>删除</td><td>del 列表[索引]</td><td>删除指定索引的数据</td></tr><tr><td></td><td></td><td>列表.remove[数据]</td><td>删除第一个出现的指定数据</td></tr><tr><td></td><td></td><td>列表.pop</td><td>删除末尾数据</td></tr><tr><td></td><td></td><td>列表.pop(索引)</td><td>删除指定索引数据</td></tr><tr><td></td><td></td><td>列表.clear</td><td>清空列表</td></tr><tr><td>4</td><td>统计</td><td>len(列表)</td><td>列表长度</td></tr><tr><td></td><td></td><td>列表.count(数据)</td><td>数据在列表中出现的次数</td></tr><tr><td>5</td><td>排序</td><td>列表.sort()</td><td>升序排序</td></tr><tr><td></td><td></td><td>列表.sort(reverse&#x3D;True)</td><td>降序排序</td></tr><tr><td></td><td></td><td>列表.reverse()</td><td>逆序、反转</td></tr></tbody></table><h4 id="del-关键字（科普）"><a href="#del-关键字（科普）" class="headerlink" title="del 关键字（科普）"></a>del 关键字（科普）</h4><ul><li>使用 <code>del</code> 关键字(<code>delete</code>) 同样可以删除列表中元素</li><li><code>del</code> 关键字本质上是用来 <strong>将一个变量从内存中删除的</strong></li><li>如果使用 <code>del</code> 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">del</span> name_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在日常开发中，要从列表删除数据，建议 <strong>使用列表提供的方法</strong></p></blockquote><h4 id="关键字、函数和方法（科普）"><a href="#关键字、函数和方法（科普）" class="headerlink" title="关键字、函数和方法（科普）"></a>关键字、函数和方法（科普）</h4><ul><li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">import</span> keywordIn <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>In <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>关键字后面不需要使用括号</p></blockquote><ul><li><strong>函数</strong> 封装了独立功能，可以直接调用</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">函数名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>函数需要死记硬背</p></blockquote><ul><li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li><li><strong>方法</strong> 需要通过 <strong>对象</strong> 来调用，表示针对这个 <strong>对象</strong> 要做的操作</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">对象<span class="token punctuation">.</span>方法名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p></blockquote><h3 id="1-3-循环遍历"><a href="#1-3-循环遍历" class="headerlink" title="1.3 循环遍历"></a>1.3 循环遍历</h3><ul><li><p><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中获取数据</p><ul><li>在 <strong>循环体内部</strong> 针对 <strong>每一个元素</strong>，执行相同的操作</li></ul></li><li><p>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的 <strong>迭代 iteration 遍历</strong></p></li><li><p>使用 <code>for</code> 就能够实现迭代遍历</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># for 循环内部使用的变量 in 列表</span><span class="token keyword">for</span> name <span class="token keyword">in</span> name_list<span class="token punctuation">:</span>    循环内部针对列表元素进行操作    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030309.png" alt="002_forin循环流程图-w420" loading="lazy"></p><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 <strong>应用场景</strong></h3><ul><li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以 <strong>存储不同类型的数据</strong></li><li>但是在开发中，更多的应用场景是<ol><li><strong>列表</strong> 存储相同类型的数据</li><li>通过 <strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ol></li></ul><h2 id="02-元组"><a href="#02-元组" class="headerlink" title="02. 元组"></a>02. 元组</h2><h3 id="2-1-元组的定义"><a href="#2-1-元组的定义" class="headerlink" title="2.1 元组的定义"></a>2.1 元组的定义</h3><ul><li><code>Tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong><ul><li><strong>元组</strong> 表示多个元素组成的序列</li><li><strong>元组</strong> 在 <code>Python</code> 开发中，有特定的应用场景</li></ul></li><li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>元组用 <code>()</code> 定义</li><li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>元组</strong> 中的位置编号</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">info_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">1.75</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">info_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="元组中-只包含一个元素-时，需要-在元素后面添加逗号"><a href="#元组中-只包含一个元素-时，需要-在元素后面添加逗号" class="headerlink" title="元组中 只包含一个元素 时，需要 在元素后面添加逗号"></a>元组中 <strong>只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">info_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030310.png" alt="003_元组示意图-w500" loading="lazy"></p><h3 id="2-2-元组常用操作"><a href="#2-2-元组常用操作" class="headerlink" title="2.2 元组常用操作"></a>2.2 元组常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>元组</strong>，例如：<code>info = ()</code></li><li>输入 <code>info.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>元组</strong> 能够使用的函数如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">info<span class="token punctuation">.</span>count  info<span class="token punctuation">.</span>index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>有关 <strong>元组</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="2-3-循环遍历"><a href="#2-3-循环遍历" class="headerlink" title="2.3 循环遍历"></a>2.3 循环遍历</h3><ul><li><strong>取值</strong> 就是从 <strong>元组</strong> 中获取存储在指定位置的数据</li><li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>元组</strong> 中获取数据</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># for 循环内部使用的变量 in 元组</span><span class="token keyword">for</span> item <span class="token keyword">in</span> info<span class="token punctuation">:</span>    循环内部针对元组元素进行操作    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>在 <code>Python</code> 中，可以使用 <code>for</code> 循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 以及 <strong>字符串</strong></li><li>提示：在实际开发中，除非 <strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li></ul></blockquote><h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li><li>但是在开发中，更多的应用场景是：<ul><li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收 <strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul><li>有关 <strong>函数的参数 和 返回值</strong>，在后续 <strong>函数高级</strong> 给大家介绍</li></ul></li><li><strong>格式字符串</strong>，格式化字符串后面的 <code>()</code> 本质上就是一个元组</li><li><strong>让列表不可以被修改</strong>，以保护数据安全</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">info <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 的年龄是 %d"</span> <span class="token operator">%</span> info<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="元组和列表之间的转换"><a href="#元组和列表之间的转换" class="headerlink" title="元组和列表之间的转换"></a>元组和列表之间的转换</h4><ul><li>使用 <code>list</code> 函数可以把元组转换成列表</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span><span class="token punctuation">(</span>元组<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 <code>tuple</code> 函数可以把列表转换成元组</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">tuple</span><span class="token punctuation">(</span>列表<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="03-字典"><a href="#03-字典" class="headerlink" title="03. 字典"></a>03. 字典</h2><h3 id="3-1-字典的定义"><a href="#3-1-字典的定义" class="headerlink" title="3.1 字典的定义"></a>3.1 字典的定义</h3><ul><li><code>dictionary</code>（字典） 是 <strong>除列表以外</strong> <code>Python</code> 之中 <strong>最灵活</strong> 的数据类型</li><li>字典同样可以用来 <strong>存储多个数据</strong><ul><li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong></li></ul></li><li>和列表的区别<ul><li><strong>列表</strong> 是 <strong>有序</strong> 的对象集合</li><li><strong>字典</strong> 是 <strong>无序</strong> 的对象集合</li></ul></li><li>字典用 <code>&#123;&#125;</code> 定义</li><li>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用 <code>,</code> 分隔<ul><li><strong>键</strong> <code>key</code> 是索引</li><li><strong>值</strong> <code>value</code> 是数据</li><li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li><li><strong>键必须是唯一的</strong></li><li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">xiaoming <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小明"</span><span class="token punctuation">,</span>            <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>            <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>            <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">1.75</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030311.png" alt="002_字典示意图" loading="lazy"></p><h3 id="3-2-字典常用操作"><a href="#3-2-字典常用操作" class="headerlink" title="3.2 字典常用操作"></a>3.2 字典常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = &#123;&#125;</code></li><li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong> 能够使用的函数如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">In [1]: xiaoming.xiaoming.clear       xiaoming.items       xiaoming.setdefaultxiaoming.copy        xiaoming.keys        xiaoming.updatexiaoming.fromkeys    xiaoming.pop         xiaoming.valuesxiaoming.get         xiaoming.popitem    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>有关 <strong>字典</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="3-3-循环遍历"><a href="#3-3-循环遍历" class="headerlink" title="3.3 循环遍历"></a>3.3 循环遍历</h3><ul><li><strong>遍历</strong> 就是 <strong>依次</strong> 从 <strong>字典</strong> 中获取所有键值对</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># for 循环内部使用的 `key 的变量` in 字典</span><span class="token keyword">for</span> k <span class="token keyword">in</span> xiaoming<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s: %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span> xiaoming<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p></blockquote><h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 <strong>应用场景</strong></h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li><li>但是在开发中，更多的应用场景是：<ul><li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li><li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">card_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>              <span class="token string">"qq"</span><span class="token punctuation">:</span> <span class="token string">"12345"</span><span class="token punctuation">,</span>              <span class="token string">"phone"</span><span class="token punctuation">:</span> <span class="token string">"110"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>             <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"李四"</span><span class="token punctuation">,</span>              <span class="token string">"qq"</span><span class="token punctuation">:</span> <span class="token string">"54321"</span><span class="token punctuation">,</span>              <span class="token string">"phone"</span><span class="token punctuation">:</span> <span class="token string">"10086"</span><span class="token punctuation">&#125;</span>             <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04. 字符串"></a>04. 字符串</h2><h3 id="4-1-字符串的定义"><a href="#4-1-字符串的定义" class="headerlink" title="4.1 字符串的定义"></a>4.1 字符串的定义</h3><ul><li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li><li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串<ul><li>虽然可以使用 <code>\&quot;</code> 或者 <code>\&#39;</code> 做字符串的转义，但是在实际开发中：<ul><li>如果字符串内部需要使用 <code>&quot;</code>，可以使用 <code>&#39;</code> 定义字符串</li><li>如果字符串内部需要使用 <code>&#39;</code>，可以使用 <code>&quot;</code> 定义字符串</li></ul></li></ul></li><li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li><li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li></ul><blockquote><p>大多数编程语言都是用 <code>&quot;</code> 来定义字符串</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python">string <span class="token operator">=</span> <span class="token string">"Hello Python"</span><span class="token keyword">for</span> c <span class="token keyword">in</span> string<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030312.png" alt="005_字符串示意图-w500" loading="lazy"></p><h3 id="4-2-字符串的常用操作"><a href="#4-2-字符串的常用操作" class="headerlink" title="4.2 字符串的常用操作"></a>4.2 字符串的常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = &quot;&quot;</code></li><li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">In [1]: hello_str.hello_str.capitalize    hello_str.isidentifier  hello_str.rindexhello_str.casefold      hello_str.islower       hello_str.rjusthello_str.center        hello_str.isnumeric     hello_str.rpartitionhello_str.count         hello_str.isprintable   hello_str.rsplithello_str.encode        hello_str.isspace       hello_str.rstriphello_str.endswith      hello_str.istitle       hello_str.splithello_str.expandtabs    hello_str.isupper       hello_str.splitlineshello_str.find          hello_str.join          hello_str.startswithhello_str.format        hello_str.ljust         hello_str.striphello_str.format_map    hello_str.lower         hello_str.swapcasehello_str.index         hello_str.lstrip        hello_str.titlehello_str.isalnum       hello_str.maketrans     hello_str.translatehello_str.isalpha       hello_str.partition     hello_str.upperhello_str.isdecimal     hello_str.replace       hello_str.zfillhello_str.isdigit       hello_str.rfind<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p></blockquote><h4 id="1-判断类型-9"><a href="#1-判断类型-9" class="headerlink" title="1) 判断类型 - 9"></a>1) 判断类型 - 9</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True</td></tr><tr><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td></tr><tr><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr><td>string.isdecimal()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code></td></tr><tr><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td></tr><tr><td>string.isnumeric()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td>string.istitle()</td><td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td></tr><tr><td>string.islower()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td></tr><tr><td>string.isupper()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td></tr></tbody></table><h4 id="2-查找和替换-7"><a href="#2-查找和替换-7" class="headerlink" title="2) 查找和替换 - 7"></a>2) 查找和替换 - 7</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.startswith(str)</td><td>检查字符串是否是以 str 开头，是则返回 True</td></tr><tr><td>string.endswith(str)</td><td>检查字符串是否是以 str 结束，是则返回 True</td></tr><tr><td>string.find(str, start&#x3D;0, end&#x3D;len(string))</td><td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td></tr><tr><td>string.rfind(str, start&#x3D;0, end&#x3D;len(string))</td><td>类似于 find()，不过是从右边开始查找</td></tr><tr><td>string.index(str, start&#x3D;0, end&#x3D;len(string))</td><td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td></tr><tr><td>string.rindex(str, start&#x3D;0, end&#x3D;len(string))</td><td>类似于 index()，不过是从右边开始</td></tr><tr><td>string.replace(old_str, new_str, num&#x3D;string.count(old))</td><td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td></tr></tbody></table><h4 id="3-大小写转换-5"><a href="#3-大小写转换-5" class="headerlink" title="3) 大小写转换 - 5"></a>3) 大小写转换 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.title()</td><td>把字符串的每个单词首字母大写</td></tr><tr><td>string.lower()</td><td>转换 string 中所有大写字符为小写</td></tr><tr><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr></tbody></table><h4 id="4-文本对齐-3"><a href="#4-文本对齐-3" class="headerlink" title="4) 文本对齐 - 3"></a>4) 文本对齐 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td></tr></tbody></table><h4 id="5-去除空白字符-3"><a href="#5-去除空白字符-3" class="headerlink" title="5) 去除空白字符 - 3"></a>5) 去除空白字符 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.lstrip()</td><td>截掉 string 左边（开始）的空白字符</td></tr><tr><td>string.rstrip()</td><td>截掉 string 右边（末尾）的空白字符</td></tr><tr><td>string.strip()</td><td>截掉 string 左右两边的空白字符</td></tr></tbody></table><h4 id="6-拆分和连接-5"><a href="#6-拆分和连接-5" class="headerlink" title="6) 拆分和连接 - 5"></a>6) 拆分和连接 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.partition(str)</td><td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td></tr><tr><td>string.rpartition(str)</td><td>类似于 partition() 方法，不过是从右边开始查找</td></tr><tr><td>string.split(str&#x3D;””, num)</td><td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td></tr><tr><td>string.splitlines()</td><td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table><h3 id="4-3-字符串的切片"><a href="#4-3-字符串的切片" class="headerlink" title="4.3 字符串的切片"></a>4.3 字符串的切片</h3><ul><li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030313.png" alt="006_字符串索引示意图" loading="lazy"></p><pre class="line-numbers language-none"><code class="language-none">字符串[开始索引:结束索引:步长]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：</p><ol><li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> &#x3D;&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul><li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li></ul></li><li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li></ol><h4 id="索引的顺序和倒序"><a href="#索引的顺序和倒序" class="headerlink" title="索引的顺序和倒序"></a>索引的顺序和倒序</h4><ul><li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong></li><li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul><li>最右边的索引值是 <strong>-1</strong>，依次递减</li></ul></li></ul><p><strong>演练需求</strong></p><ul><li><ol><li>截取从 2 ~ 5 位置 的字符串</li></ol></li><li><ol start="2"><li>截取从 2 ~ <code>末尾</code> 的字符串</li></ol></li><li><ol start="3"><li>截取从 <code>开始</code> ~ 5 位置 的字符串</li></ol></li><li><ol start="4"><li>截取完整的字符串</li></ol></li><li><ol start="5"><li>从开始位置，每隔一个字符截取字符串</li></ol></li><li><ol start="6"><li>从索引 1 开始，每隔一个取一个</li></ol></li><li><ol start="7"><li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li></ol></li><li><ol start="8"><li>截取字符串末尾两个字符</li></ol></li><li><ol start="9"><li>字符串的逆序（面试题）</li></ol></li></ul><p><strong>答案</strong></p><pre class="line-numbers language-none"><code class="language-none">num_str &#x3D; &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])# 2. 截取从 2 ~ &#96;末尾&#96; 的字符串print(num_str[2:])# 3. 截取从 &#96;开始&#96; ~ 5 位置 的字符串print(num_str[:6])# 4. 截取完整的字符串print(num_str[:])# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])# 7. 截取从 2 ~ &#96;末尾 - 1&#96; 的字符串print(num_str[2:-1])# 8. 截取字符串末尾两个字符print(num_str[-2:])# 9. 字符串的逆序（面试题）print(num_str[::-1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="05-公共方法"><a href="#05-公共方法" class="headerlink" title="05. 公共方法"></a>05. 公共方法</h2><h3 id="5-1-Python-内置函数"><a href="#5-1-Python-内置函数" class="headerlink" title="5.1 Python 内置函数"></a>5.1 Python 内置函数</h3><p>Python 包含了以下内置函数：</p><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del 有两种方式</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>cmp(item1, item2)</td><td>比较两个值，-1 小于&#x2F;0 相等&#x2F;1 大于</td><td>Python 3.x 取消了 cmp 函数</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li></ul><h3 id="5-2-切片"><a href="#5-2-切片" class="headerlink" title="5.2 切片"></a>5.2 切片</h3><p>| 描述 | Python 表达式 | 结果 | 支持的数据类型 |<br>| :—: | — | — | — | — |<br>| 切片 | “0123456789”[::-2] | “97531” | 字符串、列表、元组 |</p><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul><h3 id="5-3-运算符"><a href="#5-3-运算符" class="headerlink" title="5.3 运算符"></a>5.3 运算符</h3><table><thead><tr><th align="center">运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr><td align="center">+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td align="center">*</td><td>[“Hi!”] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td align="center">in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">&gt; &gt;&#x3D; &#x3D;&#x3D; &lt; &lt;&#x3D;</td><td>(1, 2, 3) &lt; (2, 2, 3)</td><td>True</td><td>元素比较</td><td>字符串、列表、元组</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li><li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False</td><td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False</td><td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td></tr></tbody></table><p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p><h3 id="5-4-完整的-for-循环语法"><a href="#5-4-完整的-for-循环语法" class="headerlink" title="5.4 完整的 for 循环语法"></a>5.4 完整的 for 循环语法</h3><ul><li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> 变量 <span class="token keyword">in</span> 集合<span class="token punctuation">:</span>        循环体代码<span class="token keyword">else</span><span class="token punctuation">:</span>    没有通过 <span class="token keyword">break</span> 退出循环，循环结束后，会执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></li><li>需求：要判断 某一个字典中 是否存在 指定的 值 <ul><li>如果 <strong>存在</strong>，提示并且退出循环</li><li>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">students <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"阿土"</span><span class="token punctuation">,</span>     <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>     <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>     <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">1.7</span><span class="token punctuation">,</span>     <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">75.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小美"</span><span class="token punctuation">,</span>     <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">19</span><span class="token punctuation">,</span>     <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token boolean">False</span><span class="token punctuation">,</span>     <span class="token string">"height"</span><span class="token punctuation">:</span> <span class="token number">1.6</span><span class="token punctuation">,</span>     <span class="token string">"weight"</span><span class="token punctuation">:</span> <span class="token number">45.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span>find_name <span class="token operator">=</span> <span class="token string">"阿土"</span><span class="token keyword">for</span> stu_dict <span class="token keyword">in</span> students<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>stu_dict<span class="token punctuation">)</span>    <span class="token comment"># 判断当前遍历的字典中姓名是否为find_name</span>    <span class="token keyword">if</span> stu_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">==</span> find_name<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"找到了"</span><span class="token punctuation">)</span>        <span class="token comment"># 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较</span>        <span class="token keyword">break</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有找到"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"循环结束"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="综合应用-——-名片管理系统"><a href="#综合应用-——-名片管理系统" class="headerlink" title="综合应用 —— 名片管理系统"></a>综合应用 —— 名片管理系统</h1><h2 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h2><p>综合应用已经学习过的知识点：</p><ul><li><strong>变量</strong></li><li><strong>流程控制</strong></li><li><strong>函数</strong></li><li><strong>模块</strong></li></ul><p>开发 <strong>名片管理系统</strong></p><h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><ul><li><ol><li>程序启动，显示名片管理系统欢迎界面，并显示功能菜单</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">**************************************************欢迎使用【名片管理系统】V1.01. 新建名片2. 显示全部3. 查询名片0. 退出系统**************************************************<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><ol start="2"><li>用户用数字选择不同的功能</li></ol></li><li><ol start="3"><li>根据功能选择，执行不同的功能</li></ol></li><li><ol start="4"><li>用户名片需要记录用户的 <strong>姓名</strong>、<strong>电话</strong>、<strong>QQ</strong>、<strong>邮件</strong></li></ol></li><li><ol start="5"><li>如果查询到指定的名片，用户可以选择 <strong>修改</strong> 或者 <strong>删除</strong> 名片</li></ol></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>框架搭建</li><li>新增名片</li><li>显示所有名片</li><li>查询名片</li><li>查询成功后修改、删除名片</li><li>让 Python 程序能够直接运行</li></ol><h2 id="01-框架搭建"><a href="#01-框架搭建" class="headerlink" title="01. 框架搭建"></a>01. 框架搭建</h2><p><strong>目标</strong></p><ul><li>搭建名片管理系统 <strong>框架结构</strong><ol><li><strong>准备文件</strong>，确定文件名，保证能够 <strong>在需要的位置</strong> 编写代码</li><li>编写 <strong>主运行循环</strong>，实现基本的 <strong>用户输入和判断</strong></li></ol></li></ul><h3 id="1-1-文件准备"><a href="#1-1-文件准备" class="headerlink" title="1.1 文件准备"></a>1.1 文件准备</h3><ol><li>新建 <code>cards_main.py</code> 保存 <strong>主程序功能代码</strong><ul><li>程序的入口</li><li>每一次启动名片管理系统都通过 <code>main</code> 这个文件启动</li></ul></li><li>新建 <code>cards_tools.py</code> 保存 <strong>所有名片功能函数</strong><ul><li>将对名片的 <strong>新增</strong>、<strong>查询</strong>、<strong>修改</strong>、<strong>删除</strong> 等功能封装在不同的函数中</li></ul></li></ol><h3 id="1-2-编写主运行循环"><a href="#1-2-编写主运行循环" class="headerlink" title="1.2 编写主运行循环"></a>1.2 编写主运行循环</h3><ul><li>在 <code>cards_main</code> 中添加一个 <strong>无限循环</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    <span class="token comment"># TODO(小明) 显示系统菜单</span>    action <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请选择操作功能："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"您选择的操作是：%s"</span> <span class="token operator">%</span> action<span class="token punctuation">)</span>    <span class="token comment"># 根据用户输入决定后续的操作</span>    <span class="token keyword">if</span> action <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"0"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欢迎再次使用【名片管理系统】"</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输入错误，请重新输入"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> action <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span> <span class="token keyword">or</span> action <span class="token operator">==</span> <span class="token string">"2"</span> <span class="token keyword">or</span> action <span class="token operator">==</span> <span class="token string">"3"</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>使用 <code>in</code> 针对 <strong>列表</strong> 判断，避免使用 <code>or</code> 拼接复杂的逻辑条件</li><li>没有使用 <code>int</code> 转换用户输入，可以避免 <strong>一旦用户输入的不是数字</strong>，导致程序运行出错</li></ol><h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><ul><li><code>pass</code> 就是一个空语句，不做任何事情，一般用做占位语句</li><li>是为了保持程序结构的完整性</li></ul><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><ul><li>在开发软件时，如果 <strong>不希望程序执行后</strong> 立即退出</li><li>可以在程序中增加一个 <strong>无限循环</strong></li><li><strong>由用户来决定</strong> 退出程序的时机</li></ul><h4 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h4><ul><li>在 <code>#</code> 后跟上 <code>TODO</code>，用于标记需要去做的工作</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># TODO(作者/邮件) 显示系统菜单</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-在-cards-tools-中增加四个新函数"><a href="#1-3-在-cards-tools-中增加四个新函数" class="headerlink" title="1.3 在 cards_tools 中增加四个新函数"></a>1.3 在 <code>cards_tools</code> 中增加四个新函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示菜单    """</span>    <span class="token keyword">pass</span><span class="token keyword">def</span> <span class="token function">new_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""新建名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：新建名片"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">search_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""搜索名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：搜索名片"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-导入模块"><a href="#1-4-导入模块" class="headerlink" title="1.4 导入模块"></a>1.4 导入模块</h3><ul><li>在 <code>cards_main.py</code> 中使用 <code>import</code> 导入 <code>cards_tools</code> 模块</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cards_tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改 <code>while</code> 循环的代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cards_tools<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    cards_tools<span class="token punctuation">.</span>show_menu<span class="token punctuation">(</span><span class="token punctuation">)</span>    action <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请选择操作功能："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"您选择的操作是：%s"</span> <span class="token operator">%</span> action<span class="token punctuation">)</span>    <span class="token comment"># 根据用户输入决定后续的操作</span>    <span class="token keyword">if</span> action <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>            cards_tools<span class="token punctuation">.</span>new_card<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>            cards_tools<span class="token punctuation">.</span>show_all<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"3"</span><span class="token punctuation">:</span>            cards_tools<span class="token punctuation">.</span>search_card<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"0"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欢迎再次使用【名片管理系统】"</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输入错误，请重新输入："</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>至此：<code>cards_main</code> 中的所有代码全部开发完毕！</p></blockquote><h3 id="1-5-完成-show-menu-函数"><a href="#1-5-完成-show-menu-函数" class="headerlink" title="1.5 完成 show_menu 函数"></a>1.5 完成 <code>show_menu</code> 函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示菜单    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"欢迎使用【菜单管理系统】V1.0"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"1. 新建名片"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2. 显示全部"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"3. 查询名片"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"0. 退出系统"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-保存名片数据的结构"><a href="#02-保存名片数据的结构" class="headerlink" title="02. 保存名片数据的结构"></a>02. 保存名片数据的结构</h2><p><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></p><ul><li>使用 <strong>字典</strong> 记录 <strong>每一张名片</strong> 的详细信息</li><li>使用 <strong>列表</strong> 统一记录所有的 <strong>名片字典</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127030350.png" alt="001_名片管理系统全局列表-w500" loading="lazy"></p><h3 id="定义名片列表变量"><a href="#定义名片列表变量" class="headerlink" title="定义名片列表变量"></a>定义名片列表变量</h3><ul><li>在 <code>cards_tools</code> 文件的顶部增加一个 <strong>列表变量</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 所有名片记录的列表</span>card_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li><strong>所有名片相关操作</strong>，都需要使用这个列表，所以应该 <strong>定义在程序的顶部</strong></li><li><strong>程序刚运行时，没有数据</strong>，所以是 <strong>空列表</strong></li></ol><h2 id="03-新增名片"><a href="#03-新增名片" class="headerlink" title="03. 新增名片"></a>03. 新增名片</h2><h3 id="3-1-功能分析"><a href="#3-1-功能分析" class="headerlink" title="3.1 功能分析"></a>3.1 功能分析</h3><ol><li>提示用户依次输入名片信息</li><li>将名片信息保存到一个字典</li><li>将字典添加到名片列表</li><li>提示名片添加完成</li></ol><h3 id="3-2-实现-new-card-方法"><a href="#3-2-实现-new-card-方法" class="headerlink" title="3.2 实现 new_card 方法"></a>3.2 实现 new_card 方法</h3><ul><li>根据步骤实现代码</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">new_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""新建名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：新建名片"</span><span class="token punctuation">)</span>    <span class="token comment"># 1. 提示用户输入名片信息</span>    name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入姓名："</span><span class="token punctuation">)</span>    phone <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入电话："</span><span class="token punctuation">)</span>    qq <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入 QQ 号码："</span><span class="token punctuation">)</span>    email <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入邮箱："</span><span class="token punctuation">)</span>    <span class="token comment"># 2. 将用户信息保存到一个字典</span>    card_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> name<span class="token punctuation">,</span>                 <span class="token string">"phone"</span><span class="token punctuation">:</span> phone<span class="token punctuation">,</span>                 <span class="token string">"qq"</span><span class="token punctuation">:</span> qq<span class="token punctuation">,</span>                 <span class="token string">"email"</span><span class="token punctuation">:</span> email<span class="token punctuation">&#125;</span>    <span class="token comment"># 3. 将用户字典添加到名片列表</span>    card_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>card_dict<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>card_list<span class="token punctuation">)</span>        <span class="token comment"># 4. 提示添加成功信息</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"成功添加 %s 的名片"</span> <span class="token operator">%</span> card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>技巧：在 <code>PyCharm</code> 中，可以使用 <code>SHIFT + F6</code> 统一修改变量名</p></blockquote><h2 id="04-显示所有名片"><a href="#04-显示所有名片" class="headerlink" title="04. 显示所有名片"></a>04. 显示所有名片</h2><h3 id="4-1-功能分析"><a href="#4-1-功能分析" class="headerlink" title="4.1 功能分析"></a>4.1 功能分析</h3><ul><li>循环遍历名片列表，顺序显示每一个字典的信息</li></ul><h3 id="4-2-基础代码实现"><a href="#4-2-基础代码实现" class="headerlink" title="4.2 基础代码实现"></a>4.2 基础代码实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> card_dict <span class="token keyword">in</span> card_list<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>card_dict<span class="token punctuation">)</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>显示效果不好！</li></ul><h3 id="4-3-增加标题和使用-t-显示"><a href="#4-3-增加标题和使用-t-显示" class="headerlink" title="4.3 增加标题和使用 \t 显示"></a>4.3 增加标题和使用 <code>\t</code> 显示</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span>    <span class="token comment"># 打印表头</span>    <span class="token keyword">for</span> name <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"姓名"</span><span class="token punctuation">,</span> <span class="token string">"电话"</span><span class="token punctuation">,</span> <span class="token string">"QQ"</span><span class="token punctuation">,</span> <span class="token string">"邮箱"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"\t\t"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token comment"># 打印分隔线</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"="</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> card_dict <span class="token keyword">in</span> card_list<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s\t\t%s\t\t%s\t\t%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                        card_dict<span class="token punctuation">[</span><span class="token string">"phone"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                        card_dict<span class="token punctuation">[</span><span class="token string">"qq"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                        card_dict<span class="token punctuation">[</span><span class="token string">"email"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-增加没有名片记录判断"><a href="#4-4-增加没有名片记录判断" class="headerlink" title="4.4 增加没有名片记录判断"></a>4.4 增加没有名片记录判断</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示全部    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：显示全部"</span><span class="token punctuation">)</span>    <span class="token comment"># 1. 判断是否有名片记录</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>card_list<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"提示：没有任何名片记录"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>在函数中使用 <code>return</code> 表示返回</li><li>如果在 <code>return</code> 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码</li></ul><h2 id="05-查询名片"><a href="#05-查询名片" class="headerlink" title="05. 查询名片"></a>05. 查询名片</h2><h3 id="5-1-功能分析"><a href="#5-1-功能分析" class="headerlink" title="5.1 功能分析"></a>5.1 功能分析</h3><ol><li>提示用户要搜索的姓名</li><li>根据用户输入的姓名遍历列表</li><li>搜索到指定的名片后，再执行后续的操作</li></ol><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><ul><li>查询功能实现</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">search_card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""搜索名片    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"功能：搜索名片"</span><span class="token punctuation">)</span>    <span class="token comment"># 1. 提示要搜索的姓名</span>    find_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入要搜索的姓名："</span><span class="token punctuation">)</span>    <span class="token comment"># 2. 遍历字典</span>    <span class="token keyword">for</span> card_dict <span class="token keyword">in</span> card_list<span class="token punctuation">:</span>        <span class="token keyword">if</span> card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">==</span> find_name<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"姓名\t\t\t电话\t\t\tQQ\t\t\t邮箱"</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">40</span><span class="token punctuation">)</span>                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s\t\t\t%s\t\t\t%s\t\t\t%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>                card_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                card_dict<span class="token punctuation">[</span><span class="token string">"phone"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                card_dict<span class="token punctuation">[</span><span class="token string">"qq"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                card_dict<span class="token punctuation">[</span><span class="token string">"email"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">40</span><span class="token punctuation">)</span>                        <span class="token comment"># TODO(小明) 针对找到的字典进行后续操作：修改/删除</span>            <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"没有找到 %s"</span> <span class="token operator">%</span> find_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>增加名片操作函数：<strong>修改</strong>&#x2F;<strong>删除</strong>&#x2F;<strong>返回主菜单</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deal_card</span><span class="token punctuation">(</span>find_dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""操作搜索到的名片字典    :param find_dict:找到的名片字典    """</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>find_dict<span class="token punctuation">)</span>    action_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请选择要执行的操作 "</span>                       <span class="token string">"[1] 修改 [2] 删除 [0] 返回上级菜单"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改"</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"删除"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="06-修改和删除"><a href="#06-修改和删除" class="headerlink" title="06. 修改和删除"></a>06. 修改和删除</h2><h3 id="6-1-查询成功后删除名片"><a href="#6-1-查询成功后删除名片" class="headerlink" title="6.1 查询成功后删除名片"></a>6.1 查询成功后删除名片</h3><ul><li>由于找到的字典记录已经在列表中保存</li><li>要删除名片记录，只需要把列表中对应的字典删除即可</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">"2"</span><span class="token punctuation">:</span>    card_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>find_dict<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"删除成功"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-修改名片"><a href="#6-2-修改名片" class="headerlink" title="6.2 修改名片"></a>6.2 修改名片</h3><ul><li>由于找到的字典记录已经在列表中保存</li><li>要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">"1"</span><span class="token punctuation">:</span>    find_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入姓名："</span><span class="token punctuation">)</span>    find_dict<span class="token punctuation">[</span><span class="token string">"phone"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入电话："</span><span class="token punctuation">)</span>    find_dict<span class="token punctuation">[</span><span class="token string">"qq"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入QQ："</span><span class="token punctuation">)</span>    find_dict<span class="token punctuation">[</span><span class="token string">"email"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入邮件："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 的名片修改成功"</span> <span class="token operator">%</span> find_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改名片细化"><a href="#修改名片细化" class="headerlink" title="修改名片细化"></a>修改名片细化</h4><ul><li><strong>如果用户在使用时，某些名片内容并不想修改</strong>，应该如何做呢？—— 既然系统提供的 <code>input</code> 函数不能满足需求，那么就新定义一个函数 <code>input_card_info</code> 对系统的 <code>input</code> 函数进行扩展</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">input_card_info</span><span class="token punctuation">(</span>dict_value<span class="token punctuation">,</span> tip_message<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""输入名片信息    :param dict_value: 字典原有值    :param tip_message: 输入提示信息    :return: 如果输入，返回输入内容，否则返回字典原有值    """</span>    <span class="token comment"># 1. 提示用户输入内容</span>    result_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span>tip_message<span class="token punctuation">)</span>    <span class="token comment"># 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>result_str<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> result_str    <span class="token comment"># 3. 如果用户没有输入内容，返回 `字典中原有的值`</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dict_value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="07-LINUX-上的-Shebang-符号"><a href="#07-LINUX-上的-Shebang-符号" class="headerlink" title="07. LINUX 上的 Shebang 符号(#!)"></a>07. LINUX 上的 <code>Shebang</code> 符号(<code>#!</code>)</h2><ul><li><code>#!</code>这个符号叫做 <code>Shebang</code> 或者 <code>Sha-bang</code></li><li><code>Shebang</code> 通常在 <code>Unix</code> 系统脚本的中 <strong>第一行开头</strong> 使用</li><li>指明 <strong>执行这个脚本文件</strong> 的 <strong>解释程序</strong></li></ul><h3 id="使用-Shebang-的步骤"><a href="#使用-Shebang-的步骤" class="headerlink" title="使用 Shebang 的步骤"></a>使用 Shebang 的步骤</h3><ul><li><ol><li>使用 <code>which</code> 查询 <code>python3</code> 解释器所在路径</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">which</span> python3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="2"><li>修改要运行的 <strong>主 python 文件</strong>，在第一行增加以下内容</li></ol></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#! /usr/bin/python3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="3"><li>修改 <strong>主 python 文件</strong> 的文件权限，增加执行权限</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">chmod</span> +x cards_main.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><ol start="4"><li>在需要时执行程序即可</li></ol></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./cards_main.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="变量进阶（理解）"><a href="#变量进阶（理解）" class="headerlink" title="变量进阶（理解）"></a>变量进阶（理解）</h1><h2 id="目标-16"><a href="#目标-16" class="headerlink" title="目标"></a>目标</h2><ul><li>变量的引用</li><li>可变和不可变类型</li><li>局部变量和全局变量</li></ul><h2 id="01-变量的引用"><a href="#01-变量的引用" class="headerlink" title="01. 变量的引用"></a>01. 变量的引用</h2><blockquote><ul><li>变量 和 数据 都是保存在 <strong>内存</strong> 中的</li><li>在 <code>Python</code> 中 <strong>函数 的 参数传递</strong> 以及 <strong>返回值</strong> 都是靠 <strong>引用</strong> 传递的</li></ul></blockquote><h3 id="1-1-引用的概念"><a href="#1-1-引用的概念" class="headerlink" title="1.1 引用的概念"></a>1.1 引用的概念</h3><p>在 <code>Python</code> 中</p><ul><li><strong>变量</strong> 和 <strong>数据</strong> 是分开存储的</li><li><strong>数据</strong> 保存在内存中的一个位置</li><li><strong>变量</strong> 中保存着数据在内存中的地址</li><li><strong>变量</strong> 中 <strong>记录数据的地址</strong>，就叫做 <strong>引用</strong></li><li>使用 <code>id()</code> 函数可以查看变量中保存数据所在的 <strong>内存地址</strong></li></ul><blockquote><p>注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 <strong>修改了数据的引用</strong></p><ul><li>变量 <strong>不再</strong> 对之前的数据引用</li><li>变量 <strong>改为</strong> 对新赋值的数据引用</li></ul></blockquote><h3 id="1-2-变量引用-的示例"><a href="#1-2-变量引用-的示例" class="headerlink" title="1.2 变量引用 的示例"></a>1.2 <code>变量引用</code> 的示例</h3><p>在 <code>Python</code> 中，变量的名字类似于 <strong>便签纸</strong> 贴在 <strong>数据</strong> 上</p><ul><li>定义一个整数变量 <code>a</code>，并且赋值为 <code>1</code></li></ul><table><thead><tr><th align="center">代码</th><th align="center">图示</th></tr></thead><tbody><tr><td align="center">a &#x3D; 1</td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021307.png" alt="004_a1tag" loading="lazy"></td></tr></tbody></table><ul><li>将变量 <code>a</code> 赋值为 <code>2</code></li></ul><table><thead><tr><th align="center">代码</th><th align="center">图示</th></tr></thead><tbody><tr><td align="center">a &#x3D; 2</td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021308.png" alt="005_a2tag" loading="lazy"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021309.png" alt="005_1" loading="lazy"></td></tr></tbody></table><ul><li>定义一个整数变量 <code>b</code>，并且将变量 <code>a</code> 的值赋值给 <code>b</code></li></ul><table><thead><tr><th align="center">代码</th><th align="center">图示</th></tr></thead><tbody><tr><td align="center">b &#x3D; a</td><td align="center"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021310.png" alt="006_ab2tag" loading="lazy"></td></tr></tbody></table><blockquote><p>变量 <code>b</code> 是第 2 个贴在数字 <code>2</code> 上的标签</p></blockquote><h3 id="1-3-函数的参数和返回值的传递"><a href="#1-3-函数的参数和返回值的传递" class="headerlink" title="1.3 函数的参数和返回值的传递"></a>1.3 函数的参数和返回值的传递</h3><p>在 <code>Python</code> 中，函数的 <strong>实参</strong>&#x2F;<strong>返回值</strong> 都是是靠 <strong>引用</strong> 来传递来的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d 在函数内的内存地址是 %x"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"返回值 %d 在内存中的地址是 %x"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">return</span>  resulta <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用函数前 内存地址是 %x"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>r <span class="token operator">=</span> test<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用函数后 实参内存地址是 %x"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用函数后 返回值内存地址是 %x"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-可变和不可变类型"><a href="#02-可变和不可变类型" class="headerlink" title="02. 可变和不可变类型"></a>02. 可变和不可变类型</h2><ul><li><p><strong>不可变类型</strong>，内存中的数据不允许被修改：</p><ul><li>数字类型 <code>int</code>, <code>bool</code>, <code>float</code>, <code>complex</code>, <code>long(2.x)</code></li><li>字符串 <code>str</code></li><li>元组 <code>tuple</code></li></ul></li><li><p><strong>可变类型</strong>，内存中的数据可以被修改：</p><ul><li>列表 <code>list</code></li><li>字典 <code>dict</code></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>a <span class="token operator">=</span> <span class="token string">"hello"</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">demo_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"定义列表后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_list<span class="token punctuation">)</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>demo_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改数据后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_list<span class="token punctuation">)</span><span class="token punctuation">)</span>demo_dict <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小明"</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"定义字典后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_dict<span class="token punctuation">)</span><span class="token punctuation">)</span>demo_dict<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">18</span>demo_dict<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>demo_dict<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"老王"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改数据后的内存地址 %d"</span> <span class="token operator">%</span> <span class="token builtin">id</span><span class="token punctuation">(</span>demo_dict<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：字典的 <code>key</code> <strong>只能使用不可变类型的数据</strong></p></blockquote><p><strong>注意</strong></p><ol><li><strong>可变类型</strong>的数据变化，是通过 <strong>方法</strong> 来实现的</li><li>如果给一个可变类型的变量，赋值了一个新的数据，<strong>引用会修改</strong><ul><li>变量 <strong>不再</strong> 对之前的数据引用</li><li>变量 <strong>改为</strong> 对新赋值的数据引用</li></ul></li></ol><h3 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 (hash)"></a>哈希 <code>(hash)</code></h3><ul><li><code>Python</code> 中内置有一个名字叫做 <code>hash(o)</code> 的函数<ul><li>接收一个 <strong>不可变类型</strong> 的数据作为 <strong>参数</strong></li><li><strong>返回</strong> 结果是一个 <strong>整数</strong></li></ul></li><li><code>哈希</code> 是一种 <strong>算法</strong>，其作用就是提取数据的 <strong>特征码（指纹）</strong><ul><li><strong>相同的内容</strong> 得到 <strong>相同的结果</strong></li><li><strong>不同的内容</strong> 得到 <strong>不同的结果</strong></li></ul></li><li>在 <code>Python</code> 中，设置字典的 <strong>键值对</strong> 时，会首先对 <code>key</code> 进行 <code>hash</code> 已决定如何在内存中保存字典的数据，以方便 <strong>后续</strong> 对字典的操作：<strong>增、删、改、查</strong><ul><li>键值对的 <code>key</code> 必须是不可变类型数据</li><li>键值对的 <code>value</code> 可以是任意类型的数据</li></ul></li></ul><h2 id="03-局部变量和全局变量"><a href="#03-局部变量和全局变量" class="headerlink" title="03. 局部变量和全局变量"></a>03. 局部变量和全局变量</h2><ul><li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li></ul><blockquote><p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p></blockquote><h3 id="3-1-局部变量"><a href="#3-1-局部变量" class="headerlink" title="3.1 局部变量"></a>3.1 局部变量</h3><ul><li><strong>局部变量</strong> 是在 <strong>函数内部</strong> 定义的变量，<strong>只能在函数内部使用</strong></li><li>函数执行结束后，<strong>函数内部的局部变量，会被系统回收</strong></li><li>不同的函数，可以定义相同的名字的局部变量，但是 <strong>彼此之间</strong> 不会产生影响</li></ul><h4 id="局部变量的作用"><a href="#局部变量的作用" class="headerlink" title="局部变量的作用"></a>局部变量的作用</h4><ul><li>在函数内部使用，<strong>临时</strong> 保存 <strong>函数内部需要使用的数据</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    num <span class="token operator">=</span> <span class="token number">20</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"修改后 %d"</span> <span class="token operator">%</span> num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="局部变量的生命周期"><a href="#局部变量的生命周期" class="headerlink" title="局部变量的生命周期"></a>局部变量的生命周期</h4><ul><li>所谓 <strong>生命周期</strong> 就是变量从 <strong>被创建</strong> 到 <strong>被系统回收</strong> 的过程</li><li><strong>局部变量</strong> 在 <strong>函数执行时</strong> 才会被创建</li><li><strong>函数执行结束后</strong> 局部变量 <strong>被系统回收</strong></li><li><strong>局部变量在生命周期</strong> 内，可以用来存储 <strong>函数内部临时使用到的数据</strong></li></ul><h3 id="3-2-全局变量"><a href="#3-2-全局变量" class="headerlink" title="3.2 全局变量"></a>3.2 全局变量</h3><ul><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量，所有函数内部都可以使用这个变量</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义一个全局变量</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：函数执行时，<strong>需要处理变量时</strong> 会：</p><ol><li><strong>首先</strong> 查找 <strong>函数内部</strong> 是否存在 <strong>指定名称 的局部变量</strong>，<strong>如果有，直接使用</strong></li><li>如果没有，查找 <strong>函数外部</strong> 是否存在 <strong>指定名称 的全局变量</strong>，<strong>如果有，直接使用</strong></li><li>如果还没有，程序报错！</li></ol><h4 id="1-函数不能直接修改-全局变量的引用"><a href="#1-函数不能直接修改-全局变量的引用" class="headerlink" title="1) 函数不能直接修改 全局变量的引用"></a>1) 函数不能直接修改 <code>全局变量的引用</code></h4><ul><li><strong>全局变量</strong> 是在 <strong>函数外部定义</strong> 的变量（没有定义在某一个函数内），<strong>所有函数</strong> 内部 <strong>都可以使用这个变量</strong></li></ul><blockquote><p>提示：在其他的开发语言中，大多 <strong>不推荐使用全局变量</strong> —— 可变范围太大，导致程序不好维护！</p></blockquote><ul><li>在函数内部，可以 <strong>通过全局变量的引用获取对应的数据</strong></li><li>但是，<strong>不允许直接修改全局变量的引用</strong> —— 使用赋值语句修改全局变量的值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">num <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo1"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span>    num <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo2"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值</p></blockquote><h4 id="2-在函数内部修改全局变量的值"><a href="#2-在函数内部修改全局变量的值" class="headerlink" title="2) 在函数内部修改全局变量的值"></a>2) 在函数内部修改全局变量的值</h4><ul><li>如果在函数中需要修改全局变量，需要使用 <code>global</code> 进行声明</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">num <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo1"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token comment"># global 关键字，告诉 Python 解释器 num 是一个全局变量</span>    <span class="token keyword">global</span> num    <span class="token comment"># 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已</span>    num <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"demo2"</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>demo1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-全局变量定义的位置"><a href="#3-全局变量定义的位置" class="headerlink" title="3) 全局变量定义的位置"></a>3) 全局变量定义的位置</h4><ul><li>为了保证所有的函数都能够正确使用到全局变量，应该 <strong>将全局变量定义在其他函数的上方</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token operator">%</span> a<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token operator">%</span> b<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%d"</span> <span class="token operator">%</span> c<span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token number">20</span>demo<span class="token punctuation">(</span><span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token number">30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ul><li>由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！</li></ul><p><strong>代码结构示意图如下</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127021311.png" alt="001_代码结构示意图-w240" loading="lazy"></p><h4 id="4-全局变量命名的建议"><a href="#4-全局变量命名的建议" class="headerlink" title="4) 全局变量命名的建议"></a>4) 全局变量命名的建议</h4><ul><li>为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：</li><li>全局变量名前应该增加 <code>g_</code> 或者 <code>gl_</code> 的前缀</li></ul><blockquote><p>提示：具体的要求格式，各公司要求可能会有些差异</p></blockquote><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="目标-17"><a href="#目标-17" class="headerlink" title="目标"></a>目标</h2><ul><li>函数参数和返回值的作用</li><li>函数的返回值 进阶</li><li>函数的参数 进阶</li><li>递归函数</li></ul><h2 id="01-函数参数和返回值的作用"><a href="#01-函数参数和返回值的作用" class="headerlink" title="01. 函数参数和返回值的作用"></a>01. 函数参数和返回值的作用</h2><p>函数根据 <strong>有没有参数</strong> 以及 <strong>有没有返回值</strong>，可以 <strong>相互组合</strong>，一共有 <strong>4 种</strong> 组合形式</p><ol><li>无参数，无返回值</li><li>无参数，有返回值</li><li>有参数，无返回值</li><li>有参数，有返回值</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127023303.png" alt="001_函数参数和返回值" loading="lazy"></p><blockquote><p>定义函数时，<strong>是否接收参数，或者是否返回结果</strong>，是根据 <strong>实际的功能需求</strong> 来决定的！</p></blockquote><ol><li>如果函数 <strong>内部处理的数据不确定</strong>，就可以将外界的数据以参数传递到函数内部</li><li>如果希望一个函数 <strong>执行完成后，向外界汇报执行结果</strong>，就可以增加函数的返回值</li></ol><h3 id="1-1-无参数，无返回值"><a href="#1-1-无参数，无返回值" class="headerlink" title="1.1 无参数，无返回值"></a>1.1 无参数，无返回值</h3><p>此类函数，不接收参数，也没有返回值，应用场景如下：</p><ol><li><strong>只是单纯地做一件事情</strong>，例如 <strong>显示菜单</strong></li><li>在函数内部 <strong>针对全局变量进行操作</strong>，例如：<strong>新建名片</strong>，最终结果 <strong>记录在全局变量</strong> 中</li></ol><blockquote><p>注意：</p></blockquote><ul><li>如果全局变量的数据类型是一个 <strong>可变类型</strong>，在函数内部可以使用 <strong>方法</strong> 修改全局变量的内容 —— <strong>变量的引用不会改变</strong></li><li>在函数内部，<strong>使用赋值语句</strong> 才会 <strong>修改变量的引用</strong></li></ul><h3 id="1-2-无参数，有返回值"><a href="#1-2-无参数，有返回值" class="headerlink" title="1.2 无参数，有返回值"></a>1.2 无参数，有返回值</h3><p>此类函数，不接收参数，但是有返回值，应用场景如下：</p><ul><li>采集数据，例如 <strong>温度计</strong>，返回结果就是当前的温度，而不需要传递任何的参数</li></ul><h3 id="1-3-有参数，无返回值"><a href="#1-3-有参数，无返回值" class="headerlink" title="1.3 有参数，无返回值"></a>1.3 有参数，无返回值</h3><p>此类函数，接收参数，没有返回值，应用场景如下：</p><ul><li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong></li><li>例如 <strong>名片管理系统</strong> 针对 <strong>找到的名片</strong> 做 <strong>修改</strong>、<strong>删除</strong> 操作</li></ul><h3 id="1-4-有参数，有返回值"><a href="#1-4-有参数，有返回值" class="headerlink" title="1.4 有参数，有返回值"></a>1.4 有参数，有返回值</h3><p>此类函数，接收参数，同时有返回值，应用场景如下：</p><ul><li>函数内部的代码保持不变，针对 <strong>不同的参数 处理 不同的数据</strong>，并且 <strong>返回期望的处理结果</strong></li><li>例如 <strong>名片管理系统</strong> 使用 <strong>字典默认值</strong> 和 <strong>提示信息</strong> 提示用户输入内容<ul><li>如果输入，返回输入内容</li><li>如果没有输入，返回字典默认值</li></ul></li></ul><h2 id="02-函数的返回值-进阶"><a href="#02-函数的返回值-进阶" class="headerlink" title="02. 函数的返回值 进阶"></a>02. 函数的返回值 进阶</h2><ul><li>在程序开发中，有时候，会希望 <strong>一个函数执行结束后，告诉调用者一个结果</strong>，以便调用者针对具体的结果做后续的处理</li><li><strong>返回值</strong> 是函数 <strong>完成工作</strong>后，<strong>最后</strong> 给调用者的 <strong>一个结果</strong></li><li>在函数中使用 <code>return</code> 关键字可以返回结果</li><li>调用函数一方，可以 <strong>使用变量</strong> 来 <strong>接收</strong> 函数的返回结果</li></ul><blockquote><p>问题：一个函数执行后能否返回多个结果？</p></blockquote><h3 id="示例-——-温度和湿度测量"><a href="#示例-——-温度和湿度测量" class="headerlink" title="示例 —— 温度和湿度测量"></a>示例 —— 温度和湿度测量</h3><ul><li>假设要开发一个函数能够同时返回当前的温度和湿度</li><li><strong>先完成返回温度</strong>的功能如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">measure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""返回当前的温度"""</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始测量..."</span><span class="token punctuation">)</span>    temp <span class="token operator">=</span> <span class="token number">39</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测量结束..."</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> tempresult <span class="token operator">=</span> measure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在利用 <strong>元组</strong> 在返回温度的同时，也能够返回 <strong>湿度</strong></li><li>改造如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">measure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""返回当前的温度"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始测量..."</span><span class="token punctuation">)</span>    temp <span class="token operator">=</span> <span class="token number">39</span>    wetness <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测量结束..."</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>temp<span class="token punctuation">,</span> wetness<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：如果一个函数返回的是元组，括号可以省略</p></blockquote><p><strong>技巧</strong> </p><ul><li>在 <code>Python</code> 中，可以 <strong>将一个元组</strong> 使用 <strong>赋值语句</strong> 同时赋值给 <strong>多个变量</strong></li><li>注意：变量的数量需要和元组中的元素数量保持一致</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">result <span class="token operator">=</span> temp<span class="token punctuation">,</span> wetness <span class="token operator">=</span> measure<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="面试题-——-交换两个数字"><a href="#面试题-——-交换两个数字" class="headerlink" title="面试题 —— 交换两个数字"></a>面试题 —— 交换两个数字</h3><p><strong>题目要求</strong></p><ol><li>有两个整数变量 <code>a = 6</code>, <code>b = 100</code></li><li>不使用其他变量，<strong>交换两个变量的值</strong></li></ol><h4 id="解法-1-——-使用其他变量"><a href="#解法-1-——-使用其他变量" class="headerlink" title="解法 1 —— 使用其他变量"></a>解法 1 —— 使用其他变量</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 解法 1 - 使用临时变量</span>c <span class="token operator">=</span> bb <span class="token operator">=</span> aa <span class="token operator">=</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法-2-——-不使用临时变量"><a href="#解法-2-——-不使用临时变量" class="headerlink" title="解法 2 —— 不使用临时变量"></a>解法 2 —— 不使用临时变量</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 解法 2 - 不使用临时变量</span>a <span class="token operator">=</span> a <span class="token operator">+</span> bb <span class="token operator">=</span> a <span class="token operator">-</span> ba <span class="token operator">=</span> a <span class="token operator">-</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法-3-——-Python-专有，利用元组"><a href="#解法-3-——-Python-专有，利用元组" class="headerlink" title="解法 3 —— Python 专有，利用元组"></a>解法 3 —— Python 专有，利用元组</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="03-函数的参数-进阶"><a href="#03-函数的参数-进阶" class="headerlink" title="03. 函数的参数 进阶"></a>03. 函数的参数 进阶</h2><h3 id="3-1-不可变和可变的参数"><a href="#3-1-不可变和可变的参数" class="headerlink" title="3.1. 不可变和可变的参数"></a>3.1. 不可变和可变的参数</h3><blockquote><p>问题 1：在函数内部，针对参数使用 <strong>赋值语句</strong>，会不会影响调用函数时传递的 <strong>实参变量</strong>？ —— 不会！</p></blockquote><ul><li>无论传递的参数是 <strong>可变</strong> 还是 <strong>不可变</strong> <ul><li>只要 <strong>针对参数</strong> 使用 <strong>赋值语句</strong>，会在 <strong>函数内部</strong> 修改 <strong>局部变量的引用</strong>，<strong>不会影响到 外部变量的引用</strong></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数内部"</span><span class="token punctuation">)</span>    <span class="token comment"># 赋值语句</span>    num <span class="token operator">=</span> <span class="token number">200</span>    num_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数代码完成"</span><span class="token punctuation">)</span>gl_num <span class="token operator">=</span> <span class="token number">99</span>gl_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>demo<span class="token punctuation">(</span>gl_num<span class="token punctuation">,</span> gl_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题 2：如果传递的参数是 <strong>可变类型</strong>，在函数内部，使用 <strong>方法</strong> 修改了数据的内容，<strong>同样会影响到外部的数据</strong></p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mutable</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># num_list = [1, 2, 3]</span>    num_list<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>gl_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>mutable<span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面试题-——"><a href="#面试题-——" class="headerlink" title="面试题 —— +="></a>面试题 —— <code>+=</code></h4><ul><li>在 <code>python</code> 中，列表变量调用 <code>+=</code> 本质上是在执行列表变量的 <code>extend</code> 方法，不会修改变量的引用</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num_list<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数内部代码"</span><span class="token punctuation">)</span>    <span class="token comment"># num = num + num</span>    num <span class="token operator">+=</span> num    <span class="token comment"># num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用</span>    <span class="token comment"># 函数执行结束后，外部数据同样会发生变化</span>    num_list <span class="token operator">+=</span> num_list    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num_list<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数代码完成"</span><span class="token punctuation">)</span>gl_num <span class="token operator">=</span> <span class="token number">9</span>gl_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>demo<span class="token punctuation">(</span>gl_num<span class="token punctuation">,</span> gl_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-缺省参数"><a href="#3-2-缺省参数" class="headerlink" title="3.2 缺省参数"></a>3.2 缺省参数</h3><ul><li>定义函数时，可以给 <strong>某个参数</strong> 指定一个<strong>默认值</strong>，具有默认值的参数就叫做 <strong>缺省参数</strong></li><li>调用函数时，如果没有传入 <strong>缺省参数</strong> 的值，则在函数内部使用定义函数时指定的 <strong>参数默认值</strong></li><li>函数的缺省参数，<strong>将常见的值设置为参数的缺省值</strong>，从而 <strong>简化函数的调用</strong></li><li>例如：对列表排序的方法</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">gl_num_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token comment"># 默认就是升序排序，因为这种应用需求更多</span>gl_num_list<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num_list<span class="token punctuation">)</span><span class="token comment"># 只有当需要降序排序时，才需要传递 `reverse` 参数</span>gl_num_list<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>gl_num_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指定函数的缺省参数"><a href="#指定函数的缺省参数" class="headerlink" title="指定函数的缺省参数"></a>指定函数的缺省参数</h4><ul><li>在参数后使用赋值语句，可以指定参数的缺省值</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_info</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    gender_text <span class="token operator">=</span> <span class="token string">"男生"</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> gender<span class="token punctuation">:</span>        gender_text <span class="token operator">=</span> <span class="token string">"女生"</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 是 %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ol><li>缺省参数，需要使用 <strong>最常见的值</strong> 作为默认值！</li><li>如果一个参数的值 <strong>不能确定</strong>，则不应该设置默认值，具体的数值在调用函数时，由外界传递！</li></ol><h4 id="缺省参数的注意事项"><a href="#缺省参数的注意事项" class="headerlink" title="缺省参数的注意事项"></a>缺省参数的注意事项</h4><h5 id="1-缺省参数的定义位置"><a href="#1-缺省参数的定义位置" class="headerlink" title="1) 缺省参数的定义位置"></a>1) 缺省参数的定义位置</h5><ul><li><strong>必须保证</strong> <strong>带有默认值的缺省参数</strong> <strong>在参数列表末尾</strong></li><li>所以，以下定义是错误的！</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_info</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-调用带有多个缺省参数的函数"><a href="#2-调用带有多个缺省参数的函数" class="headerlink" title="2) 调用带有多个缺省参数的函数"></a>2) 调用带有多个缺省参数的函数</h5><ul><li>在 <strong>调用函数时</strong>，如果有 <strong>多个缺省参数</strong>，<strong>需要指定参数名</strong>，这样解释器才能够知道参数的对应关系！</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">print_info</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param title: 职位    :param name: 班上同学的姓名    :param gender: True 男生 False 女生    """</span>    gender_text <span class="token operator">=</span> <span class="token string">"男生"</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> gender<span class="token punctuation">:</span>        gender_text <span class="token operator">=</span> <span class="token string">"女生"</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s%s 是 %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>title<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gender_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！</span>print_info<span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span>print_info<span class="token punctuation">(</span><span class="token string">"老王"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"班长"</span><span class="token punctuation">)</span>print_info<span class="token punctuation">(</span><span class="token string">"小美"</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-多值参数（知道）"><a href="#3-3-多值参数（知道）" class="headerlink" title="3.3 多值参数（知道）"></a>3.3 多值参数（知道）</h3><h4 id="定义支持多值参数的函数"><a href="#定义支持多值参数的函数" class="headerlink" title="定义支持多值参数的函数"></a>定义支持多值参数的函数</h4><ul><li><p>有时可能需要 <strong>一个函数</strong> 能够处理的参数 <strong>个数</strong> 是不确定的，这个时候，就可以使用 <strong>多值参数</strong></p></li><li><p><code>python</code> 中有 <strong>两种</strong> 多值参数：</p><ul><li>参数名前增加 <strong>一个</strong> <code>*</code> 可以接收 <strong>元组</strong></li><li>参数名前增加 <strong>两个</strong> <code>*</code> 可以接收 <strong>字典</strong></li></ul></li><li><p>一般在给多值参数命名时，<strong>习惯</strong>使用以下两个名字</p><ul><li><code>*args</code> —— 存放 <strong>元组</strong> 参数，前面有一个 <code>*</code></li><li><code>**kwargs</code> —— 存放 <strong>字典</strong> 参数，前面有两个 <code>*</code></li></ul></li><li><p><code>args</code> 是 <code>arguments</code> 的缩写，有变量的含义</p></li><li><p><code>kw</code> 是 <code>keyword</code> 的缩写，<code>kwargs</code> 可以记忆 <strong>键值对参数</strong></p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span>demo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"小明"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> gender<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：<strong>多值参数</strong> 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，<strong>有利于我们能够读懂大牛的代码</strong></p></blockquote><h4 id="多值参数案例-——-计算任意多个数字的和"><a href="#多值参数案例-——-计算任意多个数字的和" class="headerlink" title="多值参数案例 —— 计算任意多个数字的和"></a>多值参数案例 —— 计算任意多个数字的和</h4><p><strong>需求</strong></p><ol><li>定义一个函数 <code>sum_numbers</code>，可以接收的 <strong>任意多个整数</strong></li><li>功能要求：将传递的 <strong>所有数字累加</strong> 并且返回累加结果</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_numbers</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 遍历 args 元组顺序求和</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> args<span class="token punctuation">:</span>        num <span class="token operator">+=</span> n    <span class="token keyword">return</span> num<span class="token keyword">print</span><span class="token punctuation">(</span>sum_numbers<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="元组和字典的拆包（知道）"><a href="#元组和字典的拆包（知道）" class="headerlink" title="元组和字典的拆包（知道）"></a>元组和字典的拆包（知道）</h4><ul><li>在调用带有多值参数的函数时，如果希望：<ul><li>将一个 <strong>元组变量</strong>，直接传递给 <code>args</code></li><li>将一个 <strong>字典变量</strong>，直接传递给 <code>kwargs</code></li></ul></li><li>就可以使用 <strong>拆包</strong>，简化参数的传递，<strong>拆包</strong> 的方式是：<ul><li>在 <strong>元组变量前</strong>，增加 <strong>一个</strong> <code>*</code></li><li>在 <strong>字典变量前</strong>，增加 <strong>两个</strong> <code>*</code></li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span><span class="token comment"># 需要将一个元组变量/字典变量传递给函数对应的参数</span>gl_nums <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>gl_xiaoming <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">&#125;</span><span class="token comment"># 会把 num_tuple 和 xiaoming 作为元组传递个 args</span><span class="token comment"># demo(gl_nums, gl_xiaoming)</span>demo<span class="token punctuation">(</span><span class="token operator">*</span>gl_nums<span class="token punctuation">,</span> <span class="token operator">**</span>gl_xiaoming<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="04-函数的递归"><a href="#04-函数的递归" class="headerlink" title="04. 函数的递归"></a>04. 函数的递归</h2><blockquote><p>函数调用自身的 <strong>编程技巧</strong> 称为递归</p></blockquote><h3 id="4-1-递归函数的特点"><a href="#4-1-递归函数的特点" class="headerlink" title="4.1 递归函数的特点"></a>4.1 递归函数的特点</h3><p><strong>特点</strong></p><ul><li><strong>一个函数</strong> <strong>内部</strong> <strong>调用自己</strong><ul><li>函数内部可以调用其他函数，当然在函数内部也可以调用自己</li></ul></li></ul><p><strong>代码特点</strong></p><ol><li>函数内部的 <strong>代码</strong> 是相同的，只是针对 <strong>参数</strong> 不同，<strong>处理的结果不同</strong></li><li>当 <strong>参数满足一个条件</strong> 时，函数不再执行<ul><li><strong>这个非常重要</strong>，通常被称为递归的出口，否则 <strong>会出现死循环</strong>！</li></ul></li></ol><p>示例代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_numbers</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token comment"># 递归的出口很重要，否则会出现死循环</span>    <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    sum_numbers<span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    sum_numbers<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127023304.png" alt="002_递归调用示意图I" loading="lazy"></p><h3 id="4-2-递归案例-——-计算数字累加"><a href="#4-2-递归案例-——-计算数字累加" class="headerlink" title="4.2 递归案例 —— 计算数字累加"></a>4.2 递归案例 —— 计算数字累加</h3><p><strong>需求</strong></p><ol><li>定义一个函数 <code>sum_numbers</code></li><li>能够接收一个 <code>num</code> 的整数参数</li><li>计算 1 + 2 + … num 的结果</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_numbers</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token comment"># 假设 sum_numbers 能够完成 num - 1 的累加</span>    temp <span class="token operator">=</span> sum_numbers<span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 函数内部的核心算法就是 两个数字的相加</span>    <span class="token keyword">return</span> num <span class="token operator">+</span> temp<span class="token keyword">print</span><span class="token punctuation">(</span>sum_numbers<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220127023305.png" alt="002_递归调用示意图" loading="lazy"></p><blockquote><p>提示：递归是一个 <strong>编程技巧</strong>，初次接触递归会感觉有些吃力！在处理 <strong>不确定的循环条件时</strong>，格外的有用，例如：<strong>遍历整个文件目录的结构</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派系统备份</title>
      <link href="/posts/52784c40/"/>
      <url>/posts/52784c40/</url>
      
        <content type="html"><![CDATA[<h1 id="一、全卡备份"><a href="#一、全卡备份" class="headerlink" title="一、全卡备份"></a>一、全卡备份</h1><p>全卡备份就是直接从SD卡A复制到SD卡B</p><h2 id="1-通过GUI备份"><a href="#1-通过GUI备份" class="headerlink" title="1.通过GUI备份"></a>1.通过GUI备份</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232048.png" alt="image-20220312232048461" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232726.png" alt="image-20220312232726142" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232403.png" alt="image-20220312232403516" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220312232959.png" alt="image-20220312232959086" loading="lazy"></p><h2 id="2-命令行备份"><a href="#2-命令行备份" class="headerlink" title="2.命令行备份"></a>2.命令行备份</h2><blockquote><p>  实测，太慢了</p></blockquote><p>更新源</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo apt update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>mmcblk0</code>是SD卡A，<code>sda</code>是SD卡B，从A复制到B</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pi@raspberrypi:~ $ lsblkNAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda           8:0    1 59.5G  0 disk ├─sda1        8:1    1  256M  0 part └─sda2        8:2    1 59.2G  0 part mmcblk0     179:0    0 59.5G  0 disk ├─mmcblk0p1 179:1    0  256M  0 part &#x2F;boot└─mmcblk0p2 179:2    0 59.2G  0 part &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装<code>dc3dd</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo apt install dc3dd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>备份</p><p><code>if</code>表示要备份的卡，<code>of</code>表示要备份到的卡</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dc3dd if&#x3D;&#x2F;dev&#x2F;mmcblk0 of&#x3D;&#x2F;dev&#x2F;sda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220313001259.png" alt="image-20220313001259177" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220313013246.png" alt="image-20220313013246475" loading="lazy"></p><h1 id="二、压缩备份"><a href="#二、压缩备份" class="headerlink" title="二、压缩备份"></a>二、压缩备份</h1><p>压缩备份是它会备份整个<code>boot</code>分区，然后<code>Root</code>分区它只会备份实际使用的容量</p><p>待续。。。。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vi——终端中的编辑器</title>
      <link href="/posts/a670312d/"/>
      <url>/posts/a670312d/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><code>vi</code> 简介</li><li>打开和新建文件</li><li>三种工作模式</li><li>常用命令</li><li>分屏命令</li><li>常用命令速查图</li></ul><h2 id="01-vi-简介"><a href="#01-vi-简介" class="headerlink" title="01. vi 简介"></a>01. <code>vi</code> 简介</h2><h3 id="1-1-学习-vi-的目的"><a href="#1-1-学习-vi-的目的" class="headerlink" title="1.1 学习 vi 的目的"></a>1.1 学习 <code>vi</code> 的目的</h3><ul><li>在工作中，要对 <strong>服务器</strong> 上的文件进行 <strong>简单</strong> 的修改，可以使用 <code>ssh</code> 远程登录到服务器上，并且使用 <code>vi</code> 进行快速的编辑即可</li><li>常见需要修改的文件包括：<ul><li><strong>源程序</strong></li><li><strong>配置文件</strong>，例如 <code>ssh</code> 的配置文件 <code>~/.ssh/config</code></li></ul></li></ul><blockquote><ul><li>在没有图形界面的环境下，要编辑文件，<code>vi</code> 是最佳选择！</li><li>每一个要使用 Linux 的程序员，都应该或多或少的学习一些 <code>vi</code> 的常用命令</li></ul></blockquote><h3 id="1-2-vi-和-vim"><a href="#1-2-vi-和-vim" class="headerlink" title="1.2 vi 和 vim"></a>1.2 vi 和 vim</h3><ul><li>在很多 <code>Linux</code> 发行版中，直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li></ul><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><ul><li><code>vi</code> 是 <code>Visual interface</code> 的简称，是 <code>Linux</code> 中 <strong>最经典</strong> 的文本编辑器</li><li><code>vi</code> 的核心设计思想 —— <strong>让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118195440.png" alt="001_vi键盘-w551" loading="lazy"></p><ul><li><code>vi</code> 的特点：<ul><li><strong>没有图形界面</strong> 的 <strong>功能强大</strong> 的编辑器</li><li>只能是编辑 <strong>文本内容</strong>，不能对字体、段落进行排版</li><li><strong>不支持鼠标操作</strong></li><li><strong>没有菜单</strong></li><li><strong>只有命令</strong></li></ul></li><li><code>vi</code> 编辑器在 <strong>系统管理</strong>、<strong>服务器管理</strong> 编辑文件时，<strong>其功能永远不是图形界面的编辑器能比拟的</strong></li></ul><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a><code>vim</code></h4><p><strong>vim &#x3D; vi improved</strong></p><ul><li><code>vim</code> 是从 <code>vi</code> 发展出来的一个文本编辑器，支持 <strong>代码补全</strong>、<strong>编译</strong> 及 <strong>错误跳转</strong> 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 <strong>编辑器之神</strong></li></ul><h4 id="查询软连接命令（知道）"><a href="#查询软连接命令（知道）" class="headerlink" title="查询软连接命令（知道）"></a>查询软连接命令（知道）</h4><ul><li>在很多 <code>Linux</code> 发行版中直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查找 vi 的运行文件</span>$ <span class="token function">which</span> <span class="token function">vi</span>$ <span class="token function">ls</span> -l /usr/bin/vi$ <span class="token function">ls</span> -l /etc/alternatives/vi$ <span class="token function">ls</span> -l /usr/bin/vim.basic<span class="token comment"># 查找 vim 的运行文件</span>$ <span class="token function">which</span> <span class="token function">vim</span>$ <span class="token function">ls</span> -l /usr/bin/vim$ <span class="token function">ls</span> -l /etc/alternatives/vim$ <span class="token function">ls</span> -l /usr/bin/vim.basic <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-打开和新建文件"><a href="#02-打开和新建文件" class="headerlink" title="02. 打开和新建文件"></a>02. 打开和新建文件</h2><ul><li>在终端中输入 <code>vi</code> <strong>在后面跟上文件名</strong> 即可</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vi</span> 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果文件已经存在，会直接打开该文件</li><li>如果文件不存在，会新建一个文件</li></ul><h3 id="2-1-打开文件并且定位行"><a href="#2-1-打开文件并且定位行" class="headerlink" title="2.1 打开文件并且定位行"></a>2.1 打开文件并且定位行</h3><ul><li><p>在日常工作中，有可能会遇到 <strong>打开一个文件，并定位到指定行</strong> 的情况</p></li><li><p>例如：在开发时，<strong>知道某一行代码有错误</strong>，可以 <strong>快速定位</strong> 到出错代码的位置</p></li><li><p>这个时候，可以使用以下命令打开文件</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">vi</span> 文件名 +行数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>提示：如果只带上 <code>+</code> 而不指定行号，会直接定位到文件末尾</p></blockquote><h3 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2 异常处理"></a>2.2 异常处理</h3><ul><li>如果 <code>vi</code> 异常退出，在磁盘上可能会保存有 <strong>交换文件</strong></li><li>下次再使用 <code>vi</code> 编辑该文件时，会看到以下屏幕信息，按下字母 <code>d</code> 可以 <strong>删除交换文件</strong> 即可</li></ul><blockquote><p>提示：按下键盘时，注意关闭输入法</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118195441.png" alt="002_删除交换文件-w1048" loading="lazy"></p><h2 id="03-三种工作模式"><a href="#03-三种工作模式" class="headerlink" title="03. 三种工作模式"></a>03. 三种工作模式</h2><ul><li><p><code>vi</code> 有三种基本工作模式：</p><ol><li><strong>命令模式</strong><ul><li><strong>打开文件首先进入命令模式</strong>，是使用 <code>vi</code> 的 <strong>入口</strong></li><li>通过 <strong>命令</strong> 对文件进行常规的编辑操作，例如：<strong>定位</strong>、<strong>翻页</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>删除</strong>……</li><li>在其他图形编辑器下，通过 <strong>快捷键</strong> 或者 <strong>鼠标</strong> 实现的操作，都在 <strong>命令模式</strong> 下实现</li></ul></li><li><strong>末行模式</strong> —— 执行 <strong>保存</strong>、<strong>退出</strong> 等操作 <ul><li>要退出 <code>vi</code> 返回到控制台，需要在末行模式下输入命令</li><li><strong>末行模式</strong> 是 <code>vi</code> 的 <strong>出口</strong></li></ul></li><li><strong>编辑模式</strong> —— 正常的编辑文字</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118195442.png" alt="003_vi的模式-w500" loading="lazy"></p><blockquote><p>提示：在 <code>Touch Bar</code> 的 Mac 电脑上 ，按 <code>ESC</code> 不方便，可以使用 <code>CTRL + [</code> 替代</p></blockquote><h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">write</td><td>保存</td></tr><tr><td align="center">q</td><td align="center">quit</td><td>退出，如果没有保存，不允许退出</td></tr><tr><td align="center">q!</td><td align="center">quit</td><td>强行退出，不保存退出</td></tr><tr><td align="center">wq</td><td align="center">write &amp; quit</td><td>保存并退出</td></tr><tr><td align="center">x</td><td align="center"></td><td>保存并退出</td></tr></tbody></table><h2 id="04-常用命令"><a href="#04-常用命令" class="headerlink" title="04. 常用命令"></a>04. 常用命令</h2><h3 id="命令线路图"><a href="#命令线路图" class="headerlink" title="命令线路图"></a>命令线路图</h3><ol start="0"><li>重复次数<ul><li>在命令模式下，<strong>先输入一个数字</strong>，<strong>再跟上一个命令</strong>，可以让该命令 <strong>重复执行指定次数</strong></li></ul></li><li>移动和选择（<strong>多练</strong>）<ul><li><code>vi</code> 之所以快，关键在于 <strong>能够快速定位到要编辑的代码行</strong></li><li><strong>移动命令</strong> 能够 和 <strong>编辑操作</strong> 命令 <strong>组合使用</strong></li></ul></li><li>编辑操作<ul><li><strong>删除</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>替换</strong>、<strong>缩排</strong></li></ul></li><li>撤销和重复</li><li>查找替换</li><li>编辑</li></ol><h4 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h4><ol><li><code>vi</code> 的命令较多，<strong>不要期望一下子全部记住</strong>，个别命令忘记了，只是会影响编辑速度而已</li><li>在使用 <code>vi</code> 命令时，注意 <strong>关闭中文输入法</strong></li></ol><h3 id="4-1-移动（基本）"><a href="#4-1-移动（基本）" class="headerlink" title="4.1 移动（基本）"></a>4.1 移动（基本）</h3><ul><li>要熟练使用 <code>vi</code>，首先应该学会怎么在 <strong>命令模式</strong> 下样快速移动光标</li><li><strong>编辑操作命令</strong>，能够和 <strong>移动命令</strong> 结合在一起使用</li></ul><h4 id="1-上、下、左、右"><a href="#1-上、下、左、右" class="headerlink" title="1) 上、下、左、右"></a>1) 上、下、左、右</h4><table><thead><tr><th align="center">命令</th><th>功能</th><th align="center">手指</th></tr></thead><tbody><tr><td align="center">h</td><td>向左</td><td align="center">食指</td></tr><tr><td align="center">j</td><td>向下</td><td align="center">食指</td></tr><tr><td align="center">k</td><td>向上</td><td align="center">中指</td></tr><tr><td align="center">l</td><td>向右</td><td align="center">无名指</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118195443.png" alt="005_移动光标-w551" loading="lazy"></p><h4 id="2-行内移动"><a href="#2-行内移动" class="headerlink" title="2) 行内移动"></a>2) 行内移动</h4><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">word</td><td>向后移动一个单词</td></tr><tr><td align="center">b</td><td align="center">back</td><td>向前移动一个单词</td></tr><tr><td align="center">0</td><td align="center"></td><td>行首</td></tr><tr><td align="center">^</td><td align="center"></td><td>行首，第一个不是空白字符的位置</td></tr><tr><td align="center">$</td><td align="center"></td><td>行尾</td></tr></tbody></table><h4 id="3-行数移动"><a href="#3-行数移动" class="headerlink" title="3) 行数移动"></a>3) 行数移动</h4><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">gg</td><td align="center">go</td><td>文件顶部</td></tr><tr><td align="center">G</td><td align="center">go</td><td>文件末尾</td></tr><tr><td align="center">数字gg</td><td align="center">go</td><td>移动到 数字 对应行数</td></tr><tr><td align="center">数字G</td><td align="center">go</td><td>移动到 数字 对应行数</td></tr><tr><td align="center">:数字</td><td align="center"></td><td>移动到 数字 对应行数</td></tr></tbody></table><h4 id="4-屏幕移动"><a href="#4-屏幕移动" class="headerlink" title="4) 屏幕移动"></a>4) 屏幕移动</h4><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">Ctrl + b</td><td align="center">back</td><td>向上翻页</td></tr><tr><td align="center">Ctrl + f</td><td align="center">forward</td><td>向下翻页</td></tr><tr><td align="center">H</td><td align="center">Head</td><td>屏幕顶部</td></tr><tr><td align="center">M</td><td align="center">Middle</td><td>屏幕中间</td></tr><tr><td align="center">L</td><td align="center">Low</td><td>屏幕底部</td></tr></tbody></table><h3 id="4-2-移动（程序）"><a href="#4-2-移动（程序）" class="headerlink" title="4.2 移动（程序）"></a>4.2 移动（程序）</h3><h4 id="1-段落移动"><a href="#1-段落移动" class="headerlink" title="1) 段落移动"></a>1) 段落移动</h4><ul><li><code>vi</code> 中使用 空行 来区分段落</li><li>在程序开发时，通常 <strong>一段功能相关的代码会写在一起</strong> —— 之间没有空行</li></ul><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">{</td><td>上一段</td></tr><tr><td align="center">}</td><td>下一段</td></tr></tbody></table><h4 id="2-括号切换"><a href="#2-括号切换" class="headerlink" title="2) 括号切换"></a>2) 括号切换</h4><ul><li>在程序世界中，<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code> 使用频率很高，而且 <strong>都是成对出现的</strong></li></ul><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">%</td><td>括号匹配及切换</td></tr></tbody></table><h4 id="3-标记"><a href="#3-标记" class="headerlink" title="3) 标记"></a>3) 标记</h4><ul><li>在开发时，某一块代码可能<strong>需要稍后处理</strong>，例如：编辑、查看</li><li>此时先使用 <code>m</code> 增加一个标记，这样可以 <strong>在需要时快速地跳转回来</strong> 或者 <strong>执行其他编辑操作</strong></li><li><strong>标记名称</strong> 可以是 <code>a~z</code> 或者 <code>A~Z</code> 之间的任意 <strong>一个</strong> 字母</li><li>添加了标记的 <strong>行如果被删除</strong>，<strong>标记同时被删除</strong></li><li>如果 <strong>在其他行添加了相同名称的标记</strong>，<strong>之前添加的标记也会被替换掉</strong></li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">mx</td><td align="center">mark</td><td>添加标记 x，x 是 a<del>z 或者 A</del>Z 之间的任意一个字母</td></tr><tr><td align="center">‘x</td><td align="center"></td><td>直接定位到标记 x 所在位置</td></tr></tbody></table><h3 id="4-3-选中文本（可视模式）"><a href="#4-3-选中文本（可视模式）" class="headerlink" title="4.3 选中文本（可视模式）"></a>4.3 选中文本（可视模式）</h3><ul><li>学习 <code>复制</code> 命令前，应该先学会 <strong>怎么样选中 要复制的代码</strong></li><li>在 <code>vi</code> 中要选择文本，需要先使用 <code>Visual</code> 命令切换到 <strong>可视模式</strong></li><li><code>vi</code> 中提供了 <strong>三种</strong> 可视模式，可以方便程序员选择 <strong>选中文本的方式</strong></li><li>按 <code>ESC</code> 可以放弃选中，返回到 <strong>命令模式</strong></li></ul><table><thead><tr><th align="center">命令</th><th>模式</th><th>功能</th></tr></thead><tbody><tr><td align="center">v</td><td>可视模式</td><td>从光标位置开始按照正常模式选择文本</td></tr><tr><td align="center">V</td><td>可视行模式</td><td>选中光标经过的完整行</td></tr><tr><td align="center">Ctrl + v</td><td>可视块模式</td><td>垂直方向选中文本</td></tr></tbody></table><ul><li><strong>可视模式</strong>下，可以和 <strong>移动命令</strong> 连用，例如：<code>ggVG</code> 能够选中所有内容</li></ul><h3 id="4-4-撤销和恢复撤销"><a href="#4-4-撤销和恢复撤销" class="headerlink" title="4.4 撤销和恢复撤销"></a>4.4 撤销和恢复撤销</h3><ul><li>在学习编辑命令之前，先要知道怎样撤销之前一次 <strong>错误的</strong> 编辑动作！</li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">undo</td><td>撤销上次命令</td></tr><tr><td align="center">CTRL + r</td><td align="center">redo</td><td>恢复撤销的命令</td></tr></tbody></table><h3 id="4-5-删除文本"><a href="#4-5-删除文本" class="headerlink" title="4.5 删除文本"></a>4.5 删除文本</h3><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">cut</td><td>删除光标所在字符，或者选中文字</td></tr><tr><td align="center">d(移动命令)</td><td align="center">delete</td><td>删除移动命令对应的内容</td></tr><tr><td align="center">dd</td><td align="center">delete</td><td>删除光标所在行，可以 ndd 复制多行</td></tr><tr><td align="center">D</td><td align="center">delete</td><td>删除至行尾</td></tr></tbody></table><blockquote><p>提示：如果使用 <strong>可视模式</strong> 已经选中了一段文本，那么无论使用 <code>d</code> 还是 <code>x</code>，都可以删除选中文本</p></blockquote><ul><li>删除命令可以和 <strong>移动命令</strong> 连用，以下是常见的组合命令：</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">* dw        # 从光标位置删除到单词末尾* d0        # 从光标位置删除到一行的起始位置* d&#125;        # 从光标位置删除到段落结尾* ndd       # 从光标位置向下连续删除 n 行* d代码行G   # 从光标所在行 删除到 指定代码行 之间的所有代码* d&#39;a       # 从光标所在行 删除到 标记a 之间的所有代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-复制、粘贴"><a href="#4-6-复制、粘贴" class="headerlink" title="4.6 复制、粘贴"></a>4.6 复制、粘贴</h3><ul><li><code>vi</code> 中提供有一个 <strong>被复制文本的缓冲区</strong><ul><li><strong>复制</strong> 命令会将选中的文字保存在缓冲区 </li><li><strong>删除</strong> 命令删除的文字会被保存在缓冲区</li><li>在需要的位置，使用 <strong>粘贴</strong> 命令可以将缓冲区的文字插入到光标所在位置</li></ul></li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">y(移动命令)</td><td align="center">copy</td><td>复制</td></tr><tr><td align="center">yy</td><td align="center">copy</td><td>复制一行，可以 nyy 复制多行</td></tr><tr><td align="center">p</td><td align="center">paste</td><td>粘贴</td></tr></tbody></table><p><strong>提示</strong></p><ul><li>命令 <code>d</code>、<code>x</code> 类似于图形界面的 <strong>剪切操作</strong> —— <code>CTRL + X</code></li><li>命令 <code>y</code> 类似于图形界面的 <strong>复制操作</strong> —— <code>CTRL + C</code></li><li>命令 <code>p</code> 类似于图形界面的 <strong>粘贴操作</strong> —— <code>CTRL + V</code></li><li><code>vi</code> 中的 <strong>文本缓冲区同样只有一个</strong>，如果后续做过 <strong>复制、剪切</strong> 操作，之前缓冲区中的内容会被替换</li></ul><p><strong>注意</strong></p><ul><li><code>vi</code> 中的 <strong>文本缓冲区</strong> 和系统的 <strong>剪贴板</strong> 不是同一个</li><li>所以在其他软件中使用 <code>CTRL + C</code> 复制的内容，不能在 <code>vi</code> 中通过 <code>P</code> 命令粘贴</li><li>可以在 <strong>编辑模式</strong> 下使用 <strong>鼠标右键粘贴</strong></li></ul><h3 id="4-7-替换"><a href="#4-7-替换" class="headerlink" title="4.7 替换"></a>4.7 替换</h3><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th><th>工作模式</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">replace</td><td>替换当前字符</td><td>命令模式</td></tr><tr><td align="center">R</td><td align="center">replace</td><td>替换当前行光标后的字符</td><td>替换模式</td></tr></tbody></table><ul><li><code>R</code> 命令可以进入 <strong>替换模式</strong>，替换完成后，按下 <code>ESC</code> 可以回到 <strong>命令模式</strong></li><li><strong>替换命令</strong> 的作用就是不用进入 <strong>编辑模式</strong>，对文件进行 <strong>轻量级的修改</strong></li></ul><h3 id="4-8-缩排和重复执行"><a href="#4-8-缩排和重复执行" class="headerlink" title="4.8 缩排和重复执行"></a>4.8 缩排和重复执行</h3><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">&gt;&gt;</td><td>向右增加缩进</td></tr><tr><td align="center">&lt;&lt;</td><td>向左减少缩进</td></tr><tr><td align="center">.</td><td>重复上次命令</td></tr></tbody></table><ul><li><strong>缩排命令</strong> 在开发程序时，<strong>统一增加代码的缩进</strong> 比较有用！<ul><li>一次性 <strong>在选中代码前增加 4 个空格</strong>，就叫做 <strong>增加缩进</strong></li><li>一次性 <strong>在选中代码前删除 4 个空格</strong>，就叫做 <strong>减少缩进</strong></li></ul></li><li>在 <strong>可视模式</strong> 下，缩排命令只需要使用 <strong>一个</strong> <code>&gt;</code> 或者 <code>&lt;</code></li></ul><blockquote><p>在程序中，<strong>缩进</strong> 通常用来表示代码的归属关系</p><ul><li>前面空格越少，代码的级别越高</li><li>前面空格越多，代码的级别越低</li></ul></blockquote><h3 id="4-9-查找"><a href="#4-9-查找" class="headerlink" title="4.9 查找"></a>4.9 查找</h3><h4 id="常规查找"><a href="#常规查找" class="headerlink" title="常规查找"></a>常规查找</h4><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">&#x2F;str</td><td>查找 str</td></tr></tbody></table><ul><li>查找到指定内容之后，使用 <code>Next</code> 查找下一个出现的位置：<ul><li><code>n</code>: 查找下一个</li><li><code>N</code>: 查找上一个</li></ul></li><li>如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可</li></ul><h4 id="单词快速匹配"><a href="#单词快速匹配" class="headerlink" title="单词快速匹配"></a>单词快速匹配</h4><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">*</td><td>向后查找当前光标所在单词</td></tr><tr><td align="center">#</td><td>向前查找当前光标所在单词</td></tr></tbody></table><ul><li>在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过</li></ul><h3 id="4-10-查找并替换"><a href="#4-10-查找并替换" class="headerlink" title="4.10 查找并替换"></a>4.10 查找并替换</h3><ul><li>在 <code>vi</code> 中查找和替换命令需要在 <strong>末行模式</strong> 下执行</li><li>记忆命令格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">:%s&#x2F;&#x2F;&#x2F;g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-全局替换"><a href="#1-全局替换" class="headerlink" title="1) 全局替换"></a>1) 全局替换</h4><ul><li><strong>一次性</strong>替换文件中的 <strong>所有出现的旧文本</strong></li><li>命令格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">:%s&#x2F;旧文本&#x2F;新文本&#x2F;g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-可视区域替换"><a href="#2-可视区域替换" class="headerlink" title="2) 可视区域替换"></a>2) 可视区域替换</h4><ul><li><strong>先选中</strong> 要替换文字的 <strong>范围</strong></li><li>命令格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">:s&#x2F;旧文本&#x2F;新文本&#x2F;g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-确认替换"><a href="#3-确认替换" class="headerlink" title="3) 确认替换"></a>3) 确认替换</h4><ul><li>如果把末尾的 <code>g</code> 改成 <code>gc</code> 在替换的时候，会有提示！<strong>推荐使用！</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">:%s&#x2F;旧文本&#x2F;新文本&#x2F;gc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><code>y</code> - <code>yes</code> 替换</li><li><code>n</code> - <code>no</code> 不替换</li><li><code>a</code> - <code>all</code> 替换所有</li><li><code>q</code> - <code>quit</code> 退出替换</li><li><code>l</code> - <code>last</code> 最后一个，并把光标移动到行首</li><li><code>^E</code> 向下滚屏</li><li><code>^Y</code> 向上滚屏</li></ol><h3 id="4-11-插入命令"><a href="#4-11-插入命令" class="headerlink" title="4.11 插入命令"></a>4.11 插入命令</h3><ul><li>在 <code>vi</code> 中除了常用的 <code>i</code> 进入 <strong>编辑模式</strong> 外，还提供了以下命令同样可以进入编辑模式：</li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th><th align="center">常用</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">insert</td><td>在当前字符前插入文本</td><td align="center">常用</td></tr><tr><td align="center">I</td><td align="center">insert</td><td>在行首插入文本</td><td align="center">较常用</td></tr><tr><td align="center">a</td><td align="center">append</td><td>在当前字符后添加文本</td><td align="center"></td></tr><tr><td align="center">A</td><td align="center">append</td><td>在行末添加文本</td><td align="center">较常用</td></tr><tr><td align="center">o</td><td align="center"></td><td>在当前行后面插入一空行</td><td align="center">常用</td></tr><tr><td align="center">O</td><td align="center"></td><td>在当前行前面插入一空行</td><td align="center">常用</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118195444.png" alt="004_插入命令-w400" loading="lazy"></p><h4 id="演练-1-——-编辑命令和数字连用"><a href="#演练-1-——-编辑命令和数字连用" class="headerlink" title="演练 1 —— 编辑命令和数字连用"></a>演练 1 —— 编辑命令和数字连用</h4><ul><li>在开发中，可能会遇到连续输入 <code>N</code> 个同样的字符</li></ul><blockquote><p>在 <code>Python</code> 中有简单的方法，但是其他语言中通常需要自己输入</p></blockquote><ul><li>例如：<code>**********</code> 连续 10 个星号</li></ul><p>要实现这个效果可以在 <strong>命令模式</strong> 下</p><ol><li>输入 <code>10</code>，表示要重复 10 次</li><li>输入 <code>i</code> 进入 <strong>编辑模式</strong></li><li>输入 <code>*</code> 也就是重复的文字</li><li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 就会把第 <code>2、3</code> 两步的操作重复 <code>10</code> 次</li></ol><blockquote><p>提示：正常开发时，在 <strong>进入编辑模式之前，不要按数字</strong></p></blockquote><h4 id="演练-2-——-利用-可视块-给多行代码增加注释"><a href="#演练-2-——-利用-可视块-给多行代码增加注释" class="headerlink" title="演练 2 —— 利用 可视块 给多行代码增加注释"></a>演练 2 —— 利用 可视块 给多行代码增加注释</h4><ul><li>在开发中，可能会遇到一次性给多行代码 <strong>增加注释</strong> 的情况</li></ul><blockquote><p>在 <code>Python</code> 中，要给代码增加注释，可以在代码前增加一个 <code># </code></p></blockquote><p>要实现这个效果可以在 <strong>命令模式</strong> 下</p><ol><li>移动到要添加注释的 <strong>第 1 行代码</strong>，按 <code>^</code> 来到行首</li><li>按 <code>CTRL + v</code> 进入 <strong>可视块</strong> 模式</li><li>使用 <code>j</code> 向下连续选中要添加的代码行</li><li>输入 <code>I</code> 进入 <strong>编辑模式</strong>，并在 <strong>行首插入</strong>，注意：一定要使用 <strong>I</strong></li><li>输入 <code># </code> 也就是注释符号</li><li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 会在之前选中的每一行代码 <strong>前</strong> 插入 <code># </code></li></ol><h2 id="05-分屏命令"><a href="#05-分屏命令" class="headerlink" title="05. 分屏命令"></a>05. 分屏命令</h2><ul><li>属于 <code>vi</code> 的高级命令 —— 可以 <strong>同时编辑和查看多个文件</strong></li></ul><h3 id="5-1-末行命令扩展"><a href="#5-1-末行命令扩展" class="headerlink" title="5.1 末行命令扩展"></a>5.1 末行命令扩展</h3><p><strong>末行命令</strong> 主要是针对文件进行操作的：<strong>保存</strong>、<strong>退出</strong>、<strong>保存&amp;退出</strong>、<strong>搜索&amp;替换</strong>、<strong>另存</strong>、<strong>新建</strong>、<strong>浏览文件</strong></p><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">:e .</td><td align="center">edit</td><td>会打开内置的文件浏览器，浏览要当前目录下的文件</td></tr><tr><td align="center">:n 文件名</td><td align="center">new</td><td>新建文件</td></tr><tr><td align="center">:w 文件名</td><td align="center">write</td><td>另存为，但是仍然编辑当前文件，并不会切换文件</td></tr></tbody></table><blockquote><p>提示：切换文件之前，必须保证当前这个文件已经被保存！</p></blockquote><ul><li>已经学习过的 <strong>末行命令</strong>：</li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">write</td><td>保存</td></tr><tr><td align="center">:q</td><td align="center">quit</td><td>退出，如果没有保存，不允许退出</td></tr><tr><td align="center">:q!</td><td align="center">quit</td><td>强行退出，不保存退出</td></tr><tr><td align="center">:wq</td><td align="center">write &amp; quit</td><td>保存并退出</td></tr><tr><td align="center">:x</td><td align="center"></td><td>保存并退出</td></tr><tr><td align="center">:%s&#x2F;&#x2F;&#x2F;gc</td><td align="center"></td><td>确认搜索并替换</td></tr></tbody></table><blockquote><p>在实际开发中，可以使用 <code>w</code> 命令 <strong>阶段性的备份代码</strong></p></blockquote><h3 id="5-2-分屏命令"><a href="#5-2-分屏命令" class="headerlink" title="5.2 分屏命令"></a>5.2 分屏命令</h3><ul><li>使用 <strong>分屏命令</strong>，可以 <strong>同时编辑和查看多个文件</strong></li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">:sp [文件名]</td><td align="center">split</td><td>横向增加分屏</td></tr><tr><td align="center">:vsp [文件名]</td><td align="center">vertical split</td><td>纵向增加分屏</td></tr></tbody></table><h4 id="1-切换分屏窗口"><a href="#1-切换分屏窗口" class="headerlink" title="1) 切换分屏窗口"></a>1) 切换分屏窗口</h4><blockquote><p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">window</td><td>切换到下一个窗口</td></tr><tr><td align="center">r</td><td align="center">reverse</td><td>互换窗口</td></tr><tr><td align="center">c</td><td align="center">close</td><td>关闭当前窗口，但是不能关闭最后一个窗口</td></tr><tr><td align="center">q</td><td align="center">quit</td><td>退出当前窗口，如果是最后一个窗口，则关闭 vi</td></tr><tr><td align="center">o</td><td align="center">other</td><td>关闭其他窗口</td></tr></tbody></table><h4 id="2-调整窗口大小"><a href="#2-调整窗口大小" class="headerlink" title="2) 调整窗口大小"></a>2) 调整窗口大小</h4><blockquote><p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p></blockquote><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th>功能</th></tr></thead><tbody><tr><td align="center">+</td><td align="center"></td><td>增加窗口高度</td></tr><tr><td align="center">-</td><td align="center"></td><td>减少窗口高度</td></tr><tr><td align="center">&gt;</td><td align="center"></td><td>增加窗口宽度</td></tr><tr><td align="center">&lt;</td><td align="center"></td><td>减少窗口宽度</td></tr><tr><td align="center">&#x3D;</td><td align="center"></td><td>等分窗口大小</td></tr></tbody></table><blockquote><p>调整窗口宽高的命令可以和数字连用，例如：<code>5 CTRL + W +</code> 连续 5 次增加高度</p></blockquote><h2 id="06-常用命令速查图"><a href="#06-常用命令速查图" class="headerlink" title="06. 常用命令速查图"></a>06. 常用命令速查图</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118195445.png" alt="vi" loading="lazy"></p><h3 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h3><ul><li><code>vimrc</code> 是 <code>vim</code> 的配置文件，可以设置 vim 的配置，包括：<strong>热键</strong>、<strong>配色</strong>、<strong>语法高亮</strong>、<strong>插件</strong> 等</li><li><code>Linux</code> 中 <code>vimrc</code> 有两个位置，<strong>家目录下的配置文件优先级更高</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;vim&#x2F;vimrc~&#x2F;.vimrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>常用的插件有：<ul><li>代码补全</li><li>代码折叠</li><li>搜索</li><li>Git 集成</li><li>……</li></ul></li><li>网上有很多高手已经配置好的针对 <code>python</code> 开发的 <code>vimrc</code> 文件，可以下载过来直接使用，或者等大家多 <code>Linux</code> 比较熟悉后，再行学习！</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基本命令</title>
      <link href="/posts/65cd929b/"/>
      <url>/posts/65cd929b/</url>
      
        <content type="html"><![CDATA[<h1 id="01-Python-基础课程安排"><a href="#01-Python-基础课程安排" class="headerlink" title="01.Python 基础课程安排"></a>01.Python 基础课程安排</h1><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194457.jpg" alt="001_积跬步以至千里" loading="lazy">  </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194500.jpg" alt="002_三天打鱼两天晒网" loading="lazy"></p><h1 id="02-操作系统（科普章节）"><a href="#02-操作系统（科普章节）" class="headerlink" title="02.操作系统（科普章节）"></a>02.操作系统（科普章节）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>了解<strong>操作系统</strong>及作用</li></ul><h2 id="1-操作系统（Operation-System，OS）"><a href="#1-操作系统（Operation-System，OS）" class="headerlink" title="1. 操作系统（Operation System，OS）"></a>1. 操作系统（Operation System，OS）</h2><blockquote><p>操作系统作为接口的示意图</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194511.png" alt="001_OS作为接口的示意图" loading="lazy">￼</p><blockquote><p>没有安装操作系统的计算机，通常被称为 <strong>裸机</strong></p><ul><li>如果想在 <strong>裸机</strong> 上运行自己所编写的程序，就必须用机器语言书写程序</li><li>如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，用高级语言开发程序</li></ul></blockquote><h3 id="1-1-操作系统的作用"><a href="#1-1-操作系统的作用" class="headerlink" title="1.1 操作系统的作用"></a>1.1 操作系统的作用</h3><ul><li>是现代计算机系统中 <strong>最基本和最重要</strong> 的系统软件</li><li>是 <strong>配置在计算机硬件上的第一层软件</strong>，是对硬件系统的首次扩展</li><li>主要作用是<strong>管理好硬件设备</strong>，并为用户和应用程序提供一个简单的接口，以便于使用</li><li>而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持</li></ul><h3 id="1-2-不同应用领域的主流操作系统"><a href="#1-2-不同应用领域的主流操作系统" class="headerlink" title="1.2 不同应用领域的主流操作系统"></a>1.2 不同应用领域的主流操作系统</h3><ul><li>桌面操作系统</li><li>服务器操作系统</li><li>嵌入式操作系统</li><li>移动设备操作系统</li></ul><h4 id="1-gt-桌面操作系统"><a href="#1-gt-桌面操作系统" class="headerlink" title="1&gt; 桌面操作系统"></a>1&gt; 桌面操作系统</h4><ul><li>Windows 系列<ul><li>用户群体大</li></ul></li><li>macOS<ul><li>适合于开发人员</li></ul></li><li>Linux<ul><li>应用软件少</li></ul></li></ul><h4 id="2-gt-服务器操作系统"><a href="#2-gt-服务器操作系统" class="headerlink" title="2&gt; 服务器操作系统"></a>2&gt; 服务器操作系统</h4><ul><li>Linux<ul><li>安全、稳定、免费</li><li>占有率高</li></ul></li><li>Windows Server<ul><li>付费</li><li>占有率低</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194512.jpg" alt="002_机房照片" loading="lazy">￼</p><h4 id="3-gt-嵌入式操作系统"><a href="#3-gt-嵌入式操作系统" class="headerlink" title="3&gt; 嵌入式操作系统"></a>3&gt; 嵌入式操作系统</h4><ul><li>Linux</li></ul><h4 id="4-gt-移动设备操作系统"><a href="#4-gt-移动设备操作系统" class="headerlink" title="4&gt; 移动设备操作系统"></a>4&gt; 移动设备操作系统</h4><ul><li>iOS</li><li>Android（基于 <code>Linux</code>）</li></ul><h3 id="1-3-虚拟机"><a href="#1-3-虚拟机" class="headerlink" title="1.3 虚拟机"></a>1.3 虚拟机</h3><p>虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p><ul><li>虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能</li><li>进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响</li><li>而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统</li></ul><h1 id="03-操作系统的发展史（科普章节）"><a href="#03-操作系统的发展史（科普章节）" class="headerlink" title="03.操作系统的发展史（科普章节）"></a>03.操作系统的发展史（科普章节）</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li>了解操作系统的发展历史</li><li>知道 Linux 内核及发行版的区别</li><li>知道 Linux 的应用领域</li></ul><h2 id="01-操作系统的发展历史"><a href="#01-操作系统的发展历史" class="headerlink" title="01. 操作系统的发展历史"></a>01. 操作系统的发展历史</h2><h3 id="1-1-Unix"><a href="#1-1-Unix" class="headerlink" title="1.1 Unix"></a>1.1 Unix</h3><p>1965 年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194533.png" alt="001_大型机" loading="lazy">￼</p><p><strong>为了解决数量不够用的问题</strong></p><ul><li>1965 年左后由 <strong>贝尔实验室</strong> 加入了 <strong>麻省理工学院</strong> 以及 <strong>通用电气</strong> 合作的计划 —— 该计划要建立一套 <strong>多使用者(multi－user)<strong>、</strong>多任务(multi－processor)<strong>、</strong>多层次(multi－level)</strong> 的 <strong>MULTICS</strong> 操作系统，想让大型主机支持 300 台终端</li><li>1969 年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究</li><li>1969 年从这个项目中退出的 <strong>Ken Thompson</strong> 当时在实验室无聊时，为了让一台空闲的电脑上能够运行 “星际旅行（Space Travel）” 游行，在 8 月份左右趁着其妻子探亲的时间，<strong>用了 1 个月的时间</strong>，使用汇编写出了 Unix 操作系统的原型</li><li>1970 年，美国贝尔实验室的 <strong>Ken Thompson</strong>，以 <strong>BCPL</strong> 语言为基础，设计出很简单且很接近硬件的 <strong>B 语言</strong>（取BCPL的首字母），并且他用 <strong>B 语言</strong> 写了第一个 UNIX 操作系统</li><li>1971 年，同样酷爱 “星际旅行（Space Travel）” 的 <strong>Dennis M.Ritchie</strong> 为了能早点儿玩上游戏，加入了 <strong>Thompson</strong> 的开发项目，合作开发 UNIX，他的主要工作是改造 <strong>B 语言</strong>，因为<strong>B 语言</strong> 的跨平台性较差</li><li>1972 年，<strong>Dennis M.Ritchie</strong> 在 <strong>B 语言</strong> 的基础上最终设计出了一种新的语言，他取了 <strong>BCPL</strong> 的第二个字母作为这种语言的名字，这就是 <strong>C 语言</strong></li><li>1973 年初，<strong>C 语言</strong>的主体完成，<strong>Thompson</strong> 和 <strong>Ritchie</strong> 迫不及待地开始用它完全重写了现在大名鼎鼎的 <strong>Unix 操作系统</strong></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194534.png" alt="002_unix之父" loading="lazy">￼</p><p>肯·汤普逊（左）和丹尼斯·里奇（右）</p><h4 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h4><ul><li>在把 <strong>UNIX</strong> 移植到其他类型的计算机上使用时，<strong>C 语言</strong>强大的移植性（Portability）在此显现<ul><li>机器语言和汇编语言都不具有移植性，为 x86 开发的程序，不可能在 Alpha，SPARC 和 ARM 等机器上运行</li></ul></li><li>而 <strong>C 语言</strong>程序则可以使用在任意架构的处理器上，只要那种架构的处理器<strong>具有对应的 C 语言编译器和库</strong>，然后将 C 源代码编译、连接成目标二进制文件之后即可运行</li></ul><h4 id="Unix-家谱"><a href="#Unix-家谱" class="headerlink" title="Unix 家谱"></a>Unix 家谱</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194535.jpg" alt="003_unix家谱" loading="lazy">￼</p><h3 id="1-2-Minix"><a href="#1-2-Minix" class="headerlink" title="1.2 Minix"></a>1.2 Minix</h3><ul><li>因为 <strong>AT&amp;T（通用电气）</strong> 的政策改变，在 Version 7 Unix 推出之后，发布新的使用条款，将 UNIX 源代码私有化，在大学中不再能使用 UNIX 源代码</li><li><strong>Andrew S. Tanenbaum（塔能鲍姆）</strong> 教授为了能 <strong>在课堂上教授学生操作系统运作的细节</strong>，决定在不使用任何 AT&amp;T 的源代码前提下，自行开发与 UNIX 兼容的操作系统，以避免版权上的争议</li><li>以 <strong>小型 UNIX（mini-UNIX）</strong>之意，将它称为 <strong>MINIX</strong></li></ul><h3 id="1-3-Linux"><a href="#1-3-Linux" class="headerlink" title="1.3 Linux"></a>1.3 Linux</h3><ul><li>1991 年 <strong>林纳斯（Linus）</strong> 就读于赫尔辛基大学期间，对 Unix 产生浓厚兴趣，尝试着在Minix 上做一些开发工作</li><li>因为 <strong>Minix</strong> 只是教学使用，因此功能并不强，<strong>林纳斯</strong> 经常要用他的终端 <strong>仿真器（Terminal Emulator）</strong> 去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了磁盘驱动程序和文件系统，这些在后来成为了 Linux 第一个内核的雏形，当时，他年仅 21 岁！</li><li><strong>林纳斯</strong> 利用 GNU 的 bash 当做开发环境，gcc 当做编译工具，编写了 Linux 内核，一开始 Linux 并不能兼容 Unix<ul><li>即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致</li><li>一开始 Linux 只适用于 386，后来经过全世界的网友的帮助，最终能够兼容多种硬件</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194536.jpg" alt="004_林纳斯" loading="lazy">￼</p><h2 id="02-Linux-内核及发行版"><a href="#02-Linux-内核及发行版" class="headerlink" title="02. Linux 内核及发行版"></a>02. Linux 内核及发行版</h2><h3 id="2-1-Linux-内核版本"><a href="#2-1-Linux-内核版本" class="headerlink" title="2.1 Linux 内核版本"></a>2.1 Linux 内核版本</h3><ul><li><strong>内核（kernel）</strong>是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层</li><li>Linux 内核版本又分为 <strong>稳定版</strong> 和 <strong>开发版</strong>，两种版本是相互关联，相互循环<ul><li><strong>稳定版</strong>：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序</li><li><strong>开发版</strong>：由于要试验各种解决方案，所以变化很快</li></ul></li><li>内核源码网址：<a href="http://www.kernel.org/">http://www.kernel.org</a></li></ul><blockquote><p>所有来自全世界的对 Linux 源码的修改最终都会汇总到这个网站，由 Linus 领导的开源社区对其进行甄别和修改最终决定是否进入到 Linux 主线内核源码中</p></blockquote><h3 id="2-2-Linux-发行版本"><a href="#2-2-Linux-发行版本" class="headerlink" title="2.2 Linux 发行版本"></a>2.2 Linux 发行版本</h3><ul><li><p><strong>Linux 发行版（也被叫做 GNU&#x2F;Linux 发行版）</strong>通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件</p></li><li><p>常见的发行版本如下：</p><ul><li>Ubuntu</li><li>Redhat</li><li>Fedora</li><li>openSUSE</li><li>Linux Mint</li><li>Debian</li><li>Manjaro</li><li>Mageia</li><li>CentOS</li><li>Arch</li></ul></li><li><p>十大 Linux 服务器发行版排行榜：<a href="http://os.51cto.com/art/201612/526126.htm">http://os.51cto.com/art/201612/526126.htm</a></p></li></ul><blockquote><p>在几乎每一份与 Linux 有关的榜单上，基于 Debian 的 Ubuntu 都占有一席之位。Canonical 的Ubuntu 胜过其他所有的 Linux 服务器发行版 ―― 从简单安装、出色的硬件发现，到世界级的商业支持，Ubuntu确立了难以企及的严格标准</p></blockquote><h2 id="03-Linux-的应用领域"><a href="#03-Linux-的应用领域" class="headerlink" title="03. Linux 的应用领域"></a>03. Linux 的应用领域</h2><h3 id="3-1-服务器领域"><a href="#3-1-服务器领域" class="headerlink" title="3.1 服务器领域"></a>3.1 服务器领域</h3><ul><li>Linux 在服务器领域的应用是其重要分支</li><li>Linux 免费、稳定、高效等特点在这里得到了很好的体现<ul><li>早期因为维护、运行等原因同样受到了很大的限制</li><li>近些年来 Linux 服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛</li></ul></li></ul><h3 id="3-2-嵌入式领域"><a href="#3-2-嵌入式领域" class="headerlink" title="3.2 嵌入式领域"></a>3.2 嵌入式领域</h3><ul><li>近些年来 Linux 在嵌入式领域的应用得到了飞速的提高</li><li>Linux 运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百 KB 等特点，使其近些年来在嵌入式领域的应用得到非常大的提高</li></ul><blockquote><p>主要应用：<strong>机顶盒</strong>、<strong>数字电视</strong>、<strong>网络电话</strong>、<strong>程控交换机</strong>、<strong>手机</strong>、<strong>PDA</strong>、等都是其应用领域，得到了 Google、三星、摩托罗拉、NEC 等公司的大力推广</p></blockquote><h3 id="3-3-个人桌面领域"><a href="#3-3-个人桌面领域" class="headerlink" title="3.3 个人桌面领域"></a>3.3 个人桌面领域</h3><ul><li>此领域是传统 Linux 应用最薄弱的环节</li><li>传统 Linux 由于界面简单、操作复杂、应用软件少的缺点，一直被 Windows 所压制</li><li>近些年来随着 <strong>Ubuntu</strong>、<strong>Fedora</strong> 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，Linux 在个人桌面领域的占有率在逐渐的提高</li></ul><blockquote><p>在 Ubuntu 中玩 QQ</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194537.jpg" alt="005_ubuntu_qq" loading="lazy">￼</p><h1 id="04-文件和目录（理解）"><a href="#04-文件和目录（理解）" class="headerlink" title="04.文件和目录（理解）"></a>04.文件和目录（理解）</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ul><li>理解 Linux 文件目录的结构</li></ul><h2 id="01-单用户操作系统和多用户操作系统（科普）"><a href="#01-单用户操作系统和多用户操作系统（科普）" class="headerlink" title="01. 单用户操作系统和多用户操作系统（科普）"></a>01. 单用户操作系统和多用户操作系统（科普）</h2><ul><li><p><strong>单用户操作系统</strong>：指一台计算机在同一时间 <strong>只能由一个用户</strong> 使用，一个用户独自享用系统的全部硬件和软件资源</p><ul><li><strong>Windows XP</strong> 之前的版本都是单用户操作系统</li></ul></li><li><p><strong>多用户操作系统</strong>：指一台计算机在同一时间可以由 <strong>多个用户</strong> 使用，多个用户共同享用系统的全部硬件和软件资源</p><ul><li><strong>Unix</strong> 和 <strong>Linux</strong> 的设计初衷就是多用户操作系统</li></ul></li></ul><h2 id="02-Windows-和-Linux-文件系统区别"><a href="#02-Windows-和-Linux-文件系统区别" class="headerlink" title="02. Windows 和 Linux 文件系统区别"></a>02. <code>Windows</code> 和 <code>Linux</code> 文件系统区别</h2><h3 id="2-1-Windows-下的文件系统"><a href="#2-1-Windows-下的文件系统" class="headerlink" title="2.1 Windows 下的文件系统"></a>2.1 <code>Windows</code> 下的文件系统</h3><ul><li>在 <code>Windows</code> 下，打开 “计算机”，我们看到的是一个个的驱动器盘符：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194549.png" alt="001_Windows下的多个盘" loading="lazy">￼</p><ul><li>每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194550.png" alt="001-Windows下多个盘为节点的目录分支" loading="lazy">￼</p><h3 id="2-2-Linux-下的文件系统"><a href="#2-2-Linux-下的文件系统" class="headerlink" title="2.2 Linux 下的文件系统"></a>2.2 <code>Linux</code> 下的文件系统</h3><ul><li>在 <code>Linux</code> 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194551.png" alt="002_Ubuntu文件目录" loading="lazy">￼</p><ul><li><code>Ubuntu</code> 没有盘符这个概念，只有一个根目录 <code>/</code>，所有文件都在它下面</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194552.png" alt="003-Linux的树形示意图" loading="lazy">￼</p><h3 id="2-3-用户目录"><a href="#2-3-用户目录" class="headerlink" title="2.3 用户目录"></a>2.3 用户目录</h3><p>位于 <code>/home/user</code>，称之为用户工作目录或家目录，表示方式：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;home&#x2F;user~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-4-Linux-主要目录速查表"><a href="#2-4-Linux-主要目录速查表" class="headerlink" title="2.4 Linux 主要目录速查表"></a>2.4 <code>Linux</code> 主要目录速查表</h3><ul><li>&#x2F;：根目录，<strong>一般根目录下只存放目录</strong>，在 linux 下有且只有一个根目录，所有的东西都是从这里开始<ul><li>当在终端里输入 <code>/home</code>，其实是在告诉电脑，先从 <code>/</code>（根目录）开始，再进入到 <code>home</code> 目录</li></ul></li><li>&#x2F;bin、&#x2F;usr&#x2F;bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等</li><li>&#x2F;boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：<code>/boot/vmlinuz</code>，系统引导管理器：<code>/boot/grub</code></li><li>&#x2F;dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom /mnt</code></li><li>&#x2F;etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有<ul><li>&#x2F;etc&#x2F;inittab</li><li>&#x2F;etc&#x2F;fstab</li><li>&#x2F;etc&#x2F;init.d</li><li>&#x2F;etc&#x2F;X11</li><li>&#x2F;etc&#x2F;sysconfig</li><li>&#x2F;etc&#x2F;xinetd.d</li></ul></li><li>&#x2F;home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下<ul><li><code>~</code> 表示当前用户的家目录</li><li><code>~edu</code> 表示用户 <code>edu</code> 的家目录</li></ul></li><li>&#x2F;lib、&#x2F;usr&#x2F;lib、&#x2F;usr&#x2F;local&#x2F;lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助</li><li>&#x2F;lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下</li><li>&#x2F;mnt: &#x2F;media：光盘默认挂载点，通常光盘挂载于 &#x2F;mnt&#x2F;cdrom 下，也不一定，可以选择任意位置进行挂载</li><li>&#x2F;opt：给主机额外安装软件所摆放的目录</li><li>&#x2F;proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：&#x2F;proc&#x2F;cpuinfo、&#x2F;proc&#x2F;interrupts、&#x2F;proc&#x2F;dma、&#x2F;proc&#x2F;ioports、&#x2F;proc&#x2F;net&#x2F;* 等</li><li>&#x2F;root：系统管理员root的家目录</li><li>&#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 &#x2F;bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用</li><li>&#x2F;tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下</li><li>&#x2F;srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 &#x2F;srv&#x2F;www 内</li><li>&#x2F;usr：应用程序存放目录<ul><li>&#x2F;usr&#x2F;bin：存放应用程序</li><li>&#x2F;usr&#x2F;share：存放共享数据</li><li>&#x2F;usr&#x2F;lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件</li><li>&#x2F;usr&#x2F;local：存放软件升级包</li><li>&#x2F;usr&#x2F;share&#x2F;doc：系统说明文件存放目录</li><li>&#x2F;usr&#x2F;share&#x2F;man：程序说明文件存放目录</li></ul></li><li>&#x2F;var：放置系统执行过程中经常变化的文件<ul><li>&#x2F;var&#x2F;log：随时更改的日志文件</li><li>&#x2F;var&#x2F;spool&#x2F;mail：邮件存放的目录</li><li>&#x2F;var&#x2F;run：程序或服务启动后，其 PID 存放在该目录下</li></ul></li></ul><h1 id="05-Ubuntu-图形界面入门"><a href="#05-Ubuntu-图形界面入门" class="headerlink" title="05.Ubuntu 图形界面入门"></a>05.Ubuntu 图形界面入门</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><ul><li>熟悉 Ubuntu 图形界面的基本使用</li></ul><h2 id="01-Ubuntu-的任务栏"><a href="#01-Ubuntu-的任务栏" class="headerlink" title="01. Ubuntu 的任务栏"></a>01. Ubuntu 的任务栏</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194600.jpg" loading="lazy">￼</p><h2 id="02-窗口操作按钮"><a href="#02-窗口操作按钮" class="headerlink" title="02. 窗口操作按钮"></a>02. 窗口操作按钮</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194601.jpg" loading="lazy">￼</p><h2 id="03-窗口菜单条"><a href="#03-窗口菜单条" class="headerlink" title="03. 窗口菜单条"></a>03. 窗口菜单条</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194602.jpg" loading="lazy">￼</p><h1 id="06-常用-Linux-命令的基本使用"><a href="#06-常用-Linux-命令的基本使用" class="headerlink" title="06.常用 Linux 命令的基本使用"></a>06.常用 Linux 命令的基本使用</h1><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h2><ul><li>理解学习 Linux 终端命令的原因</li><li>常用 Linux 命令体验</li></ul><h2 id="01-学习-Linux-终端命令的原因"><a href="#01-学习-Linux-终端命令的原因" class="headerlink" title="01. 学习 Linux 终端命令的原因"></a>01. 学习 Linux 终端命令的原因</h2><ul><li>Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 <strong>磁盘操作</strong>、<strong>文件存取</strong>、<strong>目录操作</strong>、<strong>进程管理</strong>、<strong>文件权限</strong> 设定等</li><li>在职场中，大量的 <strong>服务器维护工作</strong> 都是在 <strong>远程</strong> 通过 <strong>SSH 客户端</strong> 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成</li><li>在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令</li><li>Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已</li></ul><blockquote><p>学习终端命令的技巧：</p><ul><li>不需要死记硬背，对于常用命令，用的多了，自然就记住了</li><li>不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以</li></ul></blockquote><h2 id="02-常用-Linux-命令的基本使用"><a href="#02-常用-Linux-命令的基本使用" class="headerlink" title="02. 常用 Linux 命令的基本使用"></a>02. 常用 Linux 命令的基本使用</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>02</td><td>pwd</td><td>print wrok directory</td><td>查看当前所在文件夹</td></tr><tr><td>03</td><td>cd [目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>04</td><td>touch [文件名]</td><td>touch</td><td>如果文件不存在，新建文件</td></tr><tr><td>05</td><td>mkdir [目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>06</td><td>rm [文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>07</td><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><blockquote><p>小技巧</p><ul><li><code>ctrl + shift + =</code> <strong>放大</strong>终端窗口的字体显示</li><li><code>ctrl + -</code> <strong>缩小</strong>终端窗口的字体显示</li></ul></blockquote><h3 id="03-自动补全"><a href="#03-自动补全" class="headerlink" title="03. 自动补全"></a>03. 自动补全</h3><ul><li>在敲出 <code>文件</code>／<code>目录</code>／<code>命令</code> 的前几个字母之后，按下 <code>tab</code> 键<ul><li>如果输入的没有歧义，系统会自动补全</li><li>如果还存在其他 <code>文件</code>／<code>目录</code>／<code>命令</code>，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li></ul></li></ul><blockquote><p>小技巧</p><ul><li>按 <code>上</code>／<code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li><li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li></ul></blockquote><h1 id="07-Linux-终端命令格式"><a href="#07-Linux-终端命令格式" class="headerlink" title="07.Linux 终端命令格式"></a>07.Linux 终端命令格式</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h2><ul><li>了解终端命令格式</li><li>知道如何查阅终端命令帮助信息</li></ul><h2 id="01-终端命令格式"><a href="#01-终端命令格式" class="headerlink" title="01. 终端命令格式"></a>01. 终端命令格式</h2><pre class="line-numbers language-none"><code class="language-none">command [-options] [parameter]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><ul><li><code>command</code>：命令名，相应功能的英文单词或单词的缩写</li><li><code>[-options]</code>：选项，可用来对命令进行控制，也可以省略</li><li><code>parameter</code>：传给命令的参数，可以是 <strong>零个</strong>、<strong>一个</strong> 或者 <strong>多个</strong></li></ul><blockquote><p><code>[]</code> 代表可选</p></blockquote><h2 id="02-查阅命令帮助信息（知道）"><a href="#02-查阅命令帮助信息（知道）" class="headerlink" title="02. 查阅命令帮助信息（知道）"></a>02. 查阅命令帮助信息（知道）</h2><blockquote><p>提示</p><ul><li>现阶段只需要 <strong>知道</strong> 通过以下两种方式可以查询命令的帮助信息</li><li>先学习<strong>常用命令</strong>及<strong>常用选项</strong>的使用即可，工作中如果遇到问题可以借助 <strong>网络搜索</strong></li></ul></blockquote><h3 id="2-1-help"><a href="#2-1-help" class="headerlink" title="2.1 --help"></a>2.1 <code>--help</code></h3><pre class="line-numbers language-none"><code class="language-none">command --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><ul><li>显示 <code>command</code> 命令的帮助信息</li></ul><h3 id="2-2-man"><a href="#2-2-man" class="headerlink" title="2.2 man"></a>2.2 man</h3><pre class="line-numbers language-none"><code class="language-none">man command<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><ul><li>查阅 <code>command</code> 命令的使用手册</li></ul><blockquote><p><code>man</code> 是 <strong>manual</strong> 的缩写，是 Linux 提供的一个 <strong>手册</strong>，包含了绝大部分的命令、函数的详细使用说明</p></blockquote><p>使用 <code>man</code> 时的操作键：</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>&#x2F;word</td><td>搜索 <strong>word</strong> 字符串</td></tr></tbody></table><h1 id="08-文件和目录常用命令"><a href="#08-文件和目录常用命令" class="headerlink" title="08.文件和目录常用命令"></a>08.文件和目录常用命令</h1><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h2><ul><li>查看目录内容<ul><li><code>ls</code></li></ul></li><li>切换目录<ul><li><code>cd</code></li></ul></li><li>创建和删除操作<ul><li><code>touch</code></li><li><code>rm</code></li><li><code>mkdir</code></li></ul></li><li>拷贝和移动文件<ul><li><code>cp</code></li><li><code>mv</code></li></ul></li><li>查看文件内容<ul><li><code>cat</code></li><li><code>more</code></li><li><code>grep</code></li></ul></li><li>其他<ul><li><code>echo</code></li><li>重定向 <code>&gt;</code> 和 <code>&gt;&gt;</code></li><li>管道 <code>|</code></li></ul></li></ul><h2 id="01-查看目录内容"><a href="#01-查看目录内容" class="headerlink" title="01. 查看目录内容"></a>01. 查看目录内容</h2><h3 id="1-1-终端实用技巧"><a href="#1-1-终端实用技巧" class="headerlink" title="1.1 终端实用技巧"></a>1.1 终端实用技巧</h3><h4 id="1-gt-自动补全"><a href="#1-gt-自动补全" class="headerlink" title="1&gt; 自动补全"></a>1&gt; 自动补全</h4><ul><li>在敲出 <code>文件</code>／<code>目录</code>／<code>命令</code> 的前几个字母之后，按下 <code>tab</code> 键<ul><li>如果输入的没有歧义，系统会自动补全</li><li>如果还存在其他 <code>文件</code>／<code>目录</code>／<code>命令</code>，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li></ul></li></ul><h4 id="2-gt-曾经使用过的命令"><a href="#2-gt-曾经使用过的命令" class="headerlink" title="2&gt; 曾经使用过的命令"></a>2&gt; 曾经使用过的命令</h4><ul><li>按 <code>上</code>／<code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li><li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li></ul><h3 id="1-2-ls-命令说明"><a href="#1-2-ls-命令说明" class="headerlink" title="1.2 ls 命令说明"></a>1.2 <code>ls</code> 命令说明</h3><ul><li><code>ls</code> 是英文单词 <strong>list</strong> 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 <strong>DOS</strong> 下的 <code>dir</code> 命令</li></ul><h4 id="Linux-下文件和目录的特点"><a href="#Linux-下文件和目录的特点" class="headerlink" title="Linux 下文件和目录的特点"></a>Linux 下文件和目录的特点</h4><ul><li>Linux <strong>文件</strong> 或者 <strong>目录</strong> 名称最长可以有 <code>256</code> 个字符</li><li>以 <code>.</code> 开头的文件为隐藏文件，需要用 -a 参数才能显示</li><li><strong>.</strong> 代表当前目录</li><li><strong>..</strong> 代表上一级目录</li></ul><h3 id="1-3-ls-常用选项"><a href="#1-3-ls-常用选项" class="headerlink" title="1.3 ls 常用选项"></a>1.3 ls 常用选项</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><h4 id="计算机中文件大小的表示方式（科普）"><a href="#计算机中文件大小的表示方式（科普）" class="headerlink" title="计算机中文件大小的表示方式（科普）"></a>计算机中文件大小的表示方式（科普）</h4><table><thead><tr><th>单位</th><th>英文</th><th>含义</th></tr></thead><tbody><tr><td>字节</td><td>B（Byte）</td><td>在计算机中作为一个数字单元，一般为 8 位二进制数</td></tr><tr><td>千</td><td>K（Kibibyte）</td><td>1 KB &#x3D; 1024 B，千字节 （1024 &#x3D; 2 ** 10）</td></tr><tr><td>兆</td><td>M（Mebibyte）</td><td>1 MB &#x3D; 1024 KB，百万字节</td></tr><tr><td>千兆</td><td>G（Gigabyte）</td><td>1 GB &#x3D; 1024 MB，十亿字节，千兆字节</td></tr><tr><td>太</td><td>T（Terabyte）</td><td>1 TB &#x3D; 1024 GB，万亿字节，太字节</td></tr><tr><td>拍</td><td>P（Petabyte）</td><td>1 PB &#x3D; 1024 TB，千万亿字节，拍字节</td></tr><tr><td>艾</td><td>E（Exabyte）</td><td>1 EB &#x3D; 1024 PB，百亿亿字节，艾字节</td></tr><tr><td>泽</td><td>Z（Zettabyte）</td><td>1 ZB &#x3D; 1024 EB，十万亿亿字节，泽字节</td></tr><tr><td>尧</td><td>Y（Yottabyte）</td><td>1 YB &#x3D; 1024 ZB，一亿亿亿字节，尧字节</td></tr></tbody></table><h3 id="1-4-ls-通配符的使用"><a href="#1-4-ls-通配符的使用" class="headerlink" title="1.4 ls 通配符的使用"></a>1.4 ls 通配符的使用</h3><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意个数个字符</td></tr><tr><td>?</td><td>代表任意一个字符，至少 1 个</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任一一个</td></tr><tr><td>[abc]</td><td>匹配 a、b、c 中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从 a 到 f 范围内的的任意一个字符</td></tr></tbody></table><h2 id="02-切换目录"><a href="#02-切换目录" class="headerlink" title="02. 切换目录"></a>02. 切换目录</h2><h3 id="2-1-cd"><a href="#2-1-cd" class="headerlink" title="2.1 cd"></a>2.1 <code>cd</code></h3><ul><li><code>cd</code> 是英文单词 <strong>change directory</strong> 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一</li></ul><blockquote><p>注意：Linux 所有的 <strong>目录</strong> 和 <strong>文件名</strong> 都是大小写敏感的</p></blockquote><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)</td></tr><tr><td>cd ~</td><td>切换到当前用户的主目录(&#x2F;home&#x2F;用户目录)</td></tr><tr><td>cd .</td><td>保持在当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h3 id="2-2-相对路径和绝对路径"><a href="#2-2-相对路径和绝对路径" class="headerlink" title="2.2 相对路径和绝对路径"></a>2.2 相对路径和绝对路径</h3><ul><li><strong>相对路径</strong> 在输入路径时，最前面不是 <strong>&#x2F;</strong> 或者 **~**，表示相对 <strong>当前目录</strong> 所在的目录位置</li><li><strong>绝对路径</strong> 在输入路径时，最前面是 <strong>&#x2F;</strong> 或者 **~**，表示从 <strong>根目录&#x2F;家目录</strong> 开始的具体目录位置</li></ul><h2 id="03-创建和删除操作"><a href="#03-创建和删除操作" class="headerlink" title="03. 创建和删除操作"></a>03. 创建和删除操作</h2><h3 id="3-1-touch"><a href="#3-1-touch" class="headerlink" title="3.1 touch"></a>3.1 <code>touch</code></h3><ul><li>创建文件或修改文件时间<ul><li>如果文件 <strong>不存在</strong>，可以创建一个空白文件</li><li>如果文件 <strong>已经存在</strong>，可以修改文件的末次修改日期</li></ul></li></ul><h3 id="3-2-mkdir"><a href="#3-2-mkdir" class="headerlink" title="3.2 mkdir"></a>3.2 <code>mkdir</code></h3><ul><li>创建一个新的目录</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>可以递归创建目录</td></tr></tbody></table><blockquote><p><strong>新建目录的名称</strong> 不能与当前目录中 <strong>已有的目录或文件</strong> 同名</p></blockquote><h3 id="3-3-rm"><a href="#3-3-rm" class="headerlink" title="3.3 rm"></a>3.3 <code>rm</code></h3><ul><li>删除文件或目录</li></ul><blockquote><p>使用 <code>rm</code> 命令要小心，因为文件删除后不能恢复</p></blockquote><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，<strong>删除文件夹</strong> 时必须加此参数</td></tr></tbody></table><h2 id="04-拷贝和移动文件"><a href="#04-拷贝和移动文件" class="headerlink" title="04. 拷贝和移动文件"></a>04. 拷贝和移动文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td></tr><tr><td>02</td><td>cp 源文件 目标文件</td><td>copy</td><td>复制文件或者目录</td></tr><tr><td>03</td><td>mv 源文件 目标文件</td><td>move</td><td>移动文件或者目录／文件或者目录重命名</td></tr></tbody></table><h3 id="4-1-tree"><a href="#4-1-tree" class="headerlink" title="4.1 tree"></a>4.1 <code>tree</code></h3><ul><li><code>tree</code> 命令可以以树状图列出文件目录结构</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>只显示目录</td></tr></tbody></table><h3 id="4-2-cp"><a href="#4-2-cp" class="headerlink" title="4.2 cp"></a>4.2 <code>cp</code></h3><ul><li><code>cp</code> 命令的功能是将给出的 <strong>文件</strong> 或 <strong>目录</strong> 复制到另一个 <strong>文件</strong> 或 <strong>目录</strong> 中，相当于 <strong>DOS</strong> 下的 <code>copy</code> 命令</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr><tr><td>-r</td><td>若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr></tbody></table><h3 id="4-3-mv"><a href="#4-3-mv" class="headerlink" title="4.3 mv"></a>4.3 <code>mv</code></h3><ul><li><code>mv</code> 命令可以用来 <strong>移动</strong> <strong>文件</strong> 或 <strong>目录</strong>，也可以给 <strong>文件或目录重命名</strong></li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr></tbody></table><h2 id="05-查看文件内容"><a href="#05-查看文件内容" class="headerlink" title="05. 查看文件内容"></a>05. 查看文件内容</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cat 文件名</td><td>concatenate</td><td>查看文件内容、创建文件、文件合并、追加文件内容等功能</td></tr><tr><td>02</td><td>more 文件名</td><td>more</td><td>分屏显示文件内容</td></tr><tr><td>03</td><td>grep 搜索文本 文件名</td><td>grep</td><td>搜索文本文件内容</td></tr></tbody></table><h3 id="5-1-cat"><a href="#5-1-cat" class="headerlink" title="5.1 cat"></a>5.1 <code>cat</code></h3><ul><li><code>cat</code> 命令可以用来 <strong>查看文件内容</strong>、<strong>创建文件</strong>、<strong>文件合并</strong>、<strong>追加文件内容</strong> 等功能</li><li><code>cat</code> 会一次显示所有的内容，适合 <strong>查看内容较少</strong> 的文本文件</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>对非空输出行编号</td></tr><tr><td>-n</td><td>对输出的所有行编号</td></tr></tbody></table><blockquote><p>Linux 中还有一个 <code>nl</code> 的命令和 <code>cat -b</code> 的效果等价</p></blockquote><h3 id="5-2-more"><a href="#5-2-more" class="headerlink" title="5.2 more"></a>5.2 <code>more</code></h3><ul><li><code>more</code> 命令可以用于分屏显示文件内容，每次只显示一页内容</li><li>适合于 <strong>查看内容较多</strong>的文本文件</li></ul><p>使用 <code>more</code> 的操作键：</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter 键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>&#x2F;word</td><td>搜索 <strong>word</strong> 字符串</td></tr></tbody></table><h3 id="5-3-grep"><a href="#5-3-grep" class="headerlink" title="5.3 grep"></a>5.3 <code>grep</code></h3><ul><li>Linux 系统中 <code>grep</code> 命令是一种强大的文本搜索工具</li><li><code>grep</code>允许对文本文件进行 <strong>模式</strong>查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><ul><li>常用的两种模式查找</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首，搜寻以 <strong>a</strong> 开头的行</td></tr><tr><td>ke$</td><td>行尾，搜寻以 <strong>ke</strong> 结束的行</td></tr></tbody></table><h2 id="06-其他"><a href="#06-其他" class="headerlink" title="06. 其他"></a>06. 其他</h2><h3 id="6-1-echo-文字内容"><a href="#6-1-echo-文字内容" class="headerlink" title="6.1 echo 文字内容"></a>6.1 <code>echo 文字内容</code></h3><ul><li><code>echo</code> 会在终端中显示参数指定的文字，通常会和 <strong>重定向</strong> 联合使用</li></ul><h3 id="6-2-重定向-gt-和-gt-gt"><a href="#6-2-重定向-gt-和-gt-gt" class="headerlink" title="6.2 重定向 &gt; 和 &gt;&gt;"></a>6.2 重定向 <code>&gt;</code> 和 <code>&gt;&gt;</code></h3><ul><li>Linux 允许将命令执行结果 <strong>重定向</strong>到一个 <strong>文件</strong></li><li>将本应显示在<strong>终端上的内容</strong> <strong>输出／追加</strong> 到<strong>指定文件中</strong></li></ul><p>其中</p><ul><li><code>&gt;</code> 表示输出，会覆盖文件原有的内容</li><li><code>&gt;&gt;</code> 表示追加，会将内容追加到已有文件的末尾</li></ul><h3 id="6-3-管道"><a href="#6-3-管道" class="headerlink" title="6.3 管道 |"></a>6.3 管道 <code>|</code></h3><ul><li>Linux 允许将 <strong>一个命令的输出</strong> 可以<strong>通过管道</strong> 做为 <strong>另一个命令的输入</strong></li><li>可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 <code>|</code> 的左右分为两端，左端塞东西（写），右端取东西（读）</li></ul><p>常用的管道命令有：</p><ul><li><code>more</code>：分屏显示内容</li><li><code>grep</code>：在命令执行结果的基础上查询指定的文本</li></ul><h1 id="09-远程管理常用命令"><a href="#09-远程管理常用命令" class="headerlink" title="09.远程管理常用命令"></a>09.远程管理常用命令</h1><h2 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h2><ul><li>关机&#x2F;重启<ul><li><code>shutdown</code></li></ul></li><li>查看或配置网卡信息<ul><li><code>ifconfig</code></li><li><code>ping</code></li></ul></li><li>远程登录和复制文件<ul><li><code>ssh</code></li><li><code>scp</code></li></ul></li></ul><h2 id="01-关机-x2F-重启"><a href="#01-关机-x2F-重启" class="headerlink" title="01. 关机&#x2F;重启"></a>01. 关机&#x2F;重启</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>shutdown 选项 时间</td><td>shutdown</td><td>关机／重新启动</td></tr></tbody></table><h3 id="1-1-shutdown"><a href="#1-1-shutdown" class="headerlink" title="1.1 shutdown"></a>1.1 <code>shutdown</code></h3><ul><li><code>shutdown</code> 命令可以 <strong>安全</strong> <strong>关闭</strong> 或者 <strong>重新启动系统</strong></li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>重新启动</td></tr></tbody></table><blockquote><p>提示：</p><ul><li><strong>不指定选项和参数</strong>，默认表示 <strong>1 分钟</strong>之后 <strong>关闭电脑</strong></li><li>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</li></ul></blockquote><ul><li>常用命令示例</li></ul><pre class="line-numbers language-none"><code class="language-none"># 重新启动操作系统，其中 now 表示现在$ shutdown -r now# 立刻关机，其中 now 表示现在$ shutdown now# 系统在今天的 20:25 会关机$ shutdown 20:25# 系统再过十分钟后自动关机$ shutdown +10# 取消之前指定的关机计划$ shutdown -c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="02-查看或配置网卡信息"><a href="#02-查看或配置网卡信息" class="headerlink" title="02. 查看或配置网卡信息"></a>02. 查看或配置网卡信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ifconfig</td><td>configure a network interface</td><td>查看&#x2F;配置计算机当前的网卡配置信息</td></tr><tr><td>02</td><td>ping ip地址</td><td>ping</td><td>检测到目标 ip地址 的连接是否正常</td></tr></tbody></table><h3 id="2-1-网卡-和-IP-地址"><a href="#2-1-网卡-和-IP-地址" class="headerlink" title="2.1 网卡 和 IP 地址"></a>2.1 网卡 和 IP 地址</h3><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><ul><li>网卡是一个专门负责网络通讯的硬件设备</li><li><strong>IP 地址</strong>是设置在网卡上的地址信息</li></ul><blockquote><p>我们可以把 <strong>电脑</strong> 比作 <strong>电话</strong>，<strong>网卡</strong> 相当于 <strong>SIM 卡</strong>，<strong>IP 地址</strong> 相当于 <strong>电话号码</strong></p></blockquote><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><ul><li><strong>每台联网的电脑上</strong>都有 <strong>IP 地址</strong>，<strong>是保证电脑之间正常通讯的重要设置</strong></li></ul><blockquote><p>注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯</p><p>提示：有关 <strong>IP 地址</strong>的详细内容，在就业班会详细讲解！</p></blockquote><h3 id="2-2-ifconfig"><a href="#2-2-ifconfig" class="headerlink" title="2.2 ifconfig"></a>2.2 <code>ifconfig</code></h3><ul><li><code>ifconfig</code> 可以查看／配置计算机当前的网卡配置信息</li></ul><pre class="line-numbers language-none"><code class="language-none"># 查看网卡配置信息$ ifconfig# 查看网卡对应的 IP 地址$ ifconfig | grep inet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：一台计算机中有可能会有一个 <strong>物理网卡</strong> 和 <strong>多个虚拟网卡</strong>，在 Linux 中物理网卡的名字通常以 <code>ensXX</code> 表示</p></blockquote><ul><li><code>127.0.0.1</code> 被称为 <strong>本地回环&#x2F;环回地址</strong>，一般用来测试本机网卡是否正常</li></ul><h3 id="2-3-ping"><a href="#2-3-ping" class="headerlink" title="2.3 ping"></a>2.3 <code>ping</code></h3><pre class="line-numbers language-none"><code class="language-none"># 检测到目标主机是否连接正常$ ping IP地址# 检测本地网卡工作正常$ ping 127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>ping</code> 一般用于检测当前计算机到目标计算机之间的网络 <strong>是否通畅</strong>，<strong>数值越大，速度越慢</strong></li></ul><blockquote><ul><li><code>ping</code> 的工作原理与潜水艇的声纳相似，<code>ping</code> 这个命令就是取自 <strong>声纳的声音</strong></li><li>网络管理员之间也常将 <code>ping</code> 用作动词 —— <strong>ping 一下计算机X，看他是否开着</strong></li></ul></blockquote><p>原理：网络上的机器都有 <strong>唯一确定的 IP 地址</strong>，我们给<strong>目标 IP 地址</strong>发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</p><blockquote><p>提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 <code>CTRL + C</code></p></blockquote><h2 id="03-远程登录和复制文件"><a href="#03-远程登录和复制文件" class="headerlink" title="03. 远程登录和复制文件"></a>03. 远程登录和复制文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ssh 用户名@ip</td><td>secure shell</td><td>关机／重新启动</td></tr><tr><td>02</td><td>scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径</td><td>secure copy</td><td>远程复制文件</td></tr></tbody></table><h3 id="3-1-ssh-基础（重点）"><a href="#3-1-ssh-基础（重点）" class="headerlink" title="3.1 ssh 基础（重点）"></a>3.1 <code>ssh</code> 基础（重点）</h3><p>在 Linux 中 SSH 是 <strong>非常常用</strong> 的工具，通过 <strong>SSH 客户端</strong> 我们可以连接到运行了 <strong>SSH 服务器</strong> 的远程机器上</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194637.png" alt="001_SSH示意图" loading="lazy">￼</p><ul><li><strong>SSH 客户端</strong>是一种使用 <code>Secure Shell（SSH）</code> 协议连接到远程计算机的软件程序</li><li><code>SSH</code> 是目前较可靠，<strong>专为远程登录会话和其他网络服务</strong> 提供安全性的协议<ul><li>利用 <code>SSH 协议</code> 可以有效<strong>防止远程管理过程中的信息泄露</strong></li><li>通过 <code>SSH 协议</code> 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗</li></ul></li><li><code>SSH</code> 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度</li></ul><h4 id="1-域名-和-端口号"><a href="#1-域名-和-端口号" class="headerlink" title="1) 域名 和 端口号"></a>1) 域名 和 端口号</h4><h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><ul><li>由一串 <strong>用点分隔</strong> 的名字组成，例如：<code>www.itcast.cn</code></li><li>是 <strong>IP 地址</strong> 的别名，方便用户记忆</li></ul><h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><ul><li><p><strong>IP 地址</strong>：通过 <strong>IP 地址</strong> 找到网络上的 <strong>计算机</strong></p></li><li><p><strong>端口号</strong>：通过 <strong>端口号</strong> 可以找到 <strong>计算机上运行的应用程序</strong></p><ul><li><strong>SSH 服务器</strong> 的默认端口号是 <code>22</code>，如果是默认端口号，在连接的时候，可以省略</li></ul></li><li><p>常见服务端口号列表：</p></li></ul><table><thead><tr><th>序号</th><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>01</td><td>SSH 服务器</td><td>22</td></tr><tr><td>02</td><td>Web 服务器</td><td>80</td></tr><tr><td>03</td><td>HTTPS</td><td>443</td></tr><tr><td>04</td><td>FTP 服务器</td><td>21</td></tr></tbody></table><blockquote><p>提示：有关 <strong>端口号</strong>的详细内容，在就业班会详细讲解！</p></blockquote><h4 id="2-SSH-客户端的简单使用"><a href="#2-SSH-客户端的简单使用" class="headerlink" title="2) SSH 客户端的简单使用"></a>2) SSH 客户端的简单使用</h4><pre class="line-numbers language-none"><code class="language-none">ssh [-p port] user@remote<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>user</code> 是在远程机器上的用户名，如果不指定的话默认为当前用户</li><li><code>remote</code> 是远程机器的地址，可以是 <strong>IP</strong>／<strong>域名</strong>，或者是 <strong>后面会提到的别名</strong></li><li><code>port</code> 是 <strong>SSH Server 监听的端口</strong>，如果不指定，就为默认值 <code>22</code></li></ul><blockquote><p>提示：</p><ul><li>使用 <code>exit</code> 退出当前用户的登录</li></ul><p>注意：</p><ul><li><code>ssh</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li><li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code> 或者 <code>XShell</code> 客户端软件即可</li></ul><p>提示：</p><ul><li>在工作中，SSH 服务器的端口号很有可能<strong>不是 22</strong>，如果遇到这种情况就需要使用 <code>-p</code> 选项，指定正确的端口号，否则无法正常连接到服务器</li></ul></blockquote><h4 id="3-Windows-下-SSH-客户端的安装"><a href="#3-Windows-下-SSH-客户端的安装" class="headerlink" title="3) Windows 下 SSH 客户端的安装"></a>3) Windows 下 SSH 客户端的安装</h4><ul><li><code>Putty</code> <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/latest.html">http://www.chiark.greenend.org.uk/~sgtatham&#x2F;putty&#x2F;latest.html</a></li><li><code>XShell</code> <a href="http://xshellcn.com/">http://xshellcn.com</a></li></ul><blockquote><p>建议从官方网站下载正式的安装程序</p></blockquote><h3 id="3-2-scp（掌握）"><a href="#3-2-scp（掌握）" class="headerlink" title="3.2 scp（掌握）"></a>3.2 <code>scp</code>（掌握）</h3><ul><li>scp 就是 <code>secure copy</code>，是一个在 Linux 下用来进行 <strong>远程拷贝文件</strong> 的命令</li><li>它的<strong>地址格式与 ssh 基本相同</strong>，<strong>需要注意的是</strong>，在指定端口时用的是大写的 <code>-P</code> 而不是小写的</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194638.png" alt="002_SCP示意图" loading="lazy">￼</p><pre class="line-numbers language-none"><code class="language-none"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop&#x2F;01.py# 注意：&#96;:&#96; 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop&#x2F;01.py# 把远程 家目录下的 Desktop&#x2F;01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop&#x2F;01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr><tr><td>-P</td><td>若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口</td></tr></tbody></table><blockquote><p>注意：</p><ul><li><code>scp</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li><li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code>，使用 <code>pscp</code> 命令行工具或者安装 <code>FileZilla</code> 使用 <code>FTP</code> 进行文件传输</li></ul></blockquote><h4 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a><code>FileZilla</code></h4><ul><li>官方网站：<a href="https://www.filezilla.cn/download/client">https://www.filezilla.cn/download/client</a></li><li><code>FileZilla</code> 在传输文件时，使用的是 <code>FTP 服务</code> 而不是 <code>SSH 服务</code>，因此端口号应该设置为 <code>21</code></li></ul><h3 id="3-3-SSH-高级（知道）"><a href="#3-3-SSH-高级（知道）" class="headerlink" title="3.3 SSH 高级（知道）"></a>3.3 SSH 高级（知道）</h3><ul><li>免密码登录</li><li>配置别名</li></ul><blockquote><p>提示：有关 SSH 配置信息都保存在用户家目录下的 <code>.ssh</code> 目录下</p></blockquote><h4 id="1）免密码登录"><a href="#1）免密码登录" class="headerlink" title="1）免密码登录"></a>1）免密码登录</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>配置公钥<ul><li>执行 <code>ssh-keygen</code> 即可生成 SSH 钥匙，一路回车即可</li></ul></li><li>上传公钥到服务器<ul><li>执行 <code>ssh-copy-id -p port user@remote</code>，可以让远程服务器记住我们的公钥</li></ul></li></ul><h5 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194639.png" alt="003_SSH 免密码示意图" loading="lazy">￼</p><blockquote><p>非对称加密算法</p><ul><li>使用 <strong>公钥</strong> 加密的数据，需要使用 <strong>私钥</strong> 解密</li><li>使用 <strong>私钥</strong> 加密的数据，需要使用 <strong>公钥</strong> 解密</li></ul></blockquote><h4 id="2-配置别名"><a href="#2-配置别名" class="headerlink" title="2) 配置别名"></a>2) 配置别名</h4><p>每次都输入 <code>ssh -p port user@remote</code>，时间久了会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆</p><p>而 <strong>配置别名</strong> 可以让我们进一步偷懒，譬如用：<code>ssh mac</code> 来替代上面这么一长串，那么就在 <code>~/.ssh/config</code> 里面追加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">Host mac    HostName ip地址    User itheima    Port 22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>保存之后，即可用 <code>ssh mac</code> 实现远程登录了，<code>scp</code> 同样可以使用</strong></p><h1 id="10-用户权限相关命令"><a href="#10-用户权限相关命令" class="headerlink" title="10.用户权限相关命令"></a>10.用户权限相关命令</h1><h2 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h2><ul><li><strong>用户</strong> 和 <strong>权限</strong> 的基本概念</li><li><strong>用户管理</strong> 终端命令</li><li><strong>组管理</strong> 终端命令</li><li><strong>修改权限</strong> 终端命令</li></ul><h2 id="01-用户-和-权限-的基本概念"><a href="#01-用户-和-权限-的基本概念" class="headerlink" title="01. 用户 和 权限 的基本概念"></a>01. <strong>用户</strong> 和 <strong>权限</strong> 的基本概念</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li><strong>用户</strong> 是 Linux 系统工作中重要的一环，用户管理包括 <strong>用户</strong> 与 <strong>组</strong> 管理</li><li>在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都<strong>必须拥有一个账号</strong>，并且<strong>对于不同的系统资源拥有不同的使用权限</strong></li><li>在 Linux 中，可以指定 <strong>每一个用户</strong> 针对 <strong>不同的文件或者目录</strong> 的 <strong>不同权限</strong></li><li>对 <strong>文件／目录</strong> 的权限包括：</li></ul><table><thead><tr><th>序号</th><th>权限</th><th>英文</th><th>缩写</th><th>数字代号</th></tr></thead><tbody><tr><td>01</td><td>读</td><td>read</td><td>r</td><td>4</td></tr><tr><td>02</td><td>写</td><td>write</td><td>w</td><td>2</td></tr><tr><td>03</td><td>执行</td><td>excute</td><td>x</td><td>1</td></tr></tbody></table><h3 id="1-2-组"><a href="#1-2-组" class="headerlink" title="1.2 组"></a>1.2 组</h3><ul><li>为了方便用户管理，提出了 <strong>组</strong> 的概念，如下图所示</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194646.png" alt="001_组示意图" loading="lazy">￼</p><ul><li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></li></ul><h3 id="1-3-ls-l-扩展"><a href="#1-3-ls-l-扩展" class="headerlink" title="1.3 ls -l 扩展"></a>1.3 ls -l 扩展</h3><ul><li><p><code>ls -l</code> 可以查看文件夹下文件的详细信息，从左到右依次是：</p><ul><li><strong>权限</strong>，第 1 个字符如果是 <code>d</code> 表示目录</li><li><strong>硬链接数</strong>，通俗地讲，就是有多少种方式，可以访问到当前目录／文件</li><li><strong>拥有者</strong>，家目录下 文件／目录 的拥有者通常都是当前用户</li><li><strong>组</strong>，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲</li><li><strong>大小</strong></li><li><strong>时间</strong></li><li><strong>名称</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194647.png" alt="002_权限示意图" loading="lazy">￼</p><h3 id="1-4-chmod-简单使用（重要）"><a href="#1-4-chmod-简单使用（重要）" class="headerlink" title="1.4 chmod 简单使用（重要）"></a>1.4 <code>chmod</code> 简单使用（重要）</h3><ul><li><code>chmod</code> 可以修改 <strong>用户／组</strong> 对 <strong>文件／目录</strong> 的权限</li><li>命令格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">chmod +&#x2F;-rwx 文件名|目录名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>提示：以上方式会一次性修改 <code>拥有者</code> &#x2F; <code>组</code> 权限，有关 <code>chmod</code> 的高级用法，后续会讲</p></blockquote><h3 id="1-5-超级用户"><a href="#1-5-超级用户" class="headerlink" title="1.5 超级用户"></a>1.5 超级用户</h3><ul><li>Linux 系统中的 <code>root</code> 账号通常 <strong>用于系统的维护和管理</strong>，对操作系统的所有资源 <strong>具有所有访问权限</strong></li><li>在大多数版本的 Linux 中，都不推荐 <strong>直接使用 root 账号登录系统</strong></li><li>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</li></ul><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><ul><li><code>su</code> 是 <code>substitute user</code> 的缩写，表示 <strong>使用另一个用户的身份</strong></li><li><code>sudo</code> 命令用来以其他身份来执行命令，预设的身份为 <code>root</code></li><li>用户使用 <code>sudo</code> 时，必须先输入密码，之后有 <strong>5 分钟的有效期限</strong>，超过期限则必须重新输入密码</li></ul><blockquote><p>若其未经授权的用户企图使用 <code>sudo</code>，则会发出警告邮件给管理员</p></blockquote><h2 id="02-组管理-终端命令"><a href="#02-组管理-终端命令" class="headerlink" title="02. 组管理 终端命令"></a>02. <strong>组管理</strong> 终端命令</h2><blockquote><p>提示：<strong>创建组</strong> &#x2F; <strong>删除组</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p></blockquote><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>groupadd 组名</td><td>添加组</td></tr><tr><td>02</td><td>groupdel 组名</td><td>删除组</td></tr><tr><td>03</td><td>cat &#x2F;etc&#x2F;group</td><td>确认组信息</td></tr><tr><td>04</td><td>chgrp -R 组名 文件&#x2F;目录名</td><td>递归修改文件&#x2F;目录的所属组</td></tr></tbody></table><blockquote><p>提示：</p><ul><li>组信息保存在 <code>/etc/group</code> 文件中</li><li><code>/etc</code> 目录是专门用来保存 <strong>系统配置信息</strong> 的目录</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194646.png" alt="001_组示意图" loading="lazy">￼</p><ul><li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></li></ul><h4 id="演练目标"><a href="#演练目标" class="headerlink" title="演练目标"></a>演练目标</h4><ol><li>在 <code>python</code> 用户的桌面文件夹下创建 <code>Python学习</code> 目录</li><li>新建 <code>dev</code> 组</li><li>将 <code>Python学习</code> 目录的组修改为 <code>dev</code></li></ol><h2 id="03-用户管理-终端命令"><a href="#03-用户管理-终端命令" class="headerlink" title="03. 用户管理 终端命令"></a>03. <strong>用户管理</strong> 终端命令</h2><blockquote><p>提示：<strong>创建用户</strong> &#x2F; <strong>删除用户</strong> &#x2F; <strong>修改其他用户密码</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p></blockquote><h3 id="3-1-创建用户／设置密码／删除用户"><a href="#3-1-创建用户／设置密码／删除用户" class="headerlink" title="3.1 创建用户／设置密码／删除用户"></a>3.1 创建用户／设置密码／删除用户</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>useradd -m -g 组 新建用户名</td><td>添加新用户</td><td></td></tr></tbody></table><ul><li>-m 自动建立用户家目录</li><li>-g 指定用户所在的组，否则会建立一个和同名的组</li></ul><p> |<br>| 02 | passwd 用户名 | 设置用户密码 | 如果是普通用户，直接用 passwd 可以修改自己的账户密码 |<br>| 03 | userdel -r 用户名 | 删除用户 | -r 选项会自动删除用户家目录 |<br>| 04 | cat &#x2F;etc&#x2F;passwd | grep 用户名 | 确认用户信息 | 新建用户后，用户信息会保存在 &#x2F;etc&#x2F;passwd 文件中 |</p><blockquote><p>提示：</p><ul><li>创建用户时，如果忘记添加 <code>-m</code> 选项指定新用户的家目录 —— 最简单的方法就是<strong>删除用户，重新创建</strong></li><li>创建用户时，默认会创建一个和<strong>用户名</strong>同名的<strong>组名</strong></li><li>用户信息保存在 <code>/etc/passwd</code> 文件中</li></ul></blockquote><h3 id="3-2-查看用户信息"><a href="#3-2-查看用户信息" class="headerlink" title="3.2 查看用户信息"></a>3.2 查看用户信息</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>id [用户名]</td><td>查看用户 UID 和 GID 信息</td></tr><tr><td>02</td><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>03</td><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table><h4 id="passwd-文件"><a href="#passwd-文件" class="headerlink" title="passwd 文件"></a>passwd 文件</h4><p><code>/etc/passwd</code> 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p><ol><li>用户名</li><li>密码（x，表示加密的密码）</li><li>UID（用户标识）</li><li>GID（组标识）</li><li>用户全名或本地帐号</li><li>家目录</li><li>登录使用的 Shell，就是登录之后，使用的终端命令，<code>ubuntu</code> 默认是 <code>dash</code></li></ol><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><ul><li><code>usermod</code> 可以用来设置 <strong>用户</strong> 的 <strong>主组</strong> ／ <strong>附加组</strong> 和 <strong>登录 Shell</strong>，命令格式如下：</li><li><strong>主组</strong>：通常在新建用户时指定，在 <code>etc/passwd</code> 的第 4 列 <strong>GID 对应的组</strong></li><li><strong>附加组</strong>：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定 <strong>用户的附加权限</strong></li></ul><blockquote><p>提示：设置了用户的附加组之后，需要重新登录才能生效！</p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 修改用户的主组（passwd 中的 GID）usermod -g 组 用户名# 修改用户的附加组usermod -G 组 用户名# 修改用户登录 Shellusermod -s &#x2F;bin&#x2F;bash 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，可以使用以下命令，将用户添加到 <code>sudo</code> 附加组中</p></blockquote><pre class="line-numbers language-none"><code class="language-none">usermod -G sudo 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="which（重要）"><a href="#which（重要）" class="headerlink" title="which（重要）"></a>which（重要）</h4><blockquote><p>提示</p><ul><li><code>/etc/passwd</code> 是用于保存用户信息的文件</li><li><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</li></ul></blockquote><ul><li><code>which</code> 命令可以查看执行命令所在位置，例如：</li></ul><pre class="line-numbers language-none"><code class="language-none">which ls# 输出# &#x2F;bin&#x2F;lswhich useradd# 输出# &#x2F;usr&#x2F;sbin&#x2F;useradd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="bin-和-sbin"><a href="#bin-和-sbin" class="headerlink" title="bin 和 sbin"></a><code>bin</code> 和 <code>sbin</code></h5><ul><li>在 <code>Linux</code> 中，绝大多数可执行文件都是保存在 <code>/bin</code>、<code>/sbin</code>、<code>/usr/bin</code>、<code>/usr/sbin</code></li><li><code>/bin</code>（<code>binary</code>）是二进制执行文件目录，主要用于具体应用</li><li><code>/sbin</code>（<code>system binary</code>）是系统管理员专用的二进制代码存放目录，主要用于系统管理</li><li><code>/usr/bin</code>（<code>user commands for applications</code>）后期安装的一些软件</li><li><code>/usr/sbin</code>（<code>super user commands for applications</code>）超级用户的一些管理程序</li></ul><blockquote><p>提示：</p><ul><li><code>cd</code> 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 <code>which</code> 无法找到 <code>cd</code> 命令的位置</li></ul></blockquote><h3 id="3-3-切换用户"><a href="#3-3-切换用户" class="headerlink" title="3.3 切换用户"></a>3.3 切换用户</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>su - 用户名</td><td>切换用户，并且切换目录</td><td>- 可以切换到用户家目录，否则保持位置不变</td></tr><tr><td>02</td><td>exit</td><td>退出当前登录账户</td><td></td></tr></tbody></table><ul><li><code>su</code> 不接用户名，可以切换到 <code>root</code>，但是不推荐使用，因为不安全</li><li><code>exit</code> 示意图如下：</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194648.png" alt="003_su和exit示意图" loading="lazy">￼</p><h2 id="04-修改文件权限"><a href="#04-修改文件权限" class="headerlink" title="04. 修改文件权限"></a>04. 修改文件权限</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>chown</td><td>修改拥有者</td></tr><tr><td>02</td><td>chgrp</td><td>修改组</td></tr><tr><td>03</td><td>chmod</td><td>修改权限</td></tr></tbody></table><ul><li>命令格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none"># 修改文件|目录的拥有者chown 用户名 文件名|目录名# 递归修改文件|目录的组chgrp -R 组名 文件名|目录名# 递归修改文件权限chmod -R 755 文件名|目录名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>chmod</code> 在设置权限时，可以简单地使用三个数字分别对应 <strong>拥有者</strong> ／ <strong>组</strong> 和 <strong>其他</strong> 用户的权限</li></ul><pre class="line-numbers language-none"><code class="language-none"># 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他chmod +&#x2F;-rwx 文件名|目录名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194649.png" alt="004_文件权限示意图" loading="lazy">￼</p><ul><li>常见数字组合有（<code>u</code>表示用户／<code>g</code>表示组／<code>o</code>表示其他）：<ul><li><code>777</code> &#x3D;&#x3D;&#x3D;&gt; <code>u=rwx,g=rwx,o=rwx</code></li><li><code>755</code> &#x3D;&#x3D;&#x3D;&gt; <code>u=rwx,g=rx,o=rx</code></li><li><code>644</code> &#x3D;&#x3D;&#x3D;&gt; <code>u=rw,g=r,o=r</code></li></ul></li></ul><h4 id="chmod-演练目标"><a href="#chmod-演练目标" class="headerlink" title="chmod 演练目标"></a><code>chmod</code> 演练目标</h4><ol><li>将 <code>01.py</code> 的权限修改为 <code>u=rwx,g=rx,o=r</code></li><li>将 <code>123.txt</code> 的权限修改为 <code>u=rw,g=r,o=-</code></li><li>将 <code>test</code> 目录以及目录下的 <strong>所有</strong> 文件权限修改为 <code>u=rwx,g=rwx,o=rx</code></li></ol><h1 id="11-系统信息相关命令"><a href="#11-系统信息相关命令" class="headerlink" title="11.系统信息相关命令"></a>11.系统信息相关命令</h1><ul><li>本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 <strong>系统日期和时间</strong> ／ <strong>磁盘空间占用情况</strong> ／ <strong>程序执行情况</strong></li><li>本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解</li></ul><h2 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h2><ul><li>时间和日期<ul><li><code>date</code></li><li><code>cal</code></li></ul></li><li>磁盘和目录空间<ul><li><code>df</code></li><li><code>du</code></li></ul></li><li>进程信息<ul><li><code>ps</code></li><li><code>top</code></li><li><code>kill</code></li></ul></li></ul><h2 id="01-时间和日期"><a href="#01-时间和日期" class="headerlink" title="01. 时间和日期"></a>01. 时间和日期</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>date</td><td>查看系统时间</td></tr><tr><td>02</td><td>cal</td><td><code>calendar</code> 查看日历，<code>-y</code> 选项可以查看一年的日历</td></tr></tbody></table><h2 id="02-磁盘信息"><a href="#02-磁盘信息" class="headerlink" title="02. 磁盘信息"></a>02. 磁盘信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td><code>disk free</code> 显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td><code>disk usage</code> 显示目录下的文件大小</td></tr></tbody></table><ul><li>选项说明</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>以人性化的方式显示文件大小</td></tr></tbody></table><h2 id="03-进程信息"><a href="#03-进程信息" class="headerlink" title="03. 进程信息"></a>03. 进程信息</h2><ul><li>所谓 <strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td><code>process status</code> 查看进程的详细状况</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的进程并且排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>终止指定代号的进程，<code>-9</code> 表示强行终止</td></tr></tbody></table><blockquote><p><code>ps</code> 默认只会显示当前用户通过终端启动的应用程序</p></blockquote><ul><li><code>ps</code> 选项说明功能</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><blockquote><p>提示：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则可能导致系统崩溃</p><ul><li>要退出 <code>top</code> 可以直接输入 <code>q</code></li></ul></blockquote><h1 id="12-其他命令"><a href="#12-其他命令" class="headerlink" title="12.其他命令"></a>12.其他命令</h1><h2 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h2><ul><li>查找文件<ul><li><code>find</code></li></ul></li><li>软链接<ul><li><code>ln</code></li></ul></li><li>打包和压缩<ul><li><code>tar</code></li></ul></li><li>软件安装<ul><li><code>apt-get</code></li></ul></li></ul><h2 id="01-查找文件"><a href="#01-查找文件" class="headerlink" title="01. 查找文件"></a>01. 查找文件</h2><ul><li><code>find</code> 命令功能非常强大，通常用来在 <strong>特定的目录下</strong> <strong>搜索</strong> 符合条件的文件</li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>find [路径] -name “*.py”</td><td>查找指定路径下扩展名是 <code>.py</code> 的文件，包括子目录</td></tr></tbody></table><ul><li>如果省略路径，表示在当前文件夹下查找</li><li>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</li><li>有关 <code>find</code> 的高级使用，在就业班会讲</li></ul><h3 id="演练目标-1"><a href="#演练目标-1" class="headerlink" title="演练目标"></a>演练目标</h3><ul><li>1. 搜索桌面目录下，文件名包含 <code>1</code> 的文件</li></ul><pre class="line-numbers language-none"><code class="language-none">find -name &quot;*1*&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>2. 搜索桌面目录下，所有以 <code>.txt</code> 为扩展名的文件</li></ul><pre class="line-numbers language-none"><code class="language-none">find -name &quot;*.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>3. 搜索桌面目录下，以数字 <code>1</code> 开头的文件</li></ul><pre class="line-numbers language-none"><code class="language-none">find -name &quot;1*&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="02-软链接"><a href="#02-软链接" class="headerlink" title="02. 软链接"></a>02. 软链接</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ln -s 被链接的源文件 链接文件</td><td>建立文件的软链接，用通俗的方式讲<strong>类似于</strong> Windows 下的<strong>快捷方式</strong></td></tr></tbody></table><ul><li>注意：</li><li>1. 没有 <code>-s</code> 选项建立的是一个 <strong>硬链接文件</strong><ul><li>两个文件占用相同大小的硬盘空间，<strong>工作中几乎不会建立文件的硬链接</strong></li></ul></li><li>2. <strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</li></ul><h3 id="演练目标-2"><a href="#演练目标-2" class="headerlink" title="演练目标"></a>演练目标</h3><ul><li>1. 将桌面目录下的 <code>01.py</code> <strong>移动</strong>到 <code>demo/b/c</code> 目录下</li><li>2. 在桌面目录下新建 <code>01.py</code> 的 <strong>软链接</strong> <code>FirstPython</code><ul><li>分别使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 建立 <code>FirstPython</code> 的软链接</li></ul></li><li>3. 将 <code>FirstPython</code> <strong>移动</strong>到 <code>demo</code> 目录下，对比使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 的区别</li></ul><h3 id="硬链接简介（知道）"><a href="#硬链接简介（知道）" class="headerlink" title="硬链接简介（知道）"></a>硬链接简介（知道）</h3><ul><li>在使用 <code>ln</code> 创建链接时，如果没有 <code>-s</code> 选项，会创建一个 <strong>硬链接</strong>，而不是软链接</li></ul><h4 id="硬链接演练"><a href="#硬链接演练" class="headerlink" title="硬链接演练"></a>硬链接演练</h4><ul><li>1. 在 <code>~/Desktop/demo</code> 目录下建立 <code>~/Desktop/demo/b/c/01.py</code> 的硬链接 <code>01_hard</code></li><li>2. 使用 <code>ls -l</code> 查看文件的<strong>硬链接数</strong>（硬链接——有多少种方式可以访问文件或者目录）</li><li>3. 删除 <code>~/Desktop/demo/b/c/01.py</code>，并且使用 <code>tree</code> 来确认 <code>demo</code> 目录下的三个链接文件</li></ul><h4 id="文件软硬链接的示意图"><a href="#文件软硬链接的示意图" class="headerlink" title="文件软硬链接的示意图"></a>文件软硬链接的示意图</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194703.png" alt="001_文件软硬链接示意图" loading="lazy">￼</p><blockquote><p>在 Linux 中，<strong>文件名</strong> 和 <strong>文件的数据</strong> 是分开存储的</p></blockquote><ul><li>提示：<ul><li>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 才会被删除</li><li>使用 <code>ls -l</code> 可以查看一个文件的硬链接的数量</li><li>在日常工作中，几乎不会建立文件的硬链接，知道即可</li></ul></li></ul><h2 id="03-打包压缩"><a href="#03-打包压缩" class="headerlink" title="03. 打包压缩"></a>03. 打包压缩</h2><ul><li><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</li><li>在不同操作系统中，常用的打包压缩方式是不同的<ul><li><code>Windows</code> 常用 <code>rar</code></li><li><code>Mac</code> 常用 <code>zip</code></li><li><code>Linux</code> 常用 <code>tar.gz</code></li></ul></li></ul><h3 id="3-1-打包-／-解包"><a href="#3-1-打包-／-解包" class="headerlink" title="3.1 打包 ／ 解包"></a>3.1 打包 ／ 解包</h3><ul><li><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong>工具，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></li><li><code>tar</code> 的命令格式如下：</li></ul><pre class="line-numbers language-none"><code class="language-none"># 打包文件tar -cvf 打包文件.tar 被打包的文件／路径...# 解包文件tar -xvf 打包文件.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>tar</code> 选项说明</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解开档案文件</td></tr><tr><td>v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>f</td><td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td></tr></tbody></table><blockquote><p>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</p></blockquote><h4 id="打包解包演练"><a href="#打包解包演练" class="headerlink" title="打包解包演练"></a>打包解包演练</h4><ol><li>删除桌面下的所有内容</li><li>在桌面下新建三个空白文件 <code>01.py</code>、<code>02.py</code>、<code>03.py</code></li><li>将这三个文件打一个 <code>py.tar</code> 的包</li><li>新建 <code>tar</code> 目录，并且将 <code>py.tar</code> 移动到 <code>tar</code> 目录下</li><li>解包 <code>py.tar</code></li></ol><h3 id="3-2-压缩／解压缩"><a href="#3-2-压缩／解压缩" class="headerlink" title="3.2 压缩／解压缩"></a>3.2 压缩／解压缩</h3><h4 id="1-gzip"><a href="#1-gzip" class="headerlink" title="1) gzip"></a>1) <code>gzip</code></h4><ul><li><code>tar</code> 与 <code>gzip</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong><ul><li><code>tar</code> 只负责打包文件，但不压缩</li><li>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></li></ul></li></ul><blockquote><p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p></blockquote><ul><li><p>在 <code>tar</code> 命令中有一个选项 <strong>-z</strong> 可以调用 <code>gzip</code>，从而可以方便的实现压缩和解压缩的功能</p></li><li><p>命令格式如下：</p></li></ul><pre class="line-numbers language-none"><code class="language-none"># 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>解压缩到指定目录，注意：要解压缩的目录必须存在</td></tr></tbody></table><h4 id="2-bzip2-two"><a href="#2-bzip2-two" class="headerlink" title="2) bzip2(two)"></a>2) <code>bzip2(two)</code></h4><ul><li><p><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong>（用法和 <code>gzip</code> 一样）</p><ul><li><code>tar</code> 只负责打包文件，但不压缩，</li><li>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></li></ul></li><li><p>在 <code>tar</code> 命令中有一个选项 <strong>-j</strong> 可以调用 <code>bzip2</code>，从而可以方便的实现压缩和解压缩的功能</p></li><li><p>命令格式如下：</p></li></ul><pre class="line-numbers language-none"><code class="language-none"># 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...# 解压缩文件tar -jxvf 打包文件.tar.bz2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="04-软件安装"><a href="#04-软件安装" class="headerlink" title="04. 软件安装"></a>04. 软件安装</h2><h2 id="4-1-通过-apt-安装／卸载软件"><a href="#4-1-通过-apt-安装／卸载软件" class="headerlink" title="4.1 通过 apt 安装／卸载软件"></a>4.1 通过 apt 安装／卸载软件</h2><ul><li>apt 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具</li><li>可以在终端中方便的 <strong>安装</strong>／<strong>卸载</strong>／<strong>更新软件包</strong></li></ul><pre class="line-numbers language-none"><code class="language-none"># 1. 安装软件$ sudo apt install 软件包# 2. 卸载软件$ sudo apt remove 软件名# 3. 更新已安装的包$ sudo apt upgrade <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装演练"><a href="#安装演练" class="headerlink" title="安装演练"></a>安装演练</h3><pre class="line-numbers language-none"><code class="language-none"># 一个小火车提示$ sudo apt install sl# 一个比较漂亮的查看当前进程排名的软件$ sudo apt install htop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-配置软件源"><a href="#4-2-配置软件源" class="headerlink" title="4.2 配置软件源"></a>4.2 配置软件源</h2><ul><li>如果希望在 <code>ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置<strong>镜像源</strong>，选择一个访问网速更快的服务器，来提供软件下载／安装服务</li><li>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</li></ul><blockquote><p>所谓镜像源，就是<strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内服务器通常速度会更快一些！</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194704.png" alt="003_镜像服务器示意图" loading="lazy">￼</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220118194705.png" alt="001_ubuntu设置软件源" loading="lazy">￼</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker进阶</title>
      <link href="/posts/b3ee7ac2/"/>
      <url>/posts/b3ee7ac2/</url>
      
        <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=243999746&bvid=BV1kv411q7Qc&cid=216242319&page=1" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><p><strong>docker的理念回顾</strong></p><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p><p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p><p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181015.png" alt="image-20200611220811766" loading="lazy"></p><p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><blockquote><p>方式一：直接使用命令来挂载</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> run -it -v 主机目录:容器目录<span class="token comment"># 测试</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker run -it -v /home/ceshi:/home  centos  /bin/bash</span><span class="token comment"># 启动起来的时候，我们可以通过docker inspect 容器id 来查看挂载情况：（见下图）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181016.png" alt="image-20200611224010091" loading="lazy"></p><p>测试文件的同步</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181017.png" alt="image-20200611224046109" loading="lazy"></p><p>在容器内指定目录下添加或修改一个文件，会同步到主机指定目录下！反之，在主机目录下做相关操作，也会同步到容器对应的目录下！</p><p>再来测试！</p><p>1、停止容器</p><p>2、宿主机修改文件</p><p>3、启动容器</p><p>4、容器内的数据依旧是同步的！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181018.png" alt="image-20200611224137284" loading="lazy"></p><p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步！</p><h2 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h2><p>思考：MySQL的数据持久化的问题！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 获取镜像</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker pull mysql:5.7</span><span class="token comment"># 运行容器，需要做数据挂载！ # 安装mysql,需要配置密码，这是要注意的点！</span><span class="token comment"># 官方测试：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><span class="token comment"># 启动我们的MySQL容器</span>-d后台运行-p端口映射-v卷挂载-e  环境配置--name  容器名字<span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><span class="token comment"># 启动成功之后，我们在本地使用sqlyog 连接测试一下</span><span class="token comment"># sqlyog —— 连接到服务器的3310 —— 3310和容器内的3306映射，这个时候我们就可以连接上了！</span><span class="token comment"># 本地测试创建一个数据库，查看一下我们的映射的路径是否ok!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设我们将容器删除</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181019.png" alt="image-20200611230752177" loading="lazy"></p><p>发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！</p><h2 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 匿名挂载</span>-v 容器内路径<span class="token function">docker</span> run -d -P --name nginx01 -v /etc/nginx nginx<span class="token comment"># 查看所有卷的情况</span><span class="token punctuation">[</span>root@localhost data<span class="token punctuation">]</span><span class="token comment"># docker volume ls</span>DRIVER              VOLUME NAME<span class="token builtin class-name">local</span>               2dd0379216c9ee4441ed56f8ce53461c19abe78b8cfd024ac5fbe07c3b8f09ba<span class="token comment"># 这里发现，这种就是匿名挂载，我们在 -v 后只写了容器内的路径，没有写容器外的路径！</span><span class="token comment"># 具名挂载</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span>5ba5708389bf71b2156fdbcedc50a62b16ac27adb2a3dfac42c52e9da5ace79f<span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker volume ls</span>DRIVER              VOLUME NAME<span class="token builtin class-name">local</span>               juming-nginx<span class="token comment"># 通过 -v 卷名：容器内路径</span><span class="token comment"># 查看一下这个卷  # 先找到卷所在路径 docker volume inspect 卷名，如下图：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181020.png" alt="image-20200611235522418" loading="lazy"></p><p>所有的docker容器内的卷，没有指定目录的情况下都是在**&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;xxxx&#x2F;_data**下！<br>我们通过具名挂载可以方便的找到我们的一个卷，大多数情况使用 <strong>具名挂载</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！</span>-v容器内路径       <span class="token comment"># 匿名挂载</span>-v卷名:容器内路径  <span class="token comment"># 具名挂载</span>-v/宿主机路径:容器内路径   <span class="token comment"># 指定路径挂载！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>拓展：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 通过 -v 容器内路径：ro 或 rw   改变读写权限</span>ro <span class="token comment">#readonly 只读</span>rw <span class="token comment">#readwrite 可读可写</span><span class="token comment"># 一旦创建容器时设置了容器权限，容器对我们挂载出来的内容就有限定了！</span><span class="token function">docker</span> run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx<span class="token function">docker</span> run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx<span class="token comment"># 默认是 rw</span><span class="token comment"># ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始Dockerfile"><a href="#初始Dockerfile" class="headerlink" title="初始Dockerfile"></a>初始Dockerfile</h2><p>Dockerfile 就是用来构建 docker镜像的构建文件！命令脚本！ 先体验一下！</p><p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个个的命令，每个命令都是最终镜像的一层！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建一个dockerfile文件，名字可以随机，建议 dockerfile</span><span class="token punctuation">[</span>root@localhost docker-test-volume<span class="token punctuation">]</span><span class="token comment"># vim dockerfile</span><span class="token comment"># 文件中的内容：指令(大写) 参数</span>FROM centosVOLUME <span class="token punctuation">[</span><span class="token string">"volume01"</span>,<span class="token string">"volume02"</span><span class="token punctuation">]</span>CMD <span class="token builtin class-name">echo</span><span class="token string">"----end----"</span>CMD /bin/bash<span class="token comment"># 这里的每个命令，就是镜像的一层！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181021.png" alt="image-20200612003052844" loading="lazy"></p><p>注意：我们这里的 dockerfile  是我们编写的文件名哦！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181022.png" alt="image-20200612003717223" loading="lazy"></p><p>这两个卷和外部一定有两个同步的目录！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181023.png" alt="image-20200612003946028" loading="lazy"></p><p>查看一下卷挂载在主机上的路径</p><p><strong>docker inspect 容器id</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181024.png" alt="image-20200612004608027" loading="lazy"></p><p>测试一下刚才的文件是否同步出去了！</p><p>这种方式我们未来使用十分的多，因为我们通常会构建自己的镜像！</p><p>假设构建镜像的时候没有挂在卷，要手动镜像挂载即可： (参考上文<strong>具名和匿名挂载</strong>)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-v 卷名:容器内路径 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p><strong>多个mysql同步数据！</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181025.png" alt="image-20200612223759573" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181026.png" alt="image-20200612224621379" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181027.png" alt="image-20200612225358172" loading="lazy"></p><p>在docker03下创建docker03文件后，进入docker01发现也依旧会同步过来：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181028.png" alt="image-20200612225641266" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 测试1：删除docker01后，docker02和docker03是否还可以访问原来docker01下创建的的文件？</span><span class="token comment"># 测试1的结果为：依旧可以访问！！！</span><span class="token comment"># 测试2：删除docker01后，docker02和docker03之间是否可以相互同步文件？</span><span class="token comment"># 测试2的结果为：docket02和docker03之间一九可以完成同步！！！ 见下图：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181029.png" alt="image-20200612231431551" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181030.png" alt="image-20200612231603498" loading="lazy"></p><p><strong>多个mysql实现数据共享</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">➜  ~ <span class="token function">docker</span> run -d -p <span class="token number">3306</span>:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> --name mysql01 mysql:5.7➜  ~ <span class="token function">docker</span> run -d -p <span class="token number">3307</span>:3306 -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> --name mysql02 --volumes-from mysql01  mysql:5.7<span class="token comment"># 这个时候，可以实现两个容器数据同步！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>结论：</strong></p><p>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p><p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p><hr><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h2><p><code>dockerfile</code>是用来构建docker镜像的文件！命令参数脚本！</p><p><strong>构建步骤：</strong></p><p>1、 编写一个dockerfile文件</p><p>2、 docker build 构建称为一个镜像</p><p>3、 docker run运行镜像</p><p>4、 docker push发布镜像（DockerHub 、阿里云仓库)</p><p>查看官方是怎么做的！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181031.png" alt="image-20200612233951676" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181032.png" alt="image-20200612234022746" loading="lazy"></p><p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p><p>官方既然可以制作镜像，那我们也可以！</p><h2 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h2><p><strong>基础知识：</strong></p><p>1、每个保留关键字(指令）都是必须是大写字母</p><p>2、执行从上到下顺序</p><p>3、# 表示注释</p><p>4、每一个指令都会创建提交一个新的镜像曾，并提交！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181033.png" alt="image-20200612234419262" loading="lazy"></p><p>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p><p>Docker镜像逐渐成企业交付的标准，必须要掌握！</p><p>DockerFile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</p><p>Docker容器：容器就是镜像运行起来提供服务。</p><h2 id="DockerFile的指令"><a href="#DockerFile的指令" class="headerlink" title="DockerFile的指令"></a>DockerFile的指令</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">FROM<span class="token comment"># 基础镜像，一切从这里开始构建</span>MAINTAINER<span class="token comment"># 镜像是谁写的，姓名+邮箱</span>RUN<span class="token comment"># 镜像构建的时候需要运行的命令</span>ADD<span class="token comment"># 步骤：tomcat镜像，这个tomcat压缩包！ 添加内容</span>WORKDIR<span class="token comment"># 镜像的工作目录</span>VOLUME<span class="token comment"># 挂载的目录</span>EXPOSE          <span class="token comment"># 暴露端口配置，跟 -p 是一个道理</span>CMD<span class="token comment"># 指定这个容器启动时要执行的命令,只有最后一个命令会生效，可悲替代</span>ENTRYPOINT<span class="token comment"># 指定这个容器启动的时候要执行的命令，可以追加命令</span>ONBUILD<span class="token comment"># 当构建一个被继承DockerFile 这个时候就会运行ONBUILD的指令。触发指令</span>COPY<span class="token comment"># 类似ADD,将我们文件拷贝到镜像中</span>ENV<span class="token comment"># 构建的时候设置环境变量，跟 -e 是一个意思</span><span class="token comment"># CMD 和 ENTRYPOINT 的区别说明：（后面也会介绍）</span><span class="token comment"># 若CMD 和 ENTRYPOINT 后跟的都是 ls -a 这个命令，当docker run 一个容器时，添加了 -l 选项，则CMD里的ls -a 命令就会被替换成-l;而ENTRYPOINT中的 ls -a会追加-l变成 ls -a -l  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181034.png" alt="image-20200613000838850" loading="lazy"></p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>Docker Hub中99%镜像都是从这个基础镜像过来的( <strong>FROM scratch</strong> )，然后配置需要的软件和配置来构建。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181035.png" alt="image-20200613001130237" loading="lazy"></p><blockquote><p>创建一个自己的 centos</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1、编写DockerFile文件，内容如下：</span><span class="token punctuation">[</span>root@localhost dockerfile<span class="token punctuation">]</span><span class="token comment"># cat mydockerfile-centos</span>FROM centosMAINTAINER ztx<span class="token operator">&lt;</span><span class="token number">123456</span>@qq.com<span class="token operator">></span> ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>RUN yum -y <span class="token function">install</span> <span class="token function">vim</span>RUN yum -y <span class="token function">install</span> net-toolsEXPOSE <span class="token number">80</span>CMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>CMD <span class="token builtin class-name">echo</span> <span class="token string">"----end----"</span>CMD /bin/bash<span class="token comment"># 2、通过这个文件构建镜像</span><span class="token comment"># 命令docker build -f dockerfile文件路径 -t 镜像名:[tag] .</span><span class="token punctuation">[</span>root@localhost dockerfile<span class="token punctuation">]</span><span class="token comment"># docker build -f mydockerfile-centos -t mycentos:0.1 .</span><span class="token punctuation">..</span><span class="token punctuation">..</span>Successfully built c987078b06cbSuccessfully tagged mycentos:0.1<span class="token comment"># 3、测试运行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对比：</strong></p><p><strong>之前的原生的centos</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181036.png" alt="image-20200613004551789" loading="lazy"></p><p><strong>我们增加之后的镜像</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181037.png" alt="image-20200613005056516" loading="lazy"></p><p>注：net-tools 包含一系列程序，构成了 Linux 网络的基础。</p><p>我们可以列出本地镜像的变更历史：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181038.png" alt="image-20200613005625844" loading="lazy"></p><p>我们平时拿到一个镜像，可以研究一下它是怎么做的！</p><blockquote><p>CMD 和 ENTRYPOINT 的区别</p></blockquote><p><strong>测试CMD</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 编写dockerfile文件</span>$ <span class="token function">vim</span> dockerfile-test-cmdFROM centosCMD <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span><span class="token comment"># 构建镜像</span>$ <span class="token function">docker</span> build  -f dockerfile-test-cmd -t cmd-test:0.1 <span class="token builtin class-name">.</span><span class="token comment"># 运行镜像</span>$ <span class="token function">docker</span> run cmd-test:0.1<span class="token builtin class-name">.</span><span class="token punctuation">..</span>.dockerenvbindev<span class="token comment"># 想追加一个命令  -l 成为ls -al</span>$ <span class="token function">docker</span> run cmd-test:0.1 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused <span class="token string">"exec: <span class="token entity" title="\&quot;">\"</span>-l<span class="token entity" title="\&quot;">\"</span>: executable file not found in <span class="token environment constant">$PATH</span>"</span><span class="token builtin class-name">:</span> unknown.ERRO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> error waiting <span class="token keyword">for</span> container: context canceled <span class="token comment"># cmd的情况下 -l 替换了CMD["ls","-l"]。 -l  不是命令,所以报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>测试ENTRYPOINT</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 编写dockerfile文件</span>$ <span class="token function">vim</span> dockerfile-test-entrypointFROM centosENTRYPOINT <span class="token punctuation">[</span><span class="token string">"ls"</span>,<span class="token string">"-a"</span><span class="token punctuation">]</span>$ <span class="token function">docker</span> run entrypoint-test:0.1<span class="token builtin class-name">.</span><span class="token punctuation">..</span>.dockerenvbindevetchomeliblib64lost+found <span class="token punctuation">..</span>.<span class="token comment"># 我们的命令，是直接拼接在我们的ENTRYPOINT命令后面的</span>$ <span class="token function">docker</span> run entrypoint-test:0.1 -ltotal <span class="token number">56</span>drwxr-xr-x   <span class="token number">1</span> root root <span class="token number">4096</span> May <span class="token number">16</span> 06:32 <span class="token builtin class-name">.</span>drwxr-xr-x   <span class="token number">1</span> root root <span class="token number">4096</span> May <span class="token number">16</span> 06:32 <span class="token punctuation">..</span>-rwxr-xr-x   <span class="token number">1</span> root root    <span class="token number">0</span> May <span class="token number">16</span> 06:32 .dockerenvlrwxrwxrwx   <span class="token number">1</span> root root    <span class="token number">7</span> May <span class="token number">11</span>  <span class="token number">2019</span> bin -<span class="token operator">></span> usr/bindrwxr-xr-x   <span class="token number">5</span> root root  <span class="token number">340</span> May <span class="token number">16</span> 06:32 devdrwxr-xr-x   <span class="token number">1</span> root root <span class="token number">4096</span> May <span class="token number">16</span> 06:32 etcdrwxr-xr-x   <span class="token number">2</span> root root <span class="token number">4096</span> May <span class="token number">11</span>  <span class="token number">2019</span> homelrwxrwxrwx   <span class="token number">1</span> root root    <span class="token number">7</span> May <span class="token number">11</span>  <span class="token number">2019</span> lib -<span class="token operator">></span> usr/liblrwxrwxrwx   <span class="token number">1</span> root root    <span class="token number">9</span> May <span class="token number">11</span>  <span class="token number">2019</span> lib64 -<span class="token operator">></span> usr/lib64 <span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！</p><h2 id="实战：Tomcat镜像"><a href="#实战：Tomcat镜像" class="headerlink" title="实战：Tomcat镜像"></a>实战：Tomcat镜像</h2><p>1、准备镜像文件tomcat压缩包，jdk压缩包！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181039.png" alt="image-20200613151500712" loading="lazy"></p><p>2、编写Dockerfile文件，官方命名: <strong>Dockerfile</strong> ，build会自动寻找这个文件，就不要 -f 指定了！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">FROM centosMAINTAINER kuangshen<span class="token operator">&lt;</span><span class="token number">123456</span>@qq.com<span class="token operator">></span>COPY readme.txt /usr/local/readme.txtADD jdk-8u161-linux-x64.tar.gz    /usr/local/ADD apache-tomcat-8.0.53.tar.gz   /usr/localRUN yum -y <span class="token function">install</span> <span class="token function">vim</span>ENV MYPATH /usr/localWORKDIR <span class="token variable">$MYPATH</span>ENV JAVA_HOME /usr/local/jdk1.8.0_161ENV CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-8.0.53ENV CATALINA_BASH /usr/local/apache-tomcat-8.0.53ENV <span class="token environment constant">PATH</span> <span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token variable">$CATALINA_HOME</span>/lib:<span class="token variable">$CATALINA_HOME</span>/binEXPOSE <span class="token number">8080</span>CMD /usr/local/apache-tomcat-8.0.53/bin/startup.sh <span class="token operator">&amp;&amp;</span> <span class="token function">tail</span> -F /usr/local/apache-tomcat-8.0.53/bin/logs/catalina.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、构建镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># docker build -t diytomcat .     diytomcat是定义的镜像名</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、启动镜像，创建容器</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># docker run -d -p 9090:8080 --name kuangshentomcat02 -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-8.0.53/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-8.0.53/logs diytomcat</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、访问测试</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181040.png" alt="image-20200613175551231" loading="lazy"></p><p>6、发布项目（由于做了卷挂载，我们就可以直接在本地发布项目了）</p><p>在&#x2F;home&#x2F;kuangshen&#x2F;build&#x2F;tomcat&#x2F;test目录下创建WEB-INF目录，在里面创建web.xml文件：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>           <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee                               http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd<span class="token punctuation">"</span></span>           <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在回到test目录，添加一个index.jsp页面：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>hello kuangshen<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>vim<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Hello World!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>&lt;%System.out.println("---my test web logs---");%><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现：test项目部署成功，可以直接访问！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181041.png" alt="image-20200613180033633" loading="lazy"></p><p>注意：这时进入&#x2F;home&#x2F;kuangshen&#x2F;build&#x2F;tomcat&#x2F;tomcatlogs&#x2F;目录下就可以看到日志信息了：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost tomcatlogs<span class="token punctuation">]</span><span class="token comment"># cat catalina.out </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181042.png" alt="image-20200613180355186" loading="lazy"></p><p>之前一直访问失败是web.xml配置有问题，最后也是查看该日志提示，才得以解决！！！</p><p>我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！</p><h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><blockquote><p>Docker Hub</p></blockquote><p>1、地址 <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>2、确定这个账号可以登录</p><p>3、在我们服务器上提交自己的镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost tomcat<span class="token punctuation">]</span><span class="token comment"># docker login --help</span>Usage:<span class="token function">docker</span> login <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> <span class="token punctuation">[</span>SERVER<span class="token punctuation">]</span>Log <span class="token keyword">in</span> to a Docker registry.If no server is specified, the default is defined by the daemon.Options:  -p, --password string   Password      --password-stdin    Take the password from stdin  -u, --username string   Username<span class="token comment"># 登录dockerhub</span><span class="token punctuation">[</span>root@localhost tomcat<span class="token punctuation">]</span><span class="token comment"># docker login -u ztx115</span>Password: WARNING<span class="token operator">!</span> Your password will be stored unencrypted <span class="token keyword">in</span> /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/<span class="token comment">#credentials-store</span>Login Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、登录完毕后就可以提交镜像了，就是一步 docker push</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># push自己的镜像到服务器上！</span><span class="token punctuation">[</span>root@localhost tomcat<span class="token punctuation">]</span><span class="token comment"># docker push diytomcat</span>The push refers to repository <span class="token punctuation">[</span>docker.io/library/diytomcat<span class="token punctuation">]</span>c5593011cd68: Preparing d3ce40b8178e: Preparing 02084c67dcc9: Preparing 2b7c1c6c89c5: Preparing 0683de282177: Preparing denied: requested access to the resource is denied  <span class="token comment"># 拒绝</span><span class="token comment"># push镜像的问题？</span><span class="token comment"># 解决：增加一个tag         docker tag  指定镜像的id   dockerhub的用户名/镜像重命名:[tag]</span><span class="token punctuation">[</span>root@localhost tomcat<span class="token punctuation">]</span><span class="token comment"># docker tag bb64ab96b432 ztx115/tomcat:1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181043.png" alt="image-20200613211709842" loading="lazy"></p><p><strong>注意：镜像的重命名前一定要加当前的dockerhub的用户名，否则将会push失败！！！！</strong>（如：把ztx115改成ztx,  push一定失败！）</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># docekr push上去即可！  自己平时发布的镜像尽量带上版本号</span><span class="token punctuation">[</span>root@localhost tomcat<span class="token punctuation">]</span><span class="token comment"># docker push ztx115/tomcat:1.0</span>The push refers to repository <span class="token punctuation">[</span>docker.io/ztx115/tomcat<span class="token punctuation">]</span>c5593011cd68: Pushed d3ce40b8178e: Pushed 02084c67dcc9: Pushed 2b7c1c6c89c5: Pushed 0683de282177: Pushed <span class="token number">1.0</span>: digest: sha256:b6733deccf85ad66c6f4302215dd9ea63e1579817f15a099b5858785708ed408 size: <span class="token number">1372</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181044.png" alt="image-20200613210147709" loading="lazy"></p><p>发现，提交时也是按照镜像的层级来进行提交的！</p><blockquote><p>发布到阿里云镜像服务上（狂神视频截图）</p></blockquote><p>1、登录阿里云</p><p>2、找到容器镜像服务</p><p>3、创建命名空间</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181045.png" alt="image-20200613212823736" loading="lazy"></p><p>4、创建容器镜像仓库</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181046.png" alt="image-20200613213014849" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181047.png" alt="image-20200613213135466" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181048.png" alt="image-20200613213222587" loading="lazy"></p><p>5、浏览阿里云</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181049.png" alt="image-20200613214159792" loading="lazy"></p><p>使用阿里云容器镜像的参考官方指南即可！！！（即上图）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181050.png" alt="image-20200613214846464" loading="lazy"></p><hr><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h2><p>清空所有环境</p><blockquote><p>测试</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181051.png" alt="image-20200613224119526" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 问题： docker是如何处理容器网络访问的？</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181052.png" alt="image-20200613220806390" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># [root@localhost /]# docker run -d -P --name tomcat01 tomcat</span><span class="token comment"># 查看容器的内部网络地址   ip addr,  发现容器启动的时候会得到一个 eth0@if43 ip地址，docker分配的！</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat01 ip addr</span><span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="token number">1000</span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo       valid_lft forever preferred_lft forever<span class="token number">42</span>: eth0@if43: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="token number">0</span>    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0       valid_lft forever preferred_lft forever<span class="token comment"># 思考：linux能不能ping通docker容器内部！</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># ping 172.17.0.2</span>PING <span class="token number">172.17</span>.0.2 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.476</span> ms<span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.099</span> ms<span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.105</span> ms<span class="token punctuation">..</span>.<span class="token comment"># linux 可以ping通docker容器内部</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>原理</p></blockquote><p>1、我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要装了docker，就会有一个docker01网卡。</p><p>桥接模式，使用的技术是veth-pair技术！</p><p>再次测试 ip addr，发现多了一对网卡 : </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181053.png" alt="image-20200613224311838" loading="lazy"></p><p>2、再启动一个容器测试，发现又多了一对网卡！！！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181054.png" alt="image-20200613224610781" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 我们发现这个容器带来网卡，都是一对对的</span><span class="token comment"># veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span><span class="token comment"># 正因为有这个特性，veth-pair 充当一个桥梁，连接各种虚拟网络设备</span><span class="token comment"># OpenStack，Docker容器之间的连接，OVS的连接都是使用veth-pair技术</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3、我们来测试下tomcat01和tomcat02是否可以ping通！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat02 ping 172.17.0.2</span>PING <span class="token number">172.17</span>.0.2 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.556</span> ms<span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.096</span> ms<span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.111</span> ms<span class="token punctuation">..</span>.<span class="token comment"># 结论：容器与容器之间是可以相互ping通的！！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>绘制一个网络模型图：</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181055.png" alt="image-20200613231046553" loading="lazy"></p><p><strong>结论：tomcat01 和 tomcat02 是公用一个路由器，即 docker0 !</strong> </p><p>所有的容器不指定网络的情况下，都是经 docker0 路由的，docker 会给我们的容器分配一个默认的可用ip</p><blockquote><p>小结</p></blockquote><p>Docker使用的是Linux的桥接技术，宿主机是一个Docker容器的网桥 docker0</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181056.png" alt="image-20200613232031835" loading="lazy"></p><p><strong>注意：</strong>Docker中所有网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件）</p><p>只要容器一删除，对应的一对网桥就没有！</p><h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><blockquote><p>思考一个场景：我们编写了一个微服务，database url &#x3D; ip ，项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以通过名字来访问容器？</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># tomcat02 想通过直接ping 容器名（即"tomcat01"）来ping通，而不是ip，发现失败了！</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat02 ping tomcat01</span>ping: tomcat01: Name or <span class="token function">service</span> not known<span class="token comment"># 如何解决这个问题呢？</span><span class="token comment"># 通过--link 就可以解决这个网络联通问题了！！！      发现新建的tomcat03可以ping通tomcat02</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker run -d -P --name tomcat03 --link tomcat02 tomcat</span>87a0e5f5e6da34a7f043ff6210b57f92f40b24d0d4558462e7746b2e19902721<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat03 ping tomcat02</span>PING tomcat02 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.3<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.132</span> ms<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.116</span> ms<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.116</span> ms<span class="token number">64</span> bytes from tomcat02 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">4</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.116</span> ms<span class="token comment"># 反向能ping通吗？       发现tomcat02不能oing通tomcat03</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat02 ping tomcat03</span>ping: tomcat03: Name or <span class="token function">service</span> not known<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>探究：inspect  ！！！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181057.png" alt="image-20200614002609300" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181058.png" alt="image-20200614002832045" loading="lazy"></p><p>其实这个tomcat03就是在本地配置了到tomcat02的映射：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 查看hosts 配置，在这里发现原理！  </span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat03 cat /etc/hosts</span><span class="token number">127.0</span>.0.1localhost::1localhost ip6-localhost ip6-loopbackfe00::0ip6-localnetff00::0ip6-mcastprefixff02::1ip6-allnodesff02::2ip6-allrouters<span class="token number">172.17</span>.0.3tomcat02 95303c12f6d9    <span class="token comment"># 就像windows中的 host 文件一样，做了地址绑定</span><span class="token number">172.17</span>.0.487a0e5f5e6da<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本质探究：–link  就是我们在hosts 配置中增加了一个 172.17.0.3    tomcat02   95303c12f6d9 （三条信息都是tomcat02 的）</p><p>我们现在玩Docker已经不建议使用 –link 了！！！</p><p><strong>自定义网络，不使用docker0！</strong></p><p>docker0问题：不支持容器名连接访问！</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><blockquote><p>查看所有的docker网络</p></blockquote><p>‘<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181059.png" alt="image-20200614004445923" loading="lazy"></p><p><strong>网络模式</strong></p><p>bridge  ：桥接 （docker默认，自己创建也使用bridge模式！）</p><p>none ：不配置网络</p><p>host  ：和宿主机共享网络</p><p>container  ：容器网络连通，容器直接互联！（用的少！局限很大！）</p><p><strong>测试</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 我们之前直接启动的命令 (默认是使用--net bridge，可省)，这个bridge就是我们的docker0 </span><span class="token function">docker</span> run -d -P --name tomcat01 tomcat   <span class="token function">docker</span> run -d -P --name tomcat01 --net bridge tomcat<span class="token comment"># 上面两句等价</span><span class="token comment"># docker0（即bridge）默认不支持域名访问 ！ --link可以打通连接，即支持域名访问！</span><span class="token comment"># 我们可以自定义一个网络！</span><span class="token comment"># --driver bridge    网络模式定义为 ：桥接</span><span class="token comment"># --subnet 192.168.0.0/16定义子网 ，范围为：192.168.0.2 ~ 192.168.255.255</span><span class="token comment"># --gateway 192.168.0.1子网网关设为： 192.168.0.1 </span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span>7ee3adf259c8c3d86fce6fd2c2c9f85df94e6e57c2dce5449e69a5b024efc28c<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker network ls</span>NETWORK ID          NAME                DRIVER              SCOPE461bf576946c        bridge              bridge              <span class="token builtin class-name">local</span>c501704cf28e        <span class="token function">host</span>                <span class="token function">host</span>                <span class="token builtin class-name">local</span>7ee3adf259c8        mynet               bridge              <span class="token builtin class-name">local</span>  <span class="token comment">#自定义的网络</span>9354fbcc160f        none                null                <span class="token builtin class-name">local</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自己的网络就创建好了：</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181100.png" alt="image-20200614011229854" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker run -d -P --name tomcat-net-01 --net mynet tomcat</span>b168a37d31fcdc2ff172fd969e4de6de731adf53a2960eeae3dd9c24e14fac67<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker run -d -P --name tomcat-net-02 --net mynet tomcat</span>c07d634e17152ca27e318c6fcf6c02e937e6d5e7a1631676a39166049a44c03c<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker network inspect mynet</span><span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"mynet"</span>,        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"7ee3adf259c8c3d86fce6fd2c2c9f85df94e6e57c2dce5449e69a5b024efc28c"</span>,        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2020-06-14T01:03:53.767960765+08:00"</span>,        <span class="token string">"Scope"</span><span class="token builtin class-name">:</span> <span class="token string">"local"</span>,        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"bridge"</span>,        <span class="token string">"EnableIPv6"</span><span class="token builtin class-name">:</span> false,        <span class="token string">"IPAM"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,            <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,            <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span>                    <span class="token string">"Subnet"</span><span class="token builtin class-name">:</span> <span class="token string">"192.168.0.0/16"</span>,                    <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"192.168.0.1"</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"Internal"</span><span class="token builtin class-name">:</span> false,        <span class="token string">"Attachable"</span><span class="token builtin class-name">:</span> false,        <span class="token string">"Ingress"</span><span class="token builtin class-name">:</span> false,        <span class="token string">"ConfigFrom"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Network"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"ConfigOnly"</span><span class="token builtin class-name">:</span> false,        <span class="token string">"Containers"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"b168a37d31fcdc2ff172fd969e4de6de731adf53a2960eeae3dd9c24e14fac67"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"tomcat-net-01"</span>,                <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"f0af1c33fc5d47031650d07d5bc769e0333da0989f73f4503140151d0e13f789"</span>,                <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:c0:a8:00:02"</span>,                <span class="token string">"IPv4Address"</span><span class="token builtin class-name">:</span> <span class="token string">"192.168.0.2/16"</span>,                <span class="token string">"IPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"c07d634e17152ca27e318c6fcf6c02e937e6d5e7a1631676a39166049a44c03c"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"tomcat-net-02"</span>,                <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"ba114b9bd5f3b75983097aa82f71678653619733efc1835db857b3862e744fbc"</span>,                <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:c0:a8:00:03"</span>,                <span class="token string">"IPv4Address"</span><span class="token builtin class-name">:</span> <span class="token string">"192.168.0.3/16"</span>,                <span class="token string">"IPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"Options"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,        <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token comment"># 再次测试 ping 连接</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat-net-01 ping 192.168.0.3</span>PING <span class="token number">192.168</span>.0.3 <span class="token punctuation">(</span><span class="token number">192.168</span>.0.3<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.3: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.199</span> ms<span class="token number">64</span> bytes from <span class="token number">192.168</span>.0.3: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.121</span> ms^C--- <span class="token number">192.168</span>.0.3 <span class="token function">ping</span> statistics ---<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 2msrtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.121</span>/0.160/0.199/0.039 ms<span class="token comment"># 现在不使用 --link,也可以ping 名字了！！！！！！</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat-net-01 ping tomcat-net-02</span>PING tomcat-net-02 <span class="token punctuation">(</span><span class="token number">192.168</span>.0.3<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from tomcat-net-02.mynet <span class="token punctuation">(</span><span class="token number">192.168</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.145</span> ms<span class="token number">64</span> bytes from tomcat-net-02.mynet <span class="token punctuation">(</span><span class="token number">192.168</span>.0.3<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.117</span> ms^C--- tomcat-net-02 <span class="token function">ping</span> statistics ---<span class="token number">2</span> packets transmitted, <span class="token number">2</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 3msrtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.117</span>/0.131/0.145/0.014 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在使用自定义的网络时，docker都已经帮我们维护好了对应关系，推荐我们平时这样使用网络！！！</p><p>好处：</p><p>redis——不同的集群使用不同的网络，保证了集群的安全和健康</p><p>mysql——不同的集群使用不同的网络，保证了集群的安全和健康</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181101.png" alt="image-20200614015209053" loading="lazy"></p><h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181102.png" alt="image-20200614013625192" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181103.png" alt="image-20200614013801842" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 测试打通 tomcat01 — mynet</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker network connect mynet tomcat01</span><span class="token comment"># 连通之后就是将 tomcat01 放到了 mynet 网络下！ （见下图）</span><span class="token comment"># 这就产生了 一个容器有两个ip地址 ! 参考阿里云的公有ip和私有ip</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker network inspect mynet</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181104.png" alt="image-20200614014544797" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># tomcat01 连通ok</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat01 ping tomcat-net-01</span>PING tomcat-net-01 <span class="token punctuation">(</span><span class="token number">192.168</span>.0.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.<span class="token number">64</span> bytes from tomcat-net-01.mynet <span class="token punctuation">(</span><span class="token number">192.168</span>.0.2<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.124</span> ms<span class="token number">64</span> bytes from tomcat-net-01.mynet <span class="token punctuation">(</span><span class="token number">192.168</span>.0.2<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.162</span> ms<span class="token number">64</span> bytes from tomcat-net-01.mynet <span class="token punctuation">(</span><span class="token number">192.168</span>.0.2<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.107</span> ms^C--- tomcat-net-01 <span class="token function">ping</span> statistics ---<span class="token number">3</span> packets transmitted, <span class="token number">3</span> received, <span class="token number">0</span>% packet loss, <span class="token function">time</span> 3msrtt min/avg/max/mdev <span class="token operator">=</span> <span class="token number">0.107</span>/0.131/0.162/0.023 ms<span class="token comment"># tomcat02 是依旧打不通的</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat02 ping tomcat-net-01</span>ping: tomcat-net-01: Name or <span class="token function">service</span> not known<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结论：</strong>假设要跨网络操作别人，就需要使用docker network connect  连通。。。</p><h2 id="实战：部署Redis集群"><a href="#实战：部署Redis集群" class="headerlink" title="实战：部署Redis集群"></a>实战：部署Redis集群</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181105.png" alt="image-20200614124559172" loading="lazy"></p><p>启动6个redis容器，上面三个是主，下面三个是备！</p><p>使用shell脚本启动！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建redis集群网络</span><span class="token function">docker</span> network create redis --subnet <span class="token number">172.38</span>.0.0/16<span class="token comment"># 通过脚本创建六个redis配置</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># for port in $(seq 1 6);\</span><span class="token operator">></span> <span class="token keyword">do</span> <span class="token punctuation">\</span><span class="token operator">></span> <span class="token function">mkdir</span> -p /mydata/redis/node-<span class="token variable">$&#123;port&#125;</span>/conf<span class="token operator">></span> <span class="token function">touch</span> /mydata/redis/node-<span class="token variable">$&#123;port&#125;</span>/conf/redis.conf<span class="token operator">></span> <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF<span class="token operator">>></span>/mydata/redis/node-<span class="token variable">$&#123;port&#125;</span>/conf/redis.conf<span class="token operator">></span> port <span class="token number">6379</span><span class="token operator">></span> <span class="token builtin class-name">bind</span> <span class="token number">0.0</span>.0.0<span class="token operator">></span> cluster-enabled <span class="token function">yes</span><span class="token operator">></span> cluster-config-file nodes.conf<span class="token operator">></span> cluster-node-timeout <span class="token number">5000</span><span class="token operator">></span> cluster-announce-ip <span class="token number">172.38</span>.0.1<span class="token variable">$&#123;port&#125;</span><span class="token operator">></span> cluster-announce-port <span class="token number">6379</span><span class="token operator">></span> cluster-announce-bus-port <span class="token number">16379</span><span class="token operator">></span> appendonly <span class="token function">yes</span><span class="token operator">></span> EOF<span class="token operator">></span> <span class="token keyword">done</span><span class="token comment"># 查看创建的六个redis</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># cd /mydata/</span><span class="token punctuation">[</span>root@localhost mydata<span class="token punctuation">]</span><span class="token comment"># \ls</span>redis<span class="token punctuation">[</span>root@localhost mydata<span class="token punctuation">]</span><span class="token comment"># cd redis/</span><span class="token punctuation">[</span>root@localhost redis<span class="token punctuation">]</span><span class="token comment"># ls</span>node-1  node-2  node-3  node-4  node-5  node-6<span class="token comment"># 查看redis-1的配置信息</span><span class="token punctuation">[</span>root@localhost redis<span class="token punctuation">]</span><span class="token comment"># cd node-1</span><span class="token punctuation">[</span>root@localhost node-1<span class="token punctuation">]</span><span class="token comment"># ls</span>conf<span class="token punctuation">[</span>root@localhost node-1<span class="token punctuation">]</span><span class="token comment"># cd conf/</span><span class="token punctuation">[</span>root@localhost conf<span class="token punctuation">]</span><span class="token comment"># ls</span>redis.conf<span class="token punctuation">[</span>root@localhost conf<span class="token punctuation">]</span><span class="token comment"># cat redis.conf </span>port <span class="token number">6379</span><span class="token builtin class-name">bind</span> <span class="token number">0.0</span>.0.0cluster-enabled <span class="token function">yes</span>cluster-config-file nodes.confcluster-node-timeout <span class="token number">5000</span>cluster-announce-ip <span class="token number">172.38</span>.0.11cluster-announce-port <span class="token number">6379</span>cluster-announce-bus-port <span class="token number">16379</span>appendonly <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> run -p <span class="token number">6371</span>:6379 -p <span class="token number">16371</span>:16379 --name redis-1 <span class="token punctuation">\</span>-v /mydata/redis/node-1/data:/data <span class="token punctuation">\</span>-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token function">docker</span> run -p <span class="token number">6372</span>:6379 -p <span class="token number">16372</span>:16379 --name redis-2 <span class="token punctuation">\</span>-v /mydata/redis/node-2/data:/data <span class="token punctuation">\</span>-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token function">docker</span> run -p <span class="token number">6373</span>:6379 -p <span class="token number">16373</span>:16379 --name redis-3 <span class="token punctuation">\</span>-v /mydata/redis/node-3/data:/data <span class="token punctuation">\</span>-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token function">docker</span> run -p <span class="token number">6374</span>:6379 -p <span class="token number">16374</span>:16379 --name redis-4 <span class="token punctuation">\</span>-v /mydata/redis/node-4/data:/data <span class="token punctuation">\</span>-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token function">docker</span> run -p <span class="token number">6375</span>:6379 -p <span class="token number">16375</span>:16379 --name redis-5 <span class="token punctuation">\</span>-v /mydata/redis/node-5/data:/data <span class="token punctuation">\</span>-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token function">docker</span> run -p <span class="token number">6376</span>:6379 -p <span class="token number">16376</span>:16379 --name redis-6 <span class="token punctuation">\</span>-v /mydata/redis/node-6/data:/data <span class="token punctuation">\</span>-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>-d --net redis --ip <span class="token number">172.38</span>.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181106.png" alt="image-20200614133829277" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost conf<span class="token punctuation">]</span><span class="token comment"># docker exec -it redis-1 /bin/sh</span>/data <span class="token comment"># ls</span>appendonly.aof  nodes.conf/data <span class="token comment"># redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><span class="token operator">>></span><span class="token operator">></span> Performing <span class="token builtin class-name">hash</span> slots allocation on <span class="token number">6</span> nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">0</span> - <span class="token number">5460</span>Master<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">5461</span> - <span class="token number">10922</span>Master<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> -<span class="token operator">></span> Slots <span class="token number">10923</span> - <span class="token number">16383</span>Adding replica <span class="token number">172.38</span>.0.15:6379 to <span class="token number">172.38</span>.0.11:6379Adding replica <span class="token number">172.38</span>.0.16:6379 to <span class="token number">172.38</span>.0.12:6379Adding replica <span class="token number">172.38</span>.0.14:6379 to <span class="token number">172.38</span>.0.13:6379M: c5551e2a30c220fc9de9df2e34692f20f3382b32 <span class="token number">172.38</span>.0.11:6379   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> masterM: d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94b <span class="token number">172.38</span>.0.12:6379   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> masterM: 825146ce6ab80fbb46ec43fcfec1c6e2dac55157 <span class="token number">172.38</span>.0.13:6379   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> masterS: 9f810c0e15ac99af68e114a0ee4e32c4c7067e2b <span class="token number">172.38</span>.0.14:6379   replicates 825146ce6ab80fbb46ec43fcfec1c6e2dac55157S: e370225bf57d6ef6d54ad8e3d5d745a52b382d1a <span class="token number">172.38</span>.0.15:6379   replicates c5551e2a30c220fc9de9df2e34692f20f3382b32S: 79428c1d018dd29cf191678658008cbe5100b714 <span class="token number">172.38</span>.0.16:6379   replicates d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94bCan I <span class="token builtin class-name">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span class="token function">yes</span><span class="token operator">>></span><span class="token operator">></span> Nodes configuration updated<span class="token operator">>></span><span class="token operator">></span> Assign a different config epoch to each <span class="token function">node</span><span class="token operator">>></span><span class="token operator">></span> Sending CLUSTER MEET messages to <span class="token function">join</span> the clusterWaiting <span class="token keyword">for</span> the cluster to <span class="token function">join</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">>></span><span class="token operator">></span> Performing Cluster Check <span class="token punctuation">(</span>using <span class="token function">node</span> <span class="token number">172.38</span>.0.11:6379<span class="token punctuation">)</span>M: c5551e2a30c220fc9de9df2e34692f20f3382b32 <span class="token number">172.38</span>.0.11:6379   slots:<span class="token punctuation">[</span><span class="token number">0</span>-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 79428c1d018dd29cf191678658008cbe5100b714 <span class="token number">172.38</span>.0.16:6379   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94bM: d12ebd8c9e12dbbe22e7b9b18f0f143bdc14e94b <span class="token number">172.38</span>.0.12:6379   slots:<span class="token punctuation">[</span><span class="token number">5461</span>-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5462</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: e370225bf57d6ef6d54ad8e3d5d745a52b382d1a <span class="token number">172.38</span>.0.15:6379   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates c5551e2a30c220fc9de9df2e34692f20f3382b32S: 9f810c0e15ac99af68e114a0ee4e32c4c7067e2b <span class="token number">172.38</span>.0.14:6379   slots: <span class="token punctuation">(</span><span class="token number">0</span> slots<span class="token punctuation">)</span> slave   replicates 825146ce6ab80fbb46ec43fcfec1c6e2dac55157M: 825146ce6ab80fbb46ec43fcfec1c6e2dac55157 <span class="token number">172.38</span>.0.13:6379   slots:<span class="token punctuation">[</span><span class="token number">10923</span>-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">5461</span> slots<span class="token punctuation">)</span> master   <span class="token number">1</span> additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">>></span><span class="token operator">></span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All <span class="token number">16384</span> slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker搭建redis集群完成！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181107.png" alt="image-20200614141549867" loading="lazy"></p><p>我们使用docker之后，所有的技术都会慢慢变得简单起来！</p><hr><h1 id="Springboot微服务打包Docker镜像"><a href="#Springboot微服务打包Docker镜像" class="headerlink" title="Springboot微服务打包Docker镜像"></a>Springboot微服务打包Docker镜像</h1><p>1、构建springboot项目，打包应用</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181108.png" alt="image-20200614155721369" loading="lazy"></p><p>2、编写Dockerfile，连同项目的jar包一并上传指定目录下</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181109.png" alt="image-20200614153734161" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181110.png" alt="image-20200614154114656" loading="lazy"></p><p>3、构建镜像</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181111.png" alt="image-20200614154355597" loading="lazy"></p><p>4、创建项目容器，发布运行！！！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181112.png" alt="image-20200614155034087" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181113.png" alt="image-20200614155340519" loading="lazy"></p><p>以后我们使用了Docker之后，给别人交付就是一个镜像即可！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker概述</title>
      <link href="/posts/fb618b33/"/>
      <url>/posts/fb618b33/</url>
      
        <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=838132893&bvid=BV1og4y1q7M4&cid=191591129&page=1" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="Docker为什么会出现？"><a href="#Docker为什么会出现？" class="headerlink" title="Docker为什么会出现？"></a>Docker为什么会出现？</h2><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p><p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p><p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p><p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p><p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p><p>开发环境Windows，最后发布到Linux！</p><p><strong>传统：</strong>开发jar，运维来做！</p><p><strong>现在：</strong>开发打包部署上线，一套流程做完！</p><p><strong>安卓流程：</strong>java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p><p><strong>docker流程：</strong> java-jar（环境）— 打包项目帯上环境（镜像）— ( Docker仓库：商店）—下载我们发布的镜像 —直接运行即可！</p><p>Docker给以上的问题，提出了解决方案！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181149.png" alt="image-20200610142308099" loading="lazy"></p><p>Docker的思想来源于集装箱！</p><p>JRE —多个应用（端口冲突）—原来都是交叉的！</p><p>隔离：Docker核心思想！打包装箱！每个箱子都是相互隔离的。</p><p>Docker通过隔离机制可以将服务器利用到极致！</p><p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！</p><h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>2010年，几个的年轻人，就在美国成立了一家公司 <strong>dotcloud</strong></p><p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p><p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p><p>他们将自己的技术（容器化技术）命名就是 Docker</p><p>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p><p><strong>开源</strong></p><p>2013年，Docker开源！</p><p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p><p>2014年4月9日，Docker1.0发布！</p><p>docker为什么这么火？十分的轻巧！</p><p>在容器技术出来之前，我们都是使用虚拟机技术！</p><p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p><p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">VMware <span class="token builtin class-name">:</span> linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>聊聊Docker</p></blockquote><p>Docker基于Go语言开发的！开源项目！</p><p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181150.png" alt="image-20200610143923433" loading="lazy"></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p><p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h2><blockquote><p>之前的虚拟机技术</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181151.png" alt="image-20200610144126122" loading="lazy"></p><blockquote><p>虚拟机技术缺点</p></blockquote><p>1、 资源占用十分多</p><p>2、 冗余步骤多</p><p>3、 启动很慢！</p><blockquote><p>容器技术</p></blockquote><p>容器化技术不是模拟一个完整的操作系统</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181152.png" alt="image-20200610144338073" loading="lazy"></p><p>比较Docker和虚拟机技术的不同：</p><ul><li>传统虚拟机，虚拟出一套容器内的应用直接运行在宿主机硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li><li>容器内的应用直接运行在宿主机内，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li><li>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响</li></ul><blockquote><p>DevOps (开发、运维)</p></blockquote><p><strong>应用更快速的交付和部署</strong></p><p>传统：一堆帮助文档，安装程序</p><p>Docker：打包镜像发布测试，一键运行</p><p><strong>更便捷的升级和扩缩容</strong></p><p>使用了Docker之后，我们部署应用就和搭积木一样！</p><p>项目打包为一个镜像，扩展服务器A! 服务器B</p><p><strong>更简单的系统运维</strong></p><p>在容器化之后，我们的开发，测试环境都是高度一致的。</p><p><strong>更高效的计算资源利用</strong></p><p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多个容器实例！服务器的性能可以被压榨到极致。</p><hr><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181153.png" alt="image-20200610145818895" loading="lazy"></p><p><strong>镜像（image）：</strong></p><p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像&#x3D;&#x3D;&gt;run&#x3D;&#x3D;&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p><p><strong>容器（container）:</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.</p><p>启动，停止，删除，基本命令</p><p>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p><p><strong>仓库（repository）:</strong></p><p>仓库就是存放镜像的地方！</p><p>仓库分为公有仓库和私有仓库。(很类似git)</p><p>Docker Hub是国外的。</p><p>阿里云…都有容器服务器 (配置镜像加速!)</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote><p>环境准备</p></blockquote><p>1.Linux要求内核3.0以上</p><p>2.CentOS 7</p><blockquote><p>环境查看</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#系统内核要求3.0以上</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># uname -r</span><span class="token number">3.10</span>.0-1062.el7.x86_64<span class="token comment">#系统版本</span><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/os-release </span><span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">"CentOS Linux"</span><span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token string">"7 (Core)"</span><span class="token assign-left variable">ID</span><span class="token operator">=</span><span class="token string">"centos"</span><span class="token assign-left variable">ID_LIKE</span><span class="token operator">=</span><span class="token string">"rhel fedora"</span><span class="token assign-left variable">VERSION_ID</span><span class="token operator">=</span><span class="token string">"7"</span><span class="token assign-left variable">PRETTY_NAME</span><span class="token operator">=</span><span class="token string">"CentOS Linux 7 (Core)"</span><span class="token assign-left variable">ANSI_COLOR</span><span class="token operator">=</span><span class="token string">"0;31"</span><span class="token assign-left variable">CPE_NAME</span><span class="token operator">=</span><span class="token string">"cpe:/o:centos:centos:7"</span><span class="token assign-left variable">HOME_URL</span><span class="token operator">=</span><span class="token string">"https://www.centos.org/"</span><span class="token assign-left variable">BUG_REPORT_URL</span><span class="token operator">=</span><span class="token string">"https://bugs.centos.org/"</span><span class="token assign-left variable">CENTOS_MANTISBT_PROJECT</span><span class="token operator">=</span><span class="token string">"CentOS-7"</span><span class="token assign-left variable">CENTOS_MANTISBT_PROJECT_VERSION</span><span class="token operator">=</span><span class="token string">"7"</span><span class="token assign-left variable">REDHAT_SUPPORT_PRODUCT</span><span class="token operator">=</span><span class="token string">"centos"</span><span class="token assign-left variable">REDHAT_SUPPORT_PRODUCT_VERSION</span><span class="token operator">=</span><span class="token string">"7"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>安装</p></blockquote><p>帮助文档：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#1.卸载旧版本</span> yum remove <span class="token function">docker</span> <span class="token punctuation">\</span><span class="token operator">></span>                   docker-client <span class="token punctuation">\</span><span class="token operator">></span>                   docker-client-latest <span class="token punctuation">\</span><span class="token operator">></span>                   docker-common <span class="token punctuation">\</span><span class="token operator">></span>                   docker-latest <span class="token punctuation">\</span><span class="token operator">></span>                   docker-latest-logrotate <span class="token punctuation">\</span><span class="token operator">></span>                   docker-logrotate <span class="token punctuation">\</span><span class="token operator">></span>                   docker-engine<span class="token comment">#2.需要的安装包</span>yum <span class="token function">install</span> -y yum-utils<span class="token comment">#3.设置镜像的仓库</span>yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    https://download.docker.com/linux/centos/docker-ce.repo<span class="token comment">#上述方法默认是从国外的，不推荐</span><span class="token comment">#推荐使用国内的</span>yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  <span class="token comment">#更新软件包索引</span>yum makecache fast<span class="token comment">#4.安装docker docker-ce 社区版 而ee是企业版</span>yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io <span class="token comment"># 这里我们使用社区版即可</span><span class="token comment">#5.启动docker</span>systemctl start <span class="token function">docker</span><span class="token comment">#6.使用docker version 查看是否安装成功</span><span class="token function">docker</span> version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181154.png" alt="image-20200610153718450" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#7.测试</span><span class="token function">docker</span> run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181155.png" alt="image-20200610154108118" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#8.查看一下下载的hello-world镜像</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker images</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              bf756fb1ae65        <span class="token number">5</span> months ago        <span class="token number">13</span>.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>了解：卸载docker</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#1.卸载依赖</span>yum remove docker-ce docker-ce-cli containerd.io<span class="token comment">#2. 删除资源</span><span class="token function">rm</span> -rf /var/lib/docker<span class="token comment"># /var/lib/docker 是docker的默认工作路径！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阿里云镜像加速</p><p><strong>1、登录阿里云找到容器服务——&gt;镜像加速器</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181156.png" alt="image-20200610155156310" loading="lazy"></p><p><strong>2、配置使用</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/docker<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'&#123;  "registry-mirrors": ["https://cdoid6va.mirror.aliyuncs.com"]&#125;EOF</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="回顾hello-world流程"><a href="#回顾hello-world流程" class="headerlink" title="回顾hello-world流程"></a>回顾hello-world流程</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181157.png" alt="image-20200610160359287" loading="lazy"></p><p><strong>docker run 流程图</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181158.png" alt="image-20200610160609037" loading="lazy"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker是怎么工作的？</strong></p><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在宿主机上，通过Socket从客户端访问！</p><p>DockerServer接受到Docker-Client的指令，就会执行这个命令！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181159.png" alt="image-20200610161147612" loading="lazy"></p><p><strong>Docker为什么比VM快？</strong></p><p>1、Docker有着比虚拟机更少的抽象层</p><p>2、Docker利用的是宿主机的内核，vm需要Guest Os。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181200.png" alt="image-20200610161342662" loading="lazy"></p><p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest Os，分钟级别的，而docker是利用当前宿主机的操作系统，省略了复杂的过程，秒级的！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181201.png" alt="image-20200610161845790" loading="lazy"></p><hr><h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> version     <span class="token comment"># 显示docker的版本信息</span><span class="token function">docker</span> info        <span class="token comment"># 显示docker的系统信息，包括镜像和容器的数量</span><span class="token function">docker</span> 命令 --help  <span class="token comment"># 帮助命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker images</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              bf756fb1ae65        <span class="token number">5</span> months ago        <span class="token number">13</span>.3kB<span class="token comment">#解释</span>REPOSITORY  镜像的仓库源TAG         镜像标签IMAGE ID    镜像idCREATED     镜像的创建时间SIZE        镜像的大小<span class="token comment">#可选项</span>Options:  -a, --all             <span class="token comment"># 列出所有镜像</span>  -q, --quiet           <span class="token comment"># 只显示镜像id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker search 搜索镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker search mysql</span>NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDmysql                             MySQL is a widely used, open-source relation…   <span class="token number">9604</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>                mariadb                           MariaDB is a community-developed fork of MyS…   <span class="token number">3490</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>                <span class="token comment">#可选项，通过收藏来过滤</span>--filter<span class="token operator">=</span>STARS<span class="token operator">=</span><span class="token number">3000</span>  <span class="token comment">#搜索出来的镜像就是STARS大于3000的</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker search mysql --filter=STARS=3000</span>NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDmysql               MySQL is a widely used, open-source relation…   <span class="token number">9604</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>                mariadb             MariaDB is a community-developed fork of MyS…   <span class="token number">3490</span>                <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker pull 下载镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 下载镜像 docker pull 镜像名[:tag]</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker pull mysql</span>Using default tag: latest    <span class="token comment"># 如果不写 tag,默认就是latest</span>latest: Pulling from library/mysql8559a31e96f4: Pull complete  <span class="token comment"># 分层下载，docker image的核心 联合文件系统</span>d51ce1c2e575: Pull complete c2344adc4858: Pull complete fcf3ceff18fc: Pull complete 16da0c38dc5b: Pull complete b905d1797e97: Pull complete 4b50d1c6b05c: Pull complete c75914a65ca2: Pull complete 1ae8042bdd09: Pull complete 453ac13c00a3: Pull complete 9e680cd72f08: Pull complete a6b5dc864b6c: Pull complete Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6 <span class="token comment"># 签名</span>Status: Downloaded newer image <span class="token keyword">for</span> mysql:latestdocker.io/library/mysql:latest  <span class="token comment"># 真实地址</span><span class="token function">docker</span> pull mysql 等价于: <span class="token function">docker</span> pull docker.io/library/mysql:latest<span class="token comment"># 指定版本下载</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker pull mysql:5.7</span><span class="token number">5.7</span>: Pulling from library/mysql8559a31e96f4: Already exists   <span class="token comment"># 联合文件系统的好处：上面下载过的MySQL与5.7版本的MySQL有相同的文件时不需要重复下载</span>d51ce1c2e575: Already exists c2344adc4858: Already exists fcf3ceff18fc: Already exists 16da0c38dc5b: Already exists b905d1797e97: Already exists 4b50d1c6b05c: Already exists d85174a87144: Pull complete a4ad33703fa8: Pull complete f7a5433ce20d: Pull complete 3dcd2a278b4a: Pull complete Digest: sha256:32f9d9a069f7a735e28fd44ea944d53c61f990ba71460c5c183e610854ca4854Status: Downloaded newer image <span class="token keyword">for</span> mysql:5.7docker.io/library/mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181202.png" alt="image-20200610165130055" loading="lazy"></p><p><strong>docker rmi 删除镜像</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker rmi -f 镜像id   #删除指定镜像</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker rmi -f 镜像id 镜像id 镜像id     #删除多个镜像</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker rmi -f $(docker images -aq)     #删除全部镜像</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明：有了镜像才可以创建容器，linux,下载一个centos镜像来学习</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>新建容器并启动</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> image<span class="token comment"># 参数说明</span>--name<span class="token operator">=</span><span class="token string">"Name"</span>容器名字 tomcat01 tomcat02 ，用来区分容器-d              后台方式运行-it             使用交互方式运行，进入容器查看内容-p              指定容器的端口 -p <span class="token number">8080</span>:80-p  ip:主机<span class="token punctuation">(</span>即宿主机<span class="token punctuation">)</span>端口：容器端口-p  主机端口：容器端口  <span class="token comment">#这种方式常用</span>-p  容器端口容器端口P-P              随机指定端口<span class="token punctuation">(</span>大写P<span class="token punctuation">)</span><span class="token comment"># 测试，启动并进入容器</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker run -it centos /bin/bash</span><span class="token punctuation">[</span>root@8b4c74381205 /<span class="token punctuation">]</span><span class="token comment"># ls     #查看容器内的centos,基础版本，很多命令都是不完善的！</span>bin  etc   lib  lost+found  mnt  proc  run   srv  tmp  vardev  home  lib64  media       opt  root  sbin  sys  usr<span class="token comment"># 从容器中退回主机</span><span class="token punctuation">[</span>root@8b4c74381205 /<span class="token punctuation">]</span><span class="token comment"># exit</span><span class="token builtin class-name">exit</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># ls</span><span class="token number">123</span>  bin   dev  home  lib64  mnt  proc  run   srv  tmp  var<span class="token number">222</span>  boot  etc  lib   media  opt  root  sbin  sys  usr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>列出所有运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># docker ps 命令</span><span class="token punctuation">(</span>不加） <span class="token comment"># 列出当前正在运行的容器</span>-a     <span class="token comment"># 列出当前正在运行的容器 + 带出历史运行过的容器</span>-n<span class="token operator">=</span>?   <span class="token comment"># 显示最近创建的容器</span>-q    <span class="token comment"># 只显示当前容器的编号</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker ps</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker ps -a</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES8b4c74381205        centos              <span class="token string">"/bin/bash"</span>         <span class="token number">4</span> minutes ago       Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> About a minute ago                       epic_wilsonfb87667bbc19        bf756fb1ae65        <span class="token string">"/hello"</span>            <span class="token number">2</span> hours ago         Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">2</span> hours ago                              awesome_banach<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker ps -a -n=1</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES8b4c74381205        centos              <span class="token string">"/bin/bash"</span>         <span class="token number">9</span> minutes ago       Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">6</span> minutes ago                       epic_wilson<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker ps -aq</span>8b4c74381205fb87667bbc19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>退出容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">exit</span>   <span class="token comment"># 直接退出容器</span>Ctrl + p + q  <span class="token comment"># 容器不停止退出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>删除容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> <span class="token function">rm</span> 容器id   <span class="token comment"># 删除指定容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><span class="token function">docker</span> <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span class="token variable">)</span></span>    <span class="token comment"># 删除所有容器 </span><span class="token function">docker</span> <span class="token function">ps</span> -a -q<span class="token operator">|</span><span class="token function">xargs</span> <span class="token function">docker</span> <span class="token function">rm</span>  <span class="token comment"># 删除所有容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>启动和停止容器的操作</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> start 容器id     <span class="token comment"># 启动容器</span><span class="token function">docker</span> restart 容器id   <span class="token comment"># 重启容器</span><span class="token function">docker</span> stop 容器id      <span class="token comment"># 停止当前正在运行的容器</span><span class="token function">docker</span> <span class="token function">kill</span> 容器id      <span class="token comment"># 强制停止当前正在运行的容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><p><strong>后台启动容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 命令 docker run -d 镜像名</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker run -d centos</span>e9d60f206fa19963203db6c42c2f83c5120eb90eeee2b7ba9fdc4589370fd6b6<span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker ps</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<span class="token comment"># 问题docker ps,发现 centos 停止了</span><span class="token comment"># 常见的坑，docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span><span class="token comment"># nginx,容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看日志</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> logs -f -t --tail 数字 容器id<span class="token comment"># 显示日志</span>-tf <span class="token comment"># 显示日志</span>--tail  <span class="token comment"># 要显示的日志条数</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker logs -tf --tail 10 ce989f90023d </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看容器中进程信息</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 命令 docker top 容器id</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker top ce989f90023d</span><span class="token environment constant">UID</span>                 PID                 <span class="token environment constant">PPID</span>                C                   STIME               TTY                 TIME     root                <span class="token number">12249</span>               <span class="token number">12232</span>               <span class="token number">0</span>                   <span class="token number">22</span>:44               pts/0               00:00:00 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看镜像的元数据</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 命令</span><span class="token function">docker</span> inspect 容器id<span class="token comment"># 测试</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker inspect ce989f90023d</span><span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244"</span>,        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2020-06-10T14:44:45.025360147Z"</span>,        <span class="token string">"Path"</span><span class="token builtin class-name">:</span> <span class="token string">"/bin/bash"</span>,        <span class="token string">"Args"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,        <span class="token string">"State"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Status"</span><span class="token builtin class-name">:</span> <span class="token string">"running"</span>,            <span class="token string">"Running"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Paused"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Restarting"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"OOMKilled"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Dead"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Pid"</span><span class="token builtin class-name">:</span> <span class="token number">12249</span>,            <span class="token string">"ExitCode"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"Error"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"StartedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2020-06-10T14:44:45.770227584Z"</span>,            <span class="token string">"FinishedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"0001-01-01T00:00:00Z"</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee"</span>,        <span class="token string">"ResolvConfPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/resolv.conf"</span>,        <span class="token string">"HostnamePath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/hostname"</span>,        <span class="token string">"HostsPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/hosts"</span>,        <span class="token string">"LogPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244/ce989f90023dedc0b3f39c057b91f5c0b17180b3aef7aea0df8c93731e724244-json.log"</span>,        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"/nifty_johnson"</span>,        <span class="token string">"RestartCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>,        <span class="token string">"Platform"</span><span class="token builtin class-name">:</span> <span class="token string">"linux"</span>,        <span class="token string">"MountLabel"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"ProcessLabel"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"AppArmorProfile"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"ExecIDs"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"HostConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Binds"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"ContainerIDFile"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"LogConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"Type"</span><span class="token builtin class-name">:</span> <span class="token string">"json-file"</span>,                <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"NetworkMode"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,            <span class="token string">"PortBindings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,            <span class="token string">"RestartPolicy"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"no"</span>,                <span class="token string">"MaximumRetryCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"AutoRemove"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"VolumeDriver"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"VolumesFrom"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CapAdd"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CapDrop"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Capabilities"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Dns"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"DnsOptions"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"DnsSearch"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"ExtraHosts"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"GroupAdd"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"IpcMode"</span><span class="token builtin class-name">:</span> <span class="token string">"private"</span>,            <span class="token string">"Cgroup"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Links"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"OomScoreAdj"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"PidMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Privileged"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"PublishAllPorts"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"ReadonlyRootfs"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"SecurityOpt"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"UTSMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"UsernsMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"ShmSize"</span><span class="token builtin class-name">:</span> <span class="token number">67108864</span>,            <span class="token string">"Runtime"</span><span class="token builtin class-name">:</span> <span class="token string">"runc"</span>,            <span class="token string">"ConsoleSize"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token number">0</span>,                <span class="token number">0</span>            <span class="token punctuation">]</span>,            <span class="token string">"Isolation"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"CpuShares"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"Memory"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"NanoCpus"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CgroupParent"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"BlkioWeight"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"BlkioWeightDevice"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"BlkioDeviceReadBps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"BlkioDeviceWriteBps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"BlkioDeviceReadIOps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"BlkioDeviceWriteIOps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CpuPeriod"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuQuota"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuRealtimePeriod"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuRealtimeRuntime"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpusetCpus"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"CpusetMems"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Devices"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"DeviceCgroupRules"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"DeviceRequests"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"KernelMemory"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"KernelMemoryTCP"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MemoryReservation"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MemorySwap"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MemorySwappiness"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"OomKillDisable"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"PidsLimit"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Ulimits"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CpuCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuPercent"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"IOMaximumIOps"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"IOMaximumBandwidth"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MaskedPaths"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"/proc/asound"</span>,                <span class="token string">"/proc/acpi"</span>,                <span class="token string">"/proc/kcore"</span>,                <span class="token string">"/proc/keys"</span>,                <span class="token string">"/proc/latency_stats"</span>,                <span class="token string">"/proc/timer_list"</span>,                <span class="token string">"/proc/timer_stats"</span>,                <span class="token string">"/proc/sched_debug"</span>,                <span class="token string">"/proc/scsi"</span>,                <span class="token string">"/sys/firmware"</span>            <span class="token punctuation">]</span>,            <span class="token string">"ReadonlyPaths"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"/proc/bus"</span>,                <span class="token string">"/proc/fs"</span>,                <span class="token string">"/proc/irq"</span>,                <span class="token string">"/proc/sys"</span>,                <span class="token string">"/proc/sysrq-trigger"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"GraphDriver"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Data"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"LowerDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641-init/diff:/var/lib/docker/overlay2/d4cd3bedb1e7340e62bb292c1e0d5ae37b1d1689ffc1640da67b2a8325facc21/diff"</span>,                <span class="token string">"MergedDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641/merged"</span>,                <span class="token string">"UpperDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641/diff"</span>,                <span class="token string">"WorkDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/bce8b2400427de29dd406d54ec08b3c07dc95530e80d37977a156ca971b37641/work"</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"Mounts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,        <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Hostname"</span><span class="token builtin class-name">:</span> <span class="token string">"ce989f90023d"</span>,            <span class="token string">"Domainname"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"User"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"AttachStdin"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"AttachStdout"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"AttachStderr"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Tty"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"OpenStdin"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"StdinOnce"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Env"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>            <span class="token punctuation">]</span>,            <span class="token string">"Cmd"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"/bin/bash"</span>            <span class="token punctuation">]</span>,            <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"centos"</span>,            <span class="token string">"Volumes"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"WorkingDir"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Entrypoint"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"OnBuild"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"org.label-schema.build-date"</span><span class="token builtin class-name">:</span> <span class="token string">"20200114"</span>,                <span class="token string">"org.label-schema.license"</span><span class="token builtin class-name">:</span> <span class="token string">"GPLv2"</span>,                <span class="token string">"org.label-schema.name"</span><span class="token builtin class-name">:</span> <span class="token string">"CentOS Base Image"</span>,                <span class="token string">"org.label-schema.schema-version"</span><span class="token builtin class-name">:</span> <span class="token string">"1.0"</span>,                <span class="token string">"org.label-schema.vendor"</span><span class="token builtin class-name">:</span> <span class="token string">"CentOS"</span>,                <span class="token string">"org.opencontainers.image.created"</span><span class="token builtin class-name">:</span> <span class="token string">"2020-01-14 00:00:00-08:00"</span>,                <span class="token string">"org.opencontainers.image.licenses"</span><span class="token builtin class-name">:</span> <span class="token string">"GPL-2.0-only"</span>,                <span class="token string">"org.opencontainers.image.title"</span><span class="token builtin class-name">:</span> <span class="token string">"CentOS Base Image"</span>,                <span class="token string">"org.opencontainers.image.vendor"</span><span class="token builtin class-name">:</span> <span class="token string">"CentOS"</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"NetworkSettings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Bridge"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"SandboxID"</span><span class="token builtin class-name">:</span> <span class="token string">"74d140bbc60432c5fdce865fa48f78c1138923dd292e708a25c4de17de812d56"</span>,            <span class="token string">"HairpinMode"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"LinkLocalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"LinkLocalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"Ports"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>,            <span class="token string">"SandboxKey"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/run/docker/netns/74d140bbc604"</span>,            <span class="token string">"SecondaryIPAddresses"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"SecondaryIPv6Addresses"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"3580dd1064b07f434c61e316f14cb7d7b53a3d6d7c9c0f77eb6570f1781623bc"</span>,            <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,            <span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.3"</span>,            <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,            <span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,            <span class="token string">"Networks"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"bridge"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                    <span class="token string">"IPAMConfig"</span><span class="token builtin class-name">:</span> null,                    <span class="token string">"Links"</span><span class="token builtin class-name">:</span> null,                    <span class="token string">"Aliases"</span><span class="token builtin class-name">:</span> null,                    <span class="token string">"NetworkID"</span><span class="token builtin class-name">:</span> <span class="token string">"58fd9703e96d12128c30f244be3205e3fe31fc7d1fb7fffdddba72d981e782f4"</span>,                    <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"3580dd1064b07f434c61e316f14cb7d7b53a3d6d7c9c0f77eb6570f1781623bc"</span>,                    <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,                    <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.3"</span>,                    <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,                    <span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,                    <span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,                    <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,                    <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,                    <span class="token string">"DriverOpts"</span><span class="token builtin class-name">:</span> null                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进入当前正在运行的容器</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span><span class="token comment"># 命令</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 容器id bashShell<span class="token comment"># 测试</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it ce989f90023d /bin/bash</span><span class="token punctuation">[</span>root@ce989f90023d /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="token punctuation">[</span>root@ce989f90023d /<span class="token punctuation">]</span><span class="token comment"># ps -ef</span><span class="token environment constant">UID</span>         PID   <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMDroot          <span class="token number">1</span>      <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">14</span>:44 pts/0    00:00:00 /bin/bashroot         <span class="token number">15</span>      <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">15</span>:19 pts/1    00:00:00 /bin/bashroot         <span class="token number">29</span>     <span class="token number">15</span>  <span class="token number">0</span> <span class="token number">15</span>:20 pts/1    00:00:00 <span class="token function">ps</span> -ef<span class="token comment"># 方式二</span><span class="token function">docker</span> attach 容器id<span class="token comment"># 测试</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker attach ce989f90023d</span>正在执行当前的代码<span class="token punctuation">..</span>.<span class="token comment"># docker exec# 进入容器后开启一个新的终端，可以在里面操作（常用）</span><span class="token comment"># docker attach # 进入容器正在执行的终端，不会启动新的进程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从容器内拷贝文件到主机上</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> <span class="token function">cp</span> 容器id:容器内目标文件路径  目的主机路径<span class="token comment"># 查看当前主机目录</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># ls</span>ztx<span class="token comment"># 进入docker容器内部</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker attach ce989f90023d</span><span class="token punctuation">[</span>root@ce989f90023d /<span class="token punctuation">]</span><span class="token comment"># cd /home/</span><span class="token punctuation">[</span>root@ce989f90023d home<span class="token punctuation">]</span><span class="token comment"># ls</span><span class="token comment"># 在容器内新建一个文件</span><span class="token punctuation">[</span>root@ce989f90023d home<span class="token punctuation">]</span><span class="token comment"># touch test.java</span><span class="token punctuation">[</span>root@ce989f90023d home<span class="token punctuation">]</span><span class="token comment"># exit</span><span class="token builtin class-name">exit</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker ps -a</span>CONTAINER ID     IMAGE      COMMAND       CREATED           STATUS                PORTS           NAMESce989f90023d     centos  <span class="token string">"/bin/bash"</span>  <span class="token number">44</span> minutes ago  Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">46</span> seconds ago               nifty_johnson<span class="token comment"># 将docker内文件拷贝到主机上</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># docker cp ce989f90023d:/home/test.java /home</span><span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># ls</span>test.java  ztx<span class="token punctuation">[</span>root@localhost home<span class="token punctuation">]</span><span class="token comment"># </span><span class="token comment"># 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="C:\Users\ZTX\Desktop\markdownx学习\Docker概述(1).assets\image-20200611085918923.png" alt="image-20200611085918923" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">attach      Attach to a running container       <span class="token comment"># 当前shell下attach连接指定运行的镜像</span>build       Build an image from a Dockerfile        <span class="token comment"># 通过Dockerfile定制镜像</span>commit      Create a new image from a container changes  <span class="token comment">#提交当前容器为新的镜像</span><span class="token function">cp</span>          Copy files/folders between a container and the <span class="token builtin class-name">local</span> filesystem <span class="token comment">#从容器中拷贝指定文件或目录到宿主机中</span>create      Create a new container   <span class="token comment"># 创建一个新的容器，同run,但不启动容器</span><span class="token function">diff</span>        Inspect changes to files or directories on a container's filesystem <span class="token comment">#查看docker容器的变化</span>events      Get real <span class="token function">time</span> events from the server   <span class="token comment"># 从docker服务获取容器实时事件</span><span class="token builtin class-name">exec</span>        Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a running container    <span class="token comment"># 在已存在的容器上运行命令</span><span class="token builtin class-name">export</span>      Export a container filesystem as a <span class="token function">tar</span> archive <span class="token comment"># 导出容器的内容流作为一个tar归档文件[对应import]</span><span class="token function">history</span>     Show the <span class="token function">history</span> of an image            <span class="token comment"># 展示一个镜像形成历史</span>images      List images                             <span class="token comment"># 列出系统当前的镜像</span><span class="token function">import</span>      Import the contents from a tarball to create a filesystem image <span class="token comment"># 从tar包中的内容创建一个新的文件系统镜像[对应export]</span>info        Display system-wide information         <span class="token comment"># 显示系统相关信息</span>inspect     Return low-level information on Docker objects <span class="token comment"># 查看容器详细信息</span><span class="token function">kill</span>        Kill one or <span class="token function">more</span> running containers     <span class="token comment"># 杀死指定的docker容器</span>load        Load an image from a <span class="token function">tar</span> archive or STDIN <span class="token comment"># 从一个tar包加载一个镜像[对应save]</span>login       Log <span class="token keyword">in</span> to a Docker registry  <span class="token comment"># 注册或者登录一个docker源服务器</span><span class="token builtin class-name">logout</span>      Log out from a Docker registry  <span class="token comment"># 从当前Docker registry退出</span>logs        Fetch the logs of a container  <span class="token comment"># 输出当前容器日志信息</span>pause       Pause all processes within one or <span class="token function">more</span> containers      <span class="token comment"># 暂停容器</span>port        List port mappings or a specific mapping <span class="token keyword">for</span> the container <span class="token comment"># 查看映射端口对应容器内部源端口</span><span class="token function">ps</span>          List containers  <span class="token comment"># 列出容器列表</span>pull        Pull an image or a repository from a registry <span class="token comment"># 从docker镜像源服务器拉取指定镜像或库镜像</span>push        Push an image or a repository to a registry   <span class="token comment"># 推送指定镜像或者库镜像至docker源服务器</span><span class="token function">rename</span>      Rename a container  <span class="token comment"># 给docker容器重新命名</span>restart     Restart one or <span class="token function">more</span> containers  <span class="token comment"># 重启运行的容器</span><span class="token function">rm</span>          Remove one or <span class="token function">more</span> containers  <span class="token comment"># 移除一个或者多个容器</span>rmi         Remove one or <span class="token function">more</span> images  <span class="token comment"># 移除一个或者多个镜像[无容器使用该镜像时才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span>run         Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a new container  <span class="token comment"># 创建一个新的容器并运行一个命令</span>save        Save one or <span class="token function">more</span> images to a <span class="token function">tar</span> archive <span class="token punctuation">(</span>streamed to STDOUT by default<span class="token punctuation">)</span> <span class="token comment"># 保存一个镜像为一个tar包[对应load]</span>search      Search the Docker Hub <span class="token keyword">for</span> images  <span class="token comment"># 在docker hub中搜索镜像</span>start       Start one or <span class="token function">more</span> stopped containers  <span class="token comment"># 启动容器</span>stats       Display a live stream of container<span class="token punctuation">(</span>s<span class="token punctuation">)</span> resource usage statistics <span class="token comment"># 实时显示容器资源使用统计</span>stop        Stop one or <span class="token function">more</span> running containers  <span class="token comment"># 停止容器</span>tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE <span class="token comment"># 给源中镜像打标签</span><span class="token function">top</span>         Display the running processes of a container     <span class="token comment"># 查看容器中运行的进程信息</span>unpause     Unpause all processes within one or <span class="token function">more</span> containers <span class="token comment"># 取消暂停容器</span>update      Update configuration of one or <span class="token function">more</span> containers  <span class="token comment"># 更新一个或多个容器配置</span>version     Show the Docker version information  <span class="token comment"># 查看docker版本号 </span><span class="token function">wait</span>        Block <span class="token keyword">until</span> one or <span class="token function">more</span> containers stop, <span class="token keyword">then</span> print their <span class="token builtin class-name">exit</span> codes <span class="token comment"># 截取容器停止时的退出状态值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h2><blockquote><p>作业1：Docker 安装Nginx</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 1.搜索镜像 search 建议去docker搜索，可以看到帮助文档</span><span class="token comment"># 2.下载镜像 pull</span><span class="token comment"># 3.运行测试</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker images</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEnginx               latest              2622e6cca7eb        <span class="token number">23</span> hours ago        132MBcentos              latest              470671670cac        <span class="token number">4</span> months ago        237MB<span class="token comment"># -d 后台运行</span><span class="token comment"># --name 给容器命名</span><span class="token comment"># -p 宿主机端口：容器内部端口   【端口映射操作】</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker run -d --name nginx01 -p 3344:80 nginx</span>d60570d1e45024e3687e3bf3105a6959af8ee68d34f0c62a7deee1c16ec6579fCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMESd60570d1e450        nginx               <span class="token string">"/docker-entrypoint.…"</span>   <span class="token number">2</span> minutes ago       Up <span class="token number">2</span> minutes        <span class="token number">0.0</span>.0.0:3344-<span class="token operator">></span><span class="token number">80</span>/tcp   nginx01<span class="token comment"># 本地测试访问nginx</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># curl localhost:3344</span><span class="token comment"># 进入容器</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it nginx01 /bin/bash</span>root@d60570d1e450:/<span class="token comment"># whereis nginx</span>nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@d60570d1e450:/<span class="token comment"># cd /etc/nginx/</span>root@d60570d1e450:/etc/nginx<span class="token comment"># ls</span>conf.dfastcgi_paramskoi-utf  koi-win  mime.types  modules  nginx.conf  scgi_paramsuwsgi_params  win-utf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>端口暴露的概念</strong></p><p><img src="C:\Users\ZTX\Desktop\markdownx学习\Docker概述(1).assets\image-20200611085948617.png" alt="image-20200611085948617" loading="lazy"></p><p><strong>思考问题：</strong>我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！</p><blockquote><p>作业2：Docker来装一个tomcat</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 官方文档</span><span class="token function">docker</span> run -it --rm tomcat:9.0<span class="token comment"># 我们之前的启动都是后台，停止了容器之后，容器还是可以查到 docker run -it --rm,一般用来测试，用完就删除</span><span class="token comment"># 下载再启动</span><span class="token function">docker</span> pull tomcat<span class="token comment"># 启动运行</span><span class="token function">docker</span> run -d -p <span class="token number">3355</span>:8080 --name tomcat01 tomcat<span class="token comment">#测试访问没有问题</span><span class="token comment"># 进入容器</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat01 /bin/bash</span><span class="token comment"># 发现问题：1、linux命令少了 2、webapps内没有内容（这是阿里云镜像的原因：默认是最小镜像，所有不必要的都删除）</span><span class="token comment"># 保证最小可运行环境</span><span class="token comment">#解决方法：将webapps.dist目录下内容拷至webapps下</span>root@c435d5b974a7:/usr/local/tomcat<span class="token comment"># cd webapps</span>root@c435d5b974a7:/usr/local/tomcat/webapps<span class="token comment"># ls</span>root@c435d5b974a7:/usr/local/tomcat/webapps<span class="token comment"># cd ..</span>root@c435d5b974a7:/usr/local/tomcat<span class="token comment"># ls</span>BUILDING.txt  CONTRIBUTING.md  LICENSENOTICEREADME.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  workroot@c435d5b974a7:/usr/local/tomcat<span class="token comment"># cd webapps.dist/</span>root@c435d5b974a7:/usr/local/tomcat/webapps.dist<span class="token comment"># ls</span>ROOT  docs  examples  host-manager  managerroot@c435d5b974a7:/usr/local/tomcat/webapps.dist<span class="token comment"># cd ..</span>root@c435d5b974a7:/usr/local/tomcat<span class="token comment"># cp -r webapps.dist/* webapps </span>root@c435d5b974a7:/usr/local/tomcat<span class="token comment"># cd webapps</span>root@c435d5b974a7:/usr/local/tomcat/webapps<span class="token comment"># ls</span>ROOT  docs  examples  host-manager  manager<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拷贝完成就可以访问了：</p><p><img src="C:\Users\ZTX\Desktop\markdownx学习\Docker概述(1).assets\image-20200611090019494.png" alt="image-20200611090019494" loading="lazy"></p><p><strong>思考问题：</strong>我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外部提供映射路径，webapps,我们在外部放置项目，就自动同步到内部就好了！</p><blockquote><p>作业3：部署es+kibana</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># es 暴露的端口很多！</span><span class="token comment"># es 十分耗内存</span><span class="token comment"># es 的数据一般需要放置到安全目录！挂载</span><span class="token comment"># --net somenetwork？网络配置</span><span class="token comment"># 启动 elasticsearch</span><span class="token function">docker</span> run -d --name elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> elasticsearch:7.6.2<span class="token comment"># 启动了 Linux就可卡住了   docker stats 查看cpu的状态</span><span class="token comment"># es 是十分耗内存的</span><span class="token comment"># 测试一下es是否成功了</span><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># curl localhost:9200</span><span class="token punctuation">&#123;</span>  <span class="token string">"name"</span> <span class="token builtin class-name">:</span> <span class="token string">"83b0d5dca26e"</span>,  <span class="token string">"cluster_name"</span> <span class="token builtin class-name">:</span> <span class="token string">"docker-cluster"</span>,  <span class="token string">"cluster_uuid"</span> <span class="token builtin class-name">:</span> <span class="token string">"MjhNfYTvRVui1UCrAwMdqw"</span>,  <span class="token string">"version"</span> <span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"number"</span> <span class="token builtin class-name">:</span> <span class="token string">"7.6.2"</span>,    <span class="token string">"build_flavor"</span> <span class="token builtin class-name">:</span> <span class="token string">"default"</span>,    <span class="token string">"build_type"</span> <span class="token builtin class-name">:</span> <span class="token string">"docker"</span>,    <span class="token string">"build_hash"</span> <span class="token builtin class-name">:</span> <span class="token string">"ef48eb35cf30adf4db14086e8aabd07ef6fb113f"</span>,    <span class="token string">"build_date"</span> <span class="token builtin class-name">:</span> <span class="token string">"2020-03-26T06:34:37.794943Z"</span>,    <span class="token string">"build_snapshot"</span> <span class="token builtin class-name">:</span> false,    <span class="token string">"lucene_version"</span> <span class="token builtin class-name">:</span> <span class="token string">"8.4.0"</span>,    <span class="token string">"minimum_wire_compatibility_version"</span> <span class="token builtin class-name">:</span> <span class="token string">"6.8.0"</span>,    <span class="token string">"minimum_index_compatibility_version"</span> <span class="token builtin class-name">:</span> <span class="token string">"6.0.0-beta1"</span>  <span class="token punctuation">&#125;</span>,  <span class="token string">"tagline"</span> <span class="token builtin class-name">:</span> <span class="token string">"You Know, for Search"</span><span class="token punctuation">&#125;</span><span class="token comment"># 查看docker容器占用资源情况</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181203.png" alt="image-20200611124706727" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 赶紧关闭容器，增加内存限制，修改配置文件 -e 环境配置修改</span><span class="token function">docker</span> run -d --name elasticsearch02 -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">"discovery.type=single-node"</span> -e <span class="token assign-left variable">ES_JAVA_OPTS</span><span class="token operator">=</span><span class="token string">"-Xms64m -Xmx512m"</span> elasticsearch:7.6.2  <span class="token comment"># 查看docker容器占用资源情况</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181204.png" alt="image-20200611124755826" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>root@localhost /<span class="token punctuation">]</span><span class="token comment"># curl localhost:9200</span><span class="token punctuation">&#123;</span>  <span class="token string">"name"</span> <span class="token builtin class-name">:</span> <span class="token string">"5a262b522bbf"</span>,  <span class="token string">"cluster_name"</span> <span class="token builtin class-name">:</span> <span class="token string">"docker-cluster"</span>,  <span class="token string">"cluster_uuid"</span> <span class="token builtin class-name">:</span> <span class="token string">"rGMaCpVXScGaZcv_UtK3gQ"</span>,  <span class="token string">"version"</span> <span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>    <span class="token string">"number"</span> <span class="token builtin class-name">:</span> <span class="token string">"7.6.2"</span>,    <span class="token string">"build_flavor"</span> <span class="token builtin class-name">:</span> <span class="token string">"default"</span>,    <span class="token string">"build_type"</span> <span class="token builtin class-name">:</span> <span class="token string">"docker"</span>,    <span class="token string">"build_hash"</span> <span class="token builtin class-name">:</span> <span class="token string">"ef48eb35cf30adf4db14086e8aabd07ef6fb113f"</span>,    <span class="token string">"build_date"</span> <span class="token builtin class-name">:</span> <span class="token string">"2020-03-26T06:34:37.794943Z"</span>,    <span class="token string">"build_snapshot"</span> <span class="token builtin class-name">:</span> false,    <span class="token string">"lucene_version"</span> <span class="token builtin class-name">:</span> <span class="token string">"8.4.0"</span>,    <span class="token string">"minimum_wire_compatibility_version"</span> <span class="token builtin class-name">:</span> <span class="token string">"6.8.0"</span>,    <span class="token string">"minimum_index_compatibility_version"</span> <span class="token builtin class-name">:</span> <span class="token string">"6.0.0-beta1"</span>  <span class="token punctuation">&#125;</span>,  <span class="token string">"tagline"</span> <span class="token builtin class-name">:</span> <span class="token string">"You Know, for Search"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作业4：使用 kibana 连接 es ? 思考网络如何才能连接过去！</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181205.png" alt="image-20200611125352717" loading="lazy"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul><li>portainer（线用这个）</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> run -d -p <span class="token number">8088</span>:9000 <span class="token punctuation">\</span>--restart<span class="token operator">=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span class="token operator">=</span>true portainer/portainer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>Rancher （CI&#x2F;CD再用）</li></ul><h2 id="什么是portainer"><a href="#什么是portainer" class="headerlink" title="什么是portainer ?"></a>什么是portainer ?</h2><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> run -d -p <span class="token number">8088</span>:9000 <span class="token punctuation">\</span>--restart<span class="token operator">=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span class="token operator">=</span>true portainer/portainer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>外部访问测试：<a href="http://ip:8088/">http://ip:8088/</a></p><p>通过它来访问了;</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181206.png" alt="image-20200611141621853" loading="lazy"></p><p>选择本地的：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181207.png" alt="image-20200611142004773" loading="lazy"></p><p>进入之后的面板：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181208.png" alt="image-20200611144838665" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181209.png" alt="image-20200611144900114" loading="lazy"></p><p>可视化面板我们平时不会使用，大家自己测试玩玩即可！</p><h1 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p><p>所有应用，直接打包docker镜像，就可以直接跑起来！</p><p><strong>如何得到镜像</strong></p><ul><li>从远程仓库下载</li><li>别人拷贝给你</li><li>自己制作一个镜像 DockerFile</li></ul><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote><p>UnionFs （联合文件系统）</p></blockquote><p>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><blockquote><p>Docker镜像加载原理</p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加载 kernel, Linux刚启动时会加载bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包括bootloader和 Kernel。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的&#x2F;dev,&#x2F;proc,&#x2F;bin,&#x2F;etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。<br><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181210.png" alt="image-20200611162007055" loading="lazy"></p><p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181211.png" alt="image-20200611162057734" loading="lazy"></p><p>对于个精简的OS, rootfs可以很小，只需要包合最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</p><p>虚拟机是分钟级别，容器是秒级！</p><h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><blockquote><p>分层的镜像</p></blockquote><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载！<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181212.png" alt="image-20200611163839741" loading="lazy"></p><p><strong>思考：为什么Docker镜像要采用这种分层的结构呢？</strong></p><p>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><p>查看镜像分层的方式可以通过docker image inspect 命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">➜  / <span class="token function">docker</span> image inspect redis          <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c"</span>,        <span class="token string">"RepoTags"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>            <span class="token string">"redis:latest"</span>        <span class="token punctuation">]</span>,        <span class="token string">"RepoDigests"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>            <span class="token string">"redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32"</span>        <span class="token punctuation">]</span>,        <span class="token string">"Parent"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"Comment"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2020-05-02T01:40:19.112130797Z"</span>,        <span class="token string">"Container"</span><span class="token builtin class-name">:</span> <span class="token string">"d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc"</span>,        <span class="token string">"ContainerConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Hostname"</span><span class="token builtin class-name">:</span> <span class="token string">"d30c0bcea885"</span>,            <span class="token string">"Domainname"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"User"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"AttachStdin"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"AttachStdout"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"AttachStderr"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"ExposedPorts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"6379/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"Tty"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"OpenStdin"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"StdinOnce"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Env"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,                <span class="token string">"GOSU_VERSION=1.12"</span>,                <span class="token string">"REDIS_VERSION=6.0.1"</span>,                <span class="token string">"REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz"</span>,                <span class="token string">"REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273"</span>            <span class="token punctuation">]</span>,            <span class="token string">"Cmd"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"/bin/sh"</span>,                <span class="token string">"-c"</span>,                <span class="token string">"#(nop) "</span>,                <span class="token string">"CMD [<span class="token entity" title="\&quot;">\"</span>redis-server<span class="token entity" title="\&quot;">\"</span>]"</span>            <span class="token punctuation">]</span>,            <span class="token string">"ArgsEscaped"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0"</span>,            <span class="token string">"Volumes"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"/data"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"WorkingDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/data"</span>,            <span class="token string">"Entrypoint"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"docker-entrypoint.sh"</span>            <span class="token punctuation">]</span>,            <span class="token string">"OnBuild"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"DockerVersion"</span><span class="token builtin class-name">:</span> <span class="token string">"18.09.7"</span>,        <span class="token string">"Author"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Hostname"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Domainname"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"User"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"AttachStdin"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"AttachStdout"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"AttachStderr"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"ExposedPorts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"6379/tcp"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"Tty"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"OpenStdin"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"StdinOnce"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Env"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,                <span class="token string">"GOSU_VERSION=1.12"</span>,                <span class="token string">"REDIS_VERSION=6.0.1"</span>,                <span class="token string">"REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz"</span>,                <span class="token string">"REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273"</span>            <span class="token punctuation">]</span>,            <span class="token string">"Cmd"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"redis-server"</span>            <span class="token punctuation">]</span>,            <span class="token string">"ArgsEscaped"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0"</span>,            <span class="token string">"Volumes"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"/data"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"WorkingDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/data"</span>,            <span class="token string">"Entrypoint"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"docker-entrypoint.sh"</span>            <span class="token punctuation">]</span>,            <span class="token string">"OnBuild"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> null        <span class="token punctuation">&#125;</span>,        <span class="token string">"Architecture"</span><span class="token builtin class-name">:</span> <span class="token string">"amd64"</span>,        <span class="token string">"Os"</span><span class="token builtin class-name">:</span> <span class="token string">"linux"</span>,        <span class="token string">"Size"</span><span class="token builtin class-name">:</span> <span class="token number">104101893</span>,        <span class="token string">"VirtualSize"</span><span class="token builtin class-name">:</span> <span class="token number">104101893</span>,        <span class="token string">"GraphDriver"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Data"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"LowerDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/adea96bbe6518657dc2d4c6331a807eea70567144abda686588ef6c3bb0d778a/diff:/var/lib/docker/overlay2/66abd822d34dc6446e6bebe73721dfd1dc497c2c8063c43ffb8cf8140e2caeb6/diff:/var/lib/docker/overlay2/d19d24fb6a24801c5fa639c1d979d19f3f17196b3c6dde96d3b69cd2ad07ba8a/diff:/var/lib/docker/overlay2/a1e95aae5e09ca6df4f71b542c86c677b884f5280c1d3e3a1111b13644b221f9/diff:/var/lib/docker/overlay2/cd90f7a9cd0227c1db29ea992e889e4e6af057d9ab2835dd18a67a019c18bab4/diff"</span>,                <span class="token string">"MergedDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/merged"</span>,                <span class="token string">"UpperDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/diff"</span>,                <span class="token string">"WorkDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/work"</span>            <span class="token punctuation">&#125;</span>,            <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"RootFS"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"Type"</span><span class="token builtin class-name">:</span> <span class="token string">"layers"</span>,            <span class="token string">"Layers"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13"</span>,                <span class="token string">"sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990"</span>,                <span class="token string">"sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8"</span>,                <span class="token string">"sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8"</span>,                <span class="token string">"sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123"</span>,                <span class="token string">"sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>,        <span class="token string">"Metadata"</span><span class="token builtin class-name">:</span> <span class="token punctuation">&#123;</span>            <span class="token string">"LastTagTime"</span><span class="token builtin class-name">:</span> <span class="token string">"0001-01-01T00:00:00Z"</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>理解：</strong></p><p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p><p>该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181213.png" alt="image-20200611163818495" loading="lazy"></p><p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而整体的大镜像包含了来自两个镜像层的6个文件。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181214.png" alt="image-20200611164322267" loading="lazy"></p><p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件。</p><p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181215.png" alt="image-20200611164447964" loading="lazy"></p><p>这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p><p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p><p>Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的文件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p><p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [1]。</p><blockquote><p>特点</p></blockquote><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181216.png" alt="image-20200611165355825" loading="lazy"></p><p>如何提交一个自己的镜像？</p><h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">docker</span> commit 提交容器成为一个新的副本<span class="token comment"># 命令和git原理类似</span><span class="token function">docker</span> commit -m<span class="token operator">=</span><span class="token string">"描述信息"</span> -a<span class="token operator">=</span><span class="token string">"作者"</span> 容器id 目标镜像名:<span class="token punctuation">[</span>版本TAG<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实战测试</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#1、启动一个默认的tomcat</span><span class="token comment">#2、发现这个默认的tomcat是没有webapps应用的，镜像的原因。官方的镜像默认webapps下面是没有文件的！</span><span class="token comment">#3、我自己将webapp.dist下文件拷贝至webapps下</span><span class="token comment">#4、将我们操作过的容器通过commit提交为一个镜像！我们以后就可以使用我们修改过的镜像了，这就是我们自己的一个修改的镜像</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220303181217.png" alt="image-20200611172701729" loading="lazy"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到了这里就算是入门Docker了！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机存储容量单位换算</title>
      <link href="/posts/3b245245/"/>
      <url>/posts/3b245245/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>1、比特Bit(位、b)：表示信息的最小单位，即计算机最小的存储单位，是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量【它代表从一个二进制数组中选出一元（0或1）所提供的信息量（若此二元出现的概率相等）】</p><p>2、字节Byte(B)：二进制数据的单位，计算机中数据基本单位，一个字节通常8位长。各种信息在计算机中存储、处理至少需要一个字节。例一个ASCII码用一个字节表示，一个汉字用两个字节表示</p><p>3、千字节Kilobytes(KB)：计算机存储容量的单位，也常用KB来表示。1KB&#x3D;1024字节</p><p>4、兆字节Megabytes(MB)：计算机存储容量的单位，也常用MB来表示。1MB&#x3D;1024*1024字节</p><p>5、吉字节Gigabyte(GB) ：又称千兆字节，是计算机存储容量单位，简称GB，是兆字节(MB)的1024倍，即 1024MB。</p><p>6、太字节terabyte(TB)：计算机存储容量单位，也常用TB来表示。1TB&#x3D;1024GB&#x3D;2^40字节。</p><p>PS：KB（即baiK）、MB（即M）、GB（即G）等都是基于字节换算的存储单位。</p><h1 id="二、转换"><a href="#二、转换" class="headerlink" title="二、转换"></a>二、转换</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">字节<span class="token punctuation">(</span>Byte<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">8</span>位<span class="token punctuation">(</span>bit<span class="token punctuation">)</span>                               <span class="token number">1</span>B<span class="token operator">=</span><span class="token number">8</span>b <span class="token number">1</span>KB<span class="token punctuation">(</span> Kilobyte，千字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>B                      <span class="token number">1</span>KB<span class="token operator">=</span><span class="token number">1024</span>B <span class="token number">1</span>MB<span class="token punctuation">(</span> Megabyte，兆字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>KB                     <span class="token number">1</span>MB<span class="token operator">=</span><span class="token number">1024</span>KB <span class="token number">1</span>GB<span class="token punctuation">(</span> Gigabyte，吉字节，千兆<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>MB               <span class="token number">1</span>GB<span class="token operator">=</span><span class="token number">1024</span>MB <span class="token number">1</span>TB<span class="token punctuation">(</span> Trillionbyte，万亿字节，太字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>GB       <span class="token number">1</span>TB<span class="token operator">=</span><span class="token number">1024</span>GB <span class="token number">1</span>PB<span class="token punctuation">(</span> Petabyte，千万亿字节，拍字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>TB         <span class="token number">1</span>PB<span class="token operator">=</span><span class="token number">1024</span>TB <span class="token number">1</span>EB<span class="token punctuation">(</span> Exabyte，百亿亿字节，艾字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>PB          <span class="token number">1</span>EB<span class="token operator">=</span><span class="token number">1024</span>PB <span class="token number">1</span>ZB<span class="token punctuation">(</span>Zettabyte，十万亿亿字节，泽字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>EB       <span class="token number">1</span>ZB<span class="token operator">=</span><span class="token number">1024</span>EB <span class="token number">1</span>YB<span class="token punctuation">(</span> Yottabyte，一亿亿亿字节，尧字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>ZB      <span class="token number">1</span>YB<span class="token operator">=</span><span class="token number">1024</span>ZB    <span class="token number">1</span>BB<span class="token punctuation">(</span> Brontobyte，千亿亿亿字节<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1024</span>YB             <span class="token number">1</span>BB<span class="token operator">=</span><span class="token number">1024</span>YB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在线转换工具：<a href="https://calc.itzmx.com/">PC字节计算器</a></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220224141737.png" alt="image-20220224141737338" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 计算机等级考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派GPIO串口配置</title>
      <link href="/posts/149c75f2/"/>
      <url>/posts/149c75f2/</url>
      
        <content type="html"><![CDATA[<h1 id="外设IO口定义说明"><a href="#外设IO口定义说明" class="headerlink" title="外设IO口定义说明"></a>外设IO口定义说明</h1><p>从树莓派的相关资料我们可以看到，树莓派有两个串口可以使用，一个是硬件串口（&#x2F;dev&#x2F;ttyAMA0）,另一个是mini串口（&#x2F;dev&#x2F;ttyS0）。硬件串口有单独的波特率时钟源，性能好，稳定性强；mini串口功能简单，稳定性较差，波特率由CPU内核时钟提供，受内核时钟影响。<br>树莓派（3&#x2F;4代）板载蓝牙模块，默认的硬件串口是分配给蓝牙模块使用的，而性能较差的mini串口是分配给GPIO串口 TXD0、RXD0。</p><p><img src="https://i.loli.net/2020/12/19/BhRGtWprT3yYZ6m.png" alt="image-20201027193659980" loading="lazy"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python <span class="token operator">-</span>m serial<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>list_ports <span class="token comment">#命令python查看安装到系统上的串口</span>ls <span class="token operator">-</span>l <span class="token operator">/</span>dev<span class="token operator">/</span>tty<span class="token operator">*</span>  <span class="token comment">#查看识别的串口号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="Serial-配置"><a href="#Serial-配置" class="headerlink" title="Serial 配置"></a>Serial 配置</h1><p>首先运行<code>ls /dev -al</code>命令查看到默认的串口分配方式，如下图所示：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213416.png" alt="image-20220125213416058" loading="lazy"></p><p>由于硬件串口分配给板载蓝牙使用，所以要释放掉,并设置硬件串口分配给GPIO串口。<br>首先登陆终端后，输入<code>sudo raspi-config</code>命令进入树莓派系统配置界面,选择第五个<code>Interfacing Options</code>：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213519.png" alt="image-20220125213519894" loading="lazy"></p><p>进入P6 Serial</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213546.png" alt="image-20220125213546164" loading="lazy"></p><p>选择关闭串口登录功能，打开硬件串口调试功能：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213610.png" alt="image-20220125213609989" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213626.png" alt="image-20220125213626861" loading="lazy"></p><p>完成后提示以下界面，按OK</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213655.png" alt="image-20220125213655132" loading="lazy"></p><h1 id="设置硬件串口为GPIO串口"><a href="#设置硬件串口为GPIO串口" class="headerlink" title="设置硬件串口为GPIO串口"></a>设置硬件串口为GPIO串口</h1><p>接着将串口配置为我们的GPIO串口，对输入<code>sudo nano /boot/config.txt</code>命令，将下面两行内容添加到最后:</p><p><code>dtoverlay=pi3-miniuart-bt </code></p><p><code>force_turbo=1</code></p><p>修改后保存并退出，内容如下图片所示：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213830.png" alt="image-20220125213830309" loading="lazy"></p><p>重启树莓派后，再次输入<code>ls /dev -al</code>，可以看到两个串口已经互相换了位置：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220125213908.png" alt="image-20220125213908406" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 串口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPS定位基础知识</title>
      <link href="/posts/2778c38e/"/>
      <url>/posts/2778c38e/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍篇"><a href="#介绍篇" class="headerlink" title="介绍篇"></a>介绍篇</h1><p>过去，如果你的女友是个路痴，大概会有这样的对话……</p><p>——你在哪儿呢？</p><p>——啊？我在马路上啊。</p><p>——有什么特征？</p><p>——头顶有个月亮。</p><p>——你旁边有什么啊？</p><p>——有个路灯。</p><p>——有没有路牌啊？路牌上写的什么？</p><p>——我看看啊。还真的有，上边写着“禁止停车 违者罚款”。</p><p>——姑奶奶，我真是服了你了……</p><p>——哼，你是不是不爱我了，你肯定是不爱我了，你是不是喜欢上了新来的那个前台？</p><p>——。。。</p><p>——我跟你说那个前台绝对是个伪娘！（开启八卦模式）还有还有，小王买了个新口红真好看，你也给我买好不好……</p><p>——（一脸崩溃的表情）</p><p>（路人甲：你是不可能有女友的！）</p><p>现在，如果你的女友是个路痴……</p><p>——你在哪儿啊？</p><p>——我发定位给你！乖乖的来接老娘。</p><p>——遵命。。。</p><p>作为一个标准路痴，曾经有N次陷入绝境黑历史。正所谓：手持一纸地图，双眼紧盯道路，环顾四周茫然，我现身在何处？</p><p>后来随着智能手机的普及，我以为情况能有所改善，后来才发现是我想多了——为嘛xx地图、xx导航还是总让我往死胡同里跑，非让我开车过湖？</p><p>再后来，随着手机操作系统的迭代，芯片的升级，定位才慢慢变得精准、可靠。我再也不用湖里游泳了……当然，这都是后话了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222202.png" alt="img" loading="lazy"></p><p>慢慢的随着了解的深入，才明白原来定位有这么多区别，里边的学问可大着呢。</p><p>定位给方式有很多种，室外定位有基站定位，卫星定位等方式；室内定位有BLE、RFID、Wi-Fi等方式；还有其他IP定位，惯性导航等等方式。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124220544.png" alt="image-20220124220544706" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124220557.png" alt="image-20220124220557876" loading="lazy"></p><p>“需后端支持”指需要连接到服务器进行数据解析，才能获得定位结果；</p><p>“需专有后端支持”指可能需要付费才能获得相关数据，终端设备才可以进行定位。</p><p>本文咱们就说说和物联网关系最密切的卫星定位那些事儿。</p><p>众多卫星定位系统中，最广为人知的就是GPS (Global Positioning System)了。它是美国在1958年开始研发，1964年投入使用，1994年实现全球覆盖的全球卫星定位系统。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222154.png" alt="img" loading="lazy"></p><p>GPS由24颗工作星和4颗备用星组成。卫星工作在互成55度的6条高度为2.02万KM的非同步轨道上。如此一来，在全球的任何地方、任何时间都可观测到4颗以上的GPS卫星。GPS卫星向地球发射导航电文（系统时间、星历、历书、卫星时钟修正参数、导航卫星健康状况、电离层延时参数等内容），GPS终端收到卫星发送的数据，经解算即可确定当前位置，并以NMEA0183格式，WGS-84坐标系输出数据。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222151.png" alt="img" loading="lazy"></p><p>也许有的读者会问，万一卫星坏了怎么办，GPS岂不是要失准了？其实这个担心是多余的啦，轨道上不仅有备用卫星，每年NASA也会委托Space X补发和替换寿终的卫星。</p><p>当然，卫星定位系统不是GPS一家独大的。只是因为GPS的先驱地位，所以很多人也都习惯性的把所有卫星定位系统都称之为“GPS”。</p><p>毕竟，使用GPS卫星之时，就是被美国钳制之日。GPS卫星是被美国军方控制的，他们可以随意调节某地区的定位精度（如中东地区），甚至让终端设备解算结果南辕北辙。而且GPS卫星是单向广播的，不具备双向通信能力，功能略显单一。</p><p>有鉴于此，很多国家也都在建设或已建成卫星定位系统。如中国的北斗(BeiDou)、欧洲的伽利略(Galileo)、俄罗斯的格洛纳斯(GLONASS)、印度的IRNSS等。</p><p>目前，中国的BeiDou北斗已经具备商用能力。配合基准站，甚至能给客户提供精确到毫米的定位服务。同时，BeiDou北斗也弥补了GPS的不足，具备短报文能力（驴友、海航必备。绝非手机的基站可比拟，只是资费超超超感人）。</p><p>既然太空中有那么多卫星，又有那么多种不同的卫星定位系统，那么如何知道某一片区域是否有定位卫星覆盖，以及有哪些卫星覆盖呢？Android手机请在应用商店搜索“GPS Data+”并安装，打开后即可看到当前正在使用的定位卫星：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222138.png" alt="img" loading="lazy"></p><p>由于智能手机操作系统、定位芯片、天线、算法的差异，所以并不能搜索到所有用于定位的卫星系统。通常来说，智能手机只能搜到并使用部分（如图，即GPS+Beidou+GLONASS+QZSS，没有Galileo、IRNSS）。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124220812.png" alt="image-20220124220812198" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124220826.png" alt="image-20220124220826363" loading="lazy"></p><p>观察一下表格，我们可以发现，日本简直是太“鸡贼”了——L1 C&#x2F;A、L1C、L2C、L5信号跟GPS卫星信号是完全兼容的，同时L1-SAIF还可以给日本地区提供高精度定位服务；LEX信号频点和欧洲Galileo系统的E6频点重合。也就是说，日本的QZSS当前可以作为GPS的补充，日后等到Galileo系统正式提供服务，QZSS也能实现Galileo系统的补充。</p><p>接下来进入喜闻乐见的“你问我答”环节：</p><p>Q：为什么有的时候手机定位还是很慢？</p><p>A：信号问题、基带问题等，一切皆有可能。如果想要提高定位精度，最简单方式就是——买！个！新！手！机！</p><p>Q：我想试试伽利略，有没有支持的手机呢？</p><p>A：华为有部分机型支持。</p><p>Q：小米8刘海屏不好看啊，你看VIVO NEX多美。对了，小米8说是全球第一个支持GPS双频定位（L1、L5）的手机，好像很牛逼，能做到厘米级定位吗？</p><p>A：不能。没有基准站的支持，双频顶多是减小误差，对高精度定位无助。所以，还是洗洗睡吧。</p><p>Q：北斗的短报文资费究竟有多感人？</p><p>A：十几块一条吧。你可以去某猫、某宝查看一下报价。</p><p>至于说语音通信，也有海事卫星电话可用，不同国家资费不同，从十几块到几十块一分钟；什么？你想用卫星上网？按量计费$10&#x2F;1M，怎么样，用的起吗？</p><p>Q：既然已有GPS，为什么还要重造轮子？</p><p>A：因为GPS的L1、L5是民码，大众可用，但是美军曾经在战时关闭过某些战区的数据覆盖，为了避免这种被人卡住喉舌的尴尬，所有必要发展自己的卫星定位系统。</p><p>Q：卫星定位系统只在地表有用吗？</p><p>A：非也。负海拔地区（只要有信号）、空中、甚至大气层外都可以。需要注意的是，水体、岩石等密度高的物体内无法使用。</p><p>大气层外使用，还要注意广义相对论对时钟造成的影响。</p><p>Q：《007 明日帝国》中，大反派使用了某种很牛逼的设备，通过某些手段改变了卫星参数，劫持了一艘船，这种事情可能发生吗？</p><p>A：这种事情，世界上已经发生过了。</p><p>因为GPS信号没有认证方式，且信号极弱，非常容易被劫持。例如HackRF One就可以模拟并发射GPS信号；甚至让大疆无人机在禁飞区起飞。</p><p>伊朗也是用过类似的技术，成功捕获美国的无人机。</p><p>Q：最少搜到多少颗卫星才能定位成功呢？</p><p>A：因为采用三角定位的原理，所以至少3颗卫星才能实现精准定位；具体要求如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124220849.png" alt="image-20220124220849473" loading="lazy"></p><h2 id="定位篇"><a href="#定位篇" class="headerlink" title="定位篇"></a>定位篇</h2><p>有的人会问，既然天上多卫星，为什么我看输出结果只是用了其中有限的几个呢？这是因为单片机使用的小尺寸的陶瓷天线，一般只能做到兼容2个频段（一般软件上也是多选2），无法做到同时兼容3个频段。所以通常是单选GPS或北斗；或者是GPS+北斗、GPS+GLONASS等两两组合的方式。</p><p>有的开发者实测时发现，为什么代码无误，但是定位模块就是搜不到卫星，无法定位呢？</p><p>实际上排查这种问题既简单，又复杂。之所以说简单的，是因为搜不到卫星唯一的原因就是信号问题。复杂是因为即便知道了病因，开发者也可能会觉得束手无策。</p><p>信号问题，那就是“卫星→天线→模块→代码→输出”的某个环节出现异常了。在这里，结合“望闻问切”的方法，针对可能出现的问题逐项击破。</p><p>首先，开发者应谨记，任何时候都应该避免空间上存在异物遮蔽天线（如树木、建筑、高架桥），物理上存在金属外壳等遮挡天线等情况（如铝壳、铁壳）。应确保测试环境是空旷的，无遮挡的，信号良好的。</p><p>之所以一直在强调天线、信号、无遮挡，是因为卫星的发射功率并不大，信号到达地面时已经很弱。这种信号强度相当于1.6万公里外一个25瓦的灯泡发出的光。再做个比喻，它比电视机天线所接收到的功率还要低10亿倍。</p><p>信号弱、无信号，都会表现为无法定位，或者定位慢。那么，如何判断究竟是信号问题导致的定位慢，还是真·无信号呢？观察模块输出的GGA、RMC和GSA： </p><p><strong>GGA：</strong></p><p>&#x3D;&#x3D;格式：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$–GGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx*hh&#x3D;&#x3D;</p><p>&#x3D;&#x3D;示例：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$GPGGA,065545.789,2109.9551,N,12023.4047,E,1,9,0.85,18.1,M,8.0,M,,*5E&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221001.png" alt="image-20220124221001803" loading="lazy"></p><p><strong>RMC：</strong></p><p>&#x3D;&#x3D;格式：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$–RMC,hhmmss.ss,A,llll.ll,a,yyyyy.yy,a,x.x,x.x,xxxx,x.x,a*hh&#x3D;&#x3D;</p><p>&#x3D;&#x3D;例句：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$GPRMC,100646.000,A,3109.9704,N,12123.4219,E,0.257,335.62,291216,,,A*59&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221034.png" alt="image-20220124221034365" loading="lazy"></p><p>GSA：</p><p>&#x3D;&#x3D;格式：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$–GSA,a,a,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x.x,x.x,x.x*hh&#x3D;&#x3D;</p><p>&#x3D;&#x3D;例句：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$GPGSA,A,3,10,24,12,32,25,21,15,20,31,,,,1.25,0.85,0.91*04&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221113.png" alt="image-20220124221113039" loading="lazy"></p><p>·如果GGA中的UTC时间错误，定位指示为0，卫星数目不为0；或者RMC的UTC时间错误，日期错误；GSA中卫星数目不为0，但是载噪比都很低，则可能是搜星慢，定位慢，信号差；</p><p>·如果GGA中的UTC时间错误，定位指示为0，卫星数目始终为0；或者RMC的UTC时间错误，日期错误；GSA完全没有任何有效输出，则可能是完全无信号。</p><p>对于搜星慢，定位慢，信号差的情况，应改善天线设计，保证天线面朝上的安装使用状态；并且天线周边没有金属物件遮挡，无射频干扰；在空间容许的情况下尽量选择大尺寸的陶瓷天线，必要时应使用有源天线。</p><p>对于完全无信号的情况，大概率是天线设计错误。譬如，没有给有源天线开启供电，错误使用天线型号（如芯片仅支持GPS，天线仅支持北斗；错误的使用GSM天线接收信号）等。</p><p>扩展阅读：《Luat模块GPS天线设计建议》</p><p><a href="http://blog.sina.com.cn/s/blog_5b0121350102xy8v.html">http://blog.sina.com.cn/s/blog_5b0121350102xy8v.html</a></p><p>还有一种常见情况是开发者在室内（含窗口、窗台）进行测试，这是不行的。因为室内没有卫星信号，并不能实现定位。</p><p>如果开发者不便于去户外进行测试，可以在某宝搜索“GPS 转发”并购买相关设备。这样一来，开发者就不用“风吹日晒，饱经风雨”的，“不辞辛劳”的在户外调试啦。</p><p>接下来进入大快人心的“你问我答”环节：</p><p>Q：有没有体积小、信号好强的天线？</p><p>A：鱼和熊掌不可兼得。只有最适合的，没有最好的。</p><p>Q：NMEA-0183哪里格式说明呢？</p><p>A：请到<a href="http://www.openluat.com/%E4%BA%A7%E5%93%81%E4%B8%AD%E5%BF%83%E7%9A%84GPS%E6%A8%A1%E5%9D%97%E2%80%9C%E4%B8%8B%E8%BD%BD%E4%B8%AD%E5%BF%83%E2%80%9D%E4%B8%8B%E8%BD%BD%E3%80%82">http://www.openluat.com/产品中心的GPS模块“下载中心”下载。</a></p><p>Q：GNSS和GPS什么关系啊？</p><p>A：严格来说，GPS∈GNSS。</p><p>所有的卫星定位系统都是可以称之为GNSS，GPS是GNSS的子集。</p><p>这一点在输出中也有体现，例如：GNGGA，GPGGA，BDGGA，即“混合定位”（多卫星系统）、“GPS定位”、“北斗定位”。</p><p>语句标识符：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221132.png" alt="image-20220124221132283" loading="lazy"></p><p>Q：GGA、RMC、RSV有什么分别？</p><p>A：都是NMEA-0183标准的要求。他们的释义如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221143.png" alt="image-20220124221142982" loading="lazy"></p><p>Q：UTC时间有办法换算成当地时间吗？</p><p>A：陆地的话，因为很多国家可能跨越非常多的时区，却使用统一时间，所以只能查表啦（如北京时间UTC+8）。如果是海洋，则根据经度计算时区。</p><p>Q：有没有手机能用的，测试GPS的，比较牛逼的app？</p><p>A：Android：GPS Status；GPS Test+；GPS Data+</p><p>iOS：GPS Test+</p><p>Q：为什么手机定位那么快那么准，定位模块那么慢，误差还很大？</p><p>A：因为手机是牺牲个人隐私为前提的多重定位（基站+WiFi+蓝牙+GPS+AGPS+历史数据），而模块只是用GPS天线，所以显得略慢一些。但是使用“AGPS辅助定位”后，一样可以做到秒定位。</p><p>Q：你为什么懂得那么多啊？</p><p>A：大概是因为我比较富吧。</p><p>PS: 那么，怎么使用“AGPS辅助定位”呢？请关注下文哦。</p><h2 id="秒定位篇"><a href="#秒定位篇" class="headerlink" title="秒定位篇"></a>秒定位篇</h2><p>为什么信号极好的情况下，定位速度也不快？有没有办法实现“秒定位”呢？答案当然是肯定的啦。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222123.png" alt="img" loading="lazy"></p><p>常规情况下，定位模块上电开机后，通过天线搜索卫星，解析卫星发射的数据（导航电文），然后内部生成星历，再经过复杂的计算，从而得到当前精确的位置（3D Fix）。这个过程称之为“冷启动”。根据信号强度、芯片运算能力，通常耗时几十秒到几分钟不等。</p><p>这个过程中，搜星+生成星历文件耗时最久。</p><p>不过有的读者可能会问，为什么有的时候定位模块只用了几秒就成功定位了呢？原因有二：1、非“冷启动”方式，即“温启动”或“热启动”；</p><p>2、使用了AGPS辅助定位。</p><p>那么，“冷启动”、“温启动”和“热启动”有什么区别呢？也许大家会以为，这里的“X启动”和电脑的开机、待机（睡眠）、重启近似吧？实际上并非如此哦。由于卫星所处空间位置、终端设备所处地表位置是不固定的，所以此处的“X启动”都是以最后一次定位时间和位移距离作为判断依据的：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221236.png" alt="image-20220124221236173" loading="lazy"></p><p>*自主秒定位：根据模块内保存的星历，实现快速搜星、定位。</p><p>*辅助秒定位：使用AGPS辅助，实现快速搜星、定位。</p><p>也就是说，“温启动”和“热启动”情况下，定位模块是可以实现自主秒定位的。</p><p>那么，什么又是“AGPS辅助定位”呢？在传统GPS定位方式中，定位模块需要全频段搜索以找到可用卫星，因而耗时较长。而“AGPS辅助定位”方式，是通过网络直接下载当前地区的可用卫星星历数据，并将之发送给定位模块，定位模块只搜索特定的卫星，从而提高了搜星速度，减少设备耗电。</p><p>举个例子：冷启动像是多项选择题，要把所有选项计算一遍，才能找到正确答案；而“AGPS辅助定位”就像是作弊器，排除掉了很多错误答案，只要计算少数几个即可。从而提高效率和准确率。</p><p>不过，这个世界上没有圣杯，“AGPS辅助定位”不是万金油。它的应用条件还是需要比较苛的：</p><p>·卫星信号接收条件必须良好，至少可观测到4颗卫星（如果有条件，推荐使用有源天线）；</p><p>·定位芯片必须支持AGPS辅助定位；</p><p>·必须可以准确获取当前地区星历数据；</p><p>·如果是冷启动，需要等待通信芯片附着成功，接收到星历数据后，传输给定位模块；</p><p>·如果是温启动&#x2F;热启动，亦需要重新搜星；</p><p>由此可见，只有上述条件满足的时候，才能实现秒定位。如果是冷启动 + GPRS附着传输星历数据，实际上需要等待的时间也不短呢（甚至有可能定位模块已经3D Fix，GPRS才刚刚附着成功，把星历数据发过来）。</p><p>以上海合宙通信科技有限公司的Air8xx系列模块为例，它的AGPS辅助定位基本流程如下：</p><p>1、设备从蜂窝基站获取到当前位置的小区信息；</p><p>2、设备通过蜂窝网络，将当前蜂窝小区信息传送给网络中的AGPS位置服务器；</p><p>3、APGS位置服务器根据当前小区信息查询该区域当前可用的卫星信息（包括卫星的频段、方位、仰角等相关信息），生成对应星历文件，并返回给设备；</p><p>4、通信模块通过串口把收到的星历文件传输给定位模块；</p><p>5、定位模块根据星历文件，得到的可用卫星信息，快速找到当前可用的GPS卫星，针对性的搜星，大大提升定位时间。</p><p>接下来进入普天同庆的“你问我答”环节：</p><p>Q：我的模块没有GPS芯片，能否使用“AGPS辅助定位”实现定位？</p><p>A：当然不行。这个问题就相当于“我有增压器，没有发动机，能跑100迈吗”一样。“AGPS辅助定位”，只是辅助加速定位，而不是一项独立可用的定位服务。</p><p>Q：“AGPS辅助定位”能否提高定位精度？</p><p>A：不能，它只能加快定位速度。无法提升定位精度。</p><p>Q：如何根据NMEA-0183判断AGPS是否成功写入了呢？</p><p>A：看GGA、RMC的UTC时间是否被修正，看GSV数据是否生成；</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222112.png" alt="img" loading="lazy"></p><p>GSV：</p><p>&#x3D;&#x3D;格式：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$–GSV,x,x,x,x,x,x,x,…*hh&#x3D;&#x3D;</p><p>&#x3D;&#x3D;例句：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$GPGSV,3,1,12,14,75,001,31,32,67,111,38,31,57,331,33,26,47,221,20*73&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221316.png" alt="image-20220124221316197" loading="lazy"></p><p>Q：“AGPS辅助定位”的星历文件消耗流量多吗？</p><p>A：很少，几k而已。</p><p>Q：星历文件是否需要定期更新？更新频率是多少？</p><p>A：需要根据自己的情况进行分析。如果是冷启动后，不关闭定位模块，下载一次“AGPS辅助定位”数据（星历文件）即可。运行中，定位模块内会自动生成对应的星历文件，无需重复下载；</p><p>如果是不定时启动、关闭，那么关闭4小时内启动是没必要更新的（“温启动”范畴）；如果大于4小时，模块内保存的星历已失效，则必须更新星历文件（重新下载），否则和“冷启动”无异。</p><p>Q：能否自己搭建AGPS星历数据服务器？</p><p>A：可以。不过较麻烦。建议使用我司提供的接口（请参考例程中agps.lua的代码）。</p><p>简述一下如何搭建。首先在NASA下载brdc当日的导航电文数据（以2018年2月1日为例）：</p><p><a href="ftp://cddis.gsfc.nasa.gov/pub/gps/data/daily/2018/brdc/brdc0320.18n.Z">ftp://cddis.gsfc.nasa.gov/pub/gps/data/daily/2018/brdc/brdc0320.18n.Z</a></p><p>（备用）<a href="ftp://igs.ensg.ign.fr/pub/igs/data/2018/032/brdc0320.18n.Z">ftp://igs.ensg.ign.fr/pub/igs/data/2018/032/brdc0320.18n.Z</a></p><p>GPS卫星的历书（Almanac）包含在导航电文的第四和第五子帧中，可以看作是卫星星历参数的简化子集。服务端收到客户端的请求，从导航电文中提取当日的星历，然后发送给客户端。</p><p>扩展阅读：《GPS卫星星历与历书》</p><p><a href="https://blog.csdn.net/Csdn_Darry/article/details/72052686">https://blog.csdn.net/Csdn_Darry/article/details/72052686</a></p><p>Q：以GK9501定位芯片为例，怎么把“AGPS辅助定位”的数据发送给它？</p><p>A：请参考厂商提供的相关文档，以规定格式将数据通过串口发送给定位芯片（请参考例程中agps.lua的代码）。</p><p>扩展阅读：《AIR系列GPS模块测试用例》</p><p><a href="http://blog.sina.com.cn/s/blog_5b0121350102xy8w.html">http://blog.sina.com.cn/s/blog_5b0121350102xy8w.html</a></p><p>Q：你为什么懂得那么多啊？</p><p>A：大概是因为我比较帅吧。 </p><h2 id="火星坐标（纠偏）篇"><a href="#火星坐标（纠偏）篇" class="headerlink" title="火星坐标（纠偏）篇"></a>火星坐标（纠偏）篇</h2><p>历经磨难，终于成功定位，获取正确输出。但是怎么看起来格式不太对呢，经度纬度都是4位、5位的，那岂不是要绕地球好几圈了？</p><p>其实这是NMEA-0183输出格式和我们日常使用的格式不同造成的误解。我们再来看一下GGA格式：</p><p>&#x3D;&#x3D;格式：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$–GGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx*hh&#x3D;&#x3D;</p><p>&#x3D;&#x3D;示例：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$GPGGA,065545.789,2109.9551,N,12023.4047,E,1,9,0.85,18.1,M,8.0,M,,*5E&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221405.png" alt="image-20220124221405888" loading="lazy"></p><p>有没有发现问题所在呢？</p><p>GGA输出格式：ddmm.mmmm（度-分）</p><p>日常使用格式：dd.dddddd（度）</p><p>那么如何把GGA输出的数据转换为我们日常使用的格式呢？学霸看一眼就会说，这个问题很简单嘛，balabala~~~作为学渣的我，一头雾水。</p><p>咳咳，还是直接套用公式吧。</p><p>&#x3D;&#x3D;公式如下：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;ddmm.mmmm → 小数点前移两位 → dd.mmmm → dd + 0.(mmmm&#x2F;60) &#x3D; dd.dddddd&#x3D;&#x3D; </p><p>&#x3D;&#x3D;举例：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;12023.4047 → 120.234047 → 120 + 0.(234047÷60) &#x3D; 120.390078&#x3D;&#x3D;</p><p>经过如此换算，我们就可以把获取到的数值放到地图软件里啦。</p><p>一切看似都很美好，但是……直到……你用了百度地图……我靠，卧槽……为什么误差那么大？偏差达几百米？</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222107.png" alt="img" loading="lazy"></p><p>明明在楼里，为什么地图显示我在河里？为什么！是不是定位模块有问题？还是我的又写了个bug？还是天线存在故障？黑人问号脸。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222102.png" alt="img" loading="lazy"></p><p>之所以会产生“偏差”，这就涉及到一个有关坐标系转换的问题：GCJ-02 火星坐标系统纠偏。</p><p>前文提到，模块输出数据的格式为NMEA-0183，使用的坐标系是WGS-84。通常，国际上其他国家的地图软件也都是使用WGS-84，相安无事。不过，中国国家测绘局要求所有从事地理测量、地图绘制的公司、单位机构、个人必须使用GCJ-02坐标系（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）。</p><p>也就是说，国内的地图软件大都是使用的GCJ-02坐标系。所以开发者&#x2F;用户如果将WGS-84的经纬度填入国内的地图软件，就会产生极大的偏差。</p><p>（所有的电子地图、导航设备，都需要使用GCJ-02坐标系。第一步，地图公司测绘地图，测绘完成后，送到国家测绘局，将真实坐标WGS-84的电子地图，加密成“GCJ-02火星坐标”，这样的地图才是可以出版和发布的。第二步，所有的面向客户的设备厂商，要在软件中加入该转换算法，将定位模块输出的真实WGS-84坐标，转换成GCJ-02的坐标。这样一来，“以偏治偏”，坐标系才可以完全匹配，也就没有“偏差”了）</p><p>那么，是不是所有的国内地图都使用了GCJ-02坐标系呢？非也……百度、搜狗又自成体系，自立坐标了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221456.png" alt="image-20220124221456786" loading="lazy"></p><p>其中百度较为特殊，需要 WGS-84 → GCJ-02 → BD-09 两次转换。</p><p>由于转换算法较为复杂，本文不赘述。转换算法涉及浮点运算，推荐开发者将运算任务交给服务端或者上位机。</p><p>为了方便测试，开发者在此网址 <a href="http://www.openluat.com/GPS-Offset.html">http://www.openluat.com/GPS-Offset.html</a> 测试纠偏效果。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222102.png" alt="img" loading="lazy"></p><p>开发者根据数据格式填入对应的经纬度（支持ddmm.mmmm、dd.dddd和dd°mm′ss″），点击“坐标转换”按钮，即可看到纠偏后的效果。同时该页面也提供了坐标转换、坐标轴纠偏算法的下载。</p><p>接下来进入奔走相告的“你问我答”环节：</p><p>Q：为什么无中生有搞一个GCJ-02坐标系？用WGS-84不是挺好？</p><p>A：你哦，图样图森破了。加偏收费一次，定位设备纠偏收费一次。每年车机、定位终端出货量就是几亿台，能拉动多少GDP哟。</p><p>Q：如果我在外国的地图软件上使用WGS-84可以吗？</p><p>A：没问题的，只是外国的地图软件中，大陆数据更新滞后且不完整。</p><p>Q：如果我不涉及地图加偏&#x2F;纠偏，仅需要速度、方向角等数据是否受到这个的影响呢？</p><p>A：纠偏仅是坐标值的转换，和其他数据无关。</p><p>Q：为什么推荐开发者把纠偏算法放在上位机呢？</p><p>A：因为单片机真的——算不过来。</p><p>Q：为什么感觉GPS芯片上报的经纬度，在一个小范围内飘来飘去？</p><p>A：这个是需要软件静态抑漂的。可以采用技术手段进行过滤，比如设置速度门限——在低于一定速度时，认为是静止不动的。或者事先知道用户处于什么运动模式，是静止、步行、还是开车。 </p><p>Q：我发现纠偏后还是不够精准，定位误差较大，能不能做到真·厘米级定位？</p><p>A：可以哦。请看下文“细致入微的厘米级定位”。</p><h2 id="细致入微的厘米级定位"><a href="#细致入微的厘米级定位" class="headerlink" title="细致入微的厘米级定位"></a>细致入微的厘米级定位</h2><p>通常情况下，GPS提供5m左右的定位精度，可以满足大多数大多数情况下的定位需求。不过，有一些场景，有更高精度的定位需求。譬如测绘、滑坡监控、无人机、无人驾驶汽车等。</p><p>基于GPS的特性，很难提供亚米级的定位，那么如何是好呢？经过N次技术创新和持久的基准站建设，现在可以做到覆盖全国的厘米级定位技术。</p><p>其实简单来说，高精度定位的核心就是消除误差。卫星定位精度不高，是因为误差积累导致，只要把可控的误差消除到最低，就能获得更高精度的定位结果。</p><p>卫星定位的误差来源通常有：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221606.png" alt="image-20220124221606638" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221615.png" alt="image-20220124221615036" loading="lazy"></p><p>那么，如何修正这些误差误差，使得定位结果更精准呢？需要基准站通过数据链，将其载波观测值及基准站坐标信息一同传送给用户站，用户站接收GPS卫星的载波相位与来自基准站的载波相位，并组成相位差分观测值进行及时处理，能及时给出厘米级的定位结果。</p><p>通常，我们提到的DGPS指RTD，即Real Time Differential，伪距差分。基准站上，观测所有卫星，根据基准站已知坐标和各卫星的坐标，求出每颗卫星每一时刻到基准站的真实距离。再与测得的伪距比较，得出差分改正数，将其传输至用户接收机，提高定位精度。从而实现亚米级定位。</p><p>厘米级定位，则需要用到RTK，即Real Time Kinematic，载波相位差分，实时处理两个测站载波相位观测量的差分方法。即是将基准站采集的载波相位发给用户接收机，进行求差解算坐标，从而实现厘米级定位。</p><p>文字太空洞，举例说明：BOSS告诉人力，给你发工资￥8848.00。人力听错了，发给你￥8844.00。收到工资之后，觉得不太对——数字的谐音，这不是变相骂人嘛。</p><p>你赶紧登陆ERP查询，提交实发工资金额￥8844，查询一下。嚯，不得了，系统一阵卡机（查询后台中），然后duang的一声告诉你——少发了￥4.00。你去找人力，要回来了差额￥4.00，喜提锤子R1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222051.png" alt="img" loading="lazy"></p><p>在这个故事中：</p><p>“BOSS”就是卫星——负责传达指令，不处理具体事物；</p><p>“人力”就是传播路径——上情下达，产生误差；</p><p>“ERP查询返值”就是基准站——根据“用户站”上传的数据，下发的“工资改正数”；</p><p>而你，就是用户站——将“接收值”（￥8844.00）上传给“基准站”，获得“工资改正数”（-￥4.00），你就知道是少发了￥4.00。经过计算（￥8844.00+￥4.00）即可求得正确解（￥8848.00）。</p><p>颇有点区块链的感觉了，不是吗？</p><p>扩展阅读：《DGPS与RTK的区别》</p><p><a href="https://blog.csdn.net/foreverhuylee/article/details/25693893">https://blog.csdn.net/foreverhuylee/article/details/25693893</a> </p><p>目前，服务覆盖全国范围的，只有千寻位置®。</p><p>（千寻位置®是由中国兵器工业集团和阿里巴巴集团共同发起成立。千寻位置基于北斗卫星系统（兼容GPS、GLONASS、Galileo）基础定位数据，利用遍及全国的超过2000个地基增强站及自主研发的定位算法，通过互联网技术进行大数据运算，为遍布全国的用户提供精准定位及延展服务）</p><p>用户在千寻位置®购买相关套餐后，可以使用千寻位置®提供的SDK或NTRIP协议接收RTCM差分数据。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221657.png" alt="image-20220124221657703" loading="lazy"></p><p>参考资料：<a href="https://www.qxwz.com/help-document-location-service.html">https://www.qxwz.com/help-document-location-service.html</a></p><p><a href="https://www.qxwz.com/help-document-common-find-config-service.html">https://www.qxwz.com/help-document-common-find-config-service.html</a></p><p>由于NTRIP认证方式较繁琐，所以本文不再赘述，有兴趣的读者可以点击下方链接了解更多内容：</p><p>扩展阅读：《Ntrip通讯协议》</p><p><a href="https://www.cnblogs.com/hanford/p/6028156.html">https://www.cnblogs.com/hanford/p/6028156.html</a></p><p>定位效果如此拔群，当然条件也相当苛刻啦：</p><p>·定位芯片必须支持差分数据解算；</p><p>·场地净空条件良好，尽量不要有任何遮挡（高楼、树木等）；</p><p>·SNR应大于40；</p><p>·设备具有接收数据的能力（网络接入）；</p><p>·流量消耗很高；</p><p>·测量点在基准站覆盖范围内；</p><p>* 固定解耗时较久。</p><p>我们可以通过模块输出的GGA语句判断当前定位状态：</p><p>GGA：</p><p>&#x3D;&#x3D;格式：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$–GGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx*hh&#x3D;&#x3D;</p><p>&#x3D;&#x3D;示例：&#x3D;&#x3D;</p><p>&#x3D;&#x3D;$GPGGA,065545.789,2109.9551,N,12023.4047,E,5,9,0.85,18.1,M,8.0,M,1,0999,*5E&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221755.png" alt="image-20220124221755196" loading="lazy"></p><p>如果是GPS芯片已经进行解算，并输出差分定位结果，那么GGA语句中“定位指示”应为2、4、或5；查分时间应大于0（不为空）；差分站ID应不为空。</p><p>只有同时满足上述条件，才能得到精确的测量结果。接下来，我们看一下实际测试结果。测试环境，某小区内：</p><p>测试中，使用 上海合宙通信科技有限公司提供的Air202 GPRS通信模块，对GPS芯片进行控制，连接千寻位置®平台。将模块输出的GGA原始语句上报到千寻位置®平台，将平台下发的数据传输给GPS芯片，然后打印GPS芯片解算后输出的GGA。 </p><p>通过对比图可以看出，手机定位偏差较大（并没有在顶天台测试嘛），RTK测试结果非常准确，符合测绘等需求。</p><p>接下来进入后会有期的“你问我答”环节：</p><p>Q：RTD、RTK服务贵吗？</p><p>A：可以到千寻位置®官网查询。参考价：RTD ￥6&#x2F;月&#x2F;设备；RTK ￥400&#x2F;月&#x2F;设备。</p><p>Q：如何判断我的定位结果是否为差分运算后的结果呢？</p><p>A：观察GGA语句中的定位指示输出值.</p><p>Q：流量消耗多少？</p><p>A：RTCM数据每秒下发一次，每次大约0.5k，大约需要60m&#x2F;天（按24小时计）。</p><p>Q：大约需要多久才能得到RTK固定解？</p><p>A：固定点测量大约需要10分钟。</p><p>Q：有没有把办法减少流量消耗？</p><p>A：可以根据gps状态修改代码，当定位模式为“rtk固定解”时，主动断开连接。GPS定位状态改变再重连服务器。</p><p>Q：为什么设备一直处于浮点解定位状态，无法固定。</p><p>A：请确保终端设备天线对空观测环境良好，没有受到遮挡，或处于易产生多路径信号反射的物体附近，也请留意导航卫星信号接收正常，CN0处于正常范围内，未受到无线电干扰。</p><h2 id="低功耗篇"><a href="#低功耗篇" class="headerlink" title="低功耗篇"></a>低功耗篇</h2><h2 id="21世纪，物联网最重要的是什么？"><a href="#21世纪，物联网最重要的是什么？" class="headerlink" title="21世纪，物联网最重要的是什么？"></a>21世纪，物联网最重要的是什么？</h2><p>——电池。</p><p>从常见的的共享单车、车载定位器，到不常见的远程抄表、充电桩管理。在各种和物联网相关的应用中，供电始终是一个绕不开的话题。</p><p>如果是有常电（如汽车、自动贩卖机）还好，如果是使用电池，那么每一毫安的电都要精打细算才行（哪怕是用太阳能板充电的共享单车，也经常面临“低电”困扰呢）。</p><p>MCU、GPS、通信模块等，都是众所周知的耗电大户。其中，GPS芯片因为要承担搜星、计算，输出的任务，所以它的耗电量也是不容小觑的。那么，有没有什么办法让GPS芯片“节能降耗”呢？</p><p>答案当然是肯定的。前文提到过，GPS芯片搜星时耗电量最大了，如果能让模块尽量减少搜星和追踪的耗电量，就可以达到目的啦。如何做到这两点呢？接下来我们以物联网行业最常用的国科GK9501 GPS芯片为例，进行说明。</p><p>搜星</p><p>星历下载 和 星历预测</p><p>前文提到过，通过2G网络将星历文件传给GPS芯片，从而实现秒定位+省电，众人拍手欢呼。那么，忽然又出现了个“星历预测”，这是什么鬼呢？</p><p>Q：什么是“星历预测”？</p><p>A：GK9501的软件自带“星历预测”功能。它是指在信号正常（CN值大于27）的情况下，硬件连续运行5<del>10分钟，即可在内部自动生成星历，并预测出未来2</del>3天的星历，此过程不需要耗费任何流量。实现“通电5分钟，奔跑72小时”。</p><p>当然实现“星历预测”这个功能，是有条件的：</p><p>1、星历被下载过一次（外部输入给GPS芯片星历文件，或者GPS芯片自主3D Fix）</p><p>2、GPS信号CN值不低于27</p><p>3、正常定位过一次；</p><p>4、RTC不掉电（当主电源断开后，只有RTC电源不断，星历预测功能才可以使用，RTC断开后星历预测功能将不再起作用）；</p><p>Q：“星历预测”和“星历下载”的区别是什么？对实际定位有什么帮助？</p><p>A：这个要从AGPS的发展史说起。</p><p>早期，服务器下发的星历文件是包含全部所有的可见卫星数据，将之发给GPS芯片，GPS芯片再根据星历文件去搜星。缺点是星历文件大，定位效果还差那么一丢丢；现在，首先是使用通信芯片进行基站定位，后台获取一个粗略的地理位置，查询导航电文后，再根据该地理位置精确下发当前可见卫星星历，GPS芯片再根据精确的星历文件去针对性地搜星。星历文件体积更小，定位效果更好。</p><p>由此可见：“星历预测”是芯片自动生成的，仅包含可见卫星的星历；而“星历下载”是包含全部可见（但是不可用）卫星的星历。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124221837.png" alt="image-20220124221837840" loading="lazy"></p><p>无论在什么状态下，都是GPS信号CN值越好，定位越快；6小时内的 星历下载 保存可以将RTC电源断开。</p><p>Q：如果“星历预测”可以用，那为什么还通过2G网络“星历下载”呢 ？</p><p>A：因为“星历预测”的前提是在“信号正常（CN值大于27）的情况下，连续运行5-10分钟”，电流28mA，相对比较耗电。所以大多数应用会倾向于每次都进行“星历下载”，而非使用“星历预测”——何况通过基站定位获取大概位置的动作，本身就需要2G联网服务器呢。</p><p>Q：为什么星历数据保存有效时间最长是6小时？</p><p>A：星历保存有效的时间和卫星的运行轨迹相关。</p><p>星历保存时间越长，原来星历里的可见卫星就越少。因为GPS卫星绕地一圈是12个小时，所以，星历数据有效期6小时已是极限值。超过这一时间后，原来的星历数据就没有意义了。</p><p>鉴于星历保存的时间越短，其对应星历里的可见星就越多，所以2小时内的星历比保存6小时内的星历对定位的帮助更大。</p><h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><p>动态追踪也是很耗电的，那么有没有办法让芯片“半睡半醒”的工作呢？嘿嘿，还真有办法，GK9501可是会“达芬奇睡眠法”的哦。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220124222031.png" alt="image-20220124221852729" loading="lazy"></p><p>*省功耗追踪模式实际上就是周期性自动唤醒：是GK9501根据当前的运动状态自动设置睡眠时间和运行时间。例如在运动比较快的情况下，会自动睡眠30秒，运行3秒；在运动比较慢的情况下，会自动睡眠60秒，运行3秒；达到在有大致轨迹的情况下，降低功耗的目的。如果主控也需要同步睡眠，可以通过GPIO来通知主控。当然也可以通过主控周期性切断GK9501电源的方式实现这一目的。</p><h2 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h2><p><a href="https://blog.csdn.net/zhangbijun1230/article/details/80958036">https://blog.csdn.net/zhangbijun1230/article/details/80958036</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锂电池基础知识</title>
      <link href="/posts/b36ffb21/"/>
      <url>/posts/b36ffb21/</url>
      
        <content type="html"><![CDATA[<h1 id="电池内阻"><a href="#电池内阻" class="headerlink" title="电池内阻"></a>电池内阻</h1><p>电池的内阻电流通过电池内部时受到阻力，使电池的输出电压降低，此阻力称为电池的内阻。</p><p>电池的内阻不是常数，在放电过程中随时间不断变化，因为活性物质组成、电解液浓度和温度都不断的改变，一般为几十毫欧。</p><h1 id="电池内阻计算方法"><a href="#电池内阻计算方法" class="headerlink" title="电池内阻计算方法"></a>电池内阻计算方法</h1><p>1、测定电池开路电压</p><p>2、加负载，测定电池的负载电压和电池的负载电流。</p><p>3、内阻&#x3D;（电池的开路电压-电池负载电压）&#x2F;电池的负载电流</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220227224651.png" alt="image-20220227224651705" loading="lazy"></p><h1 id="充电上限电压"><a href="#充电上限电压" class="headerlink" title="充电上限电压"></a>充电上限电压</h1><p>电池充电时不宜继续再充的电压，此时认为充满电了。<br>过充电：<br>电池在充电时，在达到充满电状态后，若还继续充电可能导致电池内压升高、电池鼓包变形、漏液等情况发生，电池的性能也会显著降低和损坏。<br>过充的最直接表现是电池发热明显，因为电池已经饱和继续往电池充电，电池难以再提高电压，就会以热的形式发散出来，同时过量的锂离子插入负极晶体内，会使电池永久性损伤。这是滥用的一种。</p><h1 id="放电终止电压"><a href="#放电终止电压" class="headerlink" title="放电终止电压"></a>放电终止电压</h1><p>电池放电时，电压下降到不宜再继续放电的最低工作电压值。<br>如果电压低于放电终止电压后继续放电电池两端的电压会迅速下降，造成过放电负极碳晶格会塌落，导致极板上的活性物在正常充电时就不易再恢复。这是滥用的一种形式。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220227225150.png" alt="image-20220227225150027" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锂电池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda使用笔记</title>
      <link href="/posts/27a7d6a4/"/>
      <url>/posts/27a7d6a4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Conda是什么？"><a href="#1-Conda是什么？" class="headerlink" title="1.Conda是什么？"></a>1.Conda是什么？</h1><p>Conda是Anaconda中的一个开源的包和环境管理工具，可以在终端窗口通过命令行使用，也可以在Anaconda Navigator中通过图形化界面使用,对编程创建独立的环境和包管理，最初是为Python语言开发，现在已不限制语言，支持Python, R, Ruby, Lua, Scala, Java, JavaScript, C&#x2F; C++, FORTRAN等。</p><h1 id="2-管理Conda"><a href="#2-管理Conda" class="headerlink" title="2.管理Conda"></a>2.管理Conda</h1><ul><li>查看版本</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>更新至最新版本</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda update conda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>更新<code>anaconda</code></li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda update anaconda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-使用conda实现环境管理"><a href="#3-使用conda实现环境管理" class="headerlink" title="3.使用conda实现环境管理"></a>3.使用conda实现环境管理</h1><p>默认创建<code>base</code>环境</p><ul><li>创建环境</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda create --name your-env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建环境并同时安装指定包</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda create --name your-env your-pkgconda create --name snakes python&#x3D;3.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>激活环境</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda activate your-env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>取消激活环境</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看已经所有创建的环境</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda info --envs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>完整的删除一个环境</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda remove --name ENVNAME --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>复制1个环境</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda create --clone ENVNAME --name NEWENV<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看某个环境的修订版</li></ul><pre class="line-numbers language-none"><code class="language-none">conda list --revisions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将一个环境恢复到指定版本</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda list --name ENVNAME --revisionsconda install --name ENVNAME --revisionREV_NUMBER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="4-包管理"><a href="#4-包管理" class="headerlink" title="4.包管理"></a>4.包管理</h1><ul><li>查看一个未安装的包在<code>Anaconda</code>库中是否存在</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda search pkg-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装一个包</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda install pkg-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看刚安装的包是否存在</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看某个环境下的包</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda list --name ENVNAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将当前环境下包的列表导出指定文件，用于创建新的环境</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda create --name NEWENV --file pkgs.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>更新某个环境下的所有包</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda update --all --name ENVNAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除某个环境下的包</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda uninstall PKGNAME --name ENVNAME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>一次安装多个包</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda install --yes PKG1 PKG2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装指定版本的包</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 在当前通道查找大于3.1.0小于3.2的包conda search PKGNAME&#x3D;3.1 &quot;PKGNAME[version&#x3D;&#39;&gt;&#x3D;3.1.0,&lt;3.2&#39;]&quot;# 使用ananconda 客户端，在所有通道下模糊查找某个包anaconda search FUZZYNAME# 从指定通道中安装某个包conda install conda-forge::PKGNAME# 安装指定版本的包conda install PKGNAME&#x3D;&#x3D;3.1.4# 限定包的版本范围conda install &quot;PKGNAME[version&#x3D;&#39;3.1.2|3.1.4&#39;]&quot;conda install &quot;PKGNAME&gt;2.5,&lt;3.2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考</strong>：</p><p>1.<a href="https://docs.conda.io/projects/conda/en/latest/commands.html">https://docs.conda.io/projects/conda/en/latest/commands.html</a></p><p>2.<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p><p>3.<a href="https://conda.io/projects/conda/en/latest/user-guide/getting-started.html">https://conda.io/projects/conda/en/latest/user-guide/getting-started.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anaconda </tag>
            
            <tag> Conda </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5训练入门</title>
      <link href="/posts/bb3c6a84/"/>
      <url>/posts/bb3c6a84/</url>
      
        <content type="html"><![CDATA[<h1 id="python按照比例分配数据集：train、test、val"><a href="#python按照比例分配数据集：train、test、val" class="headerlink" title="python按照比例分配数据集：train、test、val"></a><em>python</em>按照比例分配数据集：<em>train</em>、test、<em>val</em></h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> randomtrainval_percent <span class="token operator">=</span> <span class="token number">0.3</span>  <span class="token comment"># 可自行进行调节(设置训练和测试的比例是7：3)</span>train_percent <span class="token operator">=</span> <span class="token number">1</span>xmlfilepath <span class="token operator">=</span> <span class="token string">'Annotations'</span>txtsavepath <span class="token operator">=</span> <span class="token string">'ImageSets\Main'</span>total_xml <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>xmlfilepath<span class="token punctuation">)</span>     <span class="token comment"># 遍历Annotations文件夹中的文件名</span>num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>total_xml<span class="token punctuation">)</span>                <span class="token comment"># 总样本库数目</span><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>tv <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>num <span class="token operator">*</span> trainval_percent<span class="token punctuation">)</span>    <span class="token comment"># 总数乘以测试和训练的比例</span>tr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>tv <span class="token operator">*</span> train_percent<span class="token punctuation">)</span>        <span class="token comment"># 总数乘以交叉验证的比例</span>trainval <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> tv<span class="token punctuation">)</span>  <span class="token comment"># 从总样本库list中选择tv个随机且独立的元素</span>train <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>trainval<span class="token punctuation">,</span> tr<span class="token punctuation">)</span> <span class="token comment"># 从总样本库list中选择tr个随机且独立的元素</span><span class="token comment"># ftrainval = open('ImageSets/Main/trainval.txt', 'w')</span>ftest <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'ImageSets/Main/test.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>    <span class="token comment"># 存放测试集文件名的路径</span>ftrain <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'ImageSets/Main/train.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span>  <span class="token comment"># 存放训练集文件名的路径</span><span class="token comment"># fval = open('ImageSets/Main/val.txt', 'w')</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> total_xml<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'\n'</span>     <span class="token comment"># 去除文件名中的.xml</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">if</span> i <span class="token keyword">in</span> trainval<span class="token punctuation">:</span>        <span class="token comment"># ftrainval.write(name)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'----------'</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>name<span class="token punctuation">)</span>        <span class="token keyword">if</span> i <span class="token keyword">in</span> train<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'********'</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>name<span class="token punctuation">)</span>            ftest<span class="token punctuation">.</span>write<span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token comment"># else:</span>        <span class="token comment"># fval.write(name)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        ftrain<span class="token punctuation">.</span>write<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token comment"># ftrainval.close()</span>ftrain<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># fval.close()</span>ftest<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改coco128.yaml文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># COCO 2017 dataset http://cocodataset.org - first 128 training images</span><span class="token comment"># Train command: python train.py --data coco128.yaml</span><span class="token comment"># Default dataset location is next to /yolov5:</span><span class="token comment">#   /parent_folder</span><span class="token comment">#     /coco128</span><span class="token comment">#     /yolov5</span><span class="token comment"># download command/URL (optional)</span><span class="token comment">#download: https://github.com/ultralytics/yolov5/releases/download/v1.0/coco128.zip</span><span class="token comment"># train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]</span>train<span class="token punctuation">:</span> D<span class="token punctuation">:</span><span class="token operator">/</span>Desktop<span class="token operator">/</span>kdy<span class="token operator">/</span>car<span class="token operator">/</span>data<span class="token operator">/</span>train<span class="token punctuation">.</span>txt<span class="token comment"># 训练集路径</span>val<span class="token punctuation">:</span> D<span class="token punctuation">:</span><span class="token operator">/</span>Desktop<span class="token operator">/</span>kdy<span class="token operator">/</span>car<span class="token operator">/</span>data<span class="token operator">/</span>test<span class="token punctuation">.</span>txt<span class="token comment"># 测试集路径</span><span class="token comment"># number of classes</span>nc<span class="token punctuation">:</span> <span class="token number">6</span>names<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'bus'</span><span class="token punctuation">,</span><span class="token string">'car'</span><span class="token punctuation">,</span><span class="token string">'microbus'</span><span class="token punctuation">,</span><span class="token string">'minivan'</span><span class="token punctuation">,</span><span class="token string">'suv'</span><span class="token punctuation">,</span><span class="token string">'truck'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改模型配置文件yolov5s.yaml文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># parameters</span>nc<span class="token punctuation">:</span> <span class="token number">9</span> <span class="token comment"># number of classes   只需要修改这个类别数</span>depth_multiple<span class="token punctuation">:</span> <span class="token number">0.33</span>  <span class="token comment"># model depth multiple</span>width_multiple<span class="token punctuation">:</span> <span class="token number">0.50</span>  <span class="token comment"># layer channel multiple</span><span class="token comment"># anchors</span>anchors<span class="token punctuation">:</span>  <span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">]</span>  <span class="token comment"># P3/8</span>  <span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">61</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span><span class="token number">119</span><span class="token punctuation">]</span>  <span class="token comment"># P4/16</span>  <span class="token operator">-</span> <span class="token punctuation">[</span><span class="token number">116</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">156</span><span class="token punctuation">,</span><span class="token number">198</span><span class="token punctuation">,</span> <span class="token number">373</span><span class="token punctuation">,</span><span class="token number">326</span><span class="token punctuation">]</span>  <span class="token comment"># P5/32</span><span class="token comment"># YOLOv5 backbone</span>backbone<span class="token punctuation">:</span>  <span class="token comment"># [from, number, module, args]</span>  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Focus<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 0-P1/2</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 1-P2/4</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 3-P3/8</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 5-P4/16</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 7-P5/32</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> SPP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 9</span>  <span class="token punctuation">]</span><span class="token comment"># YOLOv5 head</span>head<span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Upsample<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'nearest'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># cat backbone P4</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 13</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Upsample<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'nearest'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># cat backbone P3</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 17</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># cat head P4</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 20</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># cat head P5</span>   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> BottleneckCSP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># 23</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Detect<span class="token punctuation">,</span> <span class="token punctuation">[</span>nc<span class="token punctuation">,</span> anchors<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment"># Detect(P3, P4, P5)</span>  <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>训练指令</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># --data 训练集的配置文件是 mask_data.yaml，会根据mask_data.yaml去寻找数据集所在位置</span><span class="token comment"># --cfg 会调用一个模型的配置文件，这个文件会告诉它训练一个yolov5s这样一个模型出来</span><span class="token comment"># --weights 所要使用到的预训练的模型，这里表示使用pretrained文件夹下的yolov5s.pt模型</span><span class="token comment"># --epoch 100 在数据集上面训练100轮</span><span class="token comment"># --batch-size 每次喂入模型的数，这里表示每次喂入模型是四个一批</span><span class="token comment"># --device cpu 表示使用CPU训练</span>python train<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span>data mask_data<span class="token punctuation">.</span>yaml <span class="token operator">-</span><span class="token operator">-</span>cfg mask_yolov5s<span class="token punctuation">.</span>yaml <span class="token operator">-</span><span class="token operator">-</span>weights pretrained<span class="token operator">/</span>yolov5s<span class="token punctuation">.</span>pt <span class="token operator">-</span><span class="token operator">-</span>epoch <span class="token number">100</span> <span class="token operator">-</span><span class="token operator">-</span>batch<span class="token operator">-</span>size <span class="token number">4</span> <span class="token operator">-</span><span class="token operator">-</span>device cpu<span class="token comment"># python train.py --data mask_data.yaml --cfg mask_yolov5l.yaml --weights pretrained/yolov5l.pt --epoch 100 --batch-size 4</span><span class="token comment"># python train.py --data mask_data.yaml --cfg mask_yolov5m.yaml --weights pretrained/yolov5m.pt --epoch 100 --batch-size 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>训练完毕的模型</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120141355.png" alt="可达鸭修改" loading="lazy"></p><p>confusion_matrix.png是混淆矩阵，可以看出每个类别的识别准确度</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120141917.png" alt="confusion_matrix" loading="lazy"></p><p>F1是衡量精度的一个指标</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120142048.png" alt="F1_curve" loading="lazy"></p><p>P是精度的曲线</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120143511.png" alt="P_curve" loading="lazy"></p><p>PR是map综合指标的曲线</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120143539.png" alt="PR_curve" loading="lazy"></p><p>R是召回率的曲线</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120143656.png" alt="R_curve" loading="lazy"></p><p>result.png表示训练过程中的损失和精度的变化趋势</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120143756.png" alt="results" loading="lazy"></p><p>train表示实际的标签是怎么样的</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120144107.jpg" alt="train_batch0" loading="lazy"></p><p>val表示模型预测出来的效果大概是怎么样的</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120144148.jpg" alt="val_batch0_pred" loading="lazy"></p><p>hyp.yaml表示超参数的</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">lr0</span><span class="token punctuation">:</span> <span class="token number">0.01</span><span class="token key atrule">lrf</span><span class="token punctuation">:</span> <span class="token number">0.1</span><span class="token key atrule">momentum</span><span class="token punctuation">:</span> <span class="token number">0.937</span><span class="token key atrule">weight_decay</span><span class="token punctuation">:</span> <span class="token number">0.0005</span><span class="token key atrule">warmup_epochs</span><span class="token punctuation">:</span> <span class="token number">3.0</span><span class="token key atrule">warmup_momentum</span><span class="token punctuation">:</span> <span class="token number">0.8</span><span class="token key atrule">warmup_bias_lr</span><span class="token punctuation">:</span> <span class="token number">0.1</span><span class="token key atrule">box</span><span class="token punctuation">:</span> <span class="token number">0.05</span><span class="token key atrule">cls</span><span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token key atrule">cls_pw</span><span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token key atrule">obj</span><span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token key atrule">obj_pw</span><span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token key atrule">iou_t</span><span class="token punctuation">:</span> <span class="token number">0.2</span><span class="token key atrule">anchor_t</span><span class="token punctuation">:</span> <span class="token number">4.0</span><span class="token key atrule">fl_gamma</span><span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token key atrule">hsv_h</span><span class="token punctuation">:</span> <span class="token number">0.015</span><span class="token key atrule">hsv_s</span><span class="token punctuation">:</span> <span class="token number">0.7</span><span class="token key atrule">hsv_v</span><span class="token punctuation">:</span> <span class="token number">0.4</span><span class="token key atrule">degrees</span><span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token key atrule">translate</span><span class="token punctuation">:</span> <span class="token number">0.1</span><span class="token key atrule">scale</span><span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token key atrule">shear</span><span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token key atrule">perspective</span><span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token key atrule">flipud</span><span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token key atrule">fliplr</span><span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token key atrule">mosaic</span><span class="token punctuation">:</span> <span class="token number">1.0</span><span class="token key atrule">mixup</span><span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token key atrule">copy_paste</span><span class="token punctuation">:</span> <span class="token number">0.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>labs是表明在这个数据集中每类数据集的数量</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120142543.png" alt="labels" loading="lazy"></p><p>best.pt是表现最好的模型</p><p>last.pt是最后一次训练的模型</p><p>val.py文件用来单独对于权重文件做验证，使用方法和detect.py类似</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220120145437.png" alt="image-20220120145437441" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5使用自有数据集训练</title>
      <link href="/posts/5f423083/"/>
      <url>/posts/5f423083/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  准备有三个文件夹，方便理解使用脚本</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404225130.png" alt="image-20220404225130645" loading="lazy"></p><h2 id="data：数据集"><a href="#data：数据集" class="headerlink" title="data：数据集"></a><strong>data：数据集</strong></h2><p>准备一个车辆数据集，放在<code>data/car/</code>文件夹中。</p><p>数据集内<code>JPEGImages</code>有2100张图片，<code>Annotations</code>有2100张xml文件。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404221235.png" alt="image-20220404221235645" loading="lazy"></p><h2 id="train-code：数据处理脚本"><a href="#train-code：数据处理脚本" class="headerlink" title="train_code：数据处理脚本"></a><strong>train_code：数据处理脚本</strong></h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404221324.png" alt="image-20220404221324108" loading="lazy"></p><p>在<code>train_code</code>文件夹中，有三个python文件，主要使用的是<code>get_labels.py</code>和<code>main.py</code>两个脚本。</p><p><code>get_labels.py</code>脚本，可以直接获取<code>Annotations</code>文件夹中，所有标注文件的标注类别。</p><p><code>main.py</code>脚本，可以将之前标注文件和图像，进行处理，转换成Yolov5可以训练的格式。</p><h2 id="查看自有数据集中的类别数"><a href="#查看自有数据集中的类别数" class="headerlink" title="查看自有数据集中的类别数"></a>查看自有数据集中的类别数</h2><p>打开<code>train_code/get_labels.py</code>，修改下方的人头数据集路径。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404221628.png" alt="image-20220404221628468" loading="lazy"></p><p>运行后，在下方就可以看到类别数量，以及标注的类别框的数量。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404221709.png" alt="image-20220404221709935" loading="lazy"></p><h2 id="转换训练数据格式"><a href="#转换训练数据格式" class="headerlink" title="转换训练数据格式"></a>转换训练数据格式</h2><h3 id="新建数据集转换文件夹"><a href="#新建数据集转换文件夹" class="headerlink" title="新建数据集转换文件夹"></a><strong>新建数据集转换文件夹</strong></h3><p>首先在data文件夹里面，新建一个<code>head_train_data</code>文件夹。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404221826.png" alt="image-20220404221826885" loading="lazy"></p><p>并在<code>head_train_data</code>文件夹中，新建一个<code>images_label_split</code>文件夹。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404222006.png" alt="image-20220404222006716" loading="lazy"></p><p>并将前面的<code>car</code>数据集，直接拷贝到<code>images_label_split</code>里面。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404222131.png" alt="image-20220404222131381" loading="lazy"></p><h3 id="main-py脚本处理：配置修改"><a href="#main-py脚本处理：配置修改" class="headerlink" title="main.py脚本处理：配置修改"></a><strong>main.py脚本处理：配置修改</strong></h3><p>打开<code>train_code/main.py</code>文件，修改训练数据的路径。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404222448.png" alt="image-20220404222448546" loading="lazy"></p><p>在前面通过<code>get_labels.py</code>脚本，我们也知道了当前数据集的类别数，比如是<code>[&#39;bus&#39;,&#39;car&#39;,&#39;microbus&#39;,&#39;minivan&#39;,&#39;suv&#39;,&#39;truck&#39;]</code>，将该类别填入<code>label_list</code>中。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404222551.png" alt="image-20220404222551717" loading="lazy"></p><p>而<code>main.py</code>文件主要分为三个部分的功能：数据集的清洗、训练集&amp;验证集划分、xml转换txt格式。</p><h3 id="main-py脚本处理：数据集清洗"><a href="#main-py脚本处理：数据集清洗" class="headerlink" title="main.py脚本处理：数据集清洗"></a><strong>main.py脚本处理：数据集清洗</strong></h3><p>数据集的清洗使用的主要是这些行的代码。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404222649.png" alt="image-20220404222649053" loading="lazy"></p><p>有的数据集有图片，没有标注文件。有的数据集有标注文件，图片有可能丢失。</p><p>同时将长宽比太小的框删除掉，并且在删除后，检查下是否存在空的标注文件，如果有，也删除。</p><p>并在最后，将标注的框显示到图片上，进一步确定脚本是否正确。</p><p>运行上面的代码，最后会跳出来一些画了框的车辆图片，按<code>q</code>键退出查看标注情况，按其他任意键可查看下一张。</p><p>在这里需要强调一点，图像出现后<strong>必须把光标移动到窗口上再按键才会退出</strong>，这是很多初学者常常忽视的地方，如果在终端内按<code>q</code>是无效的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404222958.png" alt="image-20220404222958460" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404222919.png" alt="image-20220404222918728" loading="lazy"></p><h3 id="main-py脚本处理：训练集-amp-验证集划分"><a href="#main-py脚本处理：训练集-amp-验证集划分" class="headerlink" title="main.py脚本处理：训练集&amp;验证集划分"></a><strong>main.py脚本处理：训练集&amp;验证集划分</strong></h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404223816.png" alt="image-20220404223816260" loading="lazy"></p><p>0.2表示，80%的数据进行训练，20%的数据进行验证。</p><p>运行结束后，会发现<code>head_train_data</code>这个文件夹下面多了两个文件夹，train和test，就是按照80%、20%进行划分。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404224034.png" alt="image-20220404224034339" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404224043.png" alt="image-20220404224043064" loading="lazy"></p><h3 id="main-py脚本处理：：xml转换txt格式"><a href="#main-py脚本处理：：xml转换txt格式" class="headerlink" title="main.py脚本处理：：xml转换txt格式"></a><strong>main.py脚本处理：：xml转换txt格式</strong></h3><p>xml转换成txt格式的代码主要是下面三行。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404224124.png" alt="image-20220404224124877" loading="lazy"></p><p>运行结束后，可以看到多了两个文件夹。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404224500.png" alt="image-20220404224500058" loading="lazy"></p><p><code>image_txt</code>文件夹中是所有的image和转换完的txt文件。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404224535.png" alt="image-20220404224535349" loading="lazy"></p><p>而<code>train_test_txt</code>文件夹中，则是对于训练和测试数据路径汇总的两个txt，后面训练中会用到。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404224556.png" alt="image-20220404224556530" loading="lazy"></p><h2 id="Yolov5代码训练"><a href="#Yolov5代码训练" class="headerlink" title="Yolov5代码训练"></a>Yolov5代码训练</h2><h3 id="修改训练配置"><a href="#修改训练配置" class="headerlink" title="修改训练配置"></a>修改训练配置</h3><h4 id="新建一个yaml文件"><a href="#新建一个yaml文件" class="headerlink" title="新建一个yaml文件"></a><strong>新建一个yaml文件</strong></h4><p>因为是训练人头数据集，所以在data文件夹下先新建一个<code>car.yaml</code>文件，并修改其中的参数。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404225430.png" alt="image-20220404225430813" loading="lazy"></p><p>可以复制一个<code>coco128.yaml</code>文件进行修改，其中主要涉及到训练集的txt文件、验证集的txt文件、类别数量nc、类别标签名。</p><h4 id="修改train-py参数"><a href="#修改train-py参数" class="headerlink" title="修改train.py参数"></a><strong>修改train.py参数</strong></h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404225825.png" alt="image-20220404225825625" loading="lazy"></p><p>① 修改models里面的weights路径，下载了一些pt文件放在models中，可以选择使用。</p><p>② 修改cfg路径，即网络结构的参数配置文件，需要注意的是，需要修改其中的类别数。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404225730.png" alt="image-20220404225730170" loading="lazy"></p><p>③ 修改data的路径，即前面修改的<code>car.yaml</code>文件。</p><h3 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h3><p>运行<code>train.py</code>文件，既可以开始训练。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404230522.png" alt="image-20220404230522672" loading="lazy"></p><h3 id="训练结果测试"><a href="#训练结果测试" class="headerlink" title="训练结果测试"></a>训练结果测试</h3><p>网络训练到一段时间后，可以使用<code>detect.py</code>脚本对于训练的模型，进行测试了，不过需要修改是四个参数：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220404230907.png" alt="image-20220404230907456" loading="lazy"></p><p>① weights：即前面训练好得到的权重文件</p><p>② source：即需要检测的图片数据集</p><p>③ data：修改成<code>car.yaml</code></p><p>④img-size：修改成和训练时设置的一样，320或者是640</p><p>运行<code>detect.py</code>文件后，可以在<code>inference/output</code>文件夹中得到检测的效果图片：</p><p>以上就是Yolov5的详细训练过程，其中每一步都是经过详细的测试的，可以下载对应的代码、权重，进行尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型训练 </tag>
            
            <tag> YOLOv5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5相关基础概念通俗解释</title>
      <link href="/posts/c78983b3/"/>
      <url>/posts/c78983b3/</url>
      
        <content type="html"><![CDATA[<h2 id="IOU"><a href="#IOU" class="headerlink" title="IOU"></a>IOU</h2><p>IoU(Intersection over Union，即交并比，是目标检测中常见的评价标准，主要是衡量模型生成的bounding box和ground truth box之间的重叠程度，计算公式为：</p><img src="https://img-blog.csdnimg.cn/img_convert/7649401dba88c5ab756bf07662ea6a02.png" alt="img" style="zoom:150%;" / loading="lazy"><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410191351.png" alt="img" loading="lazy"></p><h2 id="TP-TN-FP-FN的概念"><a href="#TP-TN-FP-FN的概念" class="headerlink" title="TP TN FP FN的概念"></a>TP TN FP FN的概念</h2><p>T或者N代表的是该样本是否被分类分对，P或者N代表的是该样本被分为什么</p><p>TP（True Positives）意思我们倒着来翻译就是“被分为正样本，并且分对了”，TN（True Negatives）意思是“被分为负样本，而且分对了”，FP（False Positives）意思是“被分为正样本，但是分错了”，FN（False Negatives）意思是“被分为负样本，但是分错了”。</p><p>按下图来解释，左半矩形是正样本，右半矩形是负样本。一个2分类器，在图上画了个圆，分类器认为圆内是正样本，圆外是负样本。那么左半圆分类器认为是正样本，同时它确实是正样本，那么就是“被分为正样本，并且分对了”即TP，左半矩形扣除左半圆的部分就是分类器认为它是负样本，但是它本身却是正样本，就是“被分为负样本，但是分错了”即FN。右半圆分类器认为它是正样本，但是本身却是负样本，那么就是“被分为正样本，但是分错了”即FP。右半矩形扣除右半圆的部分就是分类器认为它是负样本，同时它本身确实是负样本，那么就是“被分为负样本，而且分对了”即TN</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410191510.png" alt="image-20220410191510174" loading="lazy"></p><h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><p>基线(Baseline)：被用为对比模型表现参考点的简单模型。基线帮助模型开发者量化模型在特定问题上的预期表现。</p><h2 id="confusion"><a href="#confusion" class="headerlink" title="confusion"></a>confusion</h2><h3 id="1-混淆矩阵"><a href="#1-混淆矩阵" class="headerlink" title="1.混淆矩阵"></a>1.混淆矩阵</h3><p>①：混淆矩阵是对分类问题的预测结果的总结。使用计数值汇总正确和不正确预测的数量，并按每个类进行细分，这是混淆矩阵的关键所在。混淆矩阵显示了分类模型的在进行预测时会对哪一部分产生混淆。它不仅可以让我们了解分类模型所犯的错误，更重要的是可以了解哪些错误类型正在发生。正是这种对结果的分解克服了仅使用分类准确率所带来的局限性。</p><p>②：在机器学习领域和统计分类问题中，混淆矩阵（英语：confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例。之所以如此命名，是因为通过这个矩阵可以方便地看出机器是否将两个不同的类混淆了（比如说把一个类错当成了另一个）。</p><h3 id="2-图解"><a href="#2-图解" class="headerlink" title="2.图解"></a>2.图解</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410193117.png" alt="confusion_matrix" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410193003.png" alt="img" loading="lazy"></p><p>该图解释:</p><p>横轴是预测类别，纵轴是真实类别；</p><p><strong>每一行之和为50，表示每个类各有50个样本，第一行说明类1的50个样本有43个分类正确，5个错分为类2，2个错分为类3。</strong></p><p><strong>每一行代表了真实的目标被预测为其他类的数量，比如第一行：43代表真实的类一中有43个被预测为类一，5个被错预测为类2,2个被错预测为类3；</strong></p><p><strong>表格里的数目总数为150，表示共有150个测试样本，</strong></p><h2 id="GT-box"><a href="#GT-box" class="headerlink" title="GT box"></a>GT box</h2><p>Ground Truth box</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410185552.jpeg" alt="img" loading="lazy"></p><p>如上图所示，绿色的框为飞机的Ground Truth，红色的框是提取的Region Proposal。那么即便红色的框被分类器识别为飞机，但是由于红色的框定位不准(IoU&lt;0.5)，那么这张图相当于没有正确的检测出飞机。如果我们能对红色的框进行微调，使得经过微调后的窗口跟Ground Truth更接近，这样岂不是定位会更准确。</p><h2 id="Precision（精度）和Recall（召回率）的概念"><a href="#Precision（精度）和Recall（召回率）的概念" class="headerlink" title="Precision（精度）和Recall（召回率）的概念"></a>Precision（精度）和Recall（召回率）的概念</h2><p>有了上面TP TN FP FN的概念，这个Precision和Recall的概念一张图就能说明。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410191917.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410192027.png" alt="image-20220410192027825" loading="lazy">，翻译成中文就是“分类器认为是正类并且确实是正类的部分占所有分类器认为是正类的比例”，衡量的是一个分类器分出来的正类的确是正类的概率。两种极端情况就是，如果精度是100%，就代表所有分类器分出来的正类确实都是正类。如果精度是0%，就代表分类器分出来的正类没一个是正类。光是精度还不能衡量分类器的好坏程度，比如50个正样本和50个负样本，我的分类器把49个正样本和50个负样本都分为负样本，剩下一个正样本分为正样本，这样我的精度也是100%，但是傻子也知道这个分类器很垃圾。Precision就是检测出来的框的数目（或者是面积吧)，除以一共画出来的框。比如说有时候你预测出来10个框，只有5个是正确的，那Precision就是5&#x2F;10 &#x3D; 50%。这个只是简单的比喻，可能里面会有细节上的错误。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410192051.png" alt="image-20220410192051070" loading="lazy">，翻译成中文就是“分类器认为是正类并且确实是正类的部分占所有确实是正类的比例”，衡量的是一个分类能把所有的正类都找出来的能力。两种极端情况，如果召回率是100%，就代表所有的正类都被分类器分为正类。如果召回率是0%，就代表没一个正类被分为正类。Recall就是预测出来的正确的框，除以正确的框再加上没有预测出来的ground truth的框。距离来说就是，假设你有10个类别，你预测了6个框，6个框全中了，但是还有4个没框的，这时候Recall就是6&#x2F;10&#x3D;60%</p><h2 id="x6d-65-x50-64-48-46-53"><a href="#x6d-65-x50-64-48-46-53" class="headerlink" title="&#x6d;&#65;&#x50;&#64;&#48;&#46;&#53;"></a><a href="mailto:&#x6d;&#65;&#x50;&#64;&#48;&#46;&#53;">&#x6d;&#65;&#x50;&#64;&#48;&#46;&#53;</a></h2><p><a href="mailto:&#x6d;&#65;&#x50;&#64;&#48;&#x2e;&#x35;">&#x6d;&#65;&#x50;&#64;&#48;&#x2e;&#x35;</a>：mean Average Precision<br>通俗来说，就是给每一类分别计算AP，然后做mean平均。</p><p>那AP是什么呢，之前我一直以为是Average Precision，没错，就是平均精确度，可是这个怎么定义呢？AP是Precision-Recall Curve(PRC)下面的面积！！！</p><p>AP是Precision-Recall Curve(PRC)下面的面积！！！</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410185850.png" alt="img" loading="lazy"></p><p>PRC怎么看：先看平滑不平滑（蓝线明显好些），在看谁上谁下（同一测试集上），一般来说，上面的比下面的好</p><h2 id="109-65-80-x40-48-46-x35-0-95"><a href="#109-65-80-x40-48-46-x35-0-95" class="headerlink" title="&#109;&#65;&#80;&#x40;&#48;&#46;&#x35;:0.95"></a><a href="mailto:&#109;&#65;&#80;&#x40;&#48;&#46;&#x35;">&#109;&#65;&#80;&#x40;&#48;&#46;&#x35;</a>:0.95</h2><p><a href="mailto:&#x6d;&#x41;&#x50;&#x40;&#x30;&#x2e;&#x35;">&#x6d;&#x41;&#x50;&#x40;&#x30;&#x2e;&#x35;</a>:0.95 是在不同 IoU (从 0.5 到 0.95, 步长0.05) 设置下的平均值,又可写作<code>mmAP</code>或 AP</p><p><strong>可视化结果解释</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410192753.png" alt="results" loading="lazy"></p><ul><li>Box:推测为Box损失函数均值，越小边界盒越精准</li><li>Objectness：推测为目标检测loss均值，越小目标检测越准；</li><li>Classification：推测为分类loss均值，越小分类越准；</li><li>Precision：准确率（<strong>找对的正类&#x2F;所有找到的正类</strong>）；</li></ul><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410191115.png" alt="img" style="zoom:150%;" / loading="lazy"><p>翻译成中文就是“分类器认为是正类并且确实是正类的部分占所有分类器认为是正类的比例”，衡量的是一个分类器分出来的正类的确是正类的概率。两种极端情况就是，如果精度是100%，就代表所有分类器分出来的正类确实都是正类。如果精度是0%，就代表分类器分出来的正类没一个是正类。光是精度还不能衡量分类器的好坏程度，比如50个正样本和50个负样本，我的分类器把49个正样本和50个负样本都分为负样本，剩下一个正样本分为正样本，这样我的精度也是100%，但是显然这个分类器不太行。</p><ul><li>Recall：召回率（<strong>找对的正类&#x2F;所有本应该被找对的正类</strong>）；</li></ul><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220410191110.png" alt="img" style="zoom:150%;" / loading="lazy"><p>翻译成中文就是“分类器认为是正类并且确实是正类的部分占所有确实是正类的比例”，衡量的是一个分类能把所有的正类都找出来的能力。两种极端情况，如果召回率是100%，就代表所有的正类都被分类器分为正类。如果召回率是0%，就代表没一个正类被分为正类。</p><ul><li><a href="mailto:&#109;&#65;&#80;&#64;&#x30;&#46;&#53;">&#109;&#65;&#80;&#64;&#x30;&#46;&#53;</a> &amp; <a href="mailto:&#x6d;&#65;&#80;&#x40;&#48;&#46;&#53;">&#x6d;&#65;&#80;&#x40;&#48;&#46;&#53;</a>:0.95：m表示平均，@后面的数表示判定iou为正负样本的阈值，@0.5:0.95表示阈值取0.5:0.05:0.95后取均值。</li></ul><blockquote><p>  一般训练结果主要观察<strong>精度</strong>和<strong>召回率</strong>波动情况</p><p>  （波动不是很大则训练效果较好）</p><p>  然后观察<strong><a href="mailto:&#x6d;&#65;&#x50;&#x40;&#x30;&#x2e;&#53;">&#x6d;&#65;&#x50;&#x40;&#x30;&#x2e;&#53;</a> &amp; <a href="mailto:&#x6d;&#x41;&#80;&#64;&#48;&#x2e;&#53;">&#x6d;&#x41;&#80;&#64;&#48;&#x2e;&#53;</a>:0.95</strong> 评价训练结果</p></blockquote><p>参考链接：</p><p><a href="https://www.cnblogs.com/Flat-White/p/14724045.html">https://www.cnblogs.com/Flat-White/p/14724045.html</a></p><p><a href="https://blog.csdn.net/weixin_41990671/article/details/107300314">https://blog.csdn.net/weixin_41990671/article/details/107300314</a></p><p><a href="https://blog.csdn.net/hsqyc/article/details/81702437">https://blog.csdn.net/hsqyc/article/details/81702437</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLOv5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolov5训练参数说明</title>
      <link href="/posts/9693de03/"/>
      <url>/posts/9693de03/</url>
      
        <content type="html"><![CDATA[<h2 id="yolov5-v100"><a href="#yolov5-v100" class="headerlink" title="yolov5-v100"></a>yolov5-v100</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># --cfg：模型配置和网络结构的yaml文件路径</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--cfg'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">'models/yolov5s.yaml'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'model.yaml path'</span><span class="token punctuation">)</span>    <span class="token comment"># --data：训练数据路径</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--data'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">'data/coco128.yaml'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'data.yaml path'</span><span class="token punctuation">)</span>    <span class="token comment"># --hyp: 训练网络的一些超参数设置</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--hyp'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">'data/hyp.scratch.yaml'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'hyp.yaml path (optional)'</span><span class="token punctuation">)</span>    <span class="token comment"># --epochs：训练迭代次数</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--epochs'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">)</span>    <span class="token comment"># --batch-size：每次喂给神经网络的图片数目</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--batch-size'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"Total batch size for all gpus."</span><span class="token punctuation">)</span>    <span class="token comment"># --imgsz：训练图片尺寸,nargs='+' 表示参数可设置一个或多个</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--img-size'</span><span class="token punctuation">,</span> nargs<span class="token operator">=</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'train,test sizes'</span><span class="token punctuation">)</span>    <span class="token comment"># --rect： 是否采用矩形训练</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--rect'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'rectangular training'</span><span class="token punctuation">)</span>    <span class="token comment"># --resume： 指定你之前训练的网络模型，想继续训练这个模型</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--resume'</span><span class="token punctuation">,</span> nargs<span class="token operator">=</span><span class="token string">'?'</span><span class="token punctuation">,</span> const<span class="token operator">=</span><span class="token string">'get_last'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                        <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'resume from given path/to/last.pt, or most recent run if blank.'</span><span class="token punctuation">)</span>    <span class="token comment"># --nosave： 只保留最终网络模型</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--nosave'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'only save final checkpoint'</span><span class="token punctuation">)</span>    <span class="token comment"># --noval：是否只在最后一次测试网络模型</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--notest'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'only test final epoch'</span><span class="token punctuation">)</span>    <span class="token comment"># --noautoanchor：是否采用锚点</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--noautoanchor'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'disable autoanchor check'</span><span class="token punctuation">)</span>    <span class="token comment"># --evolve：是否寻找最优参数</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--evolve'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'evolve hyperparameters'</span><span class="token punctuation">)</span>    <span class="token comment"># --bucket：没用了</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--bucket'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'gsutil bucket'</span><span class="token punctuation">)</span>    <span class="token comment"># --cache：是否对图片进行缓存，加快训练</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--cache-images'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'cache images for faster training'</span><span class="token punctuation">)</span>    <span class="token comment"># --weigths: 指的是训练好的网络模型，用来初始化网络权重</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--weights'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">'weights/yolov5m.pt'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'initial weights path'</span><span class="token punctuation">)</span>    <span class="token comment"># --name： 训练结果保存文件名</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--name'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'renames results.txt to results_name.txt if supplied'</span><span class="token punctuation">)</span>    <span class="token comment"># --device：训练网络的设备cpu还是gpu</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--device'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'cuda device, i.e. 0 or 0,1,2,3 or cpu'</span><span class="token punctuation">)</span>    <span class="token comment"># --multi-scale：图片尺度变换</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--multi-scale'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'vary img-size +/- 50%%'</span><span class="token punctuation">)</span>    <span class="token comment"># --single-cls：训练数据集是单类别还是多类别</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--single-cls'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'train as single-class dataset'</span><span class="token punctuation">)</span>    <span class="token comment"># --sync-bn：分布式训练</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--sync-bn'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'use SyncBatchNorm, only available in DDP mode'</span><span class="token punctuation">)</span>    <span class="token comment"># --local_rank：分布式训练</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--local_rank'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'DDP parameter, do not modify'</span><span class="token punctuation">)</span>    opt <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLOv5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练集、验证集、测试集以及交验验证的理解</title>
      <link href="/posts/5c001ed5/"/>
      <url>/posts/5c001ed5/</url>
      
        <content type="html"><![CDATA[<h1 id="在人工智能机器学习中，很容易将“验证集”与“测试集”，“交叉验证”混淆。"><a href="#在人工智能机器学习中，很容易将“验证集”与“测试集”，“交叉验证”混淆。" class="headerlink" title="在人工智能机器学习中，很容易将“验证集”与“测试集”，“交叉验证”混淆。"></a>在人工智能机器学习中，很容易将“验证集”与“测试集”，“交叉验证”混淆。</h1><blockquote><p>  <code>val</code>是<code>validation</code>的简称。<code>training dataset</code>和<code>validation dataset</code>都是在训练的时候起作用。而因为<code>validation</code>的数据集和<code>training</code>没有交集，所以这部分数据对最终训练出的模型没有贡献。<code>validation</code>的主要作用是来验证是否过拟合、以及用来调节训练参数等。</p><p>  比如训练<code>0-10000</code>次迭代过程中，<code>train</code>和<code>validation</code>的<code>loss</code>都是不断降低，但是从<code>10000-20000</code>过程中<code>train loss</code>不断降低，<code>validation</code>的<code>loss</code>不降反升。那么就证明继续训练下去，模型只是对<code>training dataset</code>这部分拟合的特别好，但是泛化能力很差。所以与其选取<code>20000</code>次的结果，不如选择<code>10000</code>次的结果。这个过程的名字叫做<code>Early Stop</code>，<code>validation</code>数据在此过程中必不可少。</p></blockquote><h1 id="一、三者的区别"><a href="#一、三者的区别" class="headerlink" title="一、三者的区别"></a>一、三者的区别</h1><ul><li><p>训练集（train set） —— 用于模型拟合的数据样本。</p></li><li><p>验证集（validation set）—— 是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估。 通常用来在模型迭代训练时，用以验证当前模型泛化能力（准确率，召回率等），以决定是否停止继续训练。</p></li></ul><p>在神经网络中， 我们用验证数据集去寻找最优的网络深度（number of hidden layers)，或者决定反向传播算法的停止点或者在神经网络中选择隐藏层神经元的数量；</p><p>在普通的机器学习中常用的交叉验证（Cross Validation) 就是把训练数据集本身再细分成不同的验证数据集去训练模型。</p><ul><li>测试集 —— 用来评估模最终模型的泛化能力。但不能作为调参、选择特征等算法相关的选择的依据。</li></ul><table><thead><tr><th align="center">类别</th><th align="center">验证集</th><th align="center">测试集</th></tr></thead><tbody><tr><td align="center">是否被训练到</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">作用</td><td align="center">1)调超参数；2）监控模型是否发生过拟合（以决定是否停止训练）</td><td align="center">为了评估最终模型泛化能力</td></tr><tr><td align="center">使用次数</td><td align="center">多次使用，以不断调参</td><td align="center">仅仅一次使用</td></tr><tr><td align="center">缺陷</td><td align="center">模型在一次次重新手动调参并继续训练后所逼近的验证集，可能只代表一部分非训练集，导致最终训练好的模型泛化性能不够</td><td align="center"></td></tr></tbody></table><p>一个形象的比喻：</p><p><strong>训练集</strong>———–学生的课本；学生 根据课本里的内容来掌握知识。</p><p><strong>验证集</strong>————作业，通过作业可以知道 不同学生学习情况、进步的速度快慢。</p><p><strong>测试集</strong>———–考试，考的题是平常都没有见过，考察学生举一反三的能力。</p><p>传统上，一般三者切分的比例是：6：2：2，验证集并不是必须的。</p><h1 id="二、为什么要测试集"><a href="#二、为什么要测试集" class="headerlink" title="二、为什么要测试集"></a>二、为什么要测试集</h1><p>a)训练集直接参与了模型调参的过程，显然不能用来反映模型真实的能力（防止课本死记硬背的学生拥有最好的成绩，即防止过拟合)。</p><p>b)验证集参与了人工调参(超参数)的过程，也不能用来最终评判一个模型（刷题库的学生不能算是学习好的学生）。</p><p>c) 所以要通过最终的考试(测试集)来考察一个学(模)生(型)真正的能力（期末考试）。</p><p>但是仅凭一次考试就对模型的好坏进行评判显然是不合理的，所以接下来就要介绍交叉验证法</p><h1 id="三、交叉验证法（模型选择）"><a href="#三、交叉验证法（模型选择）" class="headerlink" title="三、交叉验证法（模型选择）"></a>三、交叉验证法（模型选择）</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h2><p>   交叉验证法的作用就是尝试利用不同的训练集&#x2F;验证集划分来对模型做多组不同的训练&#x2F;验证，来应对单独测试结果过于片面以及训练数据不足的问题。（就像通过多次考试，才通知哪些学生是比较比较牛B的）</p><p>交叉验证的做法就是将数据集粗略地分为比较均等不相交的k份，即<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220117142702.jpeg" alt="img" loading="lazy"></p><p>然后取其中的一份进行测试，另外的k-1份进行训练，然后求得error的平均值作为最终的评价，具体算法流程如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220117142738.jpeg" alt="img" loading="lazy"></p><p> 举个例子：假设建立一个BP神经网络，对于隐含层的节点数目，我们并没有很好的方法去确定。此时，一般将节点数设定为某一具体的值，通过训练集训练出相应的参数后，再由交叉验证集去检测该模型的误差；然后再改变节点数，重复上述过程，直到交叉验证误差最小。</p><h2 id="2-交叉验证算法的具体步骤如下："><a href="#2-交叉验证算法的具体步骤如下：" class="headerlink" title="2.交叉验证算法的具体步骤如下："></a>2.交叉验证算法的具体步骤如下：</h2><ol><li><pre><code> 随机将训练数据等分成k份，S1, S2, …, Sk。</code></pre></li><li><pre><code> 对于每一个模型Mi，算法执行k次，每次选择一个Sj作为验证集，而其它作为训练集来训练模型Mi，把训练得到的模型在Sj上进行测试，这样一来，每次都会得到一个误差E，最后对k次得到的误差求平均，就可以得到模型Mi的泛化误差。</code></pre></li><li><pre><code> 算法选择具有最小泛化误差的模型作为最终模型，并且在整个训练集上再次训练该模型，从而得到最终的模型。</code></pre></li></ol><p> K折交叉验证，其主要 的目的是为了选择不同的模型类型（比如一次线性模型、非线性模型、），而不是为了选择具体模型的具体参数。比如在BP神经网络中，其目的主要为了选择模型的层数、神经元的激活函数、每层模型的神经元个数（即所谓的超参数）。每一层网络神经元连接的最终权重是在模型选择（即K折交叉验证）之后，由全部的训练数据重新训练。 目的在模型选择，而非模型训练调整参数。</p><p>c) K值的选择</p><p> <strong>K值的选取是一个偏差与方差的权衡：</strong></p><p>  K&#x3D;1时，所有数据用于训练，容易过拟合；</p><p> K&#x3D;N时，相当于留一法LOOCV  (Leave-one-out cross-validation ).; </p><p>通常建议K&#x3D;10，2017年的一项研究给出了另一种经验式的选择方法[3]，作者建议  <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220117142935.png" alt="img" loading="lazy">且保证 <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220117142938.png" alt="img" loading="lazy"></p><p><strong>来源：</strong><a href="https://blog.csdn.net/kieven2008/article/details/81582591">CSDN博主『Kieven2oo8』</a></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA、CUDNN、CUDA Driver、CUDA Toolkit、NCVV的区别</title>
      <link href="/posts/e052800c/"/>
      <url>/posts/e052800c/</url>
      
        <content type="html"><![CDATA[<h1 id="CUDA、CUDNN、CUDA-Driver、CUDA-Toolkit、NCVV的区别？"><a href="#CUDA、CUDNN、CUDA-Driver、CUDA-Toolkit、NCVV的区别？" class="headerlink" title="CUDA、CUDNN、CUDA Driver、CUDA Toolkit、NCVV的区别？"></a>CUDA、CUDNN、CUDA Driver、CUDA Toolkit、NCVV的区别？</h1><h2 id="1、什么是CUDA？"><a href="#1、什么是CUDA？" class="headerlink" title="1、什么是CUDA？"></a>1、什么是CUDA？</h2><p>CUDA 英文全称是Compute Unified Device Architecture，是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107080025.png" alt="image-20220107080025307" loading="lazy"></p><h2 id="2、什么是CUDNN？"><a href="#2、什么是CUDNN？" class="headerlink" title="2、什么是CUDNN？"></a>2、什么是CUDNN？</h2><p>CUDNN 是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。可以集成到高级的机器学习框架中，如谷歌的Tensorflow、加州大学伯克利分校的caffe框架、Facebook的PyTorch框架等等。</p><ul><li>CUDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算；</li><li>CUDA这个平台一开始并没有安装CUDNN库，当开发者们需要用到深度学习GPU加速时才安装CUDNN库，工作速度相较CPU快很多。</li></ul><p>那CUDA与CUDNN的关系是什么呢？知乎上的一个解释挺好理解：</p><blockquote><p>  CUDA看作是一个工作台，上面配有很多工具，如锤子、螺丝刀等。cuDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算。它就相当于工作的工具，比如它就是个扳手。但是CUDA这个工作台买来的时候，并没有送扳手。想要在CUDA上运行深度神经网络，就要安装cuDNN，就像你想要拧个螺帽就要把扳手买回来。这样才能使GPU进行深度神经网络的工作，工作速度相较CPU快很多。</p></blockquote><h2 id="3、什么是CUDA-Driver？"><a href="#3、什么是CUDA-Driver？" class="headerlink" title="3、什么是CUDA Driver？"></a>3、什么是CUDA Driver？</h2><p>这个就是常说的显卡驱动，比如我的电脑显卡型号是：GTX 1660 SUPER，显卡驱动程序的版本：441.08。</p><p>每个版本的CUDA工具包都对应一个最低版本的CUDA Driver，也就是说如果你安装的CUDA Driver版本比官方推荐的还低，那么很可能会无法正常运行。CUDA Driver是向后兼容的，这意味着根据CUDA的特定版本编译的应用程序将继续在后续发布的Driver上也能继续工作。通常为了方便，在安装CUDA Toolkit的时候会默认安装CUDA Driver。在开发阶段可以选择默认安装Driver，但是对于像Tesla GPU这样的商用情况时，建议在官方安装最新版本的Driver。</p><p>一篇博客上总结的， CUDA Toolkit 和 CUDA Driver 版本的对应情况如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107004133.png" alt="在这里插入图片描述" loading="lazy"></p><h2 id="4、什么是CUDA-Toolkit？"><a href="#4、什么是CUDA-Toolkit？" class="headerlink" title="4、什么是CUDA Toolkit？"></a>4、什么是CUDA Toolkit？</h2><p>CUDA Toolkit 就是Nvidia 官方提供的一个完整的<strong>工具安装包</strong>，其中提供了Nvidia 驱动程序、开发CUDA 程序相关的开发工具包等可供安装的选项。</p><p>使用 Nvidia 官网提供的 CUDA Toolkit 可以安装开发 CUDA 程序所需的工具，包括 CUDA 程序的编译器、IDE、调试器等，CUDA 程序所对应的各式库文件以及它们的头文件。但对于 Pytorch 之类的深度学习框架而言，其在大多数需要使用 GPU 的情况中只需要使用 CUDA 的动态链接库支持程序的运行( Pytorch 本身与 CUDA 相关的部分是提前编译好的 )，就像常见的可执行程序一样，不需要重新进行编译过程，只需要其所依赖的动态链接库存在即可正常运行。故而，Anaconda 在安装 Pytorch 等会使用到 CUDA 的框架时，会自动为用户安装 cudatoolkit，其主要包含应用程序在使用 CUDA 相关的功能时所依赖的动态链接库。在安装了 cudatoolkit 后，只要系统上存在与当前的 cudatoolkit 所兼容的 Nvidia 驱动，则已经编译好的 CUDA 相关的程序就可以直接运行，而不需要安装完整的 Nvidia 官方提供的 CUDA Toolkit 。</p><h2 id="5、什么是NCVV？"><a href="#5、什么是NCVV？" class="headerlink" title="5、什么是NCVV？"></a>5、什么是NCVV？</h2><p>nvcc就是CUDA的编译器,可以从CUDA Toolkit的&#x2F;bin目录中获取,类似于gcc就是c语言的编译器。由于程序是要经过编译器编程成可执行的二进制文件，而cuda程序有两种代码，一种是运行在cpu上的host代码，一种是运行在gpu上的device代码，所以nvcc编译器要保证两部分代码能够编译成二进制文件在不同的机器上执行。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>链接: <a href="https://cloud.tencent.com/developer/article/1536738">https://cloud.tencent.com/developer/article/1536738</a>.<br>链接: <a href="https://developer.aliyun.com/article/761648">https://developer.aliyun.com/article/761648</a>.<br>链接: <a href="https://zhuanlan.zhihu.com/p/83971195">https://zhuanlan.zhihu.com/p/83971195</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> CUDA </tag>
            
            <tag> CUDNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu安装yolov5 GPU训练环境</title>
      <link href="/posts/ba920a62/"/>
      <url>/posts/ba920a62/</url>
      
        <content type="html"><![CDATA[<h1 id="查看ubuntu版本"><a href="#查看ubuntu版本" class="headerlink" title="查看ubuntu版本"></a>查看ubuntu版本</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>base<span class="token punctuation">)</span> user@ubuntu<span class="token operator">:</span><span class="token operator">~</span>$ cat <span class="token operator">/</span>etc<span class="token operator">/</span>issueUbuntu <span class="token number">16.04</span><span class="token number">.7</span> LTS \n \l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="查看conda环境"><a href="#查看conda环境" class="headerlink" title="查看conda环境"></a>查看conda环境</h1><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">(base) user@ubuntu:~$ conda info --env# conda environments:#base                  *  &#x2F;home&#x2F;user&#x2F;anaconda3d2l                      &#x2F;home&#x2F;user&#x2F;anaconda3&#x2F;envs&#x2F;d2lpython2                  &#x2F;home&#x2F;user&#x2F;anaconda3&#x2F;envs&#x2F;python2yolov5                   &#x2F;home&#x2F;user&#x2F;anaconda3&#x2F;envs&#x2F;yolov5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="新建python虚拟环境，方便版本管理"><a href="#新建python虚拟环境，方便版本管理" class="headerlink" title="新建python虚拟环境，方便版本管理"></a>新建python虚拟环境，方便版本管理</h1><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda create -n yolov5 python&#x3D;&#x3D;3.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看cuda版本，三种办法</p><p>①：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">(base) user@ubuntu:~$ nvidia-smiTue Mar  8 14:24:19 2022       +-----------------------------------------------------------------------------+| NVIDIA-SMI 460.32.03    Driver Version: 460.32.03    CUDA Version: 11.2     ||-------------------------------+----------------------+----------------------+| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC || Fan  Temp  Perf  Pwr:Usage&#x2F;Cap|         Memory-Usage | GPU-Util  Compute M. ||                               |                      |               MIG M. ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||   0  Tesla V100-PCIE...  Off  | 00000000:65:00.0 Off |                    0 || N&#x2F;A   41C    P0    35W &#x2F; 250W |      0MiB &#x2F; 32510MiB |      0%      Default ||                               |                      |                  N&#x2F;A |+-------------------------------+----------------------+----------------------+                                                                               +-----------------------------------------------------------------------------+| Processes:                                                                  ||  GPU   GI   CI        PID   Type   Process name                  GPU Memory ||        ID   ID                                                   Usage      ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||  No running processes found                                                 |+-----------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">(base) user@ubuntu:~$ nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2019 NVIDIA CorporationBuilt on Fri_Feb__8_19:08:17_PST_2019Cuda compilation tools, release 10.1, V10.1.105<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">(base) user@ubuntu:~$ cat &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;version.txtCUDA Version 10.1.105<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>  细心地同学会发现，有时①查看的cuda版本和②、③查出来的会不同，这是什么原因呢。原来cuda的API分为两种类型，一种是驱动（driver）API，另一种是运行（runtime）API。而我们通过nvidia-smi查看的cuda版本正是驱动API版本。通过nvcc -V 和 cat &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;version.txt查看的一般是运行API，因此两者存在出入是正常的。</p><p>  但是我们运行程序时所使用的是<strong>运行API</strong>，我们时常讲的<strong>cuda，cudnn，tensorflow-gpu版本之间的对应</strong>，也是针对运行API来讲的，也就是后两者查看的版本。</p></blockquote><h1 id="安装cudnn"><a href="#安装cudnn" class="headerlink" title="安装cudnn"></a>安装cudnn</h1><blockquote><p>  可在cuDNN的官网上下载对应版本的cuDNN安装包，官网网址：<a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN Archive</a></p><p>  cuDNN的安装方法有两种，需要下载不同的安装包</p></blockquote><h2 id="一、Tar-File形式的安装"><a href="#一、Tar-File形式的安装" class="headerlink" title="一、Tar File形式的安装"></a>一、Tar File形式的安装</h2><p><strong>.tgz 文件安装</strong></p><p>该方法仅需下载一个安装包，如图所示</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220308151135.png" alt="image-20220308151135873" loading="lazy"></p><p>下载完毕后，进入文件所在位置，解压安装包（其中 xxx 为安装包的补充名称）</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xzvf cudnn-xxx.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行安装，其实就是拷贝头文件和库文件并给予权限</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo cp cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;includesudo cp cuda&#x2F;lib64&#x2F;libcudnn* &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64sudo chmod a+r &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;include&#x2F;cudnn.h &#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64&#x2F;libcudnn*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、Debian-File形式的安装"><a href="#二、Debian-File形式的安装" class="headerlink" title="二、Debian File形式的安装"></a>二、Debian File形式的安装</h2><p><strong>.deb 文件安装</strong></p><p>该方法需要下载三个安装包，如下图所示</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220308151511.png" alt="image-20220308151511657" loading="lazy"></p><p>分别对这三个安装包执行以下命令进行安装，文件名请自行修改，要注意，必须按以下顺序进行安装，否则会因依赖问题而报错</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dpkg -i libcudnn7_7.6.4.38-1+cuda9.0_amd64.debsudo dpkg -i libcudnn7-dev_7.6.4.38-1+cuda9.0_amd64.debsudo dpkg -i libcudnn7-doc_7.6.4.38-1+cuda9.0_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="三、验证cudnn是否安装成功"><a href="#三、验证cudnn是否安装成功" class="headerlink" title="三、验证cudnn是否安装成功"></a>三、验证cudnn是否安装成功</h2><p>当选择Debian File进行安装时会在&#x2F;usr&#x2F;src&#x2F;cudnn_samples_v7有一些cudnn的例子</p><p>编译mnistCUDNN sample进行验证</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cp -r &#x2F;usr&#x2F;src&#x2F;cudnn_samples_v7&#x2F; $HOMEcd  $HOME&#x2F;cudnn_samples_v7&#x2F;mnistCUDNNmake clean &amp;&amp; make.&#x2F;mnistCUDNN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> YOLOv5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>显卡选择及驱动安装</title>
      <link href="/posts/80945641/"/>
      <url>/posts/80945641/</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识显卡"><a href="#一、认识显卡" class="headerlink" title="一、认识显卡"></a>一、认识显卡</h1><p>购买显卡之前，我们以Nvidia的显卡为例，说明一下显卡的型号上面的数字都表示什么意思，影驰表示的是显卡的制造商，Geforce是显卡系列名称，GTX表示显卡的档次，数字一般是四位，前两位表示显卡的代数，16就表示是第16代显卡，中间的第三位数字表示的是显卡的性能级别，数字越大显卡的性能级别就相对越好，最后一位一般都是0，不用去管，有的显卡还有英文的后缀，SE表示阉割版、TI和Super表示增强的版本，比如1660TI就是在1660的基础上进行了增强，6G表示显卡的显存是6个GB，最后的比较炫酷的名字是制造商定的名字，这个一般就是个噱头，不需要太关注。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107172351.jpeg" alt="v2-0d0d6041b76993e660d37ed36622f4a6_720w" loading="lazy"></p><p>另外比较重要的是大家要学会看显卡的参数，分别是架构、工艺、流处理器、核心频率、显存频率、显存位宽、显存容量，比如这里是3090的显卡信息。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107172419.png" alt="image-20210702162540231" loading="lazy"></p><ol><li>架构：相当于运行布局，布局越好跑的越流畅。</li><li>工艺：制程越小精度越高，越能发挥更多性能。</li><li>光栅以及流处理器：相当于劳动力，人越多执行力越强。</li><li>核心频率：反应速度，相当于跑车百米提速效率。</li><li>显存频率：相当于限速标志，决定了最大运行速度。</li><li>显存位宽：相当于划线，决定了最大运行通道。</li><li>显存容量：相当于道路限宽，决定了最大承载量。</li></ol><p>拿绝地求生来说，这款游戏比较吃显存。因为游戏地图数据都加载在显存内，越是精致的3D画面数据量越多，需要的显存容量就越高。深度学习的话一般主要关注两个点，一个是显存的容量一个是cuda核心的数量，这两个指标越大相对就越好。</p><p>有台式机的小伙伴可以直接买单独的显卡插在主板上，注意要看自己的电源功率是否能够为显卡提供供电。</p><p>没有台式机的小伙伴也可以考虑买带有Nvidia显卡的笔记本，目标联想拯救者系列就是个不错的选择。</p><h1 id="二、安装显卡驱动"><a href="#二、安装显卡驱动" class="headerlink" title="二、安装显卡驱动"></a>二、安装显卡驱动</h1><p>首先第一步还是要安装显卡的驱动，显卡驱动的安装需要在官网下载驱动程序，首先大家需要在设备管理器中查看你的显卡型号，这里是我的显卡。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107172604.png" alt="image-20220107172604082" loading="lazy"></p><p>去<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">官网</a>下载对应你显卡的驱动程序：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107173200.png" alt="image-20220107173200527" loading="lazy"></p><p>下载之后执行程序并进行安装即可，为了防止不必要的情况出现，<strong>安装的时候请按照默认选项执行</strong>。</p><p>安装完毕之后重启电脑在cmd中输入<code>nvidia-smi</code>，输出下列信息则表示显卡驱动安装成功。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107175606.png" alt="image-20220107175606369" loading="lazy"></p><h1 id="三、查看CUDA的版本号"><a href="#三、查看CUDA的版本号" class="headerlink" title="三、查看CUDA的版本号"></a>三、查看CUDA的版本号</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107003101.png" alt="image-20220107003101053" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107003143.png" alt="image-20220107003143389" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220107003216.png" alt="image-20220107003216332" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yun主题写作语法</title>
      <link href="/posts/a6c287ab/"/>
      <url>/posts/a6c287ab/</url>
      
        <content type="html"><![CDATA[<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 树莓派镜像烧录<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-03-05 01:31:08</span><span class="token key atrule">updated</span><span class="token punctuation">:</span> <span class="token datetime number">2020-07-14 16:31:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 西红柿<span class="token comment"># 设置作者则会显示</span><span class="token key atrule">email</span><span class="token punctuation">:</span> 2506812280@qq.com<span class="token comment"># 自动根据邮箱获取 Gravatar 头像</span><span class="token key atrule">readmore</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment"># 将会首页卡片摘要末尾强制显示一个 阅读更多 按钮</span><span class="token key atrule">sticky</span><span class="token punctuation">:</span> <span class="token number">100</span>  <span class="token comment"># 置顶</span><span class="token key atrule">hideTime</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token comment"># 强制隐藏时间显示</span><span class="token key atrule">description</span><span class="token punctuation">:</span> 描述（只出现在预览卡片上，不出现在正文中）（默认使用 400 字重以表强调，略细于加粗字体）<span class="token comment"># 设置为 index 时，将只在首页隐藏，归档中仍然展示。（譬如放一些没有必要放在首页的笔记,并在归档中方便自己查看。）</span><span class="token comment"># 当设置为 true 时，该文章仍然会被渲染，你自己可以直接访问链接进行查看。但不会被显示在展示的文章卡片与归档中。</span><span class="token key atrule">hide</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> 树莓派  <span class="token punctuation">-</span> 镜像烧录<span class="token key atrule">categories</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> 树莓派<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="额外的头部字段"><a href="#额外的头部字段" class="headerlink" title="额外的头部字段"></a>额外的头部字段</h1><h2 id="author"><a href="#author" class="headerlink" title="author"></a>author</h2><p>设置作者则会显示</p><h2 id="email"><a href="#email" class="headerlink" title="email"></a>email</h2><p>自动根据邮箱获取 <a href="https://en.gravatar.com/site/implement/images/">Gravatar</a> 头像</p><h2 id="toc"><a href="#toc" class="headerlink" title="toc"></a>toc</h2><p>是否显示目录，文章 <code>post</code> 默认显示，页面 <code>post</code> 默认不显示</p><h2 id="readmore"><a href="#readmore" class="headerlink" title="readmore"></a>readmore</h2><p>将会首页卡片摘要末尾强制显示一个 <code>阅读更多</code> 按钮</p><h2 id="hideTime"><a href="#hideTime" class="headerlink" title="hideTime"></a>hideTime</h2><p>强制隐藏时间显示</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> xxx<span class="token key atrule">author</span><span class="token punctuation">:</span> 云游君<span class="token key atrule">email</span><span class="token punctuation">:</span> me@yunyoujun.cn<span class="token key atrule">readmore</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">hideTime</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>描述（只出现在预览卡片上，不出现在正文中）（默认使用 <code>400</code> 字重以表强调，略细于加粗字体）</p><h2 id="excerpt"><a href="#excerpt" class="headerlink" title="excerpt"></a>excerpt</h2><p>摘要（不需要在 <code>Front-matter</code> 中设置，通过 <code>&lt;!-- more --&gt;</code> 截断实现，预览卡片与正文中均出现）</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token front-matter-block"><span class="token punctuation">---</span><span class="token front-matter yaml language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> xxx<span class="token key atrule">description</span><span class="token punctuation">:</span> xxxxxxx</span><span class="token punctuation">---</span></span>这里是摘要<span class="token comment">&lt;!-- more --></span>这里是更多内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><p>标签</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> 树莓派  <span class="token punctuation">-</span> 镜像烧录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><p>分类，如果您尚未安装 <code>hexo-generator-category</code>，请输入 <code>npm install hexo-generator-category</code></p><p>新建 <code>categories</code> 页面，在博客根目录下输入：</p><pre class="line-numbers language-none"><code class="language-none">hexo new page categories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2017-10-12 10:47:16</span><span class="token key atrule">comments</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">type</span><span class="token punctuation">:</span> categories<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  TIP</p><p>  <a href="https://hexo.io/zh-cn/docs/front-matter.html#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE">分类和标签</a></p><p>  尽管 Hexo 支持了为一篇文章设置多个分类，但我个人更建议你一篇文章只放在一个分类下，而使用标签来为它进行多个描述。</p><p>  同时太多的分类与标签，既不方便整理，也不利于移动端的展示。</p></blockquote><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>通过设置文章 Front Matter 中 <code>sticky</code> 属性以进行置顶，数值越高，优先级越高。</p><p>设置置顶后，文章卡片右上角将出现置顶图标。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> xxx<span class="token key atrule">sticky</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><blockquote><p>  <a href="https://yun.yunyoujun.cn/guide/config.html#type">https://yun.yunyoujun.cn/guide/config.html#type</a></p></blockquote><p>为文章设置 <code>type</code> 属性，即可将其转为其他类型卡片，并跳转 <code>url</code> 设置的链接。</p><p>譬如：</p><pre class="line-numbers language-none"><code class="language-none">---title: xxxtype: bilibiliurl: https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av8153395&#x2F;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在文章标题前将会出现 bilibili 的图标，点击标题会跳转至对应的链接。</p><p>目前默认支持以下类型（哔哩哔哩、豆瓣、GitHub、网易云音乐、推特、微信公众号、微博、语雀、知乎、Notion、外链）：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">types</span><span class="token punctuation">:</span>  <span class="token key atrule">link</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> blue    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>external<span class="token punctuation">-</span>link<span class="token punctuation">-</span>line  <span class="token key atrule">bilibili</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#FF8EB3"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>bilibili<span class="token punctuation">-</span>line  <span class="token key atrule">douban</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#007722"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>douban<span class="token punctuation">-</span>line  <span class="token key atrule">github</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> black    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>github<span class="token punctuation">-</span>line  <span class="token key atrule">netease-cloud-music</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#C10D0C"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>netease<span class="token punctuation">-</span>cloud<span class="token punctuation">-</span>music<span class="token punctuation">-</span>line  <span class="token key atrule">notion</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> black    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>notion  <span class="token key atrule">twitter</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#1da1f2"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>twitter<span class="token punctuation">-</span>line  <span class="token key atrule">wechat</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#1AAD19"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>wechat<span class="token punctuation">-</span>2<span class="token punctuation">-</span>line  <span class="token key atrule">weibo</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#E6162D"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>weibo<span class="token punctuation">-</span>line  <span class="token key atrule">yuque</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#25b864"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>yuque  <span class="token key atrule">zhihu</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> <span class="token string">"#0084FF"</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> icon<span class="token punctuation">-</span>zhihu<span class="token punctuation">-</span>line<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以自己在 <code>_config.yun.yml</code> 设置你跳转不同链接专属的图标和颜色。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">types</span><span class="token punctuation">:</span>  <span class="token key atrule">google</span><span class="token punctuation">:</span>    <span class="token key atrule">color</span><span class="token punctuation">:</span> xxx    <span class="token key atrule">icon</span><span class="token punctuation">:</span> xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当你指定的 <code>type</code> 不存在于默认支持中，也没有进行自定义，将默认使用蓝色的额外链接图标。</p><p>如果你想在你的外链卡片上显示一些信息，你可以写在 <code>&lt;!-- more --&gt;</code> 前，它会被当作摘要显示。</p><p>譬如：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>yun<span class="token key atrule">type</span><span class="token punctuation">:</span> github<span class="token key atrule">url</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/YunYouJun/hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>yun<span class="token punctuation">---</span>Hexo 主题 Yun&lt;<span class="token tag">!--</span> more <span class="token punctuation">-</span><span class="token punctuation">-</span><span class="token punctuation">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hide-隐藏文章"><a href="#hide-隐藏文章" class="headerlink" title="hide-隐藏文章"></a>hide-隐藏文章</h2><p>你可以在文章头部添加 <code>hide</code> 属性，来临时隐藏某篇文章。</p><ul><li><code>index</code>: 设置为 <code>index</code> 时，将只在首页隐藏，归档中仍然展示。（譬如放一些没有必要放在首页的笔记，并在归档中方便自己查看。）</li><li><code>true</code>: 当设置为 <code>true</code> 时，该文章仍然会被渲染，你自己可以直接访问链接进行查看。但不会被显示在展示的文章卡片与归档中。</li></ul><pre class="line-numbers language-none"><code class="language-none">---title: xxxhide: true# hide: indexsitemap: falseindexing: false---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  什么？你想完全不渲染不显示？那你为何不将其放在 <code>_drafts</code> 文件夹下，或干脆不提交这篇文章。</p></blockquote><h2 id="reward-打赏"><a href="#reward-打赏" class="headerlink" title="reward-打赏"></a>reward-打赏</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">reward</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="内容字段"><a href="#内容字段" class="headerlink" title="内容字段"></a>内容字段</h1><h2 id="图片注释"><a href="#图片注释" class="headerlink" title="图片注释"></a>图片注释</h2><p><img src="https://i.loli.net/2020/03/08/DhfLu5yngb7NZE2.png" alt="Audits - Lighthouse" loading="lazy"><em>谷歌浏览器 Audits - Lighthouse 检测分数</em></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token url"><span class="token operator">!</span>[<span class="token content">Audits - Lighthouse</span>](<span class="token url">https://i.loli.net/2020/03/08/DhfLu5yngb7NZE2.png</span>)</span><span class="token italic"><span class="token punctuation">_</span><span class="token content">谷歌浏览器 Audits - Lighthouse 检测分数</span><span class="token punctuation">_</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h2>    <div id="aplayer-BXzuUHsf" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="497572729" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><pre class="line-numbers language-none"><code class="language-none">&#123;% meting &quot;497572729&quot; &quot;netease&quot; &quot;song&quot; &quot;theme:#C20C0C&quot; %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>    <div id="aplayer-ZqJTzGhj" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2008272804" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><pre class="line-numbers language-none"><code class="language-none">&#123;% meting &quot;2008272804&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FF4081&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h2><pre class="line-numbers language-none"><code class="language-none">type: albumstitle: 相册url: &#x2F;albums&#x2F;miracle.htmlabbrlink: e26d1860date: 2020-03-05 01:31:08updated: 2020-07-14 16:31:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h1><p>安装<code>npm install --save hexo-blog-encrypt</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 文章信息头</span><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> Hello World<span class="token key atrule">tags</span><span class="token punctuation">:</span><span class="token punctuation">-</span> 作为日记加密<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2016-03-30 21:12:21</span><span class="token key atrule">password</span><span class="token punctuation">:</span> mikemessi<span class="token key atrule">abstract</span><span class="token punctuation">:</span> 有东西被加密了<span class="token punctuation">,</span> 请输入密码查看.<span class="token key atrule">message</span><span class="token punctuation">:</span> 您好<span class="token punctuation">,</span> 这里需要密码.<span class="token key atrule">wrong_pass_message</span><span class="token punctuation">:</span> 抱歉<span class="token punctuation">,</span> 这个密码看着不太对<span class="token punctuation">,</span> 请再试试.<span class="token key atrule">wrong_hash_message</span><span class="token punctuation">:</span> 抱歉<span class="token punctuation">,</span> 这个文章不能被校验<span class="token punctuation">,</span> 不过您还是能看看解密后的内容.<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装hexo及部署</title>
      <link href="/posts/17723abd/"/>
      <url>/posts/17723abd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  写给想要拥有一个自己的网站但没有资金成本的小白与曾经的自己。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直以来都想搭建一个自己的博客系统，用来记录自己在学习中遇到的问题和一些心得体会，趁着这次没有太多的事情，搭建一个属于自己的博客。由于自己平时的笔记都是使用Markdown语法来撰写的，在搜索资料与对比后决定使用<code>Hexo</code>框架。</p><p>我不是一个前端程序员，有些东西不是很了解，写的有问题或有改进的地方请大家指出。</p><h1 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h1><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是高效的静态站点生成框架，她基于 <a href="https://nodejs.org/en/">Node.js</a>，相较于 Jekyll 他有以下特点:</p><ul><li><h3 id="超快速度"><a href="#超快速度" class="headerlink" title="超快速度"></a>超快速度</h3><p>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p></li><li><h3 id="支持-Markdown"><a href="#支持-Markdown" class="headerlink" title="支持 Markdown"></a>支持 Markdown</h3><p>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p></li><li><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>只需一条指令即可部署到 Github Pages，或其他网站</p></li><li><h3 id="丰富的插件"><a href="#丰富的插件" class="headerlink" title="丰富的插件"></a>丰富的插件</h3><p>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p></li></ul><p>通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的<a href="https://hexo.io/zh-cn/docs/tag-plugins.html">标签插件</a>来快速的插入特定形式的内容。</p><p>基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的<a href="https://hexo.io/themes/">主题</a>。</p><ul><li><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3></li></ul><ol><li>Hexo</li><li>静态博客</li><li>无服务器</li><li>GitHub Pages</li></ol><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li>Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li>Git</li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。</p><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h1 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h1><h2 id="什么是-Node-js-？"><a href="#什么是-Node-js-？" class="headerlink" title="什么是 Node.js ？"></a><strong>什么是 Node.js ？</strong></h2><blockquote><p>  这得从什么是 JS 说起，JS 也就是 JavaScript。（为什么有种从盘古开天辟地开始的感觉）没错，JavaScript 就是网页的盘古。JavaScript 是一种编程语言，我们所见到的网页中的交互和逻辑处理几乎都是由 JavaScript 完成。<br>  JavaScript 语法简单，易学易用。（当然也请不要小瞧它，虽然它入门门槛低，但上限同样也很高。包括但不限于实现网站前后端，手机桌面应用程序，机器学习，计算机图形学等。）</p><p>  在 Node.js 诞生前，JavaScript 都运行于浏览器端。也就是说，它是鱼，浏览器是装满了水的水缸。<br>  2008 年，Chrome V8 诞生。2009 年，Node.js 诞生。并成为 GitHub 早期最著名的开源项目。GitHub 可能大家已有所了解，后续再说。<br>  Node.js 便是一个基于 Chrome V8 引擎的 JavaScript 运行环境。（当年第一次看到这句话时，我也一脸懵逼。）按照我的理解，JavaScript 是鱼，Chrome V8 就是抽水机，Node.js 则把这台抽水机也装在你电脑上。于是你的电脑也有了 Node.js 这个和浏览器相似的水缸，也可以在里面运行 JavaScript 了！<br>  当然 Node.js 和浏览器端还是因为自身定位和一些历史原因而有些许区别的，不再展开。<br>  <a href="https://baike.baidu.com/item/node.js/7567977">Node.js | 百度百科</a><br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript | MDN</a></p></blockquote><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p><a href="https://nodejs.org/zh-cn/">下载｜ Node.js</a></p><p>建议下载<strong>长期支持版</strong>而非<strong>当前发布版</strong>（因为如果是最新版，容易出现一些奇妙的 bug）。</p><p>全部默认下一步进行安装。</p><p>安装选项全部默认，一路点击<code>Next</code>。</p><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><blockquote><p>  Node.js 安装成功时也默认安装了 <code>npm</code>，在此后将会用到。<br>  <code>npm</code> 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。</p></blockquote><h2 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h2><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre class="line-numbers language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具—Git</p><blockquote><p>  Visual Studio Code，简称 VS Code。<br>  目前最为强大易用的编辑器，轻量且快速。（<del>宇宙第一编辑器</del>）<br>  注意：它并不是我们常常听到的 VS，VS 常常指的是 Visual Studio，是一个功能强大的 IDE（集成开发环境），体积也相比 VS Code 都要大上一个量级。</p><p>  Git 是一个开源的分布式版本控制系统，由 Linus Torvalds（同时也是 Linux 的作者）为了管理 Linux 开发而开发。<br>  简而言之，是一个版本管理工具。譬如设计师设计好了第三版的海报，客户却说还是要第一版吧，这时便可以通过 Git 快速回退到最初的版本。<br>  你只需要把每次更改的状态（Git 会自动进行检测，你只要掌握基础的几条命令就可以了）告诉 Git，而不需要每个版本都保存一份压缩包，既方便也能大大节约空间。<br>  （当然这主要只对代码文本起作用，因为 Git 的本质是记录各行代码的增减，倘若是像视频、海报这类二进制文件来说便体现不出丝毫优势了。当然想要应对这种场景还有 <a href="https://git-lfs.github.com/">Git LFS</a>。）</p></blockquote><h2 id="安装Git-1"><a href="#安装Git-1" class="headerlink" title="安装Git"></a>安装Git</h2><p>下载 <a href="https://git-scm.com/">Git</a> 并安装（如果国内速度太慢，可以试试<a href="https://pc.qq.com/detail/13/detail_22693.html">这里</a>）</p><p>macOS 用户可以下载官网的安装包进行安装，也可以直接安装 App Store 的 Xcode（附带会安装 Git，但是比较大）。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><blockquote><p>  类似的工具还有：SVN。但始终更推荐 Git，因为它功能更为强大且它的背后还有更强大的生态：GitHub。</p></blockquote><h1 id="注册-GitHub"><a href="#注册-GitHub" class="headerlink" title="注册 GitHub"></a>注册 GitHub</h1><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>这一部分内容，你也可以放到本地调试并预览成功后并打算线上部署的时候，再回过头来看。</p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>  GitHub 一听便与 Git 有所渊源。<code>Git</code> 在英文中是懒人、饭桶之意。<code>Hub</code> 则是中心、集线器的意思。譬如 USB 集线器就是 USB Hub。所以 GitHub 就是饭桶中心（<del>大雾</del>）。<br>  GitHub 是全世界最大的开源项目与代码托管平台，也是众多开发者的交流场所。<del>还是全球最大的同性交友网站</del>。<br>  而代码托管本身用到的正是上文提到的 Git 技术。</p></blockquote><p>注册 <a href="https://github.com/">GitHub</a> 账号。（虽然都是英文，但不必畏惧，也并不会造成使用障碍，只要记得最常用的选项含义即可，以及善用手头的翻译软件。）</p><blockquote><p>  注意：注册时的英文用户名将成为你可以使用的免费域名前缀。</p></blockquote><p>登录 GitHub。</p><h2 id="为什么要用-GitHub？"><a href="#为什么要用-GitHub？" class="headerlink" title="为什么要用 GitHub？"></a>为什么要用 GitHub？</h2><p>对于平民玩家来说，在初次尝试建立自己的网站时，也许并不会有闲钱或者说决心来购买自己的服务器与域名。<br>而 GitHub 则提供了 <a href="https://pages.github.com/">GitHub Pages</a> 这一服务。<br>用户们可以利用这一服务，部署自己的静态站点。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>点击右上角的 <code>+</code> -&gt; <code>New repository</code> 新建仓库。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211224358.png" loading="lazy"></p><p>仓库名称务必为 <code>你的用户名.github.io</code>，用户名是英文，大小写无所谓，但建议统一小写。（因为你会发现时常切换大小写很麻烦）</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211224924.png" alt="image-20220211224814302" loading="lazy"></p><blockquote><p>  为什么必须这个作为仓库名？<br>  GitHub Pages 服务的命名规范，同时它也将成为你的专属域名。当然，你也可以购置自己的专属域名并用它来提供内容。</p></blockquote><p>点击 <code>Create repository</code>。然后项目就建成了，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，再回到<code>GitHub Pages</code>，会变成下面这样：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211225115.png" alt="image-20220211225115298" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211225205.png" alt="image-20220211225205880" loading="lazy"></p><p>点击那个链接，就会出现自己的网页啦，效果如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211225305.png" alt="image-20220211225305706" loading="lazy"></p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p><a href="https://hexo.io/">Hexo</a></p><ul><li>GitHub: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></li><li><a href="https://hexo.io/zh-cn/docs/index.html">官方文档</a>（直接参考文档也是一个不错的选择）</li></ul><h2 id="为嘛使用-Hexo-？"><a href="#为嘛使用-Hexo-？" class="headerlink" title="为嘛使用 Hexo ？"></a><strong>为嘛使用 Hexo ？</strong></h2><blockquote><p>  Hexo 是一个快速、简洁而强大的博客框架，基于 Node.js，同样托管于 GitHub 之上。生态中拥有众多插件主题。你可以基于它快速生成一些静态页面。<br>  你可以使用别人的各种主题与插件，也可以自己定制开发想要的功能。</p></blockquote><h2 id="为什么不是…"><a href="#为什么不是…" class="headerlink" title="为什么不是…?"></a><strong>为什么不是…?</strong></h2><blockquote><p>  其他常用的博客框架还有 <a href="https://wordpress.org/">WordPress</a>，<a href="https://typecho.org/">Typecho</a>，<a href="https://ghost.org/">Ghost</a> 等，但这些往往都需要购置自己的服务器，而无法静态化地部署到 GitHub Pages 上。（当然，相应的功能和灵活性也大大提升。）静态化站点还有一个优势就是访问速度往往更快。<br>  静态网站生成器还有 <a href="https://vuepress.vuejs.org/">Vuepress</a>，<a href="https://www.gatsbyjs.org/">Gatsby</a> 等。但这些多是为了写文档而量身定制的，你也可以使用它们，但是相较 Hexo 的博客定位，它们关于博客的插件和主题以及解决办法会少得多。Hexo 提供的功能与 <a href="https://gohugo.io/">Hugo</a> 几乎都有，（生成大量文件时，甚至比 Hexo 更快）不过它是基于 GO 语言。日后你想对自己的网站进行自定义，即便是 Hugo，你编写前端的交互仍旧需要使用 JavaScript，所以选择基于 JavaScript 的 Hexo 可以降低学习成本。<br>  所以对于新手来说，使用 Hexo 作为起始点，不失为一个好选择。（当然如果你有钱租服务器，并希望快速上手的话，就可以考虑考虑 WordPress 或者 Typecho）</p></blockquote><h2 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在终端中输入以下命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">npm install hexo-cli -g# 如果安装失败，可能是没有权限，可以尝试头部加上 sudo 重新执行# sudo npm install hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>  <code>install</code> 自然是安装。<br>  <code>hexo-cli</code> 则是 <code>hexo</code> 的终端工具，可以帮助你生成一些模版文件，之后再用到。<br>  <code>-g</code> 代表的是全局安装。也就是在任何地方都可以使用，否则会只能在安装的目录下使用。</p></blockquote><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>此时，请先通过 <code>cd</code> 进入你本地电脑打算存储网站代码的文件夹目录。（或者右键文件夹 Git Bash Here）</p><p>接下来输入：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">hexo init 你的名字.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211231417.png" alt="image-20220211231417468" loading="lazy"></p><blockquote><p>  <code>hexo</code> 正是因为我们之前安装了 <code>hexo-cli</code> 这一个包，所以我们可以在终端中使用 <code>hexo</code> 这一命令。<br>  <code>init</code> 初始化博客的模版文件。后面跟的是你要新建的文件夹，最好和你此前新建的仓库名一致。</p><p>  如果在初始化过程中半天没有反应，多尝试几次，可能是因为本地连接GitHub的问题，可以考虑开代理或者修改host的方式解决。</p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 进入你的博客文件夹cd 你的名字.github.io# 默认安装所有 &#96;package.json&#96; 文件中提到的包npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211231631.png" alt="image-20220211231631300" loading="lazy"></p><pre class="line-numbers language-none"><code class="language-none"># 编译hexo g# 你也可以缩写成 hexo shexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211231738.png" alt="image-20220211231738568" loading="lazy"></p><p><code>server</code> 代表开启本地的 Hexo 服务器，这时你就可以打开浏览器，在地址栏中输入 <code>localhost:4000</code> 就可以看到本地的网页了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211231810.png" alt="image-20220211231810793" loading="lazy"></p><p>按 <code>Ctrl + C</code> 中断服务器的运行。</p><p>至此，基础的模版页面便已经搭建好了。</p><h1 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h1><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>首先右键打开git bash，然后输入下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"wushuai"</span><span class="token function">git</span> config --global user.email <span class="token string">"2506812280@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>用户名和邮箱根据你注册github的信息自行修改。</p><h2 id="连接Github"><a href="#连接Github" class="headerlink" title="连接Github"></a>连接Github</h2><p>生成密钥SSH key：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 三次回车即可生成 ssh key, 这里的邮箱最好填和刚才一样的</span>ssh-keygen -t rsa -C <span class="token string">"2506812280@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211232902.png" alt="image-20220211232902462" loading="lazy"></p><p>然后用文本编辑器(如notepad)打开id_rsa.pub这个文件, 全选复制。文件路径在命令行的提示里面可以看见。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211233434.png" alt="image-20220211233434473" loading="lazy"></p><p>接下来到GitHub上，打开“Account settings”–“SSH Keys”页面，然后点“Add SSH Key”，填上Title（随意写），在Key文本框里粘贴 id_rsa.pub文件里的全部内容。点“Add Key”，你就应该看到已经添加的Key，可以添加多个Key</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211233345.png" alt="image-20220211233345526" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211233622.png" alt="image-20220211233622008" loading="lazy"></p><p>验证是否成功，在git bash里输入下面的命令，出现你的用户名，那就成功了。</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211233819.png" alt="image-20220211233819250" loading="lazy"></p><p>接下来我们将本地的仓库与此前在 GitHub 上建立的仓库建立关联。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220211234631.png" alt="image-20220211234631497" loading="lazy"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>为了更方便的部署到 GitHub Pages，Hexo 提供了 <code>hexo-deployer-git</code> 插件。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">npm install hexo-deployer-git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>_config.yml</code> 中配置。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repo</span><span class="token punctuation">:</span> 你此前新建的仓库的链接 <span class="token comment"># 比如：https://github.com/wushuai2000/wushuai2000.github.io</span>  <span class="token key atrule">branch</span><span class="token punctuation">:</span> main <span class="token comment"># 默认使用 main 分支</span>  <span class="token key atrule">message</span><span class="token punctuation">:</span> Update Hexo Static Content <span class="token comment"># 你可以自定义此次部署更新的说明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存，部署！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>  第一次可能需要你输入用户名与密码。<br>  密码输入的时候不会出现 ***，不要害怕，已经输入进去了。</p></blockquote><p>等待完成后，打开网址 <code>https://你的名字.github.io</code> 就能看到你的线上网站了。</p><blockquote><p>  使用 https，http 可能无法正常打开。HTTPS 是多了安全加密的 HTTP，Chrome 浏览器已经默认会显示 <code>http</code> 链接为不安全。<br>  为了安全，建议开启强制 https 跳转。<code>项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Enforce HTTPS</code>。（翻到下面）<br>  此时，http 网址会自动重定向到 https</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo绑定域名</title>
      <link href="/posts/7068443c/"/>
      <url>/posts/7068443c/</url>
      
        <content type="html"><![CDATA[<h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a><strong>购买域名</strong></h2><p>自定义域名第一步：挑选好一个自己喜欢的域名并购买，域名服务商可以在阿里云旗下的万网或者腾讯云都可以，由于我之前就在阿里云买了一个域名：ccsu.top，没有使用，所以现在就用上了</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220212104451.png" alt="image-20220212104451749" loading="lazy"></p><p>买完之后在阿里云控制台域名下面就会展示出购买的域名信息</p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a><strong>解析域名</strong></h2><p>以我的阿里云为例，如下图所示，添加两条解析记录：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220212104243.png" alt="image-20220212104243325" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220212104303.png" alt="image-20220212104303051" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220212103451.png" alt="image-20220212103451170" loading="lazy"></p><h2 id="设置CNAME"><a href="#设置CNAME" class="headerlink" title="设置CNAME"></a><strong>设置CNAME</strong></h2><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220212103354.png" alt="image-20220212103354458" loading="lazy"></p><p>在项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），填写上域名。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。完成上述步骤之后就可以在浏览器输入自己的域名访问了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220212105212.png" alt="image-20220212105212611" loading="lazy"></p><h2 id="Hexo推送GitHub-Pages时自定义域名失效的问题"><a href="#Hexo推送GitHub-Pages时自定义域名失效的问题" class="headerlink" title="Hexo推送GitHub Pages时自定义域名失效的问题"></a>Hexo推送GitHub Pages时自定义域名失效的问题</h2><p>用Hexo可以实现基于Github Pages的个人博客系统，默认博客网址是 username.github.io</p><p>如果想换成自己的域名，可以在Github对应repository的Setting里，找到Github Pages， 在Custom domain里填进去自己的域名，Save。</p><p>再在域名商那里设置好域名解析，就可以实现个人域名了。</p><p>仔细观察可以发现，在Github设置好Custom domain之后，博客对应的repository里，会多出一个名为CNAME的文件，内容是自己的自定义域名的网址。</p><p>然而在本地更新hexo博客内容，并通过Git更新托管在Github的博客时，由于Hexo默认没有这个CNAME文件，原本的CNAME文件会被抹掉，于是自定义域名就失效了。</p><p>解决办法很简单：<strong>在Hexo目录里的source文件夹下面，新建一个同样内容、同样名字的CNAME文件即可。</strong></p><h1 id="您备案的网站未指向阿里云国内节点（不含香港）服务器，备案号可能被取消接入的问题解决"><a href="#您备案的网站未指向阿里云国内节点（不含香港）服务器，备案号可能被取消接入的问题解决" class="headerlink" title="您备案的网站未指向阿里云国内节点（不含香港）服务器，备案号可能被取消接入的问题解决"></a>您备案的网站未指向阿里云国内节点（不含香港）服务器，备案号可能被取消接入的问题解决</h1><p>工信部备案后一段时间会发来<br><code>Hexo博客：您备案的网站未指向阿里云国内节点（不含香港）服务器，备案号可能被取消接入</code><br>的短信警告，</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220217143200.png" alt="image-20220217143200537" loading="lazy"></p><p>下面讲述该问题的原因及解决方法。</p><p>问题描述：<br>经检查您的网站域名 xxxxxx 未指向阿里云国内节点（不含香港）服务器且无访问记录 ，依据工信部相关法规规定属于空壳网站，请您尽快将域名解析IP地址指向阿里云国内节点（不含香港）服务器。 如果3个工作日后检查发现该备案域名在在阿里云国内节点（不含香港）服务器上仍无访问记录，我们将删除网站备案接入信息。您的备案号可能会被注销，网站访问可能受到影响。</p><p>这个问题常见于个人博客，特别是 hexo 博客，购买了域名，并且备了案，由于 hexo 博客静态托管于 Github Pages 或者 Coding Pages，所以也就没有阿里云的服务器，也就不可能存在域名解析IP地址指向阿里云国内节点服务器。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220217143236.png" alt="image-20220217143236477" loading="lazy"></p><p>解决方法：<br>将你的域名添加一个二级域名，解析到某些阿里云国内节点服务器上就行了。例如我博客域名为 ccsu.top，就可以添加一个或者两个 A 记录，记录值为阿里云国内节点服务器的 IP。然后隔一段时间访问一下 beian.ccsu.top，确保有一点儿访问量就行了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220217143335.png" alt="image-20220217143335076" loading="lazy"></p><p>下面列出一些阿里云国内节点服务器 IP，挑一些能访问的就行了。</p><p>39.100.0.2 【恭喜，站点创建成功！】<br>39.100.0.16 【恭喜，站点创建成功！】<br>39.100.0.17 【恭喜，站点创建成功！】<br>39.100.0.23 【Document】<br>39.100.0.59 【恭喜，站点创建成功！】<br>39.100.0.64 【贵州鸿巨热力(集团)有限责任公司】<br>39.100.0.68 【恭喜，站点创建成功！】<br>39.100.0.75 【没有找到站点】<br>39.100.0.77 【Welcome to nginx!】<br>39.100.0.88 【恭喜，站点创建成功！】<br>39.100.0.94 【没有找到站点】<br>39.100.0.113 【IIS Windows Server】<br>39.100.0.117 【phpinfo()】<br>39.100.0.118 【没有找到站点】<br>39.100.0.119 【恭喜，站点创建成功！】<br>39.100.0.134 【宁夏塞上优家互联科技有限公司】<br>39.100.0.138 【没有找到站点】<br>39.100.0.149 【没有找到站点】<br>39.100.0.158 【没有找到站点】<br>39.100.0.159 【学点云管理后台】<br>39.100.0.167 【财经·新经济】<br>39.100.0.168 【苏州市相城区燃气有限责任公司】<br>39.100.0.169 【恭喜，站点创建成功！】<br>39.100.0.174 【The page is not foun】<br>39.100.0.177 【恭喜，站点创建成功！】<br>39.100.0.182 【IIS7】<br>39.100.0.192 【恭喜，站点创建成功！】<br>39.100.0.204 【恭喜，站点创建成功！】<br>39.100.0.209 【千胜ERP】<br>39.100.0.214 【LANMP一键安装包,集lamp,lnm】<br>39.100.0.238 【登录 - 大庆井下】<br>39.100.1.1 【上海美凯龙美学装饰工程有限公司ERP】<br>39.100.1.28 【恭喜，站点创建成功！】<br>39.100.1.44 【IIS Windows Server】<br>39.100.1.65 【恭喜，站点创建成功！】<br>39.100.1.68 【Test Page for the Ng】<br>39.100.1.95 【恭喜，站点创建成功！】</p><blockquote><p>  <a href="https://blog.csdn.net/kuashijidexibao/article/details/106503226">https://blog.csdn.net/kuashijidexibao/article/details/106503226</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相册</title>
      <link href="/posts/e26d1860/"/>
      <url>/posts/e26d1860/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">type</span><span class="token punctuation">:</span> albums<span class="token key atrule">title</span><span class="token punctuation">:</span> 相册<span class="token key atrule">url</span><span class="token punctuation">:</span> /albums/miracle.html<span class="token key atrule">abbrlink</span><span class="token punctuation">:</span> e26d1860<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-03-05 01:31:08</span><span class="token key atrule">updated</span><span class="token punctuation">:</span> <span class="token datetime number">2020-07-14 16:31:00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安装hexo主题yun</title>
      <link href="/posts/17723abd/"/>
      <url>/posts/17723abd/</url>
      
        <content type="html"><![CDATA[<h1 id="安装渲染器"><a href="#安装渲染器" class="headerlink" title="安装渲染器"></a>安装渲染器</h1><blockquote><p>  如果您没有 <code>pug</code> 与 <code>stylus</code> 的渲染器，请先安装： <a href="https://github.com/hexojs/hexo-renderer-pug">hexo-renderer-pug</a> （这个是 Hexo 官方在维护，但是好像没有下面的星多，更新的勤快。） 或 <a href="https://github.com/maxknee/hexo-render-pug">hexo-render-pug</a> （以及前者尚未支持开发时热更新，后者支持。） 和 <a href="https://github.com/hexojs/hexo-renderer-stylus">hexo-renderer-stylus</a></p>  <pre class="line-numbers language-none"><code class="language-none">npm install hexo-render-pug hexo-renderer-stylus --save# oryarn add hexo-render-pug hexo-renderer-stylusnpm install hexo-render-pug hexo-renderer-stylus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220213105356.png" alt="image-20220213105356132" loading="lazy"></p><pre class="line-numbers language-none"><code class="language-none">node -vnpm config set registry https:&#x2F;&#x2F;registry.npm.taobao.orgnpm install -g yarnnpm install hexo-cli -ghexo init wushuai2000.github.iocd wushuai2000.github.ionpm installnpm install hexo-render-pug hexo-renderer-stylusnpm i hexo-theme-yun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-yun</title>
      <link href="/posts/4567d7fd/"/>
      <url>/posts/4567d7fd/</url>
      
        <content type="html"><![CDATA[<p>Hexo 主题 Yun</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐播放实例</title>
      <link href="/posts/bf8e06ec/"/>
      <url>/posts/bf8e06ec/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-fIjrxaDp" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="497572729" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><pre class="line-numbers language-none"><code class="language-none">&#123;% meting &quot;497572729&quot; &quot;netease&quot; &quot;song&quot; &quot;theme:#C20C0C&quot; %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>    <div id="aplayer-yywnlMyQ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="2008272804" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#FF4081"    ></div><pre class="line-numbers language-none"><code class="language-none">&#123;% meting &quot;2008272804&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FF4081&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝牙HC-05使用介绍</title>
      <link href="/posts/596227bc/"/>
      <url>/posts/596227bc/</url>
      
        <content type="html"><![CDATA[<p>常见的蓝牙模块为：HC-05主从一体蓝牙模块、HC-06从机蓝牙模块、低功耗BLE蓝牙模块(cc2540或cc2541)。</p><h1 id="一、HC-05主从一体蓝牙模块"><a href="#一、HC-05主从一体蓝牙模块" class="headerlink" title="一、HC-05主从一体蓝牙模块"></a>一、HC-05主从一体蓝牙模块</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>HC-05 蓝牙串口通讯模块（以下简称模块）具有两种工作模式：命令响应工作模式和自动连接工作模式，在自动连接工作模式下模块又可分为主（Master）、从（Slave）和回环（Loopback）三种工作角色。</p><p>  当模块处于自动连接工作模式时，将自动根据事先设定的方式进行数据传输；当模块处于命令响应工作模式时能执行下述所有AT命令，用户可向模块发送各种AT指令，为模块设定控制参数或发布控制命令。通过控制模块外部引脚（PIO11）的输入电平，可以实现模块两种工作模式的切换。</p><p>1)、PIO8 连接LED，指示模块工作状态，模块上电后闪烁，不同的状态闪烁间隔不同。<br>2)、PIO9 连接LED，指示模块连接成功，蓝牙串口匹配连接成功后，LED 长亮。<br>3)、PIO11 模块状态切换脚，高电平–&gt;AT 命令响应工作状态，低电平或悬空–&gt;蓝牙常规工作状态。<br>4)、模块上已带有复位电路，重新上电即完成复位。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094039.png" alt="img" loading="lazy"></p><h2 id="2、常用AT指令"><a href="#2、常用AT指令" class="headerlink" title="2、常用AT指令"></a>2、常用AT指令</h2><p>（AT指令不区分大小写，均以回车、换行字符结尾：\r\n。在AT模式下，波特率固定为38400）</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094125.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094151.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094148.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094220.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094214.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094217.png" alt="img" loading="lazy"></p><p><img src="https://img-blog.csdnimg.cn/20200103104631585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FsZXhjZWw=,size_16,color_FFFFFF,t_70" alt="img" loading="lazy"></p><h2 id="3、使用举例—–把HC-05设置为主机步骤："><a href="#3、使用举例—–把HC-05设置为主机步骤：" class="headerlink" title="3、使用举例—–把HC-05设置为主机步骤："></a>3、使用举例—–把HC-05设置为主机步骤：</h2><p>1)、把PIO11 置高。<br>2)、给模块上电，模块会进入AT 命令响应状态，此时状态指示灯会慢闪。<br>3)、超级终端或其他串口工具，设置波特率38400，数据位8 位，停止位1 位，无校验位，无流控制。<br>4)、串口发送字符“AT+ROLE&#x3D;1\r\n”，成功返回“OK\r\n”，其中\r\n 为回车换行。<br>5)、PIO11 置低，重新上电，模块为主模块，自动搜索从模块，建立连接。</p><h2 id="4、使用举例—–让两个蓝牙模块自动配对"><a href="#4、使用举例—–让两个蓝牙模块自动配对" class="headerlink" title="4、使用举例—–让两个蓝牙模块自动配对"></a>4、使用举例—–让两个蓝牙模块自动配对</h2><p>1)、把模块1和模块2的PIO11 置高。<br>2)、给两个模块上电，模块会进入AT 命令响应状态，此时状态指示灯会慢闪。<br>3)、超级终端或其他串口工具连接两个模块，设置波特率38400，数据位8 位，停止位1 位，无校验位，无流控制。<br>4)、给两个模块发送字符“AT+PSWD&#x3D;1234\r\n”，成功返回“OK\r\n”，其中\r\n 为回车换行。（配对密码可以随便改，但要保证两个模块的配对密码一样）</p><p>5)、给模块1发送字符“AT+ROLE&#x3D;0\r\n”，成功返回“OK\r\n”。给模块2发送字符“AT+ROLE&#x3D;1\r\n”，成功返回“OK\r\n”。（把一个模块设置为主机，另一个设置为从机）</p><p>6)、把两个模块的的名字和波特率设置好。</p><p>7)、给两个模块发送字符“AT+CMODE&#x3D;1\r\n”，成功返回“OK\r\n”。（把两个模块的地址模式设置为任意地址，这样两个模块会使用配对密码自动匹配，而不管地址）</p><p>8)、PIO11 置低，重新上电，模块2为主机，会自动搜索从机模块1，建立连接。</p><p>5、使用举例—–让两个蓝牙模块唯一配对</p><p>如果使用了指令“AT+CMODE&#x3D;1\r\n”把模块设置为任意地址配对，模块在配对后会记忆最后一次配对的地址。因此两个模块完成配对后，再给两个模块发送字符“AT+CMODE&#x3D;0\r\n”，就能把模块改为唯一地址配对。模块上电后会一直搜索保存的地址，而不会和其他地址配对。</p><h1 id="二、HC-06从机蓝牙模块"><a href="#二、HC-06从机蓝牙模块" class="headerlink" title="二、HC-06从机蓝牙模块"></a>二、HC-06从机蓝牙模块</h1><h2 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>仅能作为从机。电路如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094352.png" alt="img" loading="lazy"></p><h2 id="2、AT指令（指令后面无-r-n）"><a href="#2、AT指令（指令后面无-r-n）" class="headerlink" title="2、AT指令（指令后面无\r\n）"></a>2、AT指令（指令后面无\r\n）</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094424.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094435.png" alt="img" loading="lazy"></p><h1 id="三、低功耗BLE蓝牙4-0模块-cc2540或cc2541"><a href="#三、低功耗BLE蓝牙4-0模块-cc2540或cc2541" class="headerlink" title="三、低功耗BLE蓝牙4.0模块(cc2540或cc2541)"></a>三、低功耗BLE蓝牙4.0模块(cc2540或cc2541)</h1><h2 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>蓝牙4.0标准包含两个蓝牙标准，准确的说，是一个双模的标准，它包含传统蓝牙部分（向下兼容2.0）和低功耗蓝牙部分（Bluetooth Low Energy），顾名思义BLE的特性就是极其省电，现在市面上绝大多数的可穿戴设备都是基于BLE的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094503.png" alt="img" loading="lazy"></p><p>功能脚说明：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094528.png" alt="img" loading="lazy"></p><h2 id="2、常用AT指令（AT指令不区分大小写，均以回车、换行字符结尾：-r-n）"><a href="#2、常用AT指令（AT指令不区分大小写，均以回车、换行字符结尾：-r-n）" class="headerlink" title="2、常用AT指令（AT指令不区分大小写，均以回车、换行字符结尾：\r\n）"></a>2、常用AT指令（AT指令不区分大小写，均以回车、换行字符结尾：\r\n）</h2><p>和HC-06一样，在未连接状态下就是AT模式了。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094612.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094621.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094628.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094643.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094827.png" alt="img" loading="lazy"></p><h1 id="四、JDY-10-蓝牙4-0-BLE模块"><a href="#四、JDY-10-蓝牙4-0-BLE模块" class="headerlink" title="四、JDY-10 蓝牙4.0 BLE模块"></a>四、JDY-10 蓝牙4.0 BLE模块</h1><p>也是基于蓝牙4.0标准，可是尺寸比较小。功耗也比较小。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094911.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094917.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094925.png" alt="img" loading="lazy"></p><p>波特率支持1200,2400,4800,9600,14400,19200,38400,57600,115200。模块未连接时即为AT模式。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229094946.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229095008.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229095015.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229095026.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229095034.png" alt="img" loading="lazy"></p><h1 id="五、蓝牙模块LAYOUT注意事项："><a href="#五、蓝牙模块LAYOUT注意事项：" class="headerlink" title="五、蓝牙模块LAYOUT注意事项："></a>五、蓝牙模块LAYOUT注意事项：</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211229095059.png" alt="img" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 硬件基础模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝牙 </tag>
            
            <tag> HC-05 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/posts/c56898db/"/>
      <url>/posts/c56898db/</url>
      
        <content type="html"><![CDATA[<h1 id="一、排序的基本概念"><a href="#一、排序的基本概念" class="headerlink" title="一、排序的基本概念"></a>一、排序的基本概念</h1><h2 id="1-排序算法的评价指标"><a href="#1-排序算法的评价指标" class="headerlink" title="1.排序算法的评价指标"></a>1.排序算法的评价指标</h2><ul><li>时间复杂度</li><li>空间复杂度</li><li>稳定性</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710105753.png" alt="image-20210626135434482" loading="lazy"></p><h2 id="2-排序算法的分类"><a href="#2-排序算法的分类" class="headerlink" title="2.排序算法的分类"></a>2.排序算法的分类</h2><ul><li>内部排序</li><li>外部排序</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710131801.png" alt="image-20210710131801614" loading="lazy"></p><h2 id="3-知识回顾与重要考点"><a href="#3-知识回顾与重要考点" class="headerlink" title="3.知识回顾与重要考点"></a>3.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710131822.png" alt="image-20210710131822797" loading="lazy"></p><h1 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710143708.gif" alt="img" loading="lazy"></p><h2 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1.直接插入排序"></a>1.直接插入排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token comment">//将各元素插入已排好序的序列中</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment">//若A[i]关键字小于前驱</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//用temp暂存A[i]</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment">//检查所有前面已排好序的元素</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//所有大于temp的元素都向后挪位 </span>            <span class="token punctuation">&#125;</span>            a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>         <span class="token comment">//复制到插入位置</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-直接插入排序（带哨兵）"><a href="#2-直接插入排序（带哨兵）" class="headerlink" title="2.直接插入排序（带哨兵）"></a>2.直接插入排序（带哨兵）</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//直接插入排序（带哨兵）</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                       <span class="token comment">//依次将A[2]~A[n]插入到前面已排序序列</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token comment">//若A[1]关键码小于其前驱，将A[i]插入有序表</span>        <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">//复制为哨兵，A[0]不存放元素</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>     <span class="token comment">//从后往前查找待插入位置</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">//向后挪位</span>            <span class="token punctuation">&#125;</span>            a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">//复制到插入位置</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-折半插入排序"><a href="#3-折半插入排序" class="headerlink" title="3.折半插入排序"></a>3.折半插入排序</h2><blockquote><ul><li>当 low &gt; high 时折半查找停止，应将 [low, i - 1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置</li><li>当 A[mid] &#x3D; A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插入位置</li></ul></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//折半插入排序</span><span class="token keyword">void</span> <span class="token function">InsertSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j <span class="token punctuation">,</span>low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>               <span class="token comment">//依次将a[2]~a[n]插入到前面的已排序序列</span>    <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">//将a[i]暂存到a[0]</span>        low<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>high<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">//设置折半查找范围</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span>            <span class="token comment">//折半查找（默认递增有序）</span>        <span class="token punctuation">&#123;</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">//取中间点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment">//查找左半子表</span>            <span class="token punctuation">&#123;</span>                high <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>                    <span class="token comment">//查找有半子表</span>            <span class="token punctuation">&#123;</span>                low <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token comment">//找到位置后再移动</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//统一后移元素，空出插入位置</span>        <span class="token punctuation">&#125;</span>           a<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//插入操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-知识回顾与重要考点"><a href="#4-知识回顾与重要考点" class="headerlink" title="4.知识回顾与重要考点"></a>4.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626135434.png" alt="image-20210626135434482" loading="lazy"></p><h2 id="5-测试代码"><a href="#5-测试代码" class="headerlink" title="5.测试代码"></a>5.测试代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">printstring</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印数组</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接插入排序（带哨兵）</span><span class="token keyword">void</span> <span class="token function">InsertSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//折半插入排序</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">InsertSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">InsertSort2</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printstring</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printstring</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//打印数组</span><span class="token keyword">void</span> <span class="token function">printstring</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token comment">//将各元素插入已排好序的序列中</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment">//若A[i]关键字小于前驱</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//用temp暂存A[i]</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token comment">//检查所有前面已排好序的元素</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//所有大于temp的元素都向后挪位 </span>            <span class="token punctuation">&#125;</span>            a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>         <span class="token comment">//复制到插入位置</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//直接插入排序（带哨兵）</span><span class="token keyword">void</span> <span class="token function">InsertSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                       <span class="token comment">//依次将A[2]~A[n]插入到前面已排序序列</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                   <span class="token comment">//若A[1]关键码小于其前驱，将A[i]插入有序表</span>        <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">//复制为哨兵，A[0]不存放元素</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>     <span class="token comment">//从后往前查找待插入位置</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">//向后挪位</span>            <span class="token punctuation">&#125;</span>            a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">//复制到插入位置</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//折半插入排序</span><span class="token keyword">void</span> <span class="token function">InsertSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j <span class="token punctuation">,</span>low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>               <span class="token comment">//依次将a[2]~a[n]插入到前面的已排序序列</span>    <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">//将a[i]暂存到a[0]</span>        low<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>high<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">//设置折半查找范围</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span>            <span class="token comment">//折半查找（默认递增有序）</span>        <span class="token punctuation">&#123;</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">//取中间点</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment">//查找左半子表</span>            <span class="token punctuation">&#123;</span>                high <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>                    <span class="token comment">//查找有半子表</span>            <span class="token punctuation">&#123;</span>                low <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//统一后移元素，空出插入位置</span>            <span class="token punctuation">&#125;</span>               a<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//插入操作</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、希尔排序"><a href="#三、希尔排序" class="headerlink" title="三、希尔排序"></a>三、希尔排序</h1><blockquote><ul><li>希尔排序：先追求表中元素部分有序，再逐渐逼近全局有序</li><li>时间复杂度：和增量序列d,d2,d3…的选择有关，目前无法用数学手段证明确切的时间复杂度最坏时间复杂度为O（n^2），当n在某个范围内时，可达O（n^13）</li><li>适用性：仅适用于顺序表，不适用于链表</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710144127.gif" alt="img" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">printstring</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印数组</span><span class="token keyword">void</span> <span class="token function">Shellsort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//希尔排序</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">Shellsort</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printstring</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//打印数组</span><span class="token keyword">void</span> <span class="token function">printstring</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//希尔排序</span><span class="token keyword">void</span> <span class="token function">Shellsort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>d<span class="token punctuation">;</span>    <span class="token comment">//a[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>d<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>d<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>d<span class="token operator">=</span>d<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">//步长变化</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span>d<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//需将a[i]插入有序增量子表</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//暂存在a[0]中</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>d<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">-=</span>d<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    a<span class="token punctuation">[</span>j<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//记录后移，查找插入的位置</span>                <span class="token punctuation">&#125;</span>                a<span class="token punctuation">[</span>j<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">//插入</span>            <span class="token punctuation">&#125;</span><span class="token comment">//if</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>知识回顾与重要考点</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626200257.png" alt="image-20210626200257887" loading="lazy"></p><h1 id="四、冒泡排序"><a href="#四、冒泡排序" class="headerlink" title="四、冒泡排序"></a>四、冒泡排序</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710144148.gif" alt="img" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment">//交换两个元素的值</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>             <span class="token comment">//表示本趟冒泡是否发生交换的标志</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>      <span class="token comment">//一趟冒泡过程</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//若为逆序</span>            <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//交换</span>                flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>             <span class="token comment">//本趟遍历没有发生交换，说明表已经有序</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">BubbleSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>知识回顾与重要考点</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626204924.png" alt="image-20210626204924487" loading="lazy"></p><h1 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710144206.gif" alt="img" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment">//用第一个元素将待排序序列划分成左右两个部分</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot<span class="token operator">=</span>a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">//第一个元素作为枢轴</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>           <span class="token comment">//用low、high搜索枢轴的最终位置</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> high<span class="token operator">--</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//比枢轴小的元素移到到左端</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> low<span class="token operator">++</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//比枢轴大的元素移到到右端</span>    <span class="token punctuation">&#125;</span>    a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>              <span class="token comment">//枢轴元素存放到最终位置</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span>                  <span class="token comment">//返回存放枢轴的最终位置</span><span class="token punctuation">&#125;</span><span class="token comment">//快速排序</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>          <span class="token comment">//递归跳出的条件</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pivotpos <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//划分</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivotpos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//划分左子表</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> pivotpos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//划分右子表</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-时间复杂度分析"><a href="#1-时间复杂度分析" class="headerlink" title="1.时间复杂度分析"></a>1.时间复杂度分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626213801.png" alt="image-20210626213801297" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626213618.png" alt="image-20210626213618878" loading="lazy"></p><h3 id="a-比较好的情况"><a href="#a-比较好的情况" class="headerlink" title="a.比较好的情况"></a>a.比较好的情况</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626213630.png" alt="image-20210626213630164" loading="lazy"></p><h3 id="b-最坏的情况"><a href="#b-最坏的情况" class="headerlink" title="b.最坏的情况"></a>b.最坏的情况</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626213722.png" alt="image-20210626213722500" loading="lazy"></p><h2 id="2-知识回顾与重要考点"><a href="#2-知识回顾与重要考点" class="headerlink" title="2.知识回顾与重要考点"></a>2.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210626213400.png" alt="image-20210626213400604" loading="lazy"></p><h1 id="六、简单选择排序"><a href="#六、简单选择排序" class="headerlink" title="六、简单选择排序"></a>六、简单选择排序</h1><blockquote><p>  选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710085021.gif" alt="img" loading="lazy"></p><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.代码实现</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">printstring</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印数组</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//简单选择排序</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">SelectSort</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printstring</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//打印数组</span><span class="token keyword">void</span> <span class="token function">printstring</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//简单选择排序</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token comment">//一共进行n-1趟</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">//记录最小元素的位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">//在a[i...n-1]中选择最小的元素</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//更新最小元素的位置</span>            <span class="token punctuation">&#123;</span>                min <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">!=</span> i<span class="token punctuation">)</span>        <span class="token comment">//交换元素位置，共移动元素3次</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-算法性能分析"><a href="#2-算法性能分析" class="headerlink" title="2.算法性能分析"></a>2.算法性能分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210627202749.png" alt="image-20210627202749017" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210627202804.png" alt="image-20210627202804392" loading="lazy"></p><h2 id="3-知识回顾与重要考点-1"><a href="#3-知识回顾与重要考点-1" class="headerlink" title="3.知识回顾与重要考点"></a>3.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210627202827.png" alt="image-20210627202827888" loading="lazy"></p><h1 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701144534.png" alt="image-20210701144534674" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710144242.gif" alt="img" loading="lazy"></p><h2 id="1-什么是堆（Heap）"><a href="#1-什么是堆（Heap）" class="headerlink" title="1.什么是堆（Heap）"></a>1.什么是堆（Heap）</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701144654.png" alt="image-20210701144654349" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701144612.png" alt="image-20210701144612838" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701144710.png" alt="image-20210701144710878" loading="lazy"></p><h2 id="2-建立大根堆"><a href="#2-建立大根堆" class="headerlink" title="2.建立大根堆"></a>2.建立大根堆</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701144859.png" alt="image-20210701144859918" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701145012.png" alt="image-20210701145012182" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701145040.png" alt="image-20210701145040913" loading="lazy"></p><h2 id="3-算法效率分析"><a href="#3-算法效率分析" class="headerlink" title="3.算法效率分析"></a>3.算法效率分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701145147.png" alt="image-20210701145147467" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701145203.png" alt="image-20210701145203061" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701145213.png" alt="image-20210701145213798" loading="lazy"></p><blockquote><p>  稳定性：不稳定</p></blockquote><h2 id="4-代码测试"><a href="#4-代码测试" class="headerlink" title="4.代码测试"></a>4.代码测试</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token comment">//将以k为根的子树调整为大根堆</span><span class="token keyword">void</span> <span class="token function">HeadAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">//a[0]暂存子树的根结点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span>i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">//沿着key较大的子结点向下筛选</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len<span class="token operator">&amp;&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">//取得key较大的子结点的下标</span>        <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment">//筛选结果</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//将a[i]调整到双亲结点上</span>            k <span class="token operator">=</span> i<span class="token punctuation">;</span>              <span class="token comment">//修改k值，以便继续向下筛选</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">//被筛选结点的值放入最终位置</span><span class="token punctuation">&#125;</span><span class="token comment">//建立大根堆</span><span class="token keyword">void</span> <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token comment">//从后往前调整所有非终端结点</span>    <span class="token punctuation">&#123;</span>        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>i<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//堆排序的完整逻辑</span><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//建立初始的堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>      <span class="token comment">//n-1趟的交换和建堆过程</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//堆顶元素和堆底元素交换</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//把剩余的待排序元素整理成堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">HeapSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">11</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-堆的插入"><a href="#5-堆的插入" class="headerlink" title="5.堆的插入"></a>5.堆的插入</h2><p>以小根堆为例：</p><p>对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。新元素就这样一路“上升”，直到无法继续上升为止</p><h2 id="6-堆的删除"><a href="#6-堆的删除" class="headerlink" title="6.堆的删除"></a>6.堆的删除</h2><p>以小根堆为例：</p><p>被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止</p><h2 id="7-知识回顾与重要考点"><a href="#7-知识回顾与重要考点" class="headerlink" title="7.知识回顾与重要考点"></a>7.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701145313.png" alt="image-20210701145313000" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701151154.png" alt="image-20210701151154798" loading="lazy"></p><h1 id="八、归并排序"><a href="#八、归并排序" class="headerlink" title="八、归并排序"></a>八、归并排序</h1><h2 id="1-什么是归并排序"><a href="#1-什么是归并排序" class="headerlink" title="1.什么是归并排序"></a>1.什么是归并排序</h2><blockquote><p>  归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710091212.gif" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701165158.png" alt="image-20210701165158900" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701165214.png" alt="image-20210701165214015" loading="lazy"></p><h2 id="2-算法效率分析"><a href="#2-算法效率分析" class="headerlink" title="2.算法效率分析"></a>2.算法效率分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701165325.png" alt="image-20210701165325656" loading="lazy"></p><h2 id="3-代码测试"><a href="#3-代码测试" class="headerlink" title="3.代码测试"></a>3.代码测试</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710092209.png" alt="image-20210710092209148" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//a[low...mid]和a[mid+1...high]各自有序，将两个部分归并</span><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>low<span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        b<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//将a中所有元素复制到b中</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span>j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token operator">=</span>i<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">//将最小值复制到a中</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span>   a<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span>  a<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>       <span class="token comment">//从中间划分</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//对左半部分归并排序</span>        <span class="token function">MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//对右半部分归并排序</span>        <span class="token function">Merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//归并</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-知识回顾与重要考点-1"><a href="#4-知识回顾与重要考点-1" class="headerlink" title="4.知识回顾与重要考点"></a>4.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210701165442.png" alt="image-20210701165442057" loading="lazy"></p><h1 id="九、基数排序"><a href="#九、基数排序" class="headerlink" title="九、基数排序"></a>九、基数排序</h1><h2 id="1-什么是基数排序"><a href="#1-什么是基数排序" class="headerlink" title="1.什么是基数排序"></a>1.什么是基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710101349.gif" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710101615.png" alt="image-20210710101615386" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710101734.png" alt="image-20210710101734260" loading="lazy"></p><h2 id="2-算法效率分析-1"><a href="#2-算法效率分析-1" class="headerlink" title="2.算法效率分析"></a>2.算法效率分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710101938.png" alt="image-20210710101938112" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710101944.png" alt="image-20210710101944832" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710102011.png" alt="image-20210710102011950" loading="lazy"></p><h2 id="3-基数排序的应用"><a href="#3-基数排序的应用" class="headerlink" title="3.基数排序的应用"></a>3.基数排序的应用</h2><blockquote><p>  基数排序擅长解决的问题<br>  ①数据元素的关键字可以方便地拆分为d组，且d较小<br>  ②每组关键字的取值范围不大，即r较小<br>  ③数据元素个数n较大</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710102041.png" alt="image-20210710102041125" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710102128.png" alt="image-20210710102128216" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710102149.png" alt="image-20210710102149345" loading="lazy"></p><h2 id="4-知识回顾与重要考点-2"><a href="#4-知识回顾与重要考点-2" class="headerlink" title="4.知识回顾与重要考点"></a>4.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710102215.png" alt="image-20210710102215220" loading="lazy"></p><h1 id="十、外部排序"><a href="#十、外部排序" class="headerlink" title="十、外部排序"></a>十、外部排序</h1><blockquote><p>  当所要排序的的数据量太多或者文件太大，无法直接在内存里排序，而需要依赖外部设备时，就会使用到外部排序。</p></blockquote><h2 id="1-外存与内存之间的数据交换"><a href="#1-外存与内存之间的数据交换" class="headerlink" title="1.外存与内存之间的数据交换"></a>1.外存与内存之间的数据交换</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710132055.png" alt="image-20210710132055359" loading="lazy"></p><h2 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h2><p>  假设文件需要分成k块读入，需要从小到大进行排序。</p><ol><li>依次读入每个文件块，在内存中对当前文件块进行排序（应用恰当的内排序算法），此时，每块文件相当于一个由小到大排列的有序队列；</li><li>在内存中建立一个最小堆，读入每块文件的队列头；</li><li>弹出堆顶元素，如果元素来自第i块，则从第i块文件中补充一个元素到最小值堆。弹出的元素暂存至临时数组；</li><li>当临时数组存满时，将数组写至磁盘，并清空数组内容；</li><li>重复过程3、4，直至所有文件块读取完毕。</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710132532.jpeg" alt="这里写图片描述" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710132608.jpeg" alt="这里写图片描述" loading="lazy"></p><h2 id="3-影响外部排序效率的因素"><a href="#3-影响外部排序效率的因素" class="headerlink" title="3.影响外部排序效率的因素"></a>3.影响外部排序效率的因素</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710132653.png" alt="image-20210710132653144" loading="lazy"></p><h2 id="4-优化思路"><a href="#4-优化思路" class="headerlink" title="4.优化思路"></a>4.优化思路</h2><h3 id="1-多路归并"><a href="#1-多路归并" class="headerlink" title="1.多路归并"></a>1.多路归并</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710132838.png" alt="image-20210710132838415" loading="lazy"></p><h3 id="2-减少初始归并段数量"><a href="#2-减少初始归并段数量" class="headerlink" title="2.减少初始归并段数量"></a>2.减少初始归并段数量</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710132938.png" alt="image-20210710132938509" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710132949.png" alt="image-20210710132949735" loading="lazy"></p><h2 id="5-知识回顾与重要考点"><a href="#5-知识回顾与重要考点" class="headerlink" title="5.知识回顾与重要考点"></a>5.知识回顾与重要考点</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710133141.png" alt="image-20210710133141478" loading="lazy"></p><h2 id="6-败者树优化多路平衡归并"><a href="#6-败者树优化多路平衡归并" class="headerlink" title="6.败者树优化多路平衡归并"></a>6.败者树优化多路平衡归并</h2><h3 id="1-多路平衡归并带来的问题"><a href="#1-多路平衡归并带来的问题" class="headerlink" title="1.多路平衡归并带来的问题"></a>1.多路平衡归并带来的问题</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710133857.png" alt="image-20210710133857696" loading="lazy"></p><h3 id="2-败者树的构建"><a href="#2-败者树的构建" class="headerlink" title="2.败者树的构建"></a>2.败者树的构建</h3><p>败者树——可视为一棵完全二叉树（多了一个头头）。k个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710134049.png" alt="image-20210710134049287" loading="lazy"></p><h3 id="3-败者树的使用"><a href="#3-败者树的使用" class="headerlink" title="3.败者树的使用"></a>3.败者树的使用</h3><p>基于已经构建好的败者树，选出新的胜者只需进行3场比赛</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710135449.png" alt="image-20210710135448955" loading="lazy"></p><h3 id="4-败者树在多路平衡归并中的应用"><a href="#4-败者树在多路平衡归并中的应用" class="headerlink" title="4.败者树在多路平衡归并中的应用"></a>4.败者树在多路平衡归并中的应用</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710135622.png" alt="image-20210710135622129" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710135956.png" alt="image-20210710135956927" loading="lazy"></p><h3 id="5-败者树的实现思路"><a href="#5-败者树的实现思路" class="headerlink" title="5.败者树的实现思路"></a>5.败者树的实现思路</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140044.png" alt="image-20210710140044837" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140057.png" alt="image-20210710140057547" loading="lazy"></p><h3 id="6-知识回顾与重要考点"><a href="#6-知识回顾与重要考点" class="headerlink" title="6.知识回顾与重要考点"></a>6.知识回顾与重要考点</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140142.png" alt="image-20210710140142140" loading="lazy"></p><h2 id="7-置换选择排序"><a href="#7-置换选择排序" class="headerlink" title="7.置换选择排序"></a>7.置换选择排序</h2><h3 id="1-土办法构造初始归并段"><a href="#1-土办法构造初始归并段" class="headerlink" title="1.土办法构造初始归并段"></a>1.土办法构造初始归并段</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140511.png" alt="image-20210710140511296" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140530.png" alt="image-20210710140529938" loading="lazy"></p><h3 id="2-置换-选择排序"><a href="#2-置换-选择排序" class="headerlink" title="2.置换-选择排序"></a>2.置换-选择排序</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140614.png" alt="image-20210710140614559" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140643.png" alt="image-20210710140643706" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140657.png" alt="image-20210710140657231" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140805.png" alt="image-20210710140805214" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710140836.png" alt="image-20210710140836055" loading="lazy"></p><h3 id="3-知识回顾与重要考点-2"><a href="#3-知识回顾与重要考点-2" class="headerlink" title="3.知识回顾与重要考点"></a>3.知识回顾与重要考点</h3><p>设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA,FO和WA的初始状态为空，WA可容纳ν个记录。置换-选择算法的步骤如下<br>1）从H输入w个记录到工作区WA<br>2）从WA中选出其中关键字取最小值的记录，记为 MINIMAX记录。<br>3）将 MINIMAX记录输出到FO中去。<br>4）若H不空，则从H输入下一个记录到WA中。<br>5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。<br>6）重复3）<del>5），直至在WA中选不出新的 MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。<br>7）重复2）</del>6），直至WA为空。由此得到全部初始归并段。</p><h2 id="8-最佳归并树"><a href="#8-最佳归并树" class="headerlink" title="8.最佳归并树"></a>8.最佳归并树</h2><h3 id="1-归并树的神秘性质"><a href="#1-归并树的神秘性质" class="headerlink" title="1.归并树的神秘性质"></a>1.归并树的神秘性质</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710141511.png" alt="image-20210710141511836" loading="lazy"></p><h3 id="2-构造2路归并的最佳归并树"><a href="#2-构造2路归并的最佳归并树" class="headerlink" title="2.构造2路归并的最佳归并树"></a>2.构造2路归并的最佳归并树</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710141550.png" alt="image-20210710141550078" loading="lazy"></p><h3 id="3-多路归并"><a href="#3-多路归并" class="headerlink" title="3.多路归并"></a>3.多路归并</h3><h4 id="1-多路归并的情况"><a href="#1-多路归并的情况" class="headerlink" title="1.多路归并的情况"></a>1.多路归并的情况</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710141627.png" alt="image-20210710141627266" loading="lazy"></p><h4 id="2-多路归并的最佳归并树"><a href="#2-多路归并的最佳归并树" class="headerlink" title="2.多路归并的最佳归并树"></a>2.多路归并的最佳归并树</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710141813.png" alt="image-20210710141813206" loading="lazy"></p><h4 id="3-减少一个归并段"><a href="#3-减少一个归并段" class="headerlink" title="3.减少一个归并段"></a>3.减少一个归并段</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710141921.png" alt="image-20210710141921694" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710142007.png" alt="image-20210710142007085" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710142029.png" alt="image-20210710142029371" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710142053.png" alt="image-20210710142053596" loading="lazy"></p><h4 id="4-添加虚段的数量"><a href="#4-添加虚段的数量" class="headerlink" title="4.添加虚段的数量"></a>4.添加虚段的数量</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710142615.png" alt="image-20210710142614977" loading="lazy"></p><blockquote><ul><li>应用：进行8路归并，初始归并段是19，需要添加几个归并段？</li><li>k&#x3D;8</li><li>u&#x3D;(19-1)%(7-1)&#x3D;4；需补充(k-1)-u&#x3D;(8-1)-4&#x3D;3个长度为0的虚段</li><li>验证：n<del>0</del>&#x3D;(22-1)&#x2F;(8-1)&#x3D;3可以除得尽</li></ul></blockquote><h4 id="5-知识回顾与重要考点-1"><a href="#5-知识回顾与重要考点-1" class="headerlink" title="5.知识回顾与重要考点"></a>5.知识回顾与重要考点</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210710142752.png" alt="image-20210710142752868" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/posts/8d66b5f2/"/>
      <url>/posts/8d66b5f2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204710.png" alt="image-20210726204709944" loading="lazy"></p><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204740.png" alt="image-20210726204740231" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204751.png" alt="image-20210726204751208" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204800.png" alt="image-20210726204800939" loading="lazy"></p><h2 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204812.png" alt="image-20210726204812066" loading="lazy"></p><h3 id="出栈顺序"><a href="#出栈顺序" class="headerlink" title="出栈顺序"></a>出栈顺序</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204902.png" alt="image-20210726204902687" loading="lazy"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204916.png" alt="image-20210726204916821" loading="lazy"></p><h1 id="二、顺序栈"><a href="#二、顺序栈" class="headerlink" title="二、顺序栈"></a>二、顺序栈</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726204937.png" alt="image-20210726204937548" loading="lazy"></p><h2 id="顺序栈的定义"><a href="#顺序栈的定义" class="headerlink" title="顺序栈的定义"></a>顺序栈的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205014.png" alt="image-20210726205014664" loading="lazy"></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205041.png" alt="image-20210726205041303" loading="lazy"></p><h3 id="进栈操作"><a href="#进栈操作" class="headerlink" title="进栈操作"></a>进栈操作</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205118.png" alt="image-20210726205118594" loading="lazy"></p><h3 id="出栈操作"><a href="#出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810010246.jpg" alt="image-20200624152110685" loading="lazy"></p><h3 id="读取栈顶元素"><a href="#读取栈顶元素" class="headerlink" title="读取栈顶元素"></a>读取栈顶元素</h3><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810010251.jpg" alt="image-20200624152208184" loading="lazy"></p><h2 id="另一种基本操作的实现方式"><a href="#另一种基本操作的实现方式" class="headerlink" title="另一种基本操作的实现方式"></a>另一种基本操作的实现方式</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205210.png" alt="image-20210726205210505" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205256.png" alt="image-20210726205256057" loading="lazy"></p><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205358.png" alt="image-20210726205357959" loading="lazy"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205435.png" alt="image-20210726205435561" loading="lazy"></p><h1 id="三、链栈"><a href="#三、链栈" class="headerlink" title="三、链栈"></a>三、链栈</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205457.png" alt="image-20210726205457511" loading="lazy"></p><h2 id="复习单链表"><a href="#复习单链表" class="headerlink" title="复习单链表"></a>复习单链表</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205518.png" alt="image-20210726205518576" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810010340.jpg" alt="image-20200624153252888" loading="lazy"></p><h2 id="链栈的定义"><a href="#链栈的定义" class="headerlink" title="链栈的定义"></a>链栈的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205556.png" alt="image-20210726205556417" loading="lazy"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205606.png" alt="image-20210726205606460" loading="lazy"></p><h1 id="四、队列"><a href="#四、队列" class="headerlink" title="四、队列"></a>四、队列</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205643.png" alt="image-20210726205643080" loading="lazy"></p><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205656.png" alt="image-20210726205656372" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205707.png" alt="image-20210726205707313" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205716.png" alt="image-20210726205716597" loading="lazy"></p><h2 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205730.png" alt="image-20210726205730255" loading="lazy"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205740.png" alt="image-20210726205740361" loading="lazy"></p><h1 id="五、顺序队列"><a href="#五、顺序队列" class="headerlink" title="五、顺序队列"></a>五、顺序队列</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205800.png" alt="image-20210726205800388" loading="lazy"></p><h2 id="顺序队列的定义"><a href="#顺序队列的定义" class="headerlink" title="顺序队列的定义"></a>顺序队列的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205828.png" alt="image-20210726205828662" loading="lazy"></p><h3 id="顺序队列的初始化"><a href="#顺序队列的初始化" class="headerlink" title="顺序队列的初始化"></a>顺序队列的初始化</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726205936.png" alt="image-20210726205936490" loading="lazy"></p><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210000.png" alt="image-20210726210000265" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210010.png" alt="image-20210726210010587" loading="lazy"></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210035.png" alt="image-20210726210034990" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210047.png" alt="image-20210726210046933" loading="lazy"></p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210126.png" alt="image-20210726210126251" loading="lazy"></p><h3 id="判空-x2F-判满"><a href="#判空-x2F-判满" class="headerlink" title="判空&#x2F;判满"></a>判空&#x2F;判满</h3><p>方案一：牺牲一个存储空间</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210151.png" alt="image-20210726210151059" loading="lazy"></p><p>方案二：利用size变量记录队列长度</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210211.png" alt="image-20210726210211159" loading="lazy"></p><p>方案三：利用tag记录最后一次操作</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210223.png" alt="image-20210726210223004" loading="lazy"></p><h2 id="其它实现方式"><a href="#其它实现方式" class="headerlink" title="其它实现方式"></a>其它实现方式</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210307.png" alt="image-20210726210307014" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210328.png" alt="image-20210726210328765" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210353.png" alt="image-20210726210353025" loading="lazy"></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210420.png" alt="image-20210726210420928" loading="lazy"></p><h1 id="六、链队列"><a href="#六、链队列" class="headerlink" title="六、链队列"></a>六、链队列</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210449.png" alt="image-20210726210449654" loading="lazy"></p><h2 id="链队列的定义"><a href="#链队列的定义" class="headerlink" title="链队列的定义"></a>链队列的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210500.png" alt="image-20210726210500752" loading="lazy"></p><h2 id="链队列的基本操作"><a href="#链队列的基本操作" class="headerlink" title="链队列的基本操作"></a>链队列的基本操作</h2><h3 id="链队列的初始化"><a href="#链队列的初始化" class="headerlink" title="链队列的初始化"></a>链队列的初始化</h3><p>带头结点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210631.png" alt="image-20210726210631445" loading="lazy"></p><p>不带头结点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210647.png" alt="image-20210726210647339" loading="lazy"></p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>带头节点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210701.png" alt="image-20210726210701573" loading="lazy"></p><p>不带头节点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210711.png" alt="image-20210726210711098" loading="lazy"></p><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><p>带有头节点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210725.png" alt="image-20210726210725504" loading="lazy"></p><p>不带头节点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210736.png" alt="image-20210726210736800" loading="lazy"></p><h3 id="判满"><a href="#判满" class="headerlink" title="判满"></a>判满</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210758.png" alt="image-20210726210758825" loading="lazy"></p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210828.png" alt="image-20210726210828317" loading="lazy"></p><h1 id="七、双端队列"><a href="#七、双端队列" class="headerlink" title="七、双端队列"></a>七、双端队列</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210852.png" alt="image-20210726210852720" loading="lazy"></p><h2 id="双端队列的定义"><a href="#双端队列的定义" class="headerlink" title="双端队列的定义"></a>双端队列的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726210904.png" alt="image-20210726210903964" loading="lazy"></p><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><h3 id="对于栈的输出序列的合法性"><a href="#对于栈的输出序列的合法性" class="headerlink" title="对于栈的输出序列的合法性"></a>对于栈的输出序列的合法性</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211212.png" alt="image-20210726211211957" loading="lazy"></p><p>绿色为合法，红色为非法</p><h3 id="对于输入受限的双端队列的输出序列的合法性"><a href="#对于输入受限的双端队列的输出序列的合法性" class="headerlink" title="对于输入受限的双端队列的输出序列的合法性"></a>对于输入受限的双端队列的输出序列的合法性</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211248.png" alt="image-20210726211247998" loading="lazy"></p><p>绿色为合法，红色为非法，带下划线是在栈中不合法，但在输入受限的双端队列中合法的。</p><h3 id="对于输出受限的双端队列"><a href="#对于输出受限的双端队列" class="headerlink" title="对于输出受限的双端队列"></a>对于输出受限的双端队列</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211310.png" alt="image-20210726211310281" loading="lazy"></p><p>绿色为合法，红色为非法，带下划线是在栈中不合法，但在输出受限的双端队列中合法</p><p>这种输出受限的双端队列，看序号较大的元素输出的位置，这意味着，在它输出之前，比它小的元素的相对位置是确定的，接下来就是考虑有什么插入的方法能实现这种相对位置关系！</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211326.png" alt="image-20210726211326371" loading="lazy"></p><h1 id="八、栈的应用"><a href="#八、栈的应用" class="headerlink" title="八、栈的应用"></a>八、栈的应用</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211346.png" alt="image-20210726211346767" loading="lazy"></p><h3 id="实际过程"><a href="#实际过程" class="headerlink" title="实际过程"></a>实际过程</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211355.png" alt="image-20210726211355389" loading="lazy"></p><h4 id="正好匹配"><a href="#正好匹配" class="headerlink" title="正好匹配"></a>正好匹配</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211417.png" alt="image-20210726211417509" loading="lazy"></p><h4 id="左右不匹配"><a href="#左右不匹配" class="headerlink" title="左右不匹配"></a>左右不匹配</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211427.png" alt="image-20210726211427595" loading="lazy"></p><h4 id="右括号单身"><a href="#右括号单身" class="headerlink" title="右括号单身"></a>右括号单身</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211437.png" alt="image-20210726211437034" loading="lazy"></p><h4 id="左括号单身"><a href="#左括号单身" class="headerlink" title="左括号单身"></a>左括号单身</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211447.png" alt="image-20210726211447361" loading="lazy"></p><h4 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211516.png" alt="image-20210726211516771" loading="lazy"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211553.png" alt="image-20210726211553287" loading="lazy"></p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211604.png" alt="image-20210726211604921" loading="lazy"></p><h2 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211622.png" alt="image-20210726211622556" loading="lazy"></p><h3 id="算数表达式是什么？"><a href="#算数表达式是什么？" class="headerlink" title="算数表达式是什么？"></a>算数表达式是什么？</h3><p>由三个部分组成（操作数，运算符，界限符）</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211634.png" alt="image-20210726211634409" loading="lazy"></p><h3 id="前-x2F-后缀表达式的诞生"><a href="#前-x2F-后缀表达式的诞生" class="headerlink" title="前&#x2F;后缀表达式的诞生"></a>前&#x2F;后缀表达式的诞生</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211644.png" alt="image-20210726211644195" loading="lazy"></p><h3 id="中-x2F-后-x2F-前缀表达式的区别"><a href="#中-x2F-后-x2F-前缀表达式的区别" class="headerlink" title="中&#x2F;后&#x2F;前缀表达式的区别"></a>中&#x2F;后&#x2F;前缀表达式的区别</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211654.png" alt="image-20210726211654826" loading="lazy"></p><h4 id="中转后的过程："><a href="#中转后的过程：" class="headerlink" title="中转后的过程："></a>中转后的过程：</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211703.png" alt="image-20210726211703851" loading="lazy"></p><p><strong>上图中，后缀表达式的算术符的先后次序对应中缀表达式的生效的先后次序</strong>，但是这是一定的吗？</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211716.png" alt="image-20210726211716650" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211814.png" alt="image-20210726211814054" loading="lazy"></p><p>左优先原则，可保证运算顺序唯一性，以确定机算算法输出结果的唯一性！!</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211824.png" alt="image-20210726211824944" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211929.png" alt="image-20210726211929334" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211942.png" alt="image-20210726211942205" loading="lazy"></p><h4 id="机算算法实现"><a href="#机算算法实现" class="headerlink" title="机算算法实现"></a>机算算法实现</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726211958.png" alt="image-20210726211958326" loading="lazy"> </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212059.png" alt="image-20210726212059658" loading="lazy"></p><h3 id="中转前的过程"><a href="#中转前的过程" class="headerlink" title="中转前的过程"></a>中转前的过程</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212125.png" alt="image-20210726212125015" loading="lazy"></p><p>中转后和中转前的区别：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212140.png" alt="image-20210726212140264" loading="lazy"></p><h4 id="中转前的机算过程："><a href="#中转前的机算过程：" class="headerlink" title="中转前的机算过程："></a>中转前的机算过程：</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212202.png" alt="image-20210726212202368" loading="lazy"></p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212315.png" alt="image-20210726212314936" loading="lazy"></p><p>“左优先”&#x2F;“右优先”原则和左&#x2F;右操作数不是专业说法，仅供理解！</p><h2 id="表达式求值——具体代码实现"><a href="#表达式求值——具体代码实现" class="headerlink" title="表达式求值——具体代码实现"></a>表达式求值——具体代码实现</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212335.png" alt="image-20210726212335434" loading="lazy"></p><h3 id="中转后机算"><a href="#中转后机算" class="headerlink" title="中转后机算"></a>中转后机算</h3><p>手算过程：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212356.png" alt="image-20210726212356303" loading="lazy"></p><p>机算过程：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212423.png" alt="image-20210726212423771" loading="lazy"></p><h3 id="中缀表达式的计算"><a href="#中缀表达式的计算" class="headerlink" title="中缀表达式的计算"></a>中缀表达式的计算</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212506.png" alt="image-20210726212506614" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212608.png" alt="image-20210726212608258" loading="lazy"></p><p>CPU只能执行单个的加减乘除运算，上边这么搞的意义就是为了将高级程序语言编译成简单的机器码，让CPU去执行！</p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212630.png" alt="image-20210726212630916" loading="lazy"></p><h2 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h2><p>递归的过程就是函数调用的过程</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212828.png" alt="image-20210726212828055" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212846.png" alt="image-20210726212846550" loading="lazy"></p><h3 id="适合用“递归”算法解决的问题"><a href="#适合用“递归”算法解决的问题" class="headerlink" title="适合用“递归”算法解决的问题"></a>适合用“递归”算法解决的问题</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212856.png" alt="image-20210726212856325" loading="lazy"></p><p>求阶乘：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212926.png" alt="image-20210726212926663" loading="lazy"></p><p><strong>使用递归时，需要注意调用栈溢出！</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212940.png" alt="image-20210726212940735" loading="lazy"></p><p><strong>可以自定义栈将递归算法改造成非递归算法！</strong></p><p>求斐波那契数列</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726212954.png" alt="image-20210726212954526" loading="lazy"></p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726213001.png" alt="image-20210726213001818" loading="lazy"></p><h1 id="九、队列的应用"><a href="#九、队列的应用" class="headerlink" title="九、队列的应用"></a>九、队列的应用</h1><h2 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h2><p>提示：不知道树这种数据结构的同学，可以考虑先跳过本文内容，等了解树之后，再来康康～</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726213113.png" alt="image-20210726213113786" loading="lazy"></p><p>详细实现内容在树的章节实现！</p><h2 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h2><p>遍历是指找出所有元素节点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726213124.png" alt="image-20210726213124384" loading="lazy"></p><h2 id="队列在操作系统中的应用"><a href="#队列在操作系统中的应用" class="headerlink" title="队列在操作系统中的应用"></a>队列在操作系统中的应用</h2><p><strong>CPU资源分配问题</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726213132.png" alt="image-20210726213132774" loading="lazy"></p><p><strong>打印数据缓冲区</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726213144.png" alt="image-20210726213144535" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串</title>
      <link href="/posts/58d9577e/"/>
      <url>/posts/58d9577e/</url>
      
        <content type="html"><![CDATA[<h1 id="一、串"><a href="#一、串" class="headerlink" title="一、串"></a>一、串</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005353.png" alt="image-20210727005353732" loading="lazy"></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005406.png" alt="image-20210727005406740" loading="lazy"></p><h2 id="串V-S线性表"><a href="#串V-S线性表" class="headerlink" title="串V.S线性表"></a>串V.S线性表</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005523.png" alt="image-20210727005523561" loading="lazy"></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005607.png" alt="image-20210727005607107" loading="lazy"></p><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005635.png" alt="image-20210727005635750" loading="lazy"></p><h3 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005701.png" alt="image-20210727005701467" loading="lazy"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005742.png" alt="image-20210727005742561" loading="lazy"></p><h1 id="二、存储结构"><a href="#二、存储结构" class="headerlink" title="二、存储结构"></a>二、存储结构</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005758.png" alt="image-20210727005758794" loading="lazy"></p><h2 id="顺序存储与堆分配存储"><a href="#顺序存储与堆分配存储" class="headerlink" title="顺序存储与堆分配存储"></a>顺序存储与堆分配存储</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005855.png" alt="image-20210727005855765" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005924.png" alt="image-20210727005924608" loading="lazy"></p><p>方案二的字符串长度不可以超过255</p><h2 id="块链存储"><a href="#块链存储" class="headerlink" title="块链存储"></a>块链存储</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727005953.png" alt="image-20210727005953465" loading="lazy"></p><h2 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010016.png" alt="image-20210727010016555" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010029.png" alt="image-20210727010029230" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010039.png" alt="image-20210727010038986" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010051.png" alt="image-20210727010051797" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010105.png" alt="image-20210727010105881" loading="lazy"></p><h1 id="三、模式匹配"><a href="#三、模式匹配" class="headerlink" title="三、模式匹配"></a>三、模式匹配</h1><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012517.jpg" alt="image-20200803220247955" loading="lazy"></p><h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012522.jpg" alt="image-20200803221038452" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012527.jpg" alt="image-20200803224601338" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012623.jpg" alt="image-20200803231428235" loading="lazy"></p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>最好时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012632.jpg" alt="image-20200803231735244" loading="lazy"></p><p>最坏时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012636.jpg" alt="image-20200803232029485" loading="lazy"></p><p>思想总结</p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012908.jpg" alt="image-20200803232154853" loading="lazy">四、KMP 算法</p><p>简单模式匹配的缺点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010646.png" alt="image-20210727010646197" loading="lazy"></p><p>改进思想</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010709.png" alt="image-20210727010709758" loading="lazy"></p><p>情况一</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010730.png" alt="image-20210727010730593" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010746.png" alt="image-20210727010746569" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010800.png" alt="image-20210727010759979" loading="lazy"></p><p>情况二</p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012945.jpg" alt="image-20200804224917143" loading="lazy"></p><p>情况三：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010926.png" alt="image-20210727010926790" loading="lazy"></p><p>4这里有可能多比较一次：因为4和6已经不等，但是1和6相同，这里仍会期待1和6相同，再进行一次比较，所以这里它并不是最优的算法，但是相比于朴素模式匹配，它还是少对比了两次</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010937.png" alt="image-20210727010937811" loading="lazy"></p><p>同理j指向3时少对比1次</p><p>总结：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010955.png" alt="image-20210727010955129" loading="lazy"></p><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011012.png" alt="image-20210727011012022" loading="lazy"></p><h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011116.png" alt="image-20210727011116270" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011214.png" alt="image-20210727011214643" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011236.png" alt="image-20210727011236014" loading="lazy"></p><h3 id="代码实现求next数组"><a href="#代码实现求next数组" class="headerlink" title="代码实现求next数组"></a>代码实现求next数组</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011246.png" alt="image-20210727011246482" loading="lazy"></p><h2 id="回顾总结"><a href="#回顾总结" class="headerlink" title="回顾总结"></a>回顾总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011258.png" alt="image-20210727011258409" loading="lazy"></p><h1 id="四、KMP-算法"><a href="#四、KMP-算法" class="headerlink" title="四、KMP 算法"></a>四、KMP 算法</h1><p>简单模式匹配的缺点</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010646.png" alt="image-20210727010646197" loading="lazy"></p><p>改进思想</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010709.png" alt="image-20210727010709758" loading="lazy"></p><p>情况一</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010730.png" alt="image-20210727010730593" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010746.png" alt="image-20210727010746569" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010800.png" alt="image-20210727010759979" loading="lazy"></p><p>情况二</p><p><img src="https://cdn.jsdelivr.net/gh/KimYangOfCat/MyPicStorage/2021-CSPostgraduate-408/20200810012945.jpg" alt="image-20200804224917143" loading="lazy"></p><p>情况三：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010926.png" alt="image-20210727010926790" loading="lazy"></p><p>4这里有可能多比较一次：因为4和6已经不等，但是1和6相同，这里仍会期待1和6相同，再进行一次比较，所以这里它并不是最优的算法，但是相比于朴素模式匹配，它还是少对比了两次</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010937.png" alt="image-20210727010937811" loading="lazy"></p><p>同理j指向3时少对比1次</p><p>总结：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727010955.png" alt="image-20210727010955129" loading="lazy"></p><h2 id="具体代码实现-1"><a href="#具体代码实现-1" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011012.png" alt="image-20210727011012022" loading="lazy"></p><h3 id="求next数组-1"><a href="#求next数组-1" class="headerlink" title="求next数组"></a>求next数组</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011116.png" alt="image-20210727011116270" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011214.png" alt="image-20210727011214643" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011236.png" alt="image-20210727011236014" loading="lazy"></p><h3 id="代码实现求next数组-1"><a href="#代码实现求next数组-1" class="headerlink" title="代码实现求next数组"></a>代码实现求next数组</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011246.png" alt="image-20210727011246482" loading="lazy"></p><h2 id="回顾总结-1"><a href="#回顾总结-1" class="headerlink" title="回顾总结"></a>回顾总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011258.png" alt="image-20210727011258409" loading="lazy"></p><h1 id="五、KMP-算法的优化"><a href="#五、KMP-算法的优化" class="headerlink" title="五、KMP 算法的优化"></a>五、KMP 算法的优化</h1><h2 id="KMP算法存在的问题"><a href="#KMP算法存在的问题" class="headerlink" title="KMP算法存在的问题"></a>KMP算法存在的问题</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011317.png" alt="image-20210727011317097" loading="lazy"></p><p>例子2：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011359.png" alt="image-20210727011359659" loading="lazy"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210727011418.png" alt="image-20210727011418148" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串 </tag>
            
            <tag> KMP </tag>
            
            <tag> 模式匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/posts/40f24371/"/>
      <url>/posts/40f24371/</url>
      
        <content type="html"><![CDATA[<h1 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h1><h2 id="线性表的基本概念"><a href="#线性表的基本概念" class="headerlink" title="线性表的基本概念"></a>线性表的基本概念</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165456.png" alt="image-20210726165456169" loading="lazy"><br>数据结构的三要素：逻辑结构、数据的运算、存储结构（物理结构)</p><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>线性表是具有相同数据类型的n(n&gt;&#x3D;0)个元素的有限序列。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165542.png" alt="image-20210726165542066" loading="lazy"></p><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210714142852.png" alt="image-20210714142852531" loading="lazy"></p><h2 id="什么时候要传入参数的引用“-amp-”？"><a href="#什么时候要传入参数的引用“-amp-”？" class="headerlink" title="什么时候要传入参数的引用“&amp;”？"></a>什么时候要传入参数的引用“&amp;”？</h2><p>一种是值类型，使用时会直接复制原值，修改参数不会影响原值</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165629.png" alt="image-20210726165629504" loading="lazy"></p><p>一种是引用类型，使用时操作的是原值，修改时直接修改原值！（C语言不支持这种引用类型！）</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165653.png" alt="image-20210726165653031" loading="lazy"></p><h2 id="为什么要实现对数据结构的基本操作？"><a href="#为什么要实现对数据结构的基本操作？" class="headerlink" title="为什么要实现对数据结构的基本操作？"></a>为什么要实现对数据结构的基本操作？</h2><ol><li>团队合作编程，你定义的数据结构要让别人能够很方便的使用（封装）</li><li>将常用的操作&#x2F;运算封装称函数，避免重复工作，降低出错风险。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165707.png" alt="image-20210726165707503" loading="lazy"></p><p>注意⚠️：位序是用1开始计算的！！！</p><h1 id="二、顺序表"><a href="#二、顺序表" class="headerlink" title="二、顺序表"></a>二、顺序表</h1><h3 id="顺序表的基本概念"><a href="#顺序表的基本概念" class="headerlink" title="顺序表的基本概念"></a>顺序表的基本概念</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165751.png" alt="image-20210726165751315" loading="lazy"></p><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165814.png" alt="image-20210726165814325" loading="lazy"></p><h3 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h3><h4 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165935.png" alt="image-20210726165934947" loading="lazy"></p><p>具体实现：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726165957.png" alt="image-20210726165957878" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//初始化(静态分配)</span><span class="token keyword">void</span> <span class="token function">InitList</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MaxSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//将所有元素的初始值默认设置为0</span>        <span class="token comment">//这一步其实可以省略，但是省略之后，有可能受到内存中"脏数据"的影响</span>    <span class="token punctuation">&#125;</span>    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h5><ol><li>如果“数组”存满留怎么办？</li></ol><p>可以放弃治疗，顺序表长刚开始确定后就无法更改（存储空间是静态的）</p><ol start="2"><li>如果一开始就声明一个很大的内存空间呢？会存在什么问题？</li></ol><p>浪费，会造成大量的浪费。</p><h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170057.png" alt="image-20210726170057124" loading="lazy"></p><p>具体实现方式</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170149.png" alt="image-20210726170149840" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//初始化（动态方式）</span>bool <span class="token function">InitList</span><span class="token punctuation">(</span>SeqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//用 malloc 函数申请一片连续的存储空间</span>    L<span class="token punctuation">.</span>data<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>InitSize<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token comment">//要细心呀，这里不小心写成了赋值语句，但是没有报错，找了半天错误！</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment">//(int *) 是指针的强制类型转换</span>    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    L<span class="token punctuation">.</span>MaxSize<span class="token operator">=</span>InitSize<span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170235.png" alt="image-20210726170235236" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170253.png" alt="image-20210726170253436" loading="lazy"></p><h3 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>ListInsert(&amp;L,i,e):插入操作。在表L中的第i个位置上插入指定元素e。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170337.png" alt="image-20210726170337008" loading="lazy"></p><p>详细实现方式：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170413.png" alt="image-20210726170413544" loading="lazy"></p><p>优化之后：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170444.png" alt="image-20210726170444785" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">ListInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//判断插入的位置是否合法，</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment">//判断表是否存满了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>length<span class="token operator">>=</span>MaxSize<span class="token punctuation">)</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token comment">//后面的元素后移</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">>=</span>i <span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>    L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插入操作的时间复杂度分析"><a href="#插入操作的时间复杂度分析" class="headerlink" title="插入操作的时间复杂度分析"></a>插入操作的时间复杂度分析</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170529.png" alt="image-20210726170529928" loading="lazy"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170624.png" alt="image-20210726170624021" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//删除</span>bool <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//判断i的位置是否合法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//取出将要被删除的数</span>    e<span class="token operator">=</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//将其后的数据前移</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//线性表长度减一</span>    L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="删除操作的时间复杂度分析"><a href="#删除操作的时间复杂度分析" class="headerlink" title="删除操作的时间复杂度分析"></a>删除操作的时间复杂度分析</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170650.png" alt="image-20210726170650571" loading="lazy"></p><h5 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170800.png" alt="image-20210726170800756" loading="lazy"></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h5><p>GetElem(L,i):按位查找操作，获取表L中第i个位置的元素的值</p><h6 id="静态分配状态下的实现方式"><a href="#静态分配状态下的实现方式" class="headerlink" title="静态分配状态下的实现方式"></a>静态分配状态下的实现方式</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726170924.png" alt="image-20210726170924353" loading="lazy"></p><h6 id="动态分配状态下的实现方式"><a href="#动态分配状态下的实现方式" class="headerlink" title="动态分配状态下的实现方式"></a>动态分配状态下的实现方式</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171024.png" alt="image-20210726171023978" loading="lazy"></p><p>用指针加数组下标的方式取数据的时候，数组类型决定着取数据时取几个字节！！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//按位查找</span><span class="token keyword">int</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>SeqList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//判断是否越界</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>i<span class="token operator">></span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="按位查找的时间复杂度分析"><a href="#按位查找的时间复杂度分析" class="headerlink" title="按位查找的时间复杂度分析"></a>按位查找的时间复杂度分析</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171108.png" alt="image-20210726171108725" loading="lazy"></p><h5 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171207.png" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//按值查找</span><span class="token keyword">int</span> <span class="token function">LocateElem</span><span class="token punctuation">(</span>SeqList L<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//循环出查找</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>e<span class="token punctuation">)</span>            <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//返回位序</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="结构类型的比较"><a href="#结构类型的比较" class="headerlink" title="结构类型的比较"></a>结构类型的比较</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171356.png" alt="image-20210726171356300" loading="lazy"></p><p>注意：考研初试中华，手写代码可以直接用“&#x3D;&#x3D;”，无论是ElemType是基本数据类型还是结构类型，手写代码主要考察学生是否理解算法思想，不会严格要求代码完全可运行</p><p>有的学校复试考《C语言程序设计》，那么。。。也许就要语法严格一些！</p><h6 id="按值查找的时间复杂度"><a href="#按值查找的时间复杂度" class="headerlink" title="按值查找的时间复杂度"></a>按值查找的时间复杂度</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171428.png" alt="image-20210726171428131" loading="lazy"></p><p>总结反思</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171447.png" alt="image-20210726171447192" loading="lazy"></p><h1 id="三、单链表"><a href="#三、单链表" class="headerlink" title="三、单链表"></a>三、单链表</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171938.png" alt="image-20210726171938045" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726171956.png" alt="image-20210726171956844" loading="lazy"></p><h2 id="什么是单链表？"><a href="#什么是单链表？" class="headerlink" title="什么是单链表？"></a>什么是单链表？</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726172046.png" alt="image-20210726172046492" loading="lazy"></p><h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726172308.png" alt="image-20210726172308710" loading="lazy"></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726172356.png" alt="image-20210726172355951" loading="lazy"></p><p><img src="C:/Users/king/AppData/Roaming/Typora/typora-user-images/image-20210726173031900.png" alt="image-20210726173031900" loading="lazy"></p><p>注释：或者可以理解为指向头节点的指针既可以表示整个单链表也可以表示头节点，为了便于区分才建议使用 typedef 进行重命名，以方便区别其不同的含义</p><h3 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h3><p><img src="C:/Users/king/AppData/Roaming/Typora/typora-user-images/image-20210726173037377.png" alt="image-20210726173037377" loading="lazy"></p><h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><h3 id="单链表的初始化"><a href="#单链表的初始化" class="headerlink" title="单链表的初始化"></a>单链表的初始化</h3><h4 id="不带头节点的单链表的初始化"><a href="#不带头节点的单链表的初始化" class="headerlink" title="不带头节点的单链表的初始化"></a>不带头节点的单链表的初始化</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173251.png" alt="image-20210726173251759" loading="lazy"></p><h4 id="带头节点的单链表的初始化"><a href="#带头节点的单链表的初始化" class="headerlink" title="带头节点的单链表的初始化"></a>带头节点的单链表的初始化</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173316.png" alt="image-20210726173316379" loading="lazy"></p><h4 id="两者区别是什么？"><a href="#两者区别是什么？" class="headerlink" title="两者区别是什么？"></a>两者区别是什么？</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173350.png" alt="image-20210726173350478" loading="lazy"></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173409.png" alt="image-20210726173409650" loading="lazy"></p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173426.png" alt="image-20210726173426154" loading="lazy"></p><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><h5 id="按位序插入（带头节点的单链表）"><a href="#按位序插入（带头节点的单链表）" class="headerlink" title="按位序插入（带头节点的单链表）"></a>按位序插入（带头节点的单链表）</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173553.png" alt="image-20210726173553880" loading="lazy"></p><h6 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h6><p>分析在表头插入</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173606.png" alt="image-20210726173606226" loading="lazy"></p><p>分析为什么不能颠倒</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173644.png" alt="image-20210726173627335" loading="lazy"></p><p>分析在表中插入</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173755.png" alt="image-20210726173755324" loading="lazy"></p><p>分析在表尾插入</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726173822.png" alt="image-20210726173814139" loading="lazy"></p><p>分析插入位置超出表长</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726174511.png" alt="image-20210726174510989" loading="lazy"></p><h6 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726174525.png" alt="image-20210726174524978" loading="lazy"></p><h5 id="按位插入（不带头节点）"><a href="#按位插入（不带头节点）" class="headerlink" title="按位插入（不带头节点）"></a>按位插入（不带头节点）</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726174651.png" alt="image-20210726174651203" loading="lazy"></p><p>具体实现</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726174722.png" alt="image-20210726174722358" loading="lazy"></p><p>结论：不带头节点的单链表，写代码更不方便，除非特别声明，默认推荐使用带头节点的实现方式，还有要注意在考试中带头、不带头都有可能考察，注意审题。</p><h6 id="指定节点的后插操作"><a href="#指定节点的后插操作" class="headerlink" title="指定节点的后插操作"></a>指定节点的后插操作</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726174829.png" alt="image-20210726174829417" loading="lazy"></p><h6 id="指定节点的前插操作"><a href="#指定节点的前插操作" class="headerlink" title="指定节点的前插操作"></a>指定节点的前插操作</h6><p>通过传入头指针实现前插</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726174907.png" alt="image-20210726174907717" loading="lazy"></p><p>先进行后插，然后交换前后数据，以此实现前插</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726175051.png" alt="image-20210726175051748" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726175110.png" alt="image-20210726175109994" loading="lazy"></p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h5 id="带有头节点版本"><a href="#带有头节点版本" class="headerlink" title="带有头节点版本"></a>带有头节点版本</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726175540.png" alt="image-20210726175540485" loading="lazy"></p><p>具体实现</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726175558.png" alt="image-20210726175558302" loading="lazy"></p><h6 id="删除指定结点"><a href="#删除指定结点" class="headerlink" title="删除指定结点"></a>删除指定结点</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726175752.png" alt="image-20210726175752937" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726175620.png" alt="image-20210726175620098" loading="lazy"></p><p>如果P是最后一个节点，咋办？</p><p>只能从表头表头依次寻找前驱，时间复杂度O(n)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726175657.png" alt="image-20210726175657466" loading="lazy"></p><p>单链表的局限性：无法逆向检索！！</p><h6 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h6><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180212.png" alt="image-20210726180212442" loading="lazy"></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180022.png" alt="image-20210726180022284" loading="lazy"></p><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><h5 id="按位查找-带头节点"><a href="#按位查找-带头节点" class="headerlink" title="按位查找(带头节点)"></a>按位查找(带头节点)</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180425.png" alt="image-20210726180424982" loading="lazy"></p><h5 id="按值查找-带头节点"><a href="#按值查找-带头节点" class="headerlink" title="按值查找(带头节点)"></a>按值查找(带头节点)</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180601.png" alt="image-20210726180601573" loading="lazy"></p><h5 id="求表的长度-带头节点"><a href="#求表的长度-带头节点" class="headerlink" title="求表的长度(带头节点)"></a>求表的长度(带头节点)</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180633.png" alt="image-20210726180633120" loading="lazy"></p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180647.png" alt="image-20210726180647007" loading="lazy"></p><h2 id="单链表的建立方法"><a href="#单链表的建立方法" class="headerlink" title="单链表的建立方法"></a>单链表的建立方法</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180723.png" alt="image-20210726180722977" loading="lazy"></p><p>PS：找不到对象就娶一个数据元素吧！哈哈</p><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>第一种方法：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180757.png" alt="image-20210726180756970" loading="lazy"></p><p>问题：时间复杂度太高！！可以用一个指针记录最后一个数据元素的位置来优化时间。</p><p>优化之后:</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180832.png" alt="image-20210726180831940" loading="lazy"></p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180918.png" alt="image-20210726180918378" loading="lazy"></p><p>具体实现：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726180959.png" alt="image-20210726180959158" loading="lazy"></p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726181011.png" alt="image-20210726181011287" loading="lazy"></p><h1 id="四、双链表"><a href="#四、双链表" class="headerlink" title="四、双链表"></a>四、双链表</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183619.png" alt="image-20210726183619952" loading="lazy"></p><h2 id="单链表VS双链表"><a href="#单链表VS双链表" class="headerlink" title="单链表VS双链表"></a>单链表VS双链表</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183634.png" alt="image-20210726183634075" loading="lazy"></p><h2 id="双链表基本操作"><a href="#双链表基本操作" class="headerlink" title="双链表基本操作"></a>双链表基本操作</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183648.png" alt="image-20210726183648351" loading="lazy"></p><h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183702.png" alt="image-20210726183702070" loading="lazy"></p><p>优化之后</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183719.png" alt="image-20210726183719251" loading="lazy"></p><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183736.png" alt="image-20210726183736686" loading="lazy"></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183755.png" alt="image-20210726183755465" loading="lazy"></p><h2 id="总结反思-1"><a href="#总结反思-1" class="headerlink" title="总结反思"></a>总结反思</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183805.png" alt="image-20210726183805516" loading="lazy"></p><h1 id="五、循环链表"><a href="#五、循环链表" class="headerlink" title="五、循环链表"></a>五、循环链表</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183828.png" alt="image-20210726183828015" loading="lazy"></p><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183837.png" alt="image-20210726183837306" loading="lazy"></p><p>具体实现：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183919.png" alt="image-20210726183919767" loading="lazy"></p><p>优势：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183938.png" alt="image-20210726183938049" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183945.png" alt="image-20210726183945708" loading="lazy"></p><h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726183959.png" alt="image-20210726183959302" loading="lazy"></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184008.png" alt="image-20210726184007969" loading="lazy"></p><h3 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184017.png" alt="image-20210726184017781" loading="lazy"></p><h3 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h3><p><img src="C:/Users/king/AppData/Roaming/Typora/typora-user-images/image-20210726184031060.png" alt="image-20210726184031060" loading="lazy"></p><h2 id="总结反思-2"><a href="#总结反思-2" class="headerlink" title="总结反思"></a>总结反思</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184109.png" alt="image-20210726184109253" loading="lazy"></p><h1 id="六、静态链表"><a href="#六、静态链表" class="headerlink" title="六、静态链表"></a>六、静态链表</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184147.png" alt="image-20210726184147026" loading="lazy"></p><h2 id="什么是静态链表？"><a href="#什么是静态链表？" class="headerlink" title="什么是静态链表？"></a>什么是静态链表？</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184226.png" alt="image-20210726184225973" loading="lazy"></p><h2 id="定义一个静态链表"><a href="#定义一个静态链表" class="headerlink" title="定义一个静态链表"></a>定义一个静态链表</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184303.png" alt="image-20210726184303172" loading="lazy"></p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2:"></a>方法2:</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184338.png" alt="image-20210726184338410" loading="lazy"></p><h3 id="验证方法2的定义方法"><a href="#验证方法2的定义方法" class="headerlink" title="验证方法2的定义方法"></a>验证方法2的定义方法</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184446.png" alt="image-20210726184446751" loading="lazy"></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184539.jpeg" alt="image-20200620162512284" loading="lazy"></p><h3 id="总结反思-3"><a href="#总结反思-3" class="headerlink" title="总结反思"></a>总结反思</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184543.jpeg" alt="image-20200620162709709" loading="lazy"></p><h1 id="七、线性表章节复习反思"><a href="#七、线性表章节复习反思" class="headerlink" title="七、线性表章节复习反思"></a>七、线性表章节复习反思</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184720.png" alt="image-20210726184719982" loading="lazy"></p><h2 id="逻辑结构对比"><a href="#逻辑结构对比" class="headerlink" title="逻辑结构对比"></a>逻辑结构对比</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184743.png" alt="image-20210726184743873" loading="lazy"></p><h2 id="存储结构对比"><a href="#存储结构对比" class="headerlink" title="存储结构对比"></a>存储结构对比</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184758.png" alt="image-20210726184757954" loading="lazy"></p><h2 id="基本操作对比"><a href="#基本操作对比" class="headerlink" title="基本操作对比"></a>基本操作对比</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184809.png" alt="image-20210726184809121" loading="lazy"></p><h3 id="初始化-创建"><a href="#初始化-创建" class="headerlink" title="初始化(创建)"></a>初始化(创建)</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184828.png" alt="image-20210726184828780" loading="lazy"></p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184903.png" loading="lazy"></p><h3 id="增加-x2F-删除"><a href="#增加-x2F-删除" class="headerlink" title="增加&#x2F;删除"></a>增加&#x2F;删除</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184923.png" alt="image-20210726184923124" loading="lazy"></p><h3 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184934.png" alt="image-20210726184934771" loading="lazy"></p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726184946.png" alt=" " loading="lazy"></p><p>具体使用时，需要根据具体场景去选择</p><h2 id="开放式答题的思路"><a href="#开放式答题的思路" class="headerlink" title="开放式答题的思路"></a>开放式答题的思路</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726185015.png" alt="image-20210726185015579" loading="lazy"> </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构介绍</title>
      <link href="/posts/aa22783f/"/>
      <url>/posts/aa22783f/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据结构基本概念"><a href="#一、数据结构基本概念" class="headerlink" title="一、数据结构基本概念"></a>一、数据结构基本概念</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200509.png" alt="image-20210726200509343" loading="lazy"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h3><p>数据是<strong>信息的载体</strong>，是客观描述事物属性的数、字符及<strong>所有能输入到计算机中并被计算机程序识别和处理的符号</strong>的集合。数据是计算机程序加工的原料。</p><h3 id="数据元素、数据项"><a href="#数据元素、数据项" class="headerlink" title="数据元素、数据项"></a>数据元素、数据项</h3><p><strong>数据元素</strong>是数据的基本单位，通常作为一个整体进行考虑和处理。</p><p>一个数据元素可由若干<strong>数据项</strong>组成，数据项是构成数据元素的不可分割的最小单位。</p><h3 id="数据结构、数据对象"><a href="#数据结构、数据对象" class="headerlink" title="数据结构、数据对象"></a>数据结构、数据对象</h3><p>结构——各个元素之间的关系</p><p><strong>数据结构</strong>是互相之间存在一个或多种<strong>特定关系</strong>的数据元素的集合。</p><p><strong>数据对象</strong>是具有<strong>相同性质</strong>的数据元素的集合，是一个数据的子集。</p><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200527.png" alt="image-20210726200527173" loading="lazy"></p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>即，数据元素之间的逻辑关系是什么？</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200541.png" alt="image-20210726200540987" loading="lazy"></p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200609.png" alt="image-20210726200609408" loading="lazy"></p><p>各个数据元素同属一个集合，别无其它关系</p><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200618.png" alt="image-20210726200618276" loading="lazy"></p><p>数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继</p><h4 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200636.png" alt="image-20210726200636442" loading="lazy"></p><p>数据元素之间是一对多的关系</p><h4 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200645.png" alt="image-20210726200645453" loading="lazy"></p><p>数据元素之间是多对多的关系</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>即，物理结构，如何用计算机表示数据元素的逻辑关系？</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200707.png" alt="image-20210726200707924" loading="lazy"></p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200719.png" alt="image-20210726200719555" loading="lazy"></p><p><strong>把逻辑上相邻的元素存储在物理地址上也相邻的存储单元中</strong>，元素之间的关系由存储单元的领接关系来体现。</p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200805.png" alt="image-20210726200805000" loading="lazy"></p><h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200814.png" alt="image-20210726200814419" loading="lazy"></p><h4 id="散列存储"><a href="#散列存储" class="headerlink" title="散列存储"></a>散列存储</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200822.png" alt="image-20210726200822932" loading="lazy"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726200832.png" alt="image-20210726200832057" loading="lazy"></p><ol><li>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺存储，则各个数据元素在物理上是可以离散的</li><li>数据的存储结构会影响存储空间的分配的方便程度</li><li>数据的存储机构会影响对数据运算的速度</li></ol><h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，正对运算的功能；运算的实现是针对存储结构的，指的是运算实现的具体操作步骤。</p><h2 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型是一个值的集合和定义在此集合的一组操作的总称。</p><ol><li>原子类型，其值不可再分的数据类型</li><li>结构类型，其值可以再分解为若干成分（分量）的数据类型</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201240.png" alt="image-20210726201240691" loading="lazy"></p><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>Abstract Data Type （ADT）是抽象数据组织及与之相关的操作。</p><p>ADT 是用数学化的语言定义数据的逻辑结构、定义运算。与其具体的实现无关（类似于定义类吗？可能）</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201255.png" alt="image-20210726201255574" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201308.png" alt="image-20210726201308420" loading="lazy"></p><p>在探讨一种数据结构时：</p><ol><li>定义逻辑结构（数据原元素之间的关系）</li><li>定义数据的运算（针对现实需求，应该对这种逻辑结构进行什么样的运算）</li><li>确定某种存储结构，实现数据结构，并实现一些对数据结构的基本运算</li></ol><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201324.png" alt="image-20210726201324448" loading="lazy"></p><h1 id="二、算法基本概念"><a href="#二、算法基本概念" class="headerlink" title="二、算法基本概念"></a>二、算法基本概念</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201355.png" alt="image-20210726201355477" loading="lazy"></p><h3 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h3><p>程序&#x3D;数据结构+算法</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201405.png" alt="image-20210726201405765" loading="lazy"></p><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><ol><li><p>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</p><p> 注：算法必须是有穷的，二程序可以是无穷的。</p><p> <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201458.png" alt="image-20210726201458768" loading="lazy"></p></li><li><p>确定性：算法每一条指令必须有确切的含义，对于相同的输入只能得出相同的输出</p></li><li><p>可行性：算法描述的操作都可以通过已经实现的基本运算执行有限次来实现。</p></li><li><p>输入：一个算法有0个或多个输入，这些输入取自某个特定对象的集合。</p></li><li><p>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</p><p> 五个特性，缺一不可</p></li></ol><h3 id="“好”算法的特质"><a href="#“好”算法的特质" class="headerlink" title="“好”算法的特质"></a>“好”算法的特质</h3><ol><li>正确性：算法应能正确地解决求解问题。</li><li>可读性：算法应具有良好的可读性，帮助人们理解。</li><li>健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li><li>高效率与底存储量需求：执行速度快，时间复杂度低。不费内存，空间复杂度低。</li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201634.png" alt="image-20210726201634464" loading="lazy"></p><h2 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201657.png" alt="image-20210726201657396" loading="lazy"></p><h3 id="如何评估算法时间开销？"><a href="#如何评估算法时间开销？" class="headerlink" title="如何评估算法时间开销？"></a>如何评估算法时间开销？</h3><p><strong>让算法先运行，事后统计运行时间？</strong></p><p>存在的问题？</p><ul><li>和机器性能有关，比如：超级计算机VS单片机</li><li>和编程语言有关，越高级的语言执行效率越低，没错，就是越低</li><li>和编译程序产生的机器指令质量有关</li><li>有些算法是不能事后统计的，比如，导弹控制算法。</li></ul><p>评价一个算法优劣时，需要排除与算法本身无关的外界因素，能否事先估计？</p><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><ul><li>最坏时间复杂度：最坏情况下算法的时间复杂度</li><li>平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间</li><li>最好时间复杂度：最好情况下算法的时间复杂度</li></ul><p>事前预估算法时间开销T(n)与问题规模n的关系（T 表示 time）</p><p>如何计算T，例子：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201717.png" alt="image-20210726201717301" loading="lazy"></p><h4 id="问题1-是否可以忽略表达式某些部分？"><a href="#问题1-是否可以忽略表达式某些部分？" class="headerlink" title="问题1:是否可以忽略表达式某些部分？"></a>问题1:是否可以忽略表达式某些部分？</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201727.png" alt="image-20210726201727765" loading="lazy"></p><ol><li><p>加法规则：多项相加，只保留最高阶的项，且系数变为1</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201751.png" alt="image-20210726201751782" loading="lazy"></p></li><li><p>乘法规则：多项相乘，都保留</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201812.png" alt="image-20210726201812765" loading="lazy"></p></li></ol><p>算法时间复杂度阶数顺序</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201823.png" alt="image-20200617000121744" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201931.png" alt="image-20210726201931069" loading="lazy"></p><h4 id="如果有好几千行代码，需要一行一行数？"><a href="#如果有好几千行代码，需要一行一行数？" class="headerlink" title="如果有好几千行代码，需要一行一行数？"></a>如果有好几千行代码，需要一行一行数？</h4><ol><li>顺序执行的代码只会影响常数项，可以忽略</li><li>只需要挑循环中的一个基本操作，分析它的执行次数和n的关系就好</li><li>如果有多层嵌套循环，只需要关注最深层的循环循环了几次</li></ol><h4 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726201948.png" alt="image-20210726201948853" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202012.png" alt="image-20210726202012483" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202053.png" alt="image-20210726202053679" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202104.png" alt="image-20210726202104892" loading="lazy"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202344.png" alt="image-20210726202344903" loading="lazy"></p><p>算法的性能问题只有在n很大时才会暴露出来。</p><h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><h4 id="原地工作算法"><a href="#原地工作算法" class="headerlink" title="原地工作算法"></a>原地工作算法</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202415.png" alt="image-20210726202414955" loading="lazy"></p><p>分析空间复杂度时，只需关注与问题规模相关的变量就好（讲人话，就是，看程序中的变量就好）</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202426.png" alt="image-20210726202426514" loading="lazy"></p><p>加法法则</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202443.png" alt="image-20210726202443429" loading="lazy"></p><h4 id="函数递归调用带来的内存开销"><a href="#函数递归调用带来的内存开销" class="headerlink" title="函数递归调用带来的内存开销"></a>函数递归调用带来的内存开销</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202555.png" alt="image-20210726202555477" loading="lazy"></p><p>在这种情况下，空间复杂度等于递归调用的深度。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202614.png" alt="image-20210726202614295" loading="lazy"></p><p>递归调用的过程中，每一次开辟的内存空间也可以不一致，如上例。</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210726202626.png" alt="image-20210726202626115" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zigbee单播通信</title>
      <link href="/posts/b142e803/"/>
      <url>/posts/b142e803/</url>
      
        <content type="html"><![CDATA[<h1 id="一、单播通信理论"><a href="#一、单播通信理论" class="headerlink" title="一、单播通信理论"></a>一、单播通信理论</h1><p>（1）Zigbee网络通信方式有4种：单播，广播，组播，绑定(MAC)。</p><p>（2）单播通信的特点:在Zigbee网络里，模块之间要进行通信，发射模块要明确知道接收模块的网络地址。</p><p>（3）Zigbee模块的地址特点:模块在加入网络的时候，父节点随机分配网络地址给子节点。但是协调器模块在)网络里的地址永远都是0x00。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528085917.png" alt="image-20210528085917105" loading="lazy"></p><p><strong>单播发送数据需要明确的信息</strong>：<br>    (1)目标地址<br>    (2)目标端点与簇<br>    (3)要发送的数据大小</p><p><strong>应用任务层数据发送函数</strong></p><p>该函数在GenericApp.c里的GenericApp_SendTheMessage函数里：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">AF_DataRequest</span><span class="token punctuation">(</span>              <span class="token operator">&amp;</span>GenericApp_DstAddr<span class="token punctuation">,</span> <span class="token comment">//目标的网络地址指针</span>              <span class="token operator">&amp;</span>GenericApp_epDesc<span class="token punctuation">,</span><span class="token comment">//端点描述符指针</span>              GENERICAPP_CLUSTERID<span class="token punctuation">,</span><span class="token comment">//目标簇</span>              <span class="token punctuation">(</span>byte<span class="token punctuation">)</span><span class="token function">osal_strlen</span><span class="token punctuation">(</span> theMessageData <span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token comment">//发送数据的大小</span>              <span class="token punctuation">(</span>byte <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>theMessageData<span class="token punctuation">,</span><span class="token comment">//发送数据缓冲区的地址</span>              <span class="token operator">&amp;</span>GenericApp_TransID<span class="token punctuation">,</span><span class="token comment">//这是个全局变量，用来保存发送的次数</span>              AF_DISCV_ROUTE<span class="token punctuation">,</span> AF_DEFAULT_RADIUS <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送路径，don't care</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210529101718.png" alt="image-20210529101711143" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528090054.png" alt="image-20210528090054641" loading="lazy"></p><p><strong>网络地址结构体</strong></p><p>网络地址结构体就是定义在GenericApp.c前面的一个结构体变量，该类型为afAddrType_t，系统已经默认定义了一个网络地址结构体变量GenericApp_DstAddr，我们可以在GenericApp_Init()函数中，对网络地址结构体变量的成员进行赋值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//网络地址结构体:</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>      <span class="token keyword">union</span>     <span class="token punctuation">&#123;</span>            uint16      shortAddr<span class="token punctuation">;</span><span class="token comment">//网络地址</span>            ZLongAddr_t extAddr<span class="token punctuation">;</span> <span class="token comment">//MAC地址</span>     <span class="token punctuation">&#125;</span> addr<span class="token punctuation">;</span>     <span class="token class-name">afAddrMode_t</span> addrMode<span class="token punctuation">;</span><span class="token comment">//通信模式</span>     byte endPoint<span class="token punctuation">;</span> <span class="token comment">//指定的端点</span>     uint16 panId<span class="token punctuation">;</span>  <span class="token comment">//don't care</span><span class="token punctuation">&#125;</span> <span class="token class-name">afAddrType_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//通信模式枚举类型:</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>        afAddrNotPresent <span class="token operator">=</span> AddrNotPresent<span class="token punctuation">,</span><span class="token comment">//当前不确定</span>        afAddr16Bit      <span class="token operator">=</span> Addr16Bit<span class="token punctuation">,</span><span class="token comment">//单播通信模式</span>        afAddr64Bit      <span class="token operator">=</span> Addr64Bit<span class="token punctuation">,</span><span class="token comment">//MAC通信模式</span>        afAddrGroup      <span class="token operator">=</span> AddrGroup<span class="token punctuation">,</span><span class="token comment">//组播通信模式</span>        afAddrBroadcast  <span class="token operator">=</span> AddrBroadcast<span class="token comment">//广播通信模式</span><span class="token punctuation">&#125;</span> <span class="token class-name">afAddrMode_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210529102118.png" alt="image-20210529102118365" loading="lazy"></p><h1 id="二、端点与簇"><a href="#二、端点与簇" class="headerlink" title="二、端点与簇"></a>二、端点与簇</h1><h2 id="1-端点"><a href="#1-端点" class="headerlink" title="1.端点"></a>1.端点</h2><p>(1)通常发送的数据要明确该数据是给接收模块的哪个任务层用的，而这个就是用端点来指定的</p><p>(2)端点是一个字节的编号，通常为定义在GenericApp.h中的一个宏。端点必须要与任务层绑定，而这个就是用端点描述符来实现的。</p><p>(3)端点描述符是一个结构体变量，该变量定义在GenericApp.c开头，我们也可以定义新的端点描述符。该结构体的类型为 endPointDesc_t，系统也默认定义了一个端点描述符GenericApp_epDesc。</p><p>(4)我们可以在 GenericApp_Init()函数中，把新的端点描述符变量赋值，使新的端点与某个任务层绑定。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//端点结构体类型:</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>       byte endPoint<span class="token punctuation">;</span><span class="token comment">//端点的值</span>       byte <span class="token operator">*</span>task_id<span class="token punctuation">;</span>  <span class="token comment">//与端点绑定的任务层ID</span>       SimpleDescriptionFormat_t <span class="token operator">*</span>simpleDesc<span class="token punctuation">;</span><span class="token comment">//端点的描述信息,don’t care</span>       <span class="token class-name">afNetworkLatencyReq_t</span> latencyReq<span class="token punctuation">;</span><span class="token comment">//don’t care</span><span class="token punctuation">&#125;</span> <span class="token class-name">endPointDesc_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-簇"><a href="#2-簇" class="headerlink" title="2.簇"></a>2.簇</h2><p>(1)在接收模块中，每个任务层可以对不同种类的数据采取不同的处理方式，这里的数据种类就是簇(CLUSTER)</p><p>(2)在发送模块中，簇是定义在GenericApp.h中的一个宏，我们也可以定义新的簇。</p><p>(3) 系统也默认定义了一个簇 GenericApp_CLUSTERID，在GenericApp.h中</p><h1 id="三、-应用任务层数据发送接收API"><a href="#三、-应用任务层数据发送接收API" class="headerlink" title="三、 应用任务层数据发送接收API"></a>三、 应用任务层数据发送接收API</h1><p>(1)该函数为GenericApp.c中的void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210529115258.png" alt="image-20210529115258491" loading="lazy"></p><p>(2)在switch语句中可以定义对不同的簇采用不同的方式处理数据</p><p>(3)该函数中的pkt-&gt;cmd.Data就是接收数据的首地址</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528090956.png" alt="image-20210528090956245" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> ZigBee </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
            <tag> 单播通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zigbee无线通信与网络组建</title>
      <link href="/posts/121b6cd5/"/>
      <url>/posts/121b6cd5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-无线通信理论"><a href="#一、-无线通信理论" class="headerlink" title="一、 无线通信理论"></a>一、 无线通信理论</h1><p>Zigbee无线通信，需要高频的载波来提供发射频率，Zigbee模块之间要可以正常通信，接收模块和发送模块的频率要一致。</p><p>​    Zigbee有27个载波可以进行通信，载波又叫做信道。这些载波的频率落在某些频率区段，我们把这些区段叫做频段。</p><p>​        2.4G频段                        16个信道<br>​        915M频段     896M频段   11个信道</p><p>​    但TI的所有支持Zigbee底层协议的芯片只能在2.4G频段的16个信道里进行通信。即11<del>26信道(0</del>10信道在915M和896M的频段内)</p><p><strong>网络地址</strong>：<br>    在Zigbee无线局域网里，每一个模块都有一个在该网络里唯一的2个字节的地址，这个地址我们叫做网络地址(或者叫做网络短地址)。</p><p><strong>PANID</strong>：<br>    这也是一个2个字节的编号，用来区分不用的Zigbee无线局域网，我们称为个域网ID。两个模块之间要进行通信，PANID一定要一样。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528084644.png" alt="image-20210528084643979" loading="lazy"></p><p><strong>信道与PANID的设置</strong>：<br>    在Tools文件组里的f8wConfig.cfg文件中<br>    (1)设置信道<br>        -DDEFAULT_CHANLIST&#x3D;0x00000800  &#x2F;&#x2F; 11 - 0x0B<br>    (2)设置PANID<br>        -DZDAPP_CONFIG_PAN_ID&#x3D;0x1234<br>注意:如果把PANID设置为0xFFFF,则意味着该模块不受PANID的限制</p><h1 id="二、-网络组建理论"><a href="#二、-网络组建理论" class="headerlink" title="二、 网络组建理论"></a>二、 网络组建理论</h1><p>在Zigbee无线局域网里，节点(无线模块)按照在网络里的功能可以划分为：协调器、路由器、终端这三种角色。<br>    它们的硬件可以是一模一样的，之所以在网络里表现出不同的功能，是因为它们下载了不同功能版本的程序，在同一个网络里担当了不同的角色功能。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528084808.png" alt="image-20210528084807987" loading="lazy"></p><p>​    下载了路由器和终端代码的模块，它们上电后的第一件事情去寻找网络，请求加入。然而网络不会无缘无故产生，是由下载了协调器代码的模块创建的。<br>​    下载了协调器代码的模块上电后的第一件事就是创建网络。<br>     任何一个网络里，第一个节点一定是该网络的协调器，<strong>有且只能有一个协调器</strong>。</p><p>​    如果有一个协调器创建了一个网络ID是0x1234，还有一个协调器也创建了一个网络ID为0x1234，此时后面创建的网络ID加一，即为0x1235。</p><p>​    任何一个Zigbee模块要加入到某个网络，一定要一个处于该网络里的节点作为介绍人，并且这个介绍人不能是终端节点(即路由器或者协调器)。在加入网络以后，介绍人节点和被介绍加入的节点互为父子关系。    介绍人是被介绍人的父节点，被介绍人是介绍人的、子节点。有多个可作为介绍人资格的节点，会选择信号强度高的节点作为介绍人。</p><p>​    协调器在创建完网络后，在网络里的功能与路由器没有任何区别，只不过协调器的网络地址比较特殊只能是0x0000，而其他加入的节点的网络地址是动态分配的。<br>​    终端节点与其他模块的通信必须要通过它的父节点，而路由器(协调器)之间通信可以直接通信的。<br>   因此，<strong>路由器在网络里充当的是拓扑扩展的中转站的功能</strong>。</p><h1 id="三、Zigbee三种网络架构"><a href="#三、Zigbee三种网络架构" class="headerlink" title="三、Zigbee三种网络架构"></a>三、Zigbee三种网络架构</h1><h2 id="1-星形拓扑"><a href="#1-星形拓扑" class="headerlink" title="1.星形拓扑"></a>1.星形拓扑</h2><p>​    星形拓扑是最简单的一种拓扑形式，他包含一个Co-ordinator（协调者） 节点和一系列的 End Device（终端）节点。每一个End Device 节点只能和 Co-ordinator 节点进行通讯。如果需要在两个 End Device 节点之间进行通讯必须通过Co-ordinator 节点进行信息的转发。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528085042.png" alt="image-20210528085042404" loading="lazy"></p><h2 id="2-树形拓扑"><a href="#2-树形拓扑" class="headerlink" title="2.树形拓扑"></a>2.树形拓扑</h2><p>​    树形拓扑包括一个Co-ordinator（协调者）以及一系列的 Router（路由器） 和 End Device（终端）节点。Co-ordinator 连接一系列的 Router 和 End Device， 他的子节点的 Router也可以连接一系列的 Router 和End Device. 这样可以重复多个层级。树形拓扑的结构如下图所示：       </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528085105.png" alt="image-20210528085105782" loading="lazy"></p><h2 id="3-Mesh拓扑（网状拓扑）"><a href="#3-Mesh拓扑（网状拓扑）" class="headerlink" title="3.Mesh拓扑（网状拓扑）"></a>3.Mesh拓扑（网状拓扑）</h2><p>​    Mesh拓扑（网状拓扑） 包含一个Co-ordinator和一系列的Router 和End Device。这种网络拓扑形式和树形拓扑相同；请参考上面所提到的树形网络拓扑。但是，网状网络拓扑具有更加灵活的信息路由规则，在可能的情况下，路由节点之间可以直接的通讯。这种路由机制使得信息的通讯变得更有效率，而且意味这一旦一个路由路径出现了问题，信息可以自动的沿着其他的路由路径进行传输。 网状拓扑的示意图如下所示：       </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528085155.png" alt="image-20210528085155248" loading="lazy"></p><h2 id="4-三种网络架构对比"><a href="#4-三种网络架构对比" class="headerlink" title="4.三种网络架构对比"></a>4.三种网络架构对比</h2><p>​        MESH 网状网络拓扑结构的网络具有强大的功能，网络可以通过“多级跳”的方式来通信；该拓扑结构还可以组成极为复杂的网络；网络还具备自组织、自愈功能；<br>​        星型和族树型网络适合点多多点、距离相对较近的应用。<br>​       我们可以在 “nwk_globals.h” 文件中159行进行修改网络结构，默认为网状拓扑结构。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210528085251.png" alt="image-20210528085251909" loading="lazy"></p><p>​    我们可以在GenericApp.c文件中的GenericApp_ProcessEvent函数中的switch语句的 case ZDO_STATE_CHANGE中修改代码内容，让模块在不同的网络状态下亮不同的灯。</p><p>​    注意:下载了协调器的代码的模块，创建了网络之后就是协调器状态，而终端和路由器要加入了网络才是对应的状态。终端和路由器要加入网络的条件是，信道和PANID要一致。</p>]]></content>
      
      
      <categories>
          
          <category> ZigBee </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
            <tag> 自动组网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zstack协议栈</title>
      <link href="/posts/3fbe36e5/"/>
      <url>/posts/3fbe36e5/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Zstack协议栈概述"><a href="#一、Zstack协议栈概述" class="headerlink" title="一、Zstack协议栈概述"></a>一、Zstack协议栈概述</h1><h2 id="什么是Zstack协议栈"><a href="#什么是Zstack协议栈" class="headerlink" title="什么是Zstack协议栈"></a>什么是Zstack协议栈</h2><p>为了使Zigbee的开发更加简单高效，TI公司推出了基于cc2530芯片的协议栈Z-STACK.协议栈的实质就是能实现各个功能的实例框架代码，我们想要实现自己的功能程序，只需要在协议栈的基础上修改或添加即可。</p><ul><li>​    Z-STACK的发展</li><li>​    由0.01版本 到 1.5.1a..</li><li>​    mesh: 之前的升级版本</li><li>​    HA:  家庭自动化(智能家居)</li><li>​    SE:  智能能源</li></ul><p>​    ….他们的区别是应用部分不同(初学者建议用早期的版本)</p><h1 id="二、Zstack协议栈结构"><a href="#二、Zstack协议栈结构" class="headerlink" title="二、Zstack协议栈结构"></a>二、Zstack协议栈结构</h1><p>​      Z-Stack协议栈符合ZigBee协议，由物理层、MAC层、网络层和应用层组成，由于Z-Stack协议栈是一个半开源的协议栈，MAC层和网络层的部分源代码是非开源的，因此我们学习的开源部分，主要包括main函数、APP层、ZDO层、NWK层和HAL层。</p><h2 id="1-工程目录结构"><a href="#1-工程目录结构" class="headerlink" title="1.工程目录结构"></a>1.工程目录结构</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130146.png" alt="image-20210526141312372" loading="lazy"></p><p><strong>APP</strong>： 应用层目录， 这是用户创建各种不同工程的区域， 在这个目录中包含了应用层的内容和这个项目的主要内容， 在协议栈里面一般是以操作系统的任务实现的。<br><strong>HAL</strong>： 硬件层目录， 包含有与硬件相关的配置和驱动及操作函数。<br><strong>MAC</strong>： MAC 层目录， 包含了 MAC 层的参数配置文件及其 MAC 的 LIB 库的函数接口文件。<br><strong>MT</strong>： 监控调试层， 主要用于调试目的， 即实现通过串口调试各层， 与各层进行直接交互。<br><strong>NWK</strong>： 网络层目录， 含网络层配置参数文件及网络层库的函数接口文件， APS 层库的函数接口。<br><strong>OSAL</strong>： 协议栈的操作系统。<br><strong>Profile</strong>： AF 层目录， 包含 AF 层处理函数文件。<br><strong>Security</strong>： 安全层目录， 安全层处理函数接口文件， 比如加密函数等。<br><strong>Services</strong>： 地址处理函数目录， 包括着地址模式的定义及地址处理函数。<br><strong>Tools</strong>： 工程配置目录， 包括空间划分及 ZStack 相关配置信息。<br><strong>ZDO</strong>： ZDO 目录。<br><strong>ZMac</strong>： MAC 层目录， 包括 MAC 层参数配置及 MAC 层 LIB 库函数回调处理函数。<br><strong>ZMain</strong>： 主函数目录， 包括入口函数 main（ ） 及硬件配置文件。<br><strong>Output</strong>： 输出文件目录， 这个 EW8051 IDE 自动生成的。    </p><h2 id="2-main函数解析"><a href="#2-main函数解析" class="headerlink" title="2.main函数解析"></a>2.main函数解析</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/* 关闭所有中断*/</span><span class="token function">osal_int_disable</span><span class="token punctuation">(</span> INTS_ALL <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 初始化硬件设备*/</span><span class="token function">HAL_BOARD_INIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*电源检测*/</span><span class="token function">zmain_vdd_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*初始化I/O*/</span><span class="token function">InitBoard</span><span class="token punctuation">(</span> OB_COLD <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*初始化硬件抽象层HAL驱动*/</span><span class="token function">HalDriverInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*初始化NV*/</span><span class="token function">osal_nv_init</span><span class="token punctuation">(</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*初始化 MAC*/</span><span class="token function">ZMacInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*确定64位IEEE地址*/</span><span class="token function">zmain_ext_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*初始化NV向量*/</span><span class="token function">zgInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">NONWK</span></span><span class="token comment">/* AF层初始化/afInit();#endif/*初始化任务*/</span><span class="token function">osal_init_system</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*开启中断*/</span><span class="token function">osal_int_enable</span><span class="token punctuation">(</span> INTS_ALL <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*硬件I/O初始化完毕*/</span><span class="token function">InitBoard</span><span class="token punctuation">(</span> OB_READY <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">zmain_dev_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 如果定义了LCD，初始化LCD */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">LCD_SUPPORTED</span></span><span class="token function">zmain_lcd_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">WDT_IN_PM1</span></span><span class="token comment">/* 如果定义了看门狗，看门狗使能 */</span><span class="token function">WatchDogEnable</span><span class="token punctuation">(</span> WDTIMX <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*操作系统运行*/</span><span class="token function">osal_start_system</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong>osal_int_disable()</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint8 <span class="token function">osal_int_disable</span><span class="token punctuation">(</span> uint8 interrupt_id <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/*判断ID是否为中断ID*/</span><span class="token keyword">if</span> <span class="token punctuation">(</span> interrupt_id <span class="token operator">==</span> INTS_ALL <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/*关掉所有中断*/</span><span class="token function">HAL_DISABLE_INTERRUPTS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*中断关闭成功，返回SUCCESS */</span><span class="token keyword">return</span> <span class="token punctuation">(</span> SUCCESS <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">/*如果ID与INST_ALL不同，返回INVALID_INTERRUPT_ID*/</span><span class="token keyword">return</span> <span class="token punctuation">(</span> INVALID_INTERRUPT_ID <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-APP层解析"><a href="#3-APP层解析" class="headerlink" title="3.APP层解析"></a>3.APP层解析</h2><p>OSAL_SampleApp.c中包含osalInitTasks()与taskArr[]。</p><p><strong>osalInitTasks()函数主要功能是为任务分配空间</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">osalInitTasks</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    uint8 taskID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    tasksEvents <span class="token operator">=</span> <span class="token punctuation">(</span>uint16 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">osal_mem_alloc</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> uint16 <span class="token punctuation">)</span> <span class="token operator">*</span> tasksCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">osal_memset</span><span class="token punctuation">(</span> tasksEvents<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span> uint16 <span class="token punctuation">)</span> <span class="token operator">*</span> tasksCnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">macTaskInit</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">nwk_init</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Hal_Init</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span> MT_TASK <span class="token punctuation">)</span></span></span>    <span class="token function">MT_TaskInit</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token function">APS_Init</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span> ZIGBEE_FRAGMENTATION <span class="token punctuation">)</span></span></span>    <span class="token function">APSF_Init</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token function">ZDApp_Init</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span> ZIGBEE_FREQ_AGILITY <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span> <span class="token punctuation">(</span> ZIGBEE_PANID_CONFLICT <span class="token punctuation">)</span></span></span>    <span class="token function">ZDNwkMgr_Init</span><span class="token punctuation">(</span> taskID<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token function">SampleApp_Init</span><span class="token punctuation">(</span> taskID <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130152.png" alt="image-20210526142358533" loading="lazy"></p><p><strong>OSAL_SampleApp.c</strong></p><p><strong>tasksArr中存放了事件处理回调函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> pTaskEventHandlerFn tasksArr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    macEventLoop<span class="token punctuation">,</span>    nwk_event_loop<span class="token punctuation">,</span>    Hal_ProcessEvent<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span> MT_TASK <span class="token punctuation">)</span></span></span>    MT_ProcessEvent<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    APS_event_loop<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span> ZIGBEE_FRAGMENTATION <span class="token punctuation">)</span></span></span>    APSF_ProcessEvent<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    ZDApp_event_loop<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span> ZIGBEE_FREQ_AGILITY <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">defined</span> <span class="token punctuation">(</span> ZIGBEE_PANID_CONFLICT <span class="token punctuation">)</span></span></span>    ZDNwkMgr_event_loop<span class="token punctuation">,</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    SampleApp_ProcessEvent<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130157.png" alt="image-20210526142515869" loading="lazy"></p><p><strong>Z-Stack协议栈的APP层主要功能是实现用户定义的事件，APP层由5个文件组成</strong>    </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130201.png" alt="image-20210526142553502" loading="lazy"></p><blockquote><p>  SamplApp.c文件主要有两个功能：<br>      (1)对应用层用户定义的任务<br>      (2)进行初始化；调用事件处理函数。</p></blockquote><ul><li>用户任务初始化函数SampleApp_Init()</li><li>任务处理函数SampleApp_ProcessEvent()</li><li>按键处理事件SampleApp_HandleKeys()</li><li>数据发送函数SampleApp_SendFlashMessage()</li><li>数据发送函数SampleApp_SendPeriodicMessage()</li><li>数据接收函数SampleApp_MessageMSGCB()</li></ul><p><strong>SampleApp_Init()</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">SampleApp_Init</span><span class="token punctuation">(</span> uint8 task_id <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    SampleApp_TaskID <span class="token operator">=</span> task_id<span class="token punctuation">;</span>    SampleApp_NwkState <span class="token operator">=</span> DEV_INIT<span class="token punctuation">;</span>    SampleApp_TransID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span> BUILD_ALL_DEVICES <span class="token punctuation">)</span></span></span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">readCoordinatorJumper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>        zgDeviceLogicalType <span class="token operator">=</span> ZG_DEVICETYPE_COORDINATOR<span class="token punctuation">;</span>    <span class="token keyword">else</span>        zgDeviceLogicalType <span class="token operator">=</span> ZG_DEVICETYPE_ROUTER<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span> HOLD_AUTO_START <span class="token punctuation">)</span></span></span>    <span class="token function">ZDOInitDevice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token comment">/*SampleApp_Periodic_DstAddr地址模式初始化为广播地址*/</span>    SampleApp_Periodic_DstAddr<span class="token punctuation">.</span>addrMode <span class="token operator">=</span>    <span class="token punctuation">(</span><span class="token class-name">afAddrMode_t</span><span class="token punctuation">)</span>AddrBroadcast<span class="token punctuation">;</span>    <span class="token comment">/* SampleApp_Periodic_DstAddr端点初始化*/</span>    SampleApp_Periodic_DstAddr<span class="token punctuation">.</span>endPoint <span class="token operator">=</span> SAMPLEAPP_ENDPOINT<span class="token punctuation">;</span>    SampleApp_Periodic_DstAddr<span class="token punctuation">.</span>addr<span class="token punctuation">.</span>shortAddr <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>    SampleApp_Flash_DstAddr<span class="token punctuation">.</span>addrMode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">afAddrMode_t</span><span class="token punctuation">)</span>afAddrGroup<span class="token punctuation">;</span>    SampleApp_Flash_DstAddr<span class="token punctuation">.</span>endPoint <span class="token operator">=</span> SAMPLEAPP_ENDPOINT<span class="token punctuation">;</span>    SampleApp_Flash_DstAddr<span class="token punctuation">.</span>addr<span class="token punctuation">.</span>shortAddr <span class="token operator">=</span> SAMPLEAPP_FLASH_GROUP<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130206.png" alt="image-20210526143651898" loading="lazy"></p><p><strong>SampleApp_Init()</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SampleApp_epDesc<span class="token punctuation">.</span>endPoint <span class="token operator">=</span> SAMPLEAPP_ENDPOINT<span class="token punctuation">;</span>SampleApp_epDesc<span class="token punctuation">.</span>task_id <span class="token operator">=</span> <span class="token operator">&amp;</span>SampleApp_TaskID<span class="token punctuation">;</span>SampleApp_epDesc<span class="token punctuation">.</span>simpleDesc<span class="token operator">=</span> <span class="token punctuation">(</span>SimpleDescriptionFormat_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>SampleApp_SimpleDesc<span class="token punctuation">;</span>SampleApp_epDesc<span class="token punctuation">.</span>latencyReq <span class="token operator">=</span> noLatencyReqs<span class="token punctuation">;</span><span class="token function">afRegister</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>SampleApp_epDesc <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">RegisterForKeys</span><span class="token punctuation">(</span> SampleApp_TaskID <span class="token punctuation">)</span><span class="token punctuation">;</span>SampleApp_Group<span class="token punctuation">.</span>ID <span class="token operator">=</span> <span class="token number">0x0001</span><span class="token punctuation">;</span><span class="token function">osal_memcpy</span><span class="token punctuation">(</span> SampleApp_Group<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"Group 1"</span><span class="token punctuation">,</span> <span class="token number">7</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">aps_AddGroup</span><span class="token punctuation">(</span> SAMPLEAPP_ENDPOINT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>SampleApp_Group <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span> LCD_SUPPORTED <span class="token punctuation">)</span></span></span><span class="token function">HalLcdWriteString</span><span class="token punctuation">(</span> <span class="token string">"SampleApp"</span><span class="token punctuation">,</span> HAL_LCD_LINE_1 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130210.png" alt="image-20210526143749526" loading="lazy"></p><p><strong>SampleApp_ProcessEvent()</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130215.png" alt="image-20210526143838169" loading="lazy"></p><p><strong>SampleApp_ProcessEvent()</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130219.png" alt="image-20210526143903337" loading="lazy"></p><p><strong>SampleApp_HandleKeys()</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130223.png" alt="image-20210526143922288" loading="lazy"></p><p><strong>SampleApp_MessageMSGCB()</strong></p><p>SampleApp_MessageMSGCB()函数主要实现数据接收功能，数据的接收通过判断簇ID来<br>与发送端发送的数据进行匹配。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130227.png" alt="image-20210526144842589" loading="lazy"></p><p><strong>SampleApp_SendPeriodicMessage()</strong></p><p>SampleApp_SendPeriodicMessage()函数主要功能是实现周期性数据的发送，通过调用<br>AF_DataRequest()函数进行数据的发送。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130231.png" alt="image-20210526144912513" loading="lazy"></p><p><strong>SampleApp.h</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130234.png" alt="image-20210526144937850" loading="lazy"></p><h2 id="4-ZDO层解析"><a href="#4-ZDO层解析" class="headerlink" title="4.ZDO层解析"></a>4.ZDO层解析</h2><p><strong>目录结构</strong></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130239.png" alt="image-20210526145815215" loading="lazy"></p><p>ZDApp_Init()函数：初始化ZDO网络设备短地址；获得64位IEEE地址信息；ZDO层初始化；网络设备启动。</p><h2 id="5-NWK层解析"><a href="#5-NWK层解析" class="headerlink" title="5.NWK层解析"></a>5.NWK层解析</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h3><p><img src="https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210527185136.png" alt="image-20210527185136679" loading="lazy"></p><h3 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a><strong>网络拓扑结构</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*星型网络*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NWK_MODE_STAR</span>         <span class="token expression"><span class="token number">0</span></span></span><span class="token comment">/*树型网络*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NWK_MODE_TREE</span>         <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">/*网状网络*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NWK_MODE_MESH</span>         <span class="token expression"><span class="token number">2</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="网络参数设置"><a href="#网络参数设置" class="headerlink" title="网络参数设置"></a><strong>网络参数设置</strong></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*协议栈模式参数*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NETWORK_SPECIFIC</span>      <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HOME_CONTROLS</span>         <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZIGBEEPRO_PROFILE</span>    <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GENERIC_STAR</span>          <span class="token expression"><span class="token number">3</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GENERIC_TREE</span>          <span class="token expression"><span class="token number">4</span></span></span><span class="token comment">/*信道设置*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_CHANNELS_868MHZ</span>     <span class="token expression"><span class="token number">0x00000001</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_CHANNELS_915MHZ</span>     <span class="token expression"><span class="token number">0x000007FE</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_CHANNELS_24GHZ</span>      <span class="token expression"><span class="token number">0x07FFF800</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-HAL层解析"><a href="#6-HAL层解析" class="headerlink" title="6.HAL层解析"></a>6.HAL层解析</h2><p><img src="https://raw.githubusercontent.com/Editblog/PicGo/main/img/20210527185224.png" alt="20210527184135.png" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">HAL目录Common：实现了硬件初始化函数<span class="token function">Hal_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、硬件抽象层驱动初始化<span class="token function">HalDriverInit</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>函数和硬件抽象层事件处理函数<span class="token function">Hal_ProcessEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；Include：中主要包含了硬件资源的定义与函数声明；Target：主要为LED等硬件资源进行配置、实现硬件资源的实现函数；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Hal_Init()函数主要为硬件抽象层注册任务ID</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Hal_Init</span><span class="token punctuation">(</span> uint8 task_id <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/* 注册任务 ID */</span>Hal_TaskID <span class="token operator">=</span> task_id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HalDriverInit()函数主要实现硬件资源的初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HalDriverInit</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/*定时器初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_TIMER<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_TIMER <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalTimerInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*ADC初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_ADC<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_ADC <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalAdcInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*DMA初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_DMA<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_DMA <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalDmaInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*Flash初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_FLASH<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_FLASH <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalFlashInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*AES初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_AES<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_AES <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalAesInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*LCD初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_LCD<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_LCD <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalLcdInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*LED初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_LED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_LED <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalLedInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*UART初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_UART<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_UART <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalUARTInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*KEY按键初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_KEY<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_KEY <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalKeyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/*SPI初始化*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_SPI<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_SPI <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalSpiInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HHal_ProcessEvent()函数由APP层OSAL_SampleApp.c文件调用，主要实现硬件抽象层的各种事件处理，比如系统消息事件、LED闪烁事件、按键事件和睡眠模式事件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint16 <span class="token function">Hal_ProcessEvent</span><span class="token punctuation">(</span> uint8 task_id<span class="token punctuation">,</span> uint16 events <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>uint8 <span class="token operator">*</span>msgPtr<span class="token punctuation">;</span><span class="token comment">/*系统消息事件*/</span><span class="token keyword">if</span> <span class="token punctuation">(</span> events <span class="token operator">&amp;</span> SYS_EVENT_MSG <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>msgPtr <span class="token operator">=</span> <span class="token function">osal_msg_receive</span><span class="token punctuation">(</span>Hal_TaskID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>msgPtr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">osal_msg_deallocate</span><span class="token punctuation">(</span> msgPtr <span class="token punctuation">)</span><span class="token punctuation">;</span>msgPtr <span class="token operator">=</span> <span class="token function">osal_msg_receive</span><span class="token punctuation">(</span> Hal_TaskID <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> events <span class="token operator">^</span> SYS_EVENT_MSG<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*LED闪烁事件*/</span><span class="token keyword">if</span> <span class="token punctuation">(</span> events <span class="token operator">&amp;</span> HAL_LED_BLINK_EVENT <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">defined</span> <span class="token punctuation">(</span>BLINK_LEDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_LED <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token function">HalLedUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* BLINK_LEDS &amp;&amp; HAL_LED */</span></span><span class="token keyword">return</span> events <span class="token operator">^</span> HAL_LED_BLINK_EVENT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*按键事件*/</span><span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> HAL_KEY_EVENT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>defined HAL_KEY<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HAL_KEY <span class="token operator">==</span> TRUE<span class="token punctuation">)</span></span></span><span class="token comment">/* Check for keys */</span><span class="token function">HalKeyPoll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Hal_KeyIntEnable<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">osal_start_timerEx</span><span class="token punctuation">(</span> Hal_TaskID<span class="token punctuation">,</span> HAL_KEY_EVENT<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token keyword">return</span> events <span class="token operator">^</span> HAL_KEY_EVENT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*睡眠模式*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">POWER_SAVING</span></span><span class="token keyword">if</span> <span class="token punctuation">(</span> events <span class="token operator">&amp;</span> HAL_SLEEP_TIMER_EVENT <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">halRestoreSleepLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> events <span class="token operator">^</span> HAL_SLEEP_TIMER_EVENT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    HTarget hal_board_cfg.h文件中为硬件资源LED等进行配置，在官方的协议栈中定义了3个LED，分别接CC2530的P1_0、P1_1和P1_4引脚。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* LED1配置 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_BV</span>           <span class="token expression"><span class="token function">BV</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_SBIT</span>         <span class="token expression">P1_0</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_DDR</span>          <span class="token expression">P1DIR</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1_POLARITY</span>     <span class="token expression">ACTIVE_HIGH</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">HAL_BOARD_CC2530EB_REV17</span></span>  <span class="token comment">/* LED2配置 */</span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED2_BV</span>           <span class="token expression"><span class="token function">BV</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED2_SBIT</span>         <span class="token expression">P1_1</span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED2_DDR</span>          <span class="token expression">P1DIR</span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED2_POLARITY</span>     <span class="token expression">ACTIVE_HIGH</span></span>   <span class="token comment">/* LED3配置 */</span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED3_BV</span>           <span class="token expression"><span class="token function">BV</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED3_SBIT</span>         <span class="token expression">P1_4</span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED3_DDR</span>          <span class="token expression">P1DIR</span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED3_POLARITY</span>     <span class="token expression">ACTIVE_HIGH</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制LED开关状态。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span> <span class="token punctuation">(</span>HAL_BOARD_CC2530EB_REV17<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">defined</span> <span class="token punctuation">(</span>HAL_PA_LNA<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">defined</span> <span class="token punctuation">(</span>HAL_PA_LNA_CC2590<span class="token punctuation">)</span></span></span><span class="token comment">/*打开LED*/</span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_OFF_LED1</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">st</span><span class="token punctuation">(</span> LED1_SBIT <span class="token operator">=</span> <span class="token function">LED1_POLARITY</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_OFF_LED2</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">st</span><span class="token punctuation">(</span> LED2_SBIT <span class="token operator">=</span> <span class="token function">LED2_POLARITY</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_OFF_LED3</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">st</span><span class="token punctuation">(</span> LED3_SBIT <span class="token operator">=</span> <span class="token function">LED3_POLARITY</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_OFF_LED4</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token function">HAL_TURN_OFF_LED1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token comment">/*关闭LED*/</span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_ON_LED1</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">st</span><span class="token punctuation">(</span> LED1_SBIT <span class="token operator">=</span> <span class="token function">LED1_POLARITY</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_ON_LED2</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">st</span><span class="token punctuation">(</span> LED2_SBIT <span class="token operator">=</span> <span class="token function">LED2_POLARITY</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_ON_LED3</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">st</span><span class="token punctuation">(</span> LED3_SBIT <span class="token operator">=</span> <span class="token function">LED3_POLARITY</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TURN_ON_LED4</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">HAL_TURN_ON_LED1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token comment">/*LED状态改变*/</span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TOGGLE_LED1</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token function">st</span><span class="token punctuation">(</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>LED1_SBIT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> LED1_SBIT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> LED1_SBIT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TOGGLE_LED2</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token function">st</span><span class="token punctuation">(</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>LED2_SBIT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> LED2_SBIT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> LED2_SBIT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TOGGLE_LED3</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token function">st</span><span class="token punctuation">(</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>LED3_SBIT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> LED3_SBIT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> LED3_SBIT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_TOGGLE_LED4</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token function">HAL_TOGGLE_LED1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>   <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_STATE_LED1</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">LED1_POLARITY</span> <span class="token punctuation">(</span>LED1_SBIT<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_STATE_LED2</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">LED2_POLARITY</span> <span class="token punctuation">(</span>LED2_SBIT<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_STATE_LED3</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span><span class="token function">LED3_POLARITY</span> <span class="token punctuation">(</span>LED3_SBIT<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HAL_STATE_LED4</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token function">HAL_STATE_LED1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在Drives文件中定义了硬件资源的驱动函数文件</p><ul><li><strong>LED</strong>：在hal_led.c文件中实现，为LED提供驱动函数；</li><li><strong>ADC</strong>：在hal_adc.c文件中实现，为ADC提供驱动函数；</li><li><strong>KEY</strong>：在hal_key.c文件中实现，为按键提供驱动函数；</li><li><strong>LCD</strong>：在hal_LCD.c文件中实现，为LCD提供驱动函数；</li><li><strong>定时器</strong>：在hal_timer.c文件中实现，为定时器提供驱动函数；</li><li><strong>串口</strong>：在hal_uart.c文件中实现，为串口提供驱动函数；</li><li><strong>DMA</strong>：在hal_dma.c文件中实现，为DMA提供驱动函数；</li><li><strong>flash</strong>：在hal_flash.c文件中实现，为flash提供驱动函数。</li></ul><p>APP应用层调用LED设置函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">HalLedSet</span><span class="token punctuation">(</span>uint8 leds<span class="token punctuation">,</span>uint8 mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">HalLedBlink</span><span class="token punctuation">(</span>uint8 leds<span class="token punctuation">,</span>uint8 numBlink<span class="token punctuation">,</span>uint8 percend<span class="token punctuation">,</span>uint16 period<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20210527185047.png" alt="image-20210527185047722" loading="lazy"></p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> ZigBee </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
            <tag> 协议栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zigbee串口通信</title>
      <link href="/posts/d1180c9/"/>
      <url>/posts/d1180c9/</url>
      
        <content type="html"><![CDATA[<h1 id="一、串口通信原理"><a href="#一、串口通信原理" class="headerlink" title="一、串口通信原理"></a>一、串口通信原理</h1><h2 id="1-什么是UART"><a href="#1-什么是UART" class="headerlink" title="1.什么是UART"></a>1.什么是UART</h2><p>​      UART : Universal Asynchronous  Receiver&#x2F;Transmitter  通用异步收发器<br>​    一种常用也是最简单的串行数据传输协议。数据线只需要两根就可以实现全双工。<br>​    Tx:发送数据线<br>​    Rx:接收数据线<br>​        A                B<br>​        Tx &lt;———–&gt; Rx<br>​        Rx &lt;———–&gt; Tx<br>​        GND&lt;———–&gt; GND</p><h2 id="2-上位机与下位机"><a href="#2-上位机与下位机" class="headerlink" title="2.上位机与下位机"></a>2.上位机与下位机</h2><p>​         模块之间的通信,根据其在系统中的功能与作用可分为上位机 与 下位机。</p><p>上位机：<br>    把处理性能强的计算机称为上位机。数据的统一处理都在上位机完成。</p><p>下位机：<br>    把数据采集和发送的终端，处理性能单一的计算机，称为下位机。</p><p>一般一个上位机会对应多个下位机，这种模式可以使数据处理的更加全面，同时也大大降低成本。</p><h2 id="3-UART数据帧"><a href="#3-UART数据帧" class="headerlink" title="3.UART数据帧"></a>3.UART数据帧</h2><p>UART protocol  串口协议<br>    串口发送和接收数据是以帧为单位，Frame</p><pre><code>1帧(Frame) = 1start bit(起始位) + 5~9bits数据位 + 0/1bit校验位 + stop bits(0.5,1,1.5)停止位起始位：一个周期的低电平数据位：5~9bits数据位，具体是多少bits，需要双方协商，并且传送先传送最低位(LSB)校验位：    0bit：没有校验    1bit：有校验        奇校验：数据位+校验位的这一段数据里的1的个数是奇数。        偶校验：数据位+校验位的这一段数据里的1的个数是偶数。停止位：高电平        1个停止位            Baudrate(波特率):传输速率，即没一个秒传输了多少个bit位    4800    9600    115200bps: bits per second</code></pre><h1 id="二、串口配置"><a href="#二、串口配置" class="headerlink" title="二、串口配置"></a>二、串口配置</h1><h2 id="1-串口初始化相关的结构体halUARTCfg-t"><a href="#1-串口初始化相关的结构体halUARTCfg-t" class="headerlink" title="1.    串口初始化相关的结构体halUARTCfg_t"></a>1.    串口初始化相关的结构体halUARTCfg_t</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>  bool                configured<span class="token punctuation">;</span><span class="token comment">//是否设置串口</span>  uint8               baudRate<span class="token punctuation">;</span> <span class="token comment">//波特率设置</span>  bool                flowControl<span class="token punctuation">;</span><span class="token comment">//控制流设置</span>  uint16              flowControlThreshold<span class="token punctuation">;</span><span class="token comment">//RX缓存安全字节数(了解)</span>  uint8               idleTimeout<span class="token punctuation">;</span><span class="token comment">//RX来数据超时时间(了解)</span>  <span class="token class-name">halUARTBufControl_t</span> rx<span class="token punctuation">;</span><span class="token comment">//接收数据长度</span>  <span class="token class-name">halUARTBufControl_t</span> tx<span class="token punctuation">;</span><span class="token comment">//发送数据长度</span>  bool                intEnable<span class="token punctuation">;</span><span class="token comment">//中断使能</span>  uint32              rxChRvdTime<span class="token punctuation">;</span><span class="token comment">//接收数据时间</span>  <span class="token class-name">halUARTCBack_t</span>      callBackFunc<span class="token punctuation">;</span><span class="token comment">//回调函数</span><span class="token punctuation">&#125;</span><span class="token class-name">halUARTCfg_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-串口初始化示例"><a href="#2-串口初始化示例" class="headerlink" title="2. 串口初始化示例"></a>2. 串口初始化示例</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">InitUart</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">halUARTCfg_t</span>   uartConfig<span class="token punctuation">;</span>uartConfig<span class="token punctuation">.</span>configured           <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>  <span class="token comment">//</span>uartConfig<span class="token punctuation">.</span>baudRate             <span class="token operator">=</span> HAL_UART_BR_38400<span class="token punctuation">;</span>uartConfig<span class="token punctuation">.</span>flowControl          <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>uartConfig<span class="token punctuation">.</span>flowControlThreshold <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span> uartConfig<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>maxBufSize        <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>  uartConfig<span class="token punctuation">.</span>tx<span class="token punctuation">.</span>maxBufSize        <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>  uartConfig<span class="token punctuation">.</span>idleTimeout          <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    uartConfig<span class="token punctuation">.</span>intEnable            <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>                uartConfig<span class="token punctuation">.</span>callBackFunc         <span class="token operator">=</span> SerialApp_CallBack<span class="token punctuation">;</span>   <span class="token function">HalUARTOpen</span> <span class="token punctuation">(</span>SERIAL_APP_PORT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uartConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-串口实现"><a href="#3-串口实现" class="headerlink" title="3.串口实现"></a>3.串口实现</h2><p>​        串口的读操作函数为HalUARTRead()，主要功能是读取上位机通过串口发送至设备节点的数据。</p><p>​    uint16 HalUARTRead(uint8 port, uint8 *buf, uint16 len)<br>​    @port：串口端口的设置，可以设置为串口0或串口1；<br>​    @buf：数据缓冲区；<br>​    @len：数据长度。<br>​    返回值:实际成功读取的字节数</p><p>串口的<strong>读</strong>操作函数为**HalUARTRead()**，主要功能是读取上位机通过串口发送至设备节点的数据。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint16 <span class="token function">HalUARTRead</span><span class="token punctuation">(</span>uint8 port<span class="token punctuation">,</span> uint8 <span class="token operator">*</span>buf<span class="token punctuation">,</span> uint16 len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_DMA <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_0<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTReadDMA</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_DMA <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_1<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTReadDMA</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_ISR <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_0<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTReadISR</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_ISR <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_1<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTReadISR</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">HAL_UART_USB</span></span>  <span class="token keyword">return</span> <span class="token function">HalUARTRx</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  串口的<strong>写</strong>操作函数为**HalUARTWrite()**，主要功能是实现向上位机或其他设备通过串口发送数据。<br>    uint16 HalUARTWrite(uint8 port, uint8 *buf, uint16 len)<br>    @port：串口端口的设置，可以设置为串口0或串口1；<br>    @buf：数据缓冲区；<br>    @len：数据长度。<br>    返回值:实际成功发送的字节数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">uint16 <span class="token function">HalUARTWrite</span><span class="token punctuation">(</span>uint8 port<span class="token punctuation">,</span> uint8 <span class="token operator">*</span>buf<span class="token punctuation">,</span> uint16 len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_DMA <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_0<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTWriteDMA</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_DMA <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_1<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTWriteDMA</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_ISR <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_0<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTWriteISR</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>HAL_UART_ISR <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">==</span> HAL_UART_PORT_1<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token function">HalUARTWriteISR</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">HAL_UART_USB</span></span>  <span class="token function">HalUARTTx</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、程序设计"><a href="#三、程序设计" class="headerlink" title="三、程序设计"></a>三、程序设计</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">SerialApp_CallBack</span><span class="token punctuation">(</span>uint8 port<span class="token punctuation">,</span> uint8 event<span class="token punctuation">)</span>   <span class="token comment">//接收数据会触发</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">HalUARTRead</span><span class="token punctuation">(</span>HAL_UART_PORT_0<span class="token punctuation">,</span>buf<span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">led_ctrl</span><span class="token punctuation">(</span>LED0<span class="token punctuation">,</span>LED_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">led_ctrl</span><span class="token punctuation">(</span>LED1<span class="token punctuation">,</span>LED_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">,</span><span class="token string">"byebye"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">led_ctrl</span><span class="token punctuation">(</span>LED0<span class="token punctuation">,</span>LED_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">led_ctrl</span><span class="token punctuation">(</span>LED1<span class="token punctuation">,</span>LED_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">InitUart</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">halUARTCfg_t</span>   uartConfig<span class="token punctuation">;</span>uartConfig<span class="token punctuation">.</span>configured           <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>  uartConfig<span class="token punctuation">.</span>baudRate             <span class="token operator">=</span> HAL_UART_BR_9600<span class="token punctuation">;</span> <span class="token comment">//设置波特率</span>uartConfig<span class="token punctuation">.</span>flowControl          <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>uartConfig<span class="token punctuation">.</span>flowControlThreshold <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span> uartConfig<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>maxBufSize        <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>  uartConfig<span class="token punctuation">.</span>tx<span class="token punctuation">.</span>maxBufSize        <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>  uartConfig<span class="token punctuation">.</span>idleTimeout          <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    uartConfig<span class="token punctuation">.</span>intEnable            <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>                uartConfig<span class="token punctuation">.</span>callBackFunc         <span class="token operator">=</span> SerialApp_CallBack<span class="token punctuation">;</span>  <span class="token comment">//设置回调函数 </span><span class="token function">HalUARTOpen</span> <span class="token punctuation">(</span>HAL_UART_PORT_0<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uartConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> events <span class="token operator">&amp;</span> GENERICAPP_MY_EVT1 <span class="token punctuation">)</span><span class="token comment">//事件</span>  <span class="token punctuation">&#123;</span><span class="token comment">//事件要做的事</span>    P1_0 <span class="token operator">=</span> <span class="token operator">!</span>P1_0<span class="token punctuation">;</span>    P1_1 <span class="token operator">=</span> <span class="token operator">!</span>P1_1<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"hello,are you ok?\r\n"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">HalUARTWrite</span><span class="token punctuation">(</span>HAL_UART_PORT_0<span class="token punctuation">,</span>str<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Start_DHT11</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//读取dht11数据</span>    <span class="token punctuation">&#123;</span>      <span class="token function">sprintf</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span><span class="token string">"temperature:%d,humidity:%d\r\n"</span><span class="token punctuation">,</span>temperature<span class="token punctuation">,</span>humidity<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">HalUARTWrite</span><span class="token punctuation">(</span>HAL_UART_PORT_0<span class="token punctuation">,</span>temp<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">HalUARTWrite</span><span class="token punctuation">(</span>HAL_UART_PORT_0<span class="token punctuation">,</span><span class="token string">"error\r\n"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>events <span class="token operator">^</span> GENERICAPP_MY_EVT1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ZigBee </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
            <tag> 串口通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zigbee驱动DHT11温湿度传感器</title>
      <link href="/posts/5f805b8b/"/>
      <url>/posts/5f805b8b/</url>
      
        <content type="html"><![CDATA[<h1 id="一、DHT11传感器概述"><a href="#一、DHT11传感器概述" class="headerlink" title="一、DHT11传感器概述"></a>一、DHT11传感器概述</h1><h2 id="DHT11传感器概述"><a href="#DHT11传感器概述" class="headerlink" title="DHT11传感器概述"></a>DHT11传感器概述</h2><p>​      DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器。 它应用专用的数字模块采集技术和温湿度传感技术， 确保产品具有极高的可靠性与卓越的长期稳定性。<br>​    传感器包括一个电阻式感湿元件和一个NTC测温元件，并与一个高性能8位单片机相连接    。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130316.png" alt="image-20210527152514400" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130321.png" alt="image-20210527152050788" loading="lazy"></p><p>DHT11传感器体积小，功耗极低，信号传输距离可达20米以上。具有品质卓越、超快响应、抗干扰能力强、性价比极高等优点。<br>    产品为 4 针单排引脚封:</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130324.png" alt="image-20210527152113012" loading="lazy"></p><p>DHT11与MCU连接图:</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130328.png" alt="image-20210527152127031" loading="lazy"></p><h1 id="二、DHT11通信协议分析"><a href="#二、DHT11通信协议分析" class="headerlink" title="二、DHT11通信协议分析"></a>二、DHT11通信协议分析</h1><h2 id="1-DHT11数据传输协议"><a href="#1-DHT11数据传输协议" class="headerlink" title="1. DHT11数据传输协议"></a>1. DHT11数据传输协议</h2><p>​       DHT11通过DATA线与MCU实现半双工通讯。每次通讯时间4ms左右,数据分小数部分和整数部分,具体格式在下面说明(当前小数部分用于以后扩展,现读出为零)。<br>操作流程如下:一次完整的数据传输为40bit,高位先出。<br>数据格式:<br>​    40bits &#x3D; 8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据 +8bit校验和 </p><p>​    数据传送正确时，校验和数据 “ 8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据” 所得结果的末8位。<br>​     即:<br>​    校验和数据  &#x3D;（ 8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据）% 256。</p><h2 id="2-DHT11数据通讯过程"><a href="#2-DHT11数据通讯过程" class="headerlink" title="2. DHT11数据通讯过程"></a>2. DHT11数据通讯过程</h2><p>​    (1)总线空闲状态为高电平,主机把总线拉低18毫秒，向DHT11发送开始信号。</p><p>​      (2)DHT11接收到主机的开始信号后,等待主机开始信号结束,然后发送80us低电平响应信号。</p><p>​      (3)主机发送开始信号结束后,延时等待20-40us后, 读取DHT11的响应信号,主机发送开始信号后,可以切换到输入模式,或者输出高电平均可, 总线由上拉电阻拉高。</p><p>​      (4) DHT11发送响应信号后,再把总线拉高80us,准备发送数据。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130333.png" alt="image-20210527152256797" loading="lazy"></p><p>  (1)DHT11总共会发送40bits的数据,而每一bit数据都以50us低电平时隙开始。</p><p>​       (2)50us的低电平时隙结束后，接下来的高电平的长短决定了该数据位是0还是1。</p><p>​       (3)高电平时长在26~28us左右表示0，在70us左右表示1，格式见下面图示。</p><p>​       (4)如果读取响应信号一直为高电平,则表示DHT11没有响应,请检查线路是否连接正常.当最后一bit数据传送完毕后，DHT11拉低总线50us,随后总线由上拉电阻拉高进入空闲状态。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130336.png" alt="image-20210527152323798" loading="lazy"></p><p> 整个通讯过程如图所示：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130341.png" alt="image-20210527152342588" loading="lazy"></p><h2 id="3-微秒级延时函数"><a href="#3-微秒级延时函数" class="headerlink" title="3.微秒级延时函数"></a>3.微秒级延时函数</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token expression">“OnBoard<span class="token punctuation">.</span>h”</span></span><span class="token function">MicroWait</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="三、实例演示"><a href="#三、实例演示" class="headerlink" title="三、实例演示"></a>三、实例演示</h1><h2 id="dht11-h"><a href="#dht11-h" class="headerlink" title="dht11.h"></a><strong>dht11.h</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DHT11_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DHT11_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"iocc2530.h"</span></span><span class="token keyword">extern</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> temperature<span class="token punctuation">,</span>humidity<span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">Start_DHT11</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="dht11-c"><a href="#dht11-c" class="headerlink" title="dht11.c"></a><strong>dht11.c</strong></h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dht11.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"OnBoard.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DATA</span>  <span class="token expression">P0_4</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> temperature<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>humidity<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">DATA_IO_input_Cfg</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//设置为上拉输入模式</span><span class="token punctuation">&#123;</span>    P0SEL <span class="token operator">&amp;=</span> <span class="token number">0xEF</span><span class="token punctuation">;</span>   <span class="token comment">// 1110 1111 把P04设置为普通IO模式</span>    P0DIR <span class="token operator">&amp;=</span> <span class="token number">0xEF</span><span class="token punctuation">;</span>   <span class="token comment">// 1110 1111 把P04设置为输入模式</span>    P0INP <span class="token operator">&amp;=</span> <span class="token number">0xEF</span><span class="token punctuation">;</span>   <span class="token comment">// 1110 1111 把P04设置为上下拉模式</span>    P2INP <span class="token operator">&amp;=</span> <span class="token number">0xDF</span><span class="token punctuation">;</span>   <span class="token comment">// 1101 1111 把P0组设置为上拉模式</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">DATA_IO_output_Cfg</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//设置为输出模式</span><span class="token punctuation">&#123;</span>    P0SEL <span class="token operator">&amp;=</span> <span class="token number">0xEF</span><span class="token punctuation">;</span>   <span class="token comment">// 1110 1111 把P04设置为普通IO模式</span>    P0DIR <span class="token operator">|=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>   <span class="token comment">// 0001 0000 把P04设置为输出模式</span><span class="token comment">//    P0INP |= 0x10;   // 0001 0000 把P04设置为三态模式</span><span class="token punctuation">&#125;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">Read_Byte</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> tmp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>DATA <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//每个bit都是从50us的低电平开始</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>DATA <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">MicroWait</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时30us</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>DATA <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      tmp <span class="token operator">|=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把该bit设置为1</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*@Start_DHT11 : 采集一次温湿度数据@retval : 如果成功，把温湿度的值保存到全局变量，并返回1          如果失败，返回0*/</span><span class="token keyword">int</span> <span class="token function">Start_DHT11</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//开始采集数据</span><span class="token punctuation">&#123;</span>  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">DATA_IO_output_Cfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置为输出模式</span>  DATA <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//发送开始信号</span>  <span class="token function">MicroWait</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时至少18ms</span>  DATA <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//拉高20~40us</span>  <span class="token function">MicroWait</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DATA_IO_input_Cfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置为输入模式</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>DATA <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等DHT11回响应信号</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>DATA <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等DHT11把总线拉高，准备接收数据</span>  buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Read_Byte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Read_Byte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Read_Byte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Read_Byte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Read_Byte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">256</span> <span class="token operator">==</span> buf<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    humidity <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    temperature <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ZigBee </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
            <tag> DHT11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZigBee的GPIO与外部中断原理</title>
      <link href="/posts/4adf1e22/"/>
      <url>/posts/4adf1e22/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-cc2530最小系统"><a href="#一、-cc2530最小系统" class="headerlink" title="一、 cc2530最小系统"></a>一、 cc2530最小系统</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130053.png" alt="image-20210525142548926" loading="lazy"></p><h1 id="二、GPIO概述"><a href="#二、GPIO概述" class="headerlink" title="二、GPIO概述"></a>二、GPIO概述</h1><p> <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130107.png" alt="image-20210525143732557" loading="lazy"></p><h1 id="三、IO口的输入输出配置"><a href="#三、IO口的输入输出配置" class="headerlink" title="三、IO口的输入输出配置"></a>三、IO口的输入输出配置</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130112.png" alt="image-20210525143800845" loading="lazy"></p><p> <strong>上拉输入</strong>：有上拉电阻</p><p>​                按键未按下时端口接高电平，即高电平 1  状态—3.3v</p><p>​                按键按下时端口接低电平，即低电平 0 状态——-0</p><p> <strong>下拉输入</strong>：有下拉电阻</p><p>​                 按键未按下时端口接低电平，即低电平 0 状态—0v</p><p>​                 按键按下时端口接高电平，即高电平 1 状态——3.3v</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130119.png" alt="image-20210525143939066" loading="lazy"></p><h1 id="四、外部中断"><a href="#四、外部中断" class="headerlink" title="四、外部中断"></a>四、外部中断</h1><h2 id="1-什么是外部中断"><a href="#1-什么是外部中断" class="headerlink" title="1.什么是外部中断"></a>1.什么是外部中断</h2><p>外部中断是单片机实时地处理外部事件的一种内部机制。当某种外部事件发生时，单片机的中断系统将迫使CPU暂停正在执行的程序，转而去进行中断事件的处理；中断处理完毕后．又返回被中断的程序处，继续执行下去。</p><h2 id="2-外部中断的作用"><a href="#2-外部中断的作用" class="headerlink" title="2.外部中断的作用"></a>2.外部中断的作用</h2><h3 id="1-实时处理功能"><a href="#1-实时处理功能" class="headerlink" title="(1)实时处理功能"></a>(1)实时处理功能</h3><p>在实时控制中，现场的各种参数、信息均随时问和现场而变化。这些外界变量可根据要求随时向CPU发出中断申请．请求CPU及时处珲中断请求，如中断条件</p><h3 id="2-故障处理功能"><a href="#2-故障处理功能" class="headerlink" title="(2)故障处理功能"></a>(2)故障处理功能</h3><p>针对难以预料的情况或故障，如掉电、存储出错、运算溢出等，可通过中断系统由故障源向CPU发出中断请求，再由CPU转到相应的故障处理程序进行处理。</p><h2 id="3-cc2530的外部中断原理"><a href="#3-cc2530的外部中断原理" class="headerlink" title="3.cc2530的外部中断原理"></a>3.cc2530的外部中断原理</h2><p> CC2530 有 21 个数字 I&#x2F;O 引脚，可以配置为通用数字 I&#x2F;O 或外设 I&#x2F;O 信号，配置为连接到 ADC、定时器或 USART 外设。这些 I&#x2F;O 口的用途可以通过一系列寄存器配置，由用户软件加以实现。</p><p>​    I&#x2F;O 端口具备如下重要特性：</p><ul><li>​        21 个数字 I&#x2F;O 引脚</li><li>​        可以配置为通用 I&#x2F;O 或外部设备 I&#x2F;O</li><li>​        输入口具备上拉或下拉能力</li><li>​        具有外部中断能力</li></ul><p>​     21 个 I&#x2F;O 引脚都可以用作于外部中断源输入口。因此如果需要外部设备可以产生中断。外部中断功能也可以从睡眠模式唤醒设备。</p><p>​    通用 I&#x2F;O 引脚设置为输入后，可以用于产生中断。中断可以设置在外部信号的上升或下降沿触发。 P0、 P1 或 P2 端口都有中断使能位，对位于 IENl-2 寄存器内的端口所有的位都是公共的，如下：</p><ul><li><p>IENI.P0IE： P0 中断使能</p></li><li><p>IEN2.PIIE： P1 中断使能</p></li><li><p>IEN2.P2IE： P2 中断使能</p></li></ul><p>除了这些公共中断使能之外，每个端口的位都有位于 SFR 寄存器 P0IEN、P1IEN 和 P2IEN 的单独的中断使能。即使配置为外设 I&#x2F;O 或通用输出的 I&#x2F;O 引脚使能时都有中断产生。 </p><p>当中断条件发生在 I&#x2F;O 引脚之一上面，P0-P2 中断标志寄存器 P0IFG、P1IFG或 P2IFG 中相应的中断状态标志将设置为 1。不管引脚是否设置了它的中断使能位，中断状态标志都被设置。当中断已经执行，中断状态标志被清除，该标志写入 0。这个标志必须在清除 CPU 端口中断标志（ PxIF）之前被清除。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130124.png" alt="image-20210525164054625" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130128.png" alt="image-20210525164314863" loading="lazy"></p><p>用于中断的 SFR 寄存器描述在下一节。寄存器总结如下：</p><ul><li>P0IEN: P0 中断使能</li><li>P1IEN： P1 中断使能</li><li>P2IEN： P2 中断使能</li><li>PICTL： P0、 P1 和 P2 触发沿设置</li><li>P0FG： P0 中断标志</li><li>P1IFG： P1 中断标志</li><li>P2IFG： P2 中断标志</li></ul><h2 id="4-外部中断配置步骤"><a href="#4-外部中断配置步骤" class="headerlink" title="4.外部中断配置步骤"></a>4.外部中断配置步骤</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215130134.png" alt="image-20210525170345047" loading="lazy"></p><p>(1)初始化IO口工作在普通IO模式，上拉输入状态</p><p>(2)首先打开IO口组中断允许位&#x3D;&#x3D;&#x3D;&gt;PxIE</p><ul><li>​    P0IE  是 IEN1(0xB8)的第5位</li><li>​    P1IE  是 IEN2(0x9A)的第4位</li><li>​    P2IE  是 IEN2(0X9A)的第1位</li></ul><p>(3)打开组内对应的具体某IO口中断&#x3D;&#x3D;&#x3D;&#x3D;&gt;PxIEN</p><p>(4)设置是上升沿还是下降沿触发&#x3D;&#x3D;&#x3D;&gt;PICTL(0,代表上升沿触发；1，代表下降沿触发)</p><p>(5)打开CPU总中断 EA&#x3D;1;    </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">exti_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//(1)初始化IO口工作在普通IO模式，上拉输入状态</span>    <span class="token function">key_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//(2)首先打开IO口组中断允许位===>PxIE</span>    IEN2 <span class="token operator">|=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment">//0001 0000 0x10</span>    <span class="token comment">//(3)打开组内对应的具体某IO口中断====>PxIEN</span>    P1IEN <span class="token operator">|=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//0000 0100 0x40</span>    <span class="token comment">//(4)设置是上升沿还是下降沿触发===>PICTL(0,代表上升沿触发；1，代表下降沿触发)</span>    PICTL <span class="token operator">|=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//0000 0010 0x02 设置为下降沿触发</span>    <span class="token comment">//(5)打开CPU总中断 EA=1;</span>    EA <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-外部中断服务程序示例"><a href="#5-外部中断服务程序示例" class="headerlink" title="5.外部中断服务程序示例"></a>5.外部中断服务程序示例</h2><p><strong>led_key.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"iocc2530.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"led_key.h"</span></span><span class="token comment">/*@led init：对LED进行初始化@retval:none @note:LED对应的引脚是P10和P11，初始化为普通IO，输出模式*/</span><span class="token keyword">void</span> <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    P1SEL <span class="token operator">&amp;=</span> <span class="token number">0xfc</span><span class="token punctuation">;</span>  <span class="token comment">//1111 1100  把P1_0和P1_1设置为通IO模式</span>    P1DIR <span class="token operator">|=</span> <span class="token number">0x03</span><span class="token punctuation">;</span>  <span class="token comment">//0000 0011  把P1_0和P1_1设置为输出模式</span>    P1_0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    P1_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*@led ctr1：对LED的状态进行控的函数@led num：指定对哪一盏LED等进行控制，可选择为LEDO,LED1@led state：指定LED的状态，可选择为 LED ON, LED OFF @retval：none*/</span><span class="token keyword">void</span> <span class="token function">led_ctrl</span><span class="token punctuation">(</span><span class="token keyword">int</span> led_num<span class="token punctuation">,</span><span class="token keyword">int</span> led_state<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>led_num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> LED0<span class="token operator">:</span>        P1_0 <span class="token operator">=</span> led_state<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> LED1<span class="token operator">:</span>        P1_1 <span class="token operator">=</span> led_state<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*@key init：按键的初始化函数@retval none @note：按键应的引是P12，应初始化为普通IO，上拉输入模式*/</span><span class="token keyword">void</span> <span class="token function">key_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    P1SEL <span class="token operator">&amp;=</span> <span class="token number">0xFB</span><span class="token punctuation">;</span>   <span class="token comment">// 1111 1011 把P12设置为普通IO模式</span>    P1DIR <span class="token operator">&amp;=</span> <span class="token number">0xFB</span><span class="token punctuation">;</span>   <span class="token comment">// 1111 1011 把P12设置为输入模式</span>    P1INP <span class="token operator">&amp;=</span> <span class="token number">0xFB</span><span class="token punctuation">;</span>   <span class="token comment">// 1111 1011 把P12设置为上下拉模式</span>    P2INP <span class="token operator">&amp;=</span> <span class="token number">0xBF</span><span class="token punctuation">;</span>   <span class="token comment">// 1011 1111 把P1组设置为上拉模式</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">key_status</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> P1_2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*@exti_init：中断初始化函数@retval none @note：none*/</span><span class="token keyword">void</span> <span class="token function">exti_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//(1)初始化IO口工作在普通IO模式，上拉输入状态</span>    <span class="token function">key_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//(2)首先打开IO口组中断允许位===>PxIE</span>    IEN2 <span class="token operator">|=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment">//0001 0000 0x10</span>    <span class="token comment">//(3)打开组内对应的具体某IO口中断====>PxIEN</span>    P1IEN <span class="token operator">|=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//0000 0100 0x40</span>    <span class="token comment">//(4)设置是上升沿还是下降沿触发===>PICTL(0,代表上升沿触发；1，代表下降沿触发)</span>    PICTL <span class="token operator">|=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//0000 0010 0x02 设置为下降沿触发</span>    <span class="token comment">//(5)打开CPU总中断 EA=1;</span>    EA <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> i<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">587</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">optimize<span class="token operator">=</span>none       </span><span class="token comment">//不进行编译优化</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">vector<span class="token operator">=</span>P1INT_VECTOR </span><span class="token comment">//P1组引发中断,vector中断矢量表,下面这段代码必须放在这个地方</span></span>__interrupt <span class="token keyword">void</span> <span class="token function">exint</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//P1组</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>P1IFG <span class="token operator">&amp;</span> <span class="token number">0X04</span><span class="token punctuation">)</span><span class="token comment">//0000 0100</span>      <span class="token punctuation">&#123;</span><span class="token comment">//确定是P1_2产生了外部中断</span>             <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//按键消抖</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>P1_2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>        <span class="token comment">//中断要做的事情</span>                P1_0 <span class="token operator">=</span> <span class="token operator">!</span>P1_0<span class="token punctuation">;</span>                P1_1 <span class="token operator">=</span> <span class="token operator">!</span>P1_1<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      P1IFG <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//把中断状态标志位清0</span>      P1IF <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//组中断标志位清0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>led_key.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LED_KEY_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LED_KEY_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"iocc2530.h"</span></span><span class="token keyword">enum</span> <span class="token class-name">LED_NUM</span><span class="token punctuation">&#123;</span>LED0<span class="token punctuation">,</span>LED1<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">LED_STATE</span><span class="token punctuation">&#123;</span>LED_OFF<span class="token punctuation">,</span>LED_ON<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">KEY_STATUS</span><span class="token punctuation">&#123;</span>KEY_DOWN<span class="token punctuation">,</span>KEY_UP<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">led_ctrl</span><span class="token punctuation">(</span><span class="token keyword">int</span> led_num<span class="token punctuation">,</span><span class="token keyword">int</span> led_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">key_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">key_status</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">exti_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>main.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"iocc2530.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"led_key.h"</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exti_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ZigBee </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPIO </tag>
            
            <tag> ZigBee </tag>
            
            <tag> cc2530 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IAR软件安装</title>
      <link href="/posts/55cac7e0/"/>
      <url>/posts/55cac7e0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Zigbee概述"><a href="#一、Zigbee概述" class="headerlink" title="一、Zigbee概述"></a>一、Zigbee概述</h1><h2 id="1-什么是Zigbee"><a href="#1-什么是Zigbee" class="headerlink" title="1.什么是Zigbee"></a>1.什么是Zigbee</h2><p>ZigBee是一种近距离、低复杂度的双向无线通信系统，主要用于距离短、功耗低、传输速率不高的电子设备之间进行数据传输，且具有低功耗、低成本、大容量、时延短、可靠性高以及网络拓扑结构灵活的特点。</p><p>Zigbee本质就是无线设备之间的一种通信方式，类似于人和人之间用普通话交流，普通话就是一种通信方式。Zigbee，Zigbee通信方式，Zigbee协议说的都是一回事。</p><p>Zigbee的主要作用是用来构建无线局域网。         </p><h2 id="2-各通信方式的比较"><a href="#2-各通信方式的比较" class="headerlink" title="2.各通信方式的比较"></a>2.各通信方式的比较</h2><p>蓝牙：功耗比较低，组建网络节点数少(7~8个)</p><p>WIFI：通信速率比较大，功耗大，等等</p><p>Zigbee：<br>    优点：可以组建大规模的网络，功耗低(TI cc2530正常工作电流8mA,最低工作电流只有几uA)<br>    缺点：通信速率比较小( 250KBPS)</p><p><strong>注意</strong>：Zigbee只是完成数据通信的工作，要实现具体的使用的功能系统，一般会把Zigbee模块连接到计算机(处理器)，计算机通过编好的程序来对整个系统进行监控。</p><h2 id="3-相关概念"><a href="#3-相关概念" class="headerlink" title="3.相关概念"></a>3.相关概念</h2><p>Zigbee联盟：制定Zigbee协议的协会组织(美国)</p><p>TI(德州仪器)：一个Zigbee芯片厂商，主要把Zigbee协议用于推广和实际应用。除了TI，还有ember,飞思卡尔等等</p><p>Zstack：TI公司推出Zigbee软件上支持的协议栈。实质就是一堆示例代码。</p><p>cc2530：TI公司推出的支持Zigbee底层协议的一种芯片(8051单片机内核)</p><p>​                                cc2530F256  TI  58J</p><p>IAR：写Zigbee程序的一个软件，集成开发工具，编辑器，编译器，下载器，仿真器。</p><h2 id="4-Zigbee网络体系结构"><a href="#4-Zigbee网络体系结构" class="headerlink" title="4.Zigbee网络体系结构"></a>4.Zigbee网络体系结构</h2><p>​    ZigBee协议基础为IEEE 802.15.4，ZigBee联盟在IEEE 802.15.4基础之上重新定义了网络层和应用层。Zigbee使用全球免费频段进行通讯，能够在三个不同的频段上通讯。全球通用的频段是 2.400GHz-2.484GHz，欧洲采用的频段是 868.0 MHz-868.66MHz，美国采用的频段是 902MHz-928MHz。传输速率分别为 250kbps 20kbps 和 40kbps。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125426.png" alt="image-20210524144248153" loading="lazy"></p><h1 id="二-IAR软件的安装使用"><a href="#二-IAR软件的安装使用" class="headerlink" title="二.IAR软件的安装使用"></a>二.IAR软件的安装使用</h1><h2 id="1-IAR软件的安装与注册"><a href="#1-IAR软件的安装与注册" class="headerlink" title="1.IAR软件的安装与注册"></a>1.IAR软件的安装与注册</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125452.png" alt="image-20210524144514258" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125457.png" alt="image-20210524144603942" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125500.png" alt="image-20210524144617238" loading="lazy"></p><h2 id="2-IAR工程建立"><a href="#2-IAR工程建立" class="headerlink" title="2.IAR工程建立"></a>2.IAR工程建立</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125507.png" alt="image-20210524160638596" loading="lazy"></p><p>(1)先创建一个工作空间</p><p>​     File–&gt;new–&gt;workspace</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125507.png" alt="image-20210524160439296" loading="lazy"><br>(2)创建一个工程</p><p>​    Project–&gt;Create New Project–&gt;Empty project–&gt;0K–&gt;保存到指定目录</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125528.png" alt="image-20210524160521787" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125533.png" alt="image-20210524160541970" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125539.png" alt="image-20210524160725839" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125542.png" alt="image-20210524160739328" loading="lazy"></p><p>(3)新建一个文件–&gt;保存为.c文件</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125548.png" alt="image-20210524161451809" loading="lazy"></p><p>(4)把.c文件添加进工程</p><p>​    右击”工程名-Debug”–&gt;Add</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125557.png" alt="image-20210524161527552" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125601.png" alt="image-20210524161540404" loading="lazy"></p><p>(5)编译：保存工作空间到已创建的工程文件夹中</p><h2 id="3-选项配置"><a href="#3-选项配置" class="headerlink" title="3.选项配置"></a>3.选项配置</h2><p>  “工程名-Debug”–&gt;options    </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125605.png" alt="image-20210524161841240" loading="lazy">    (1)General Options–&gt;Device 选择Texas Instruments cc2530F256<br>    <img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125609.png" alt="image-20210524161944984" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125616.png" alt="image-20210524162035248" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125620.png" alt="image-20210524162143659" loading="lazy"></p><p>​    (2)Linker–&gt;Output–&gt;Override default勾上，Allow C-SPY-specific extra output file 勾上</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125624.png" alt="image-20210524162850892" loading="lazy"><br>    (3)Debugger–&gt;Driver–&gt;选择Texas Instrments</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125630.png" alt="image-20210524163015925" loading="lazy"></p><h1 id="三、驱动安装"><a href="#三、驱动安装" class="headerlink" title="三、驱动安装"></a>三、驱动安装</h1><p>在设备管理器里，未安装驱动显示的是SmartRF04EB，装好驱动后，显示的则是CC2430DB</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125634.png" alt="20210524163315.png" loading="lazy"></p><blockquote><p>  哈希值错误解决办法<br>  1.Windows键+ R，输入shutdown.exe &#x2F;r &#x2F;o &#x2F;f &#x2F;t 00 ，系统会重新启动一个“选择一个选项”<br>  2从“选择一个选项”屏幕上，选择“疑难解答” ，选择从“疑难解答”屏幕“高级选项” ，选择从“高级选项”屏幕“Windows启动设置” ，点击“重新启动”按钮，系统将重新启动，以“高级启动选项”屏幕 ；重启<br>  3.这会重启之后就跳出来安全模式等列表了<br>  4.选择倒数第三个，禁用强制驱动程序签名，对应哪个数字就按那个数字。<br>  5.重启，按照一般方法驱动就可以成功安装了</p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125638.png" alt="image-20210524164934779" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125642.png" alt="image-20210524164954508" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125646.png" alt="image-20210524165131848" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125702.png" alt="image-20210524165200626" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125659.png" alt="image-20210524165209775" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125709.png" alt="20210524165248.png" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125715.png" alt="image-20210524165314844" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125911.jpeg" alt="IMG_20210524_164615" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125836.jpeg" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125901.png" alt="image-20210524213027330" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125854.png" alt="image-20210524213040881" loading="lazy"></p><h1 id="四、编译与仿真"><a href="#四、编译与仿真" class="headerlink" title="四、编译与仿真"></a>四、编译与仿真</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125752.png" alt="image-20210524165506833" loading="lazy"></p><h1 id="五、生成Hex文件设置"><a href="#五、生成Hex文件设置" class="headerlink" title="五、生成Hex文件设置"></a>五、生成Hex文件设置</h1><p>“工程名-Debug”–&gt;options ，Linker–&gt;Extra Output–&gt;Genetare extra outputfile 勾上，Override defualt勾上–&gt;命名为.hex文件，output format :intel-extended–&gt;OK</p><p>​    再次编译后就会在 Debug&#x2F;Exe目录中生成.hex文件</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125749.png" alt="image-20210524170747455" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125743.png" alt="image-20210524171410614" loading="lazy"></p><h1 id="六、ZigBee核心控制器"><a href="#六、ZigBee核心控制器" class="headerlink" title="六、ZigBee核心控制器"></a>六、ZigBee核心控制器</h1><p>无线通信采用Ti Zigbee方案。Zigbee节点采用Ti(德州仪器)公司 CC2530，GEC-CC2530有21个数字输入&#x2F;输出引脚，可以配置为通用数字I&#x2F;O或外设I&#x2F;O信号，外设I&#x2F;O可连接到ADC、定时器或USART等。</p><p>其中21个I&#x2F;O 引脚分成3 个端口(端口0、端口1 和端口2，表示为P0、P1 和P2),其中，P0和P1 每组有8个IO引脚，而P2组仅有5 个引脚实物如图。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220215125737.png" alt="image-20210524213506210" loading="lazy"></p><h1 id="七、代码烧录测试"><a href="#七、代码烧录测试" class="headerlink" title="七、代码烧录测试"></a>七、代码烧录测试</h1><p>LED闪烁</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"iocc2530.h"</span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> uchar<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span>  uint<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED0</span> <span class="token expression">P1_0                </span><span class="token comment">//定义P1.0口为LED0控制端</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED1</span> <span class="token expression">P1_1                </span><span class="token comment">//定义P1.0口为LED1控制端</span></span><span class="token comment">//点亮两盏LED灯</span><span class="token keyword">void</span> <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    P1DIR <span class="token operator">|=</span> <span class="token number">0x03</span><span class="token punctuation">;</span>    LED0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    LED1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span>uint msec<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     uint i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>msec<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span><span class="token number">535</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                      <span class="token punctuation">&#123;</span>        LED1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                  LED0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               LED1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                   LED0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ZigBee </category>
          
          <category> 课程设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZigBee </tag>
            
            <tag> IAR软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派驱动57步进电机</title>
      <link href="/posts/7da4ed6c/"/>
      <url>/posts/7da4ed6c/</url>
      
        <content type="html"><![CDATA[<h1 id="一、57步进电机参数"><a href="#一、57步进电机参数" class="headerlink" title="一、57步进电机参数"></a>一、57步进电机参数</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211222103121.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211222103210.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211222103221.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211222103159.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211222103226.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211222103231.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20211222103152.png" alt="img" loading="lazy"></p><h1 id="二、树莓派利用python控制57步进电机"><a href="#二、树莓派利用python控制57步进电机" class="headerlink" title="二、树莓派利用python控制57步进电机"></a>二、树莓派利用python控制57步进电机</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO<span class="token keyword">import</span> time<span class="token comment"># w1,w2,w3,w4,w5,w6 = 0,1,0,0,0,0,0   细分400，电流3.5A，电压24V</span>IN1 <span class="token operator">=</span> <span class="token number">20</span>  <span class="token comment"># 接PUL-</span>IN2 <span class="token operator">=</span> <span class="token number">21</span>  <span class="token comment"># 接PUL+</span>IN3 <span class="token operator">=</span> <span class="token number">12</span>  <span class="token comment"># 接DIR-</span>IN4 <span class="token operator">=</span> <span class="token number">16</span>  <span class="token comment"># 接DIR+</span><span class="token keyword">def</span> <span class="token function">setStep</span><span class="token punctuation">(</span>w1<span class="token punctuation">,</span> w2<span class="token punctuation">,</span> w3<span class="token punctuation">,</span> w4<span class="token punctuation">)</span><span class="token punctuation">:</span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> w1<span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> w2<span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN3<span class="token punctuation">,</span> w3<span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN4<span class="token punctuation">,</span> w4<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    setStep<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># 正转</span><span class="token comment"># 控制电机旋转的快慢和圈数 delay越小转得越快，1600为一圈</span><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> steps<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> steps<span class="token punctuation">)</span><span class="token punctuation">:</span>        setStep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token comment"># 控制电机一直旋转</span><span class="token keyword">def</span> <span class="token function">yizhi</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        setStep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token comment"># 反转</span><span class="token comment"># 控制电机旋转的快慢和圈数 delay越小转得越快，1600为一圈</span><span class="token keyword">def</span> <span class="token function">backward</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> steps<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> steps<span class="token punctuation">)</span><span class="token punctuation">:</span>        setStep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>        setStep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token comment"># 初始化树莓派引脚，设置树莓派的引脚为输出状态</span><span class="token keyword">def</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    GPIO<span class="token punctuation">.</span>setwarnings<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN3<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>    GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN4<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span><span class="token comment"># 带异常处理</span><span class="token comment"># 控制电机正转一圈</span><span class="token keyword">def</span> <span class="token function">hhh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>         forward<span class="token punctuation">(</span><span class="token number">0.0001</span><span class="token punctuation">,</span><span class="token number">1600</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> KeyboardInterrupt<span class="token punctuation">:</span>  <span class="token comment"># When 'Ctrl+C' is pressed, the child function destroy() will be  executed.</span>         destroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 带异常处理</span><span class="token comment"># 控制电机一直旋转</span><span class="token keyword">def</span> <span class="token function">zzz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    setup<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>         yizhi<span class="token punctuation">(</span><span class="token number">0.0001</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> KeyboardInterrupt<span class="token punctuation">:</span>  <span class="token comment"># When 'Ctrl+C' is pressed, the child function destroy() will be  executed.</span>         destroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 检测正转和反转</span><span class="token keyword">def</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        i<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"1、正转\t2、反转\t3、退出\n请输入数字： "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>            b <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入脉冲个数（1600个脉冲为一圈）："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            forward<span class="token punctuation">(</span><span class="token number">0.0001</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"请等待3秒..."</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"stop..."</span><span class="token punctuation">)</span>            stop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> i<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">:</span>            a<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入脉冲个数（1600个脉冲为一圈）："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            backward<span class="token punctuation">(</span><span class="token number">0.0001</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>  <span class="token comment"># 发射脉冲时间间隔0.0001（单位秒）   脉冲个数a 如果编码器的设置是8细分 那么1600冲就转360度</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"请等待3秒..."</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"stop..."</span><span class="token punctuation">)</span>            stop<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># stop</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            destroy<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token comment"># 清除树莓派引脚状态赋值            </span><span class="token keyword">def</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 释放数据</span>    <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>  <span class="token comment"># Program start from here</span>   setup<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">try</span><span class="token punctuation">:</span>        loop<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">except</span> KeyboardInterrupt<span class="token punctuation">:</span>  <span class="token comment"># When 'Ctrl+C' is pressed, the child function destroy() will be  executed.</span>        destroy<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 57步进电机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B引脚定义及运行实例</title>
      <link href="/posts/97a88a5c/"/>
      <url>/posts/97a88a5c/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派4B引脚定义及运行实例"><a href="#树莓派4B引脚定义及运行实例" class="headerlink" title="树莓派4B引脚定义及运行实例"></a>树莓派4B引脚定义及运行实例</h1><h1 id="一、树莓派引脚定义"><a href="#一、树莓派引脚定义" class="headerlink" title="一、树莓派引脚定义"></a>一、树莓派引脚定义</h1><p>学习如何用树莓派驱动LED灯时需要先了解树莓派管脚GPIO的编码方式，树莓派的管脚编码方式与51单片机的管脚编码有些不一样，在树莓派的GPIO上分为<strong>两种编码方式</strong>，分别为<strong>BCM</strong>和<strong>wiringPi编码</strong>，不同的编码方式在编写程序驱动GPIO时稍有区别，具体编码如下：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409083903.png" alt="image-20201027185041036" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409085736.png" alt="树莓派 gpio 针脚" loading="lazy"></p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409083911.png" alt="image-20201027193659980" style="zoom:150%;" / loading="lazy"><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220409083906.png" alt="image-20201027193715459" style="zoom:150%;" / loading="lazy"><h1 id="二、蜂鸣器响"><a href="#二、蜂鸣器响" class="headerlink" title="二、蜂鸣器响"></a>二、蜂鸣器响</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO                <span class="token comment"># 引入GPIO模块</span><span class="token keyword">from</span> time <span class="token keyword">import</span> sleep                     <span class="token comment"># 引入time模块</span>GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span>            <span class="token comment"># 使用BCM编号方式</span>GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span>GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>            <span class="token comment"># 将GPIO19设置为输出模式</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                                     <span class="token comment"># 无限循环  </span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span>GPIO<span class="token punctuation">.</span>HIGH<span class="token punctuation">)</span>   <span class="token comment"># 将GPIO19设置为高电平，点亮LED  </span>    sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                                    <span class="token comment"># 等待1秒钟 </span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span>GPIO<span class="token punctuation">.</span>LOW<span class="token punctuation">)</span>  <span class="token comment"># 将GPIO19设置为低电平，熄灭LED </span>    sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                              <span class="token comment"># 等待0.5秒钟 </span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                      <span class="token comment"># 按下任意键退出</span>GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment"># 清理释放GPIO资源，将GPIO复位 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序（龙哥）</title>
      <link href="/posts/c56898db/"/>
      <url>/posts/c56898db/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-为什么要排序"><a href="#1-为什么要排序" class="headerlink" title="1.为什么要排序"></a>1.为什么要排序</h2><p>查找是计算机应用中必不可少并且使用频率很高的一个操作。在一个排序表中查找一个元素，要比在一个无序表中查找效率高得多。所以为了提高查找效率，节省CPU时间，需要排序。</p><h2 id="2-什么是排序"><a href="#2-什么是排序" class="headerlink" title="2.什么是排序"></a>2.什么是排序</h2><p>所谓排序，就是整理表中的数据几素，使之按儿素的关键字递增&#x2F;递减的顺序排列。</p><h2 id="3-排序的稳定性"><a href="#3-排序的稳定性" class="headerlink" title="3.排序的稳定性"></a>3.排序的稳定性</h2><p>当待排序元素的关键字不相同时，排序的结果是唯一的。如果待排序的表中，有多个关键字相间的元素：经过排序后这些共有相同关键字的元素之间的相对次序保持不变，则称这种排序方法是稳定的；反之，若具有相同关键字的元素之间的相对次序发生变化，则称这种的方法是不稳定的。</p><h2 id="4-排序稳定性的意义"><a href="#4-排序稳定性的意义" class="headerlink" title="4.排序稳定性的意义"></a>4.排序稳定性的意义</h2><p>什么时候需要稳定的排序方法？什么时候不需要呢？<br>考虑一下这种情况：<br>原序列按关键字Ki排列，现在要求按关键字Km排列，期望：在结果序列中，关键字Km相同的记录按原关键字Ki排列！！<br>“主关键字相同，按原次关键字排列”</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210121201807023.png" alt="image-20210121201807023" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210121201826774.png" alt="image-20210121201826774" loading="lazy"></p><h2 id="5-排序方法分类"><a href="#5-排序方法分类" class="headerlink" title="5.排序方法分类"></a>5.排序方法分类</h2><h3 id="1-分类方法一"><a href="#1-分类方法一" class="headerlink" title="(1)分类方法一"></a>(1)分类方法一</h3><p>我们根据待排序的数据元素是否全部在内存中，我们把排序方法，分为两类：<br>内排序：整个排序元素都在内存中处理，不涉及内、外存的数据交换。<br>外排序：待排序元素有一部分不在内存（如：内存装不下）</p><p><img src="D:/Desktop/image-20210121200637084.png" alt="image-20210121200637084" loading="lazy"></p><h3 id="2-分类方法二"><a href="#2-分类方法二" class="headerlink" title="(2)分类方法二"></a>(2)分类方法二</h3><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127183540.png" alt="img" loading="lazy"></p><h2 id="6-排序算法性能评估"><a href="#6-排序算法性能评估" class="headerlink" title="6.排序算法性能评估"></a>6.排序算法性能评估</h2><p>（1）算法的时间复杂度<br>            评估一下算法 <strong>运行时间</strong><br>            T（n）&#x3D;O（f（n））</p><p>（2）算法的空间复杂度<br>            评估一下算法 <strong>所用空间</strong><br>            s（n）&#x3D;O（f（n））</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127183628.png" alt="img" loading="lazy"></p><h2 id="7-相关概念总结"><a href="#7-相关概念总结" class="headerlink" title="7.相关概念总结"></a>7.相关概念总结</h2><ul><li><strong>稳定</strong>：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a&#x3D;b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127183925.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127184114.png" alt="img" loading="lazy"></p><h3 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h3><p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p><p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</p><p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</p><p>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p><p>关于稳定性</p><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><p>名词解释：</p><ul><li>n：数据规模</li><li>k：”桶”的个数</li><li>In-place：占用常数内存，不占用额外内存</li><li>Out-place：占用额外内存</li><li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><h1 id="二、直接插入排序"><a href="#二、直接插入排序" class="headerlink" title="二、直接插入排序"></a>二、直接插入排序</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>（基本思想）每次将一个待排序的元素，按其关键字大小插入到已经排好序的子表中的适当位置，直到全部元素插入完成为止。<br>                直接插入排序&lt;&lt;&lt;<br>                折半插入排序<br>                希尔排序|</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210122183206813.png" alt="image-20210122183206813" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210122183231936.png" alt="image-20210122183231936" loading="lazy"></p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="img" loading="lazy"></p><h2 id="2-基本思路"><a href="#2-基本思路" class="headerlink" title="2.基本思路"></a>2.基本思路</h2><h3 id="step1：找插入位置"><a href="#step1：找插入位置" class="headerlink" title="step1：找插入位置"></a>step1：找插入位置</h3><p>​            从第一个元素开始，找到第一个比待插入元素大的元素，<br>​                “插入位置”I    </p><h3 id="step2：插入操作"><a href="#step2：插入操作" class="headerlink" title="step2：插入操作"></a>step2：插入操作</h3><p>​            从最后面，一个一个元素往后挪</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210122183653824.png" alt="image-20210122183653824" loading="lazy"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#define N 10&#x2F;*    insert:把元素x,插入到升序数组a[]中去            a[0] a[1] ... a[n-1]    @a:数组名    @n:原有序表的元素个数，0,...,n-1    @x:待插入元素    返回值：        无返回*&#x2F;void insert(int a[], int n, int x)&#123;    int i,j,k;    &#x2F;&#x2F;step1:找插入位置    for(i &#x3D; 0;i &lt; n; i++)    &#123;        if(a[i] &gt; x)        &#123;            break;        &#125;    &#125;    &#x2F;&#x2F;i就是插入位置    &#x2F;&#x2F;step: 插入操作(先挪后插入)    for(j &#x3D; n-1; j &gt;&#x3D; i;j--)    &#123;        a[j+1] &#x3D; a[j];    &#125;    a[i] &#x3D; x;&#125;&#x2F;&#x2F;给数组a[n]进行 直接插入排序void insertSort(int a[], int n)&#123;    int i;    for(i &#x3D; 1; i &lt; n; i++)    &#123;        insert(a, i, a[i]);    &#125;&#125;int main()&#123;    int a[N];    int i;    for(i &#x3D; 0;i &lt; N; i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    insertSort(a, N);    for(i &#x3D; 0;i &lt; N; i++)    &#123;        printf(&quot;%d &quot;,a[i]);    &#125;    printf(&quot;\n&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-直接插入改进"><a href="#3-直接插入改进" class="headerlink" title="3.直接插入改进"></a>3.直接插入改进</h2><p>“边比较边挪位置”<br>从最后面的元素，一个一个与待插入元素x比较</p><p>[ai] &gt; x &#x3D;&gt; 把[ai]往后挪</p><p>​    a[i+1]-a[i]<br>直到a[i] &lt;&#x3D; x此时i+1就是插入位置。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123090733160.png" alt="image-20210123090733160" loading="lazy"></p><h3 id="（1）龙哥改进版"><a href="#（1）龙哥改进版" class="headerlink" title="（1）龙哥改进版"></a>（1）龙哥改进版</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token comment">/*    insert:把元素x,插入到升序数组a[]中去            a[0] a[1] ... a[n-1]    @a:数组名    @n:原有序表的元素个数，0,...,n-1    @x:待插入元素    返回值：        无返回*/</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>        <span class="token comment">//debug</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[1;34m%d\033[0m\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//高亮打印 </span>      <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    a<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">//k+1就是插入位置</span>            <span class="token comment">//debug</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\033[1;34m%d\033[0m "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//高亮打印 </span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n------------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//给数组a[n]进行 直接插入排序</span><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">insertSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）改进版集成"><a href="#（2）改进版集成" class="headerlink" title="（2）改进版集成"></a>（2）改进版集成</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#define N 5void InsertSot(int a[] , int n)&#123;int i,j;for(i&#x3D;1;i&lt;n;i++)&#123;for(j&#x3D;i-1;j&gt;&#x3D;0 &amp;&amp; a[j]&gt;a[i];j--)&#123;a[j+1] &#x3D; a[j];&#125;a[j+1] &#x3D; a[i];&#125;&#125;int main()&#123;int a[N]&#x3D;&#123;0&#125;;int i;for(i&#x3D;0;i&lt;N;i++)&#123;scanf(&quot;%d&quot;,&amp;a[i]);&#125;InsertSot(a,N);for(i&#x3D;0;i&lt;N;i++)&#123;printf(&quot;%d&quot;,a[i]);&#125;printf(&quot;\n&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（3）课外集成版"><a href="#（3）课外集成版" class="headerlink" title="（3）课外集成版"></a>（3）课外集成版</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该记录后仍然有序。插入排序中较简单的种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。*&#x2F;&#x2F;*基本有序，记录数少*&#x2F;&#x2F;*基本思想： 每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序 的一组元素的合适位置上去，直到元素全部插完为止。直接插入排序； 当插入第i(i&gt;&#x3D;1)个元素时，前面的array[0],array[1],…,array[i-1]已经 排好序，此时用array[i]的排序码与array[i-1],array[i-2],…的排序码顺序 进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移元素集合越接近有序，直接插入排序算法的时间效率越高 最优情况下：时间效率为O(n) 最差情况下：时间复杂度为O(n^2) 空间复杂度：O(1)，它是一种稳定的排序算法*&#x2F;#include &lt;stdio.h&gt;void InsertSort(int k[], int n)&#123;int i, j, temp;for( i&#x3D;1; i &lt; n; i++ )&#123;if( k[i] &lt; k[i-1] )&#123;temp &#x3D; k[i];for( j&#x3D;i-1; k[j] &gt; temp; j-- )&#123;k[j+1] &#x3D; k[j];&#125;k[j+1] &#x3D; temp;&#125;&#125;&#125;int main()&#123;int i, a[10] &#x3D; &#123;5, 2, 6, 0, 3, 9, 1, 7, 4, 8&#125;;InsertSort(a, 10);printf(&quot;排序后的结果是：&quot;);for( i&#x3D;0; i &lt; 10; i++ )&#123;printf(&quot;%d&quot;, a[i]);&#125;printf(&quot;\n\n&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-直接插入排序的性能分析"><a href="#4-直接插入排序的性能分析" class="headerlink" title="4.直接插入排序的性能分析"></a>4.直接插入排序的性能分析</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h3><h4 id="a-最坏情况"><a href="#a-最坏情况" class="headerlink" title="a.最坏情况"></a>a.最坏情况</h4><p>​            每次来的都是“最小元素”            “反序”</p><p>​            O(n^2^)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123094724749.png" alt="image-20210123094724749" loading="lazy"></p><h4 id="b-最好情况"><a href="#b-最好情况" class="headerlink" title="b.最好情况"></a>b.最好情况</h4><p>​            每次来的都是”最大元素”        正序</p><p>​            O(n)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123094916432.png" alt="image-20210123094916432" loading="lazy"></p><h4 id="c-平均情况"><a href="#c-平均情况" class="headerlink" title="c.平均情况"></a>c.平均情况</h4><p>​                O(n^2^)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123095227821.png" alt="image-20210123095227821" loading="lazy"></p><h3 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h3><p>​            O(1)</p><h2 id="5-直接插入排序稳定性分析"><a href="#5-直接插入排序稳定性分析" class="headerlink" title="5.直接插入排序稳定性分析"></a>5.直接插入排序稳定性分析</h2><p>直接插入排序    是    稳定的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123095704143.png" alt="image-20210123095703913" loading="lazy"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>1.插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率。O（n）</p><p>但</p><p>2.插入排序一般来说是低效的，因为插入排序每次只能将数据移动一个位置。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>插入排序由于O( n2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。例如，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。又如，在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123095753674.png" alt="image-20210123095753674" loading="lazy"></p><h1 id="三、折半插入排序"><a href="#三、折半插入排序" class="headerlink" title="三、折半插入排序"></a>三、折半插入排序</h1><h2 id="1-什么是折半插入排序"><a href="#1-什么是折半插入排序" class="headerlink" title="1.什么是折半插入排序"></a>1.什么是折半插入排序</h2><p>（Binary Insertion Sort）折半插入排序又称二分插入排序，是插入排序的一种。<br>折半插入排序是对直接插入排序的一种改进。<br>        改进？<br>    （直接插入排序）线性查找     —&gt;    折半查找</p><p>​        减少比较次数</p><p>基本思路：<br>        每次插入操作，采用折半查找的方式，查找插入位置，</p><p>​        然后再插入元素（先挪后插入）。</p><h2 id="2-算法思路"><a href="#2-算法思路" class="headerlink" title="2.算法思路"></a>2.算法思路</h2><h3 id="step-1：找插入位置（Insertion-Position）"><a href="#step-1：找插入位置（Insertion-Position）" class="headerlink" title="step 1：找插入位置（Insertion Position）"></a>step 1：找插入位置（Insertion Position）</h3><p>待查找范围的下标    [low，high]<br>每次跟中间元素PK mid&#x3D;（low+hiqh）&#x2F;  2</p><p>根据PK结果，调整待查找范围（改变low or high）</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123104037173.png" alt="image-20210123104037173" loading="lazy"></p><p>如此重复，直到查找不成功（1ow&gt;high了）或 查找到？</p><h4 id="1-查找不成功"><a href="#1-查找不成功" class="headerlink" title="(1)查找不成功"></a>(1)查找不成功</h4><p>（原有序表中没有待插入的元素）时，插入位置的确定</p><p>​    Insertion Position &#x3D; high + 1 (low)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123104103657.png" alt="image-20210123104103657" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123104624817.png" alt="image-20210123104624817" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105046439.png" alt="image-20210123105046439" loading="lazy"></p><h4 id="2-查找成功"><a href="#2-查找成功" class="headerlink" title="(2)查找成功"></a>(2)查找成功</h4><p>（原有序表中有待插入的元素）时，插入位置的确定</p><p>靠后的插入位置，更优化（后续挪动次数会少一些）</p><p>low &#x3D; mid+1，when x &#x3D;&#x3D; a[mid]</p><p>…</p><p>&#x3D;&gt;    查找不成功</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105259464.png" alt="image-20210123105259464" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105909395.png" alt="image-20210123105909395" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123105810213.png" alt="image-20210123105810213" loading="lazy"></p><h3 id="step-2：插入操作"><a href="#step-2：插入操作" class="headerlink" title="step 2：插入操作"></a>step 2：插入操作</h3><h4 id="1-先挪元素"><a href="#1-先挪元素" class="headerlink" title="(1)先挪元素"></a>(1)先挪元素</h4><p>​        [last，—&gt; Insertion Position]<br>​                        high+1</p><h4 id="2-插入操作"><a href="#2-插入操作" class="headerlink" title="(2)插入操作"></a>(2)插入操作</h4><p>x-&gt;[Insertion Position]</p><p>​    x-&gt;a[high +1]</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#define N 5&#x2F;*BinInsert:一次折半插入@a:有序表，数组名@n:有序表的元素个数a[0] a[1] ... a[n-1]@x：待插入元素返回值：无 *&#x2F;void BinInsert(int a[], int n,int x)&#123;int i; int low &#x3D; 0;&#x2F;&#x2F;查找范围，最左边元素的下标int high &#x3D; n-1;&#x2F;&#x2F;查找范围，最右边元素的下标int mid;&#x2F;&#x2F;查找范围中间元素的下标&#x2F;&#x2F;step 1：用二分法找插入位置while(low &lt;&#x3D; high)&#123;mid &#x3D; (low + high)&#x2F;2;if(x &gt;&#x3D; a[mid])&#123;low &#x3D; mid + 1;&#125;else&#x2F;&#x2F;x &lt; a[mid] &#123;high &#x3D; mid - 1;&#125;&#125;&#x2F;&#x2F;high+1 就是x的插入位置 &#x2F;&#x2F;step2: 插入操作(先挪后插入) for(i &#x3D; n - 1; i &gt;&#x3D; high+1; i--)&#123;a[i+1] &#x3D; a[i];&#125;a[high+1] &#x3D; x;&#125; void insertSort(int a[] , int n)&#123;int i,j;for(i &#x3D; 1; i &lt; n; i++)&#123;BinInsert(a,i,a[i]);&#125;&#125;int main()&#123;int a[N]&#x3D;&#123;0&#125;;int i;for(i&#x3D;0;i&lt;N;i++)&#123;scanf(&quot;%d&quot;,&amp;a[i]);&#125;insertSort(a,N);for(i&#x3D;0;i&lt;N;i++)&#123;printf(&quot;%d&quot;,a[i]);&#125;printf(&quot;\n&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-折半插入排序的性能分析"><a href="#3-折半插入排序的性能分析" class="headerlink" title="3.折半插入排序的性能分析"></a>3.折半插入排序的性能分析</h2><h4 id="1-时间复杂度-1"><a href="#1-时间复杂度-1" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h4><p>一次BinInsert的时间T&#x3D;Ts +Tm</p><p>其中 Ts 为一次二分查找的时间</p><p>二分查找插入位置时，都是“查找不成功（查找最坏）”的情况</p><p>so，每次查找比较次数为：1og2N </p><p>​            Ts&#x3D;t1*log2N </p><p>​            Tm为一次移动元素的时间<br>根据插入位置，每次插入移动元素的个数，分为：<br>最好情况：移动一个<br>最坏情况：移动n个<br>平均情况：移动（n&#x2F;2）</p><p>所以，我们根据移动元素的情形，把折半插入排序的时间复杂度分为三种情况：<br>最好情况：</p><p>​                O(nlog<del>2</del>N)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123113926334.png" alt="image-20210123112952294" loading="lazy"></p><p>最坏情况：</p><p>​                O( n^2^)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123113826430.png" alt="image-20210123113826430" loading="lazy"></p><p>平均情况：</p><p>​                O( n^2^)</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123113926334.png" alt="image-20210123113926334" loading="lazy"></p><h4 id="2-空间复杂度-1"><a href="#2-空间复杂度-1" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h4><p>​                    O(1)</p><h2 id="4-折半插入排序稳定性分析"><a href="#4-折半插入排序稳定性分析" class="headerlink" title="4.折半插入排序稳定性分析"></a>4.折半插入排序稳定性分析</h2><p>折半插入排序    是    稳定的。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123134417341.png" alt="image-20210123134417341" loading="lazy"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123135701205.png" alt="image-20210123135701205" loading="lazy"></p><p>折半插入排序相比直接插入排序只优化了查找插入位置的比较次数，移动元素的次数并没有解决。所以：<br>（1）当数据元素比较多（N值比较大）or<br>（2）移动元素的代价    小于    关键字比较时</p><p>​        采用折半插入排序比较有优势。</p><h1 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h1><h2 id="1-什么是希尔排序"><a href="#1-什么是希尔排序" class="headerlink" title="1.什么是希尔排序"></a>1.什么是希尔排序</h2><p>希尔排序，是由Donald shel1于1959年提出的一种排序算法。又称“缩小增量排序”，是插入排序的一种。<br>基本思想：<br>（1）把待排序列，分成多个间隔为h的子序例，</p><p>​        然后对每个子序列进行直接插入排序；</p><p>​        重复（1）多次，每次间隔h不同（并且越来越小），</p><p>​        最后一次选取间隔h&#x3D;1，完成排序。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124115913.gif" alt="img" loading="lazy"></p><h2 id="2-算法思路-1"><a href="#2-算法思路-1" class="headerlink" title="2.算法思路"></a>2.算法思路</h2><p>h-sorting<br>        增量h排序 &#x2F; “间隔h排序”</p><p>h-sorted&#x2F;h-ordered<br>        增量h有序 &#x2F; ”间隔h有序”</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123140816426.png" alt="image-20210123140816426" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123141319425.png" alt="image-20210123141319425" loading="lazy"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define N 5&#x2F;*    h_sorting：一次增量h排序     @a:进行增量h排序的原始序列，数组名     @n:原有序表的元素个数，    a[0] a[1] ,..., a[n-1]     @h:增量h&#x2F;间隔h     返回值：        无返回*&#x2F;void h_sorting(int a[], int n, int h)&#123;int i,j;int x;for(i &#x3D; h; i &lt; n; i++)&#123;x &#x3D; a[i];for(j &#x3D; i - h; j &gt;&#x3D; 0 &amp;&amp; a[j] &gt; x; j &#x3D; j-h)&#123;a[j+h] &#x3D; a[j];&#125;a[j+h] &#x3D; x;&#125; &#125; &#x2F;&#x2F;对数组a，进行一个shell排序 void shell_sort(int a[], int n)&#123;int i;&#x2F;&#x2F;增量序列 int h[] &#x3D; &#123;8,4,2,1&#125;; for(i &#x3D; 0; i &lt; 4; i++)&#123;h_sorting(a, n, h[i]);&#125;&#125;int main()&#123;int i;    int a[N];    for(i &#x3D; 0; i &lt; N; i++)    &#123;    scanf(&quot;%d&quot;,&amp;a[i]);&#125;shell_sort(a, N);for(i &#x3D; 0; i &lt; N; i++)    &#123;    printf(&quot;%d\t&quot;,a[i]);&#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-希尔插入排序的性能分析"><a href="#3-希尔插入排序的性能分析" class="headerlink" title="3.希尔插入排序的性能分析"></a>3.希尔插入排序的性能分析</h2><p>关于希尔排序的几个基本认知：<br>（1）ht-Orderd序列，在后面的hi-sorting后，将仍然保持它的排序性；【定理】<br>（2）在h-sorting时，采用插入排序被证实比其他排序方法效率更高；<br>（3）不同的增量序列，对希尔排序的性能影响比较大。</p><h4 id="1-时间复杂度-2"><a href="#1-时间复杂度-2" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h4><p>一般认为，希尔排序的时间复杂度为：<br>            平均&#x2F;最坏情况下                        最好的情况下（本身就是有序的）<br>            O（n^r^），1&lt;r&lt;2                            O（nlog<del>2</del>n）</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123144403182.png" alt="image-20210123144403182" loading="lazy"></p><h4 id="2-空间复杂度-2"><a href="#2-空间复杂度-2" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h4><p>​                        O（1）</p><h2 id="4-希尔排序稳定性分析"><a href="#4-希尔排序稳定性分析" class="headerlink" title="4.希尔排序稳定性分析"></a>4.希尔排序稳定性分析</h2><p>​                                希尔排序是一种    不稳定    的排序方法。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123144513092.png" alt="image-20210123144513092" loading="lazy"></p><h2 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5.总结"></a>5.总结</h2><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀–快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123144621673.png" alt="image-20210123144621673" loading="lazy"></p><h1 id="五、冒泡排序"><a href="#五、冒泡排序" class="headerlink" title="五、冒泡排序"></a>五、冒泡排序</h1><h2 id="1-什么是冒泡排序"><a href="#1-什么是冒泡排序" class="headerlink" title="1.什么是冒泡排序"></a>1.什么是冒泡排序</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123153036871.png" alt="image-20210123153036871" loading="lazy"></p><p>冒泡排序（BubbleSort），是一种简单的排序算法。</p><p>它“从头到尾”重复遍历要排序的数列，一次比较两个元素，如果他们的顺序是错的，就把他们交换过来。</p><p>遍历数列的工作要重复进行，直到没有元素需要交换，此时排序完成。</p><p>“相邻元素两两比较，如果顺序是错的，就交换他们”</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/849589-20171015223238449-2146169197.gif" alt="img" loading="lazy"></p><h2 id="2-算法思路-2"><a href="#2-算法思路-2" class="headerlink" title="2.算法思路"></a>2.算法思路</h2><p>（1）比较第一个和第二个元素。如果第一个比第二个大，就交换他们两个</p><p>（2）比较第二个和第三个元素。如果第二个比第三个大，就交换他们两个</p><p>……</p><p>（n）比较第n-1个和第n个元素。如果第n-1个比第n个大，就交换他们两个</p><p>​        上面过程实际上是对每一对相邻元素作同样的比较交换工作，</p><p>​        从第一对到最后一对，这一趟做完后，最大的元素会在最后的位置上。</p><p>​        “一趟冒泡”：把一个最大的元素归位。</p><p>上面冒泡”过程，重复N-1（最多N-1）趟，所有元素都会归位。</p><p>“N-1趟冒泡”：排序完成。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123145949207.png" alt="image-20210123145949207" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123150038094.png" alt="image-20210123150038094" loading="lazy"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token comment">//冒泡排序</span><span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//第t趟冒泡 [0, N-1] </span><span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//[0, n-1-t] 第t趟冒泡，待排序区的下标</span><span class="token comment">//一趟冒泡</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">bubble_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123151525102.png" alt="image-20210123151525102" loading="lazy"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define N 5&#x2F;&#x2F;冒泡排序void bubble_sort(int a[], int n)&#123;int i;int t &#x3D; 0;&#x2F;&#x2F;第t趟冒泡 [0, N-1] int temp;int exchange &#x3D; 0;&#x2F;&#x2F;标记，是否有元素进行交换&#x2F;&#x2F;1 表示有元素进行交换&#x2F;&#x2F;0 表示没有元素进行交换 for(t &#x3D; 0; t &lt; n - 1; t++)&#123;&#x2F;&#x2F;[0, n-1-t] 第t趟冒泡，待排序区的下标&#x2F;&#x2F;一趟冒泡for(i &#x3D; 0; i &lt; n-1-t; i++)&#123;if(a[i] &gt; a[i+1])&#123;temp &#x3D; a[i];a[i] &#x3D; a[i+1];a[i+1] &#x3D; temp;exchange &#x3D; 1; &#125;&#125; if(exchange &#x3D;&#x3D; 0)&#x2F;&#x2F;刚刚那趟冒泡过程，没有发生元素交换，&#123;break;&#125; &#125;&#125; int main()&#123;int i;    int a[N];    for(i &#x3D; 0; i &lt; N; i++)    &#123;    scanf(&quot;%d&quot;,&amp;a[i]);&#125;bubble_sort(a, N);for(i &#x3D; 0; i &lt; N; i++)    &#123;    printf(&quot;%d\t&quot;,a[i]);&#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="另外的版本"><a href="#另外的版本" class="headerlink" title="另外的版本"></a>另外的版本</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*优化过的正宗版本的冒泡排序*&#x2F;&#x2F;*用flag模拟布尔类型，如果遍历一遍后没有元素位置的交换就不再进行再次遍历排序*&#x2F;#include &lt;stdio.h&gt;void BubbleSort(int k[], int n)&#123;int i, j, temp, count1&#x3D;0, count2&#x3D;0, flag;flag &#x3D; 1;for( i&#x3D;0; i &lt; n-1 &amp;&amp; flag; i++ )&#123;for( j&#x3D;n-1; j &gt; i; j-- )&#123;count1++;flag &#x3D; 0;if( k[j-1] &gt; k[j] )&#123;count2++;temp &#x3D; k[j-1];k[j-1] &#x3D; k[j];k[j] &#x3D; temp;flag &#x3D; 1;&#125;&#125;&#125;printf(&quot;总共进行了%d次比较，进行了%d次移动！&quot;, count1, count2);&#125;int main()&#123;int i, a[10] &#x3D; &#123;5, 2, 6, 0, 3, 9, 1, 7, 4, 8&#125;;BubbleSort(a, 10);printf(&quot;排序后的结果是：&quot;);for( i&#x3D;0; i &lt; 10; i++ )&#123;printf(&quot;%d&quot;, a[i]);&#125;printf(&quot;\n\n&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-冒泡排序的性能分析"><a href="#3-冒泡排序的性能分析" class="headerlink" title="3.冒泡排序的性能分析"></a>3.冒泡排序的性能分析</h2><h4 id="1-时间复杂度-3"><a href="#1-时间复杂度-3" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h4><h5 id="a-最好情况"><a href="#a-最好情况" class="headerlink" title="a.最好情况"></a>a.最好情况</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152217350.png" alt="image-20210123152052135" loading="lazy"></p><h5 id="b-最坏情况"><a href="#b-最坏情况" class="headerlink" title="b.最坏情况"></a>b.最坏情况</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152217350.png" alt="image-20210123152217350" loading="lazy"></p><h5 id="c-平均情况-1"><a href="#c-平均情况-1" class="headerlink" title="c.平均情况"></a>c.平均情况</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152314489.png" alt="image-20210123152314489" loading="lazy"></p><h4 id="2-空间复杂度-3"><a href="#2-空间复杂度-3" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h4><p>​                            O（1）</p><h2 id="4-冒泡排序稳定性分析"><a href="#4-冒泡排序稳定性分析" class="headerlink" title="4.冒泡排序稳定性分析"></a>4.冒泡排序稳定性分析</h2><p>​        冒泡排序是一种    <strong>稳定的</strong>    排序方法。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152717358.png" alt="image-20210123152717358" loading="lazy"></p><h2 id="5-总结-2"><a href="#5-总结-2" class="headerlink" title="5.总结"></a>5.总结</h2><p>简言之，冒泡排序除开它迷人的名字和导致了某些有趣的理论问题这一事实之外，似乎没有什么值得推荐的。—Knuth《计算机程序设计艺术》</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123152651749.png" alt="image-20210123152651749" loading="lazy"></p><h3 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="(1)什么时候最快"></a>(1)什么时候最快</h3><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p><h3 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="(2) 什么时候最慢"></a>(2) 什么时候最慢</h3><p>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p><h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="(3)适用场景"></a>(3)适用场景</h3><p>冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p><h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a>六、快速排序</h1><h2 id="1-什么是快速排序"><a href="#1-什么是快速排序" class="headerlink" title="1.什么是快速排序"></a>1.什么是快速排序</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123155510747.png" alt="image-20210123155510747" loading="lazy"></p><p>快速排序（英语：QuickSort）是一种高效的排序算法，最早由英国计算机科学家Tony Hoare于1959年发明。<br>快速排序不断重复的一个操作是：选取一个基准值（pivot），然后把原序列划分（partition）为两部分，一部分小于基准值，另外一部分大于等于基准值，所以快速排序又称划分交换排序（partition-exchange sort）。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="img" loading="lazy"></p><h2 id="2-算法思路-3"><a href="#2-算法思路-3" class="headerlink" title="2.算法思路"></a>2.算法思路</h2><p>快速排序采用分治算法（divide-and-conquer），它是这样工作的：<br>（1）从待排序的数列中选择一个基准元素（pivot），然后（2）把剩余元素划分（“分割”）为两个子数列：<br>小于基准元素值的子序列S1和<br>大于等于基准元素值的子序列s2<br>（3）子序列S1和s2按同样的方法递归执行（1）和（2），直到序列中的元素个数为0或1。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123160026835.png" alt="image-20210123160026835" loading="lazy"></p><p>具体的算法步骤：Qsort（A[ ]，left，right）</p><p>关键：把序列分割成两部分：“小”基准值“大”</p><p>（1）（在待排序数列中）选择一个元素作为基准值pivot</p><p>（2）把基准值与区间最后一个元素交换</p><p>（3）设置两个索i，j : i从区间第一个元素开始，而 j 从区间倒数第二个开始（倒数第一个是pivot）</p><p>（4）i往右找下一个比pivot大（&gt;&#x3D;）的元素，</p><p>​        while（A[i]&lt;pivot）i++；</p><p>j往左找下一个比pivot小的元素</p><p>​        while（j&gt;&#x3D;0&amp;&amp;A[j]&gt;&#x3D;pivot）j–；</p><p>（5）ifi&lt;j则交换A[i]与A[j]的位置</p><p>​        重复（4），（5）直到i&gt;&#x3D;j</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123165053504.png" alt="image-20210123165053504" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123163826922.png" alt="image-20210123163826922" loading="lazy"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>ElemType <span class="token operator">*</span>p<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ElemType t<span class="token punctuation">;</span> t <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>s<span class="token punctuation">;</span><span class="token operator">*</span>s <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*QSort：把数列A[1eft]...A[right]进行快速的排序@A：数组名@left：待排序数列最左边元素的下标@right：待排序数列最右边元素的下标返回值：无。*/</span><span class="token keyword">void</span> <span class="token function">QSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ElemType pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//1.选取一个基准值</span><span class="token comment">//2.把基准值元素与 最后一个元素交换</span><span class="token comment">//3.设置两个索引 i,j;</span><span class="token comment">//i从第一个元素开始往右遍历</span><span class="token comment">//j从倒数第二个元素开始往左遍历</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token keyword">int</span> j <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//4.”两头点蜡“ </span><span class="token comment">//i从左->右，找下一个比pivot大（>=）的元素</span><span class="token keyword">while</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//j从右->左，找下一个比pivot小的元素 </span><span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//交换：把大的元素放在序列的右边</span><span class="token comment">//把小的元素放在序列的左边</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token comment">//i >= j</span><span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//6.i 指向的位置就是pivot的位置</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>A<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//S1: A[left] ... A[i-1]</span><span class="token function">QSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//S2:A[i+1] ... A[right] </span><span class="token function">QSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>ElemType A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">QSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-三数中值分割法"><a href="#3-三数中值分割法" class="headerlink" title="3.三数中值分割法"></a>3.三数中值分割法</h2><h3 id="快排-pivot-选择策略"><a href="#快排-pivot-选择策略" class="headerlink" title="快排 pivot 选择策略"></a>快排 pivot 选择策略</h3><p>1.每次固定选择序列中的第一个or最后一个元素作为pivo如果输入序列是随机的，那么这种策略是可以接受的但是如果输入是预排序的或反序的，那么这种策略下的分割是非常糟糕的，因为所有的元素不是被划入s1就是被划入S2</p><p>预排序的输入（或具有一大预排序数据的输入）是相当常见的，因此这种策略绝对是糟糕的主意</p><p>2.般来说这种策略非常安全，除非随机数生成器有问题，因为随机的 pivot 不可能总是产生劣质的要割方面，随机数的生成一般是昂贵的，所以这种策略根本减少了算法其余的平均运行时间</p><p>3.三数中值分割法（ Median-of- Three Partitioning）<br>pivot的最好的选择是数列的中值</p><p>不幸的是，这很难算出。所以中值只能估计，中值的估计量可以通过随机选取三个元素，并用它们的中值作为 pivot而得到事实上，随机性并没有多大帮助，因此一般的做法是使用左端、右端、和中心位置上三个元素的中值作为pivot</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/image-20210123194012123.png" alt="image-20210123194012123" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/%E4%B8%89%E5%80%BC.png" alt="image-20210123205843034" loading="lazy"></p><p><img src="C:\Users\king\AppData\Roaming\Typora\typora-user-images\image-20210124112644914.png" alt="image-20210124112644914" loading="lazy"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#define N 5typedef int ElemType;void swap(ElemType *p,ElemType *s)&#123;ElemType t; t &#x3D; *p;*p &#x3D; *s;*s &#x3D; t;&#125;&#x2F;*QSort：把数列A[1eft]...A[right]进行快速的排序@A：数组名@left：待排序数列最左边元素的下标@right：待排序数列最右边元素的下标返回值：无。*&#x2F;void QSort(ElemType A[], int left, int right)&#123;if(left &gt;&#x3D; right)&#123;return ;&#125;ElemType pivot; &#x2F;&#x2F;&#x3D; A[right]; &#x2F;&#x2F;1.选取一个基准值&#x2F;&#x2F;2.把基准值元素与 最后一个元素交换&#x2F;&#x2F; 采用“三数分割法”int center &#x3D; (left + right)&#x2F;2;if(A[left] &gt; A[center])&#123;swap(&amp;A[left], &amp;A[center]);&#125;if(A[left] &gt; A[right])&#123;swap(&amp;A[left], &amp;A[right]);&#125;if(A[center] &gt; A[right])&#123;swap(&amp;A[center], &amp;A[right]);&#125; &#x2F;&#x2F; A[left] &lt;&#x3D; A[center] &lt;&#x3D; A[right]pivot &#x3D; A[center];swap(&amp;A[center], &amp;A[right-1]);&#x2F;&#x2F;left....right-1&#x2F;&#x2F; pivot:A[right - 1]&#x2F;&#x2F;3.设置两个索引 i,j;&#x2F;&#x2F;i从第一个元素开始往右遍历&#x2F;&#x2F;j从倒数第二个元素开始往左遍历int i &#x3D; left;int j &#x3D; right - 1;for(; i &lt; j ; )&#123;&#x2F;&#x2F;4.”两头点蜡“ &#x2F;&#x2F;i从左-&gt;右，找下一个比pivot大（&gt;&#x3D;）的元素while(A[++i] &lt; pivot);&#x2F;&#x2F;j从右-&gt;左，找下一个比pivot小的元素 while(A[--j] &gt; pivot);if(i &lt; j)&#123;&#x2F;&#x2F;交换：把大的元素放在序列的右边&#x2F;&#x2F;把小的元素放在序列的左边swap(&amp;A[i], &amp;A[j]); &#125; else&#x2F;&#x2F;i &gt;&#x3D; j&#123;break;&#125;&#125; &#x2F;&#x2F;6.i 指向的位置就是pivot的位置swap(&amp;A[i], &amp;A[right-1]);&#x2F;&#x2F;S1: A[left] ... A[i-1]QSort(A, left, i-1);&#x2F;&#x2F;S2:A[i+1] ... A[right] QSort(A, i+1, right);&#125;void QuickSort(ElemType A[], int n)&#123;QSort(A, 0, n-1);&#125;int main()&#123;int i;    int a[N];    for(i &#x3D; 0; i &lt; N; i++)    &#123;    scanf(&quot;%d&quot;,&amp;a[i]);&#125;QuickSort(a, N);for(i &#x3D; 0; i &lt; N; i++)    &#123;    printf(&quot;%d\t&quot;,a[i]);&#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-快速排序的性能分析"><a href="#4-快速排序的性能分析" class="headerlink" title="4.快速排序的性能分析"></a>4.快速排序的性能分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113036.png" alt="image-20210124113036589" loading="lazy"></p><h4 id="1-时间复杂度-4"><a href="#1-时间复杂度-4" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h4><h5 id="a-最坏情况-1"><a href="#a-最坏情况-1" class="headerlink" title="a.最坏情况"></a>a.最坏情况</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113157.png" alt="image-20210124113156762" loading="lazy"></p><h5 id="b-最好情况-1"><a href="#b-最好情况-1" class="headerlink" title="b.最好情况"></a>b.最好情况</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113251.png" alt="image-20210124113250865" loading="lazy"></p><h5 id="c-平均情况-2"><a href="#c-平均情况-2" class="headerlink" title="c.平均情况"></a>c.平均情况</h5><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113557.png" alt="image-20210124113556982" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124113438.png" alt="image-20210124113437532" loading="lazy"></p><h4 id="2-空间复杂度-4"><a href="#2-空间复杂度-4" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124114022.png" alt="image-20210124114022789" loading="lazy"></p><h2 id="5-快速排序稳定性分析"><a href="#5-快速排序稳定性分析" class="headerlink" title="5.快速排序稳定性分析"></a>5.快速排序稳定性分析</h2><p>快速排序是    不稳定    的。</p><h2 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6.总结"></a>6.总结</h2><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210124114240.png" alt="image-20210124114240345" loading="lazy"></p><p>关于快速排序对于很小的数组（&lt;&#x3D;20），快速排序不如插入排序好不仅如此；因为快速排序是递归，所以这样的情形还经常发生。<br>通常的解决方法是对于小的数组不递归地使用快速排序，而代之以如插入排序这样对小数组有效的排序算法。<br>所以一般在实现快速排序算法（如：c&#x2F;c++标准库中）时，定义一个递归的截止范围（ cutoff range），当序列元素个数小于这个范围时，使用直接插入排序。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define cutoff 10&#x2F;&#x2F;数组长度小于10用插入排序，大于10使用快速排序&#x2F;*对于小的数组不递归地使用快速排序，而代之以如插入排序这样对小数组有效的排序算法。*&#x2F;void QSort(ElemType A[], int left, int right)&#123;if(right - left &lt; cutoff)&#123;insertsort(A+left, right-left+1);&#125;else    &#123;        ElemType pivot; &#x2F;&#x2F;&#x3D; A[right];         &#x2F;&#x2F;1.选取一个基准值        &#x2F;&#x2F;2.把基准值元素与 最后一个元素交换        &#x2F;&#x2F; 采用“三数分割法”        int center &#x3D; (left + right)&#x2F;2;        if(A[left] &gt; A[center])        &#123;            swap(&amp;A[left], &amp;A[center]);        &#125;        if(A[left] &gt; A[right])        &#123;            swap(&amp;A[left], &amp;A[right]);        &#125;        if(A[center] &gt; A[right])        &#123;            swap(&amp;A[center], &amp;A[right]);        &#125;         &#x2F;&#x2F; A[left] &lt;&#x3D; A[center] &lt;&#x3D; A[right]        pivot &#x3D; A[center];        swap(&amp;A[center], &amp;A[right-1]);&#x2F;&#x2F;left....right-1        &#x2F;&#x2F; pivot:A[right - 1]        &#x2F;&#x2F;3.设置两个索引 i,j;        &#x2F;&#x2F;i从第一个元素开始往右遍历        &#x2F;&#x2F;j从倒数第二个元素开始往左遍历        int i &#x3D; left;        int j &#x3D; right - 1;        for(; i &lt; j ; )        &#123;            &#x2F;&#x2F;4.”两头点蜡“             &#x2F;&#x2F;i从左-&gt;右，找下一个比pivot大（&gt;&#x3D;）的元素            while(A[++i] &lt; pivot);            &#x2F;&#x2F;j从右-&gt;左，找下一个比pivot小的元素             while(A[--j] &gt; pivot);            if(i &lt; j)            &#123;                &#x2F;&#x2F;交换：把大的元素放在序列的右边                &#x2F;&#x2F;把小的元素放在序列的左边                swap(&amp;A[i], &amp;A[j]);             &#125;             else&#x2F;&#x2F;i &gt;&#x3D; j            &#123;                break;            &#125;        &#125;         &#x2F;&#x2F;6.i 指向的位置就是pivot的位置        swap(&amp;A[i], &amp;A[right-1]);        &#x2F;&#x2F;S1: A[left] ... A[i-1]        QSort(A, left, i-1);        &#x2F;&#x2F;S2:A[i+1] ... A[right]         QSort(A, i+1, right);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="七-选择排序"><a href="#七-选择排序" class="headerlink" title="七.选择排序"></a>七.选择排序</h1><h2 id="1-什么是选择排序"><a href="#1-什么是选择排序" class="headerlink" title="1.什么是选择排序"></a>1.什么是选择排序</h2><p>选择排序（ Selection Sort）是一种简单直观的排序算法.</p><p>它的工作原理如下：</p><p>在未排序序列中（ unsorted list，无序区）中找到最小（大）元素，和序列中的第一个元素交换位置；（这个操作会使最小元素归位）</p><p>然后，再从剩余的未排序元素中继续寻找最小（大）元素，重复上面的操作。</p><p>直到所有元素归位，排序完成</p><p>基本思想：</p><p>选择+交换</p><p>选择排序又分为：</p><p>直接选择排序（简单选择排序）</p><p>堆排序</p><h2 id="2-算法思路-4"><a href="#2-算法思路-4" class="headerlink" title="2.算法思路"></a>2.算法思路</h2><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img" loading="lazy"></p><p>（1）从待排序数列（无序区）中，选择一个关键字最小的元素；</p><p>（2）如果最小元素不是待排序数列的第一个元素，则交换他们；“一次选择交换”；</p><p>（3）从余下的N-1个元素中，选择最小的，重复（1）（2）步骤，直到排序完成。</p><p>整个序列：</p><p>​                经过N-1次的选择交换，排序完成</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125181916.png" alt="image-20210125181909128" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125181934.png" alt="image-20210125181934226" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125182149.png" alt="image-20210125182149469" loading="lazy"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#define N 5void swap(int *p,int *s)&#123;int t; t &#x3D; *p;*p &#x3D; *s;*s &#x3D; t;&#125;&#x2F;*selection sort：直接选择排序@a：待排序数组名@n：待排序元素个数返回值：无*&#x2F;void selection_sort(int a[], int n)&#123;int i;int t;&#x2F;&#x2F;选择的次数t [0,n-1]int min;&#x2F;&#x2F;指向每次选择区域最小元素&#x2F;&#x2F;第t趟选择， 选择区域下标[t, n-1]for(t &#x3D; 0; t &lt; n-1; t++)&#123;min &#x3D; t;for(i &#x3D; t+1; i &lt; n; i++)&#123;if(a[i] &lt; a[min])&#123;min &#x3D; i;&#125;&#125;if(t !&#x3D; min)&#123;swap(&amp;a[t], &amp;a[min]);&#125;&#125;&#125;int main()&#123;int i;    int a[N];    for(i &#x3D; 0; i &lt; N; i++)    &#123;    scanf(&quot;%d&quot;,&amp;a[i]);&#125;selection_sort(a, N);for(i &#x3D; 0; i &lt; N; i++)    &#123;    printf(&quot;%d\t&quot;,a[i]);&#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-选择排序的性能分析"><a href="#3-选择排序的性能分析" class="headerlink" title="3.选择排序的性能分析"></a>3.选择排序的性能分析</h2><h3 id="1-时间复杂度-5"><a href="#1-时间复杂度-5" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h3><p>比较次数o（n^2^）</p><p>交换次数    0次    最好情况</p><p>​                n-1次    最坏情况</p><p>​                0&lt;，&lt;n-1    平均情况</p><p>然而，无论元素的初始排列如何，所需进行的关键字比较次数相同均为：n（n-1）&#x2F;2</p><p>选择排序时间复杂度（最好、最坏、平均）为：O（n^2^）</p><h3 id="2-空间复杂度-5"><a href="#2-空间复杂度-5" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h3><p>​                        O（1）</p><h2 id="4-选择排序稳定性分析"><a href="#4-选择排序稳定性分析" class="headerlink" title="4.选择排序稳定性分析"></a>4.选择排序稳定性分析</h2><p>​            选择排序是一种    不稳定    的排序方法</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125184549.png" alt="image-20210125184549734" loading="lazy"></p><h2 id="5-总结-3"><a href="#5-总结-3" class="headerlink" title="5.总结"></a>5.总结</h2><p>原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见</p><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125184641.png" alt="image-20210125184641554" loading="lazy"></p><h1 id="八-堆排序"><a href="#八-堆排序" class="headerlink" title="八.堆排序"></a>八.堆排序</h1><h2 id="1-什么是堆排序"><a href="#1-什么是堆排序" class="headerlink" title="1.什么是堆排序"></a>1.什么是堆排序<img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185210.png" alt="image-20210125185210617" loading="lazy"></h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185245.png" alt="image-20210125185245626" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185505.png" alt="image-20210125185505834" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185611.png" alt="image-20210125185611798" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185754.png" alt="image-20210125185754290" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125185900.png" alt="image-20210125185900117" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213436.gif" alt="img" loading="lazy"></p><h2 id="2-算法思路-5"><a href="#2-算法思路-5" class="headerlink" title="2.算法思路"></a>2.算法思路</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190056.png" alt="image-20210125190056471" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190209.png" alt="image-20210125190209046" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190310.png" alt="image-20210125190310315" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190536.png" alt="image-20210125190535982" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190717.png" alt="image-20210125190717479" loading="lazy"></p><h3 id="1-空穴上滤"><a href="#1-空穴上滤" class="headerlink" title="(1)空穴上滤"></a>(1)空穴上滤</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125190913.png" alt="image-20210125190913360" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191021.png" alt="image-20210125191021772" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191142.png" alt="image-20210125191141869" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191409.png" alt="image-20210125191409441" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191513.png" alt="image-20210125191513160" loading="lazy"></p><h3 id="2-空穴下滤"><a href="#2-空穴下滤" class="headerlink" title="(2)空穴下滤"></a>(2)空穴下滤</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191730.png" alt="image-20210125191730431" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125191831.png" alt="image-20210125191831299" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125192025.png" alt="image-20210125192025440" loading="lazy"></p><h3 id="3-代码实现关键"><a href="#3-代码实现关键" class="headerlink" title="(3)代码实现关键"></a>(3)代码实现关键</h3><h4 id="a-数据类型的实现"><a href="#a-数据类型的实现" class="headerlink" title="a.数据类型的实现"></a>a.数据类型的实现</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125192545.png" alt="image-20210125192545763" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125193137.png" alt="image-20210125193137702" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125193310.png" alt="image-20210125193310248" loading="lazy"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;&#x2F;&#x2F;无穷小 #define VERY_SMALL -1&#x2F;&#x2F;堆中结点的数据类型 typedef int ElemType;typedef struct Heapstruct&#123;int Capacity;&#x2F;&#x2F;堆中的最大容量int size;&#x2F;&#x2F;堆中实际的结点数，最后那个结点的编号（下标）ElemType *Elements;&#125;HeapStruct;&#x2F;*Init Heap：分配一个堆的结构体@n：指定堆中最大容量返回值：返回分配到的堆的结构体的指针*&#x2F;HeapStruct* Init_Heap(int n)&#123;Heapstruct *H&#x3D; malloc(sizeof(*H));H-&gt;Capacity &#x3D; n;H-&gt;size &#x3D; 0;H-&gt;Elements &#x3D; malloc(sizeof(ElemType)*(n+1));H-&gt;Elements[0] &#x3D; VERY_SMALL;  &#x2F;&#x2F;??return H;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="b-Insert操作的实现"><a href="#b-Insert操作的实现" class="headerlink" title="b.Insert操作的实现"></a>b.Insert操作的实现</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125194713.png" alt="image-20210125194713377" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125195104.png" alt="image-20210125195104011" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*Insert MinHeap：最小堆的插入操作@H：指向最小堆结构体指针@X：待插入元素返回值：无返回值。*/</span><span class="token keyword">void</span> <span class="token function">Insert_MinHeap</span><span class="token punctuation">(</span>Heapstruct <span class="token operator">*</span>H<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//指向空穴结点的下标</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token operator">++</span>H<span class="token operator">-></span>size<span class="token punctuation">;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">;</span> i <span class="token operator">=</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="c-Delete-Min操作的实现"><a href="#c-Delete-Min操作的实现" class="headerlink" title="c.Delete_Min操作的实现"></a>c.Delete_Min操作的实现</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125200153.png" alt="image-20210125200153750" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125200823.png" alt="image-20210125200823587" loading="lazy"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*Delete_Min：删除最小堆的最小值并调整使其仍然为最小堆@H：指向要删除最小值的最小堆返回值：返回删除的最小值*&#x2F;ElemType Delete_Min(Heapstruct *H)&#123;ElemType min &#x3D; H-&gt;Elements[1];ElemType last &#x3D; H-&gt;Elements[H-&gt;size--];int i;&#x2F;&#x2F;指向空穴结点的下标int child;&#x2F;&#x2F;指向空穴的较小孩子结点for(i &#x3D; 1; 2*i &lt;&#x3D; H-&gt;size; i &#x3D; child)&#123;child &#x3D; 2*i;&#x2F;&#x2F;如果有右孩子 并且 右孩子小于左孩子,child++ if(child + 1 &lt;&#x3D; H-&gt;size &amp;&amp; H-&gt;Elements[child + 1] &lt; H-&gt;Elements[child])&#123;child++;&#125;&#x2F;&#x2F;将孩子结点与最后一个结点比较，如果小于最后一个结点&#x2F;&#x2F;将孩子结点的值给父结点，此时孩子结点为新的空穴结点 if(H-&gt;Elements[child] &lt; last)&#123;H-&gt;Elements[i] &#x3D; H-&gt;Elements[child];&#125;else&#x2F;&#x2F;last比最小的孩子结点还要小 &#123;break;&#125;&#125; H-&gt;Elements[i] &#x3D; last;return min;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="d-堆排序代码实现"><a href="#d-堆排序代码实现" class="headerlink" title="d.堆排序代码实现"></a>d.堆排序代码实现</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125204832.png" alt="image-20210125204832101" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token comment">//无穷小 </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">VERY_SMALL</span> <span class="token expression"><span class="token operator">-</span><span class="token number">1</span></span></span><span class="token comment">//堆中结点的数据类型 </span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Heapstruct</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> Capacity<span class="token punctuation">;</span><span class="token comment">//堆中的最大容量</span><span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">//堆中实际的结点数，最后那个结点的编号（下标）</span>ElemType <span class="token operator">*</span>Elements<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>HeapStruct<span class="token punctuation">;</span><span class="token comment">/*Init Heap：分配一个堆的结构体@n：指定堆中最大容量返回值：返回分配到的堆的结构体的指针*/</span>HeapStruct<span class="token operator">*</span> <span class="token function">Init_Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>HeapStruct <span class="token operator">*</span>H<span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>H<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>H<span class="token operator">-></span>Capacity <span class="token operator">=</span> n<span class="token punctuation">;</span>H<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>H<span class="token operator">-></span>Elements <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> VERY_SMALL<span class="token punctuation">;</span>  <span class="token comment">//??</span><span class="token keyword">return</span> H<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*Insert MinHeap：最小堆的插入操作@H：指向最小堆结构体指针@X：待插入元素返回值：无返回值。*/</span><span class="token keyword">void</span> <span class="token function">Insert_MinHeap</span><span class="token punctuation">(</span>HeapStruct <span class="token operator">*</span>H<span class="token punctuation">,</span> ElemType x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//指向空穴结点的下标</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token operator">++</span>H<span class="token operator">-></span>size<span class="token punctuation">;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">;</span> i <span class="token operator">=</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*Delete_Min：删除最小堆的最小值并调整使其仍然为最小堆@H：指向要删除最小值的最小堆返回值：返回删除的最小值*/</span>ElemType <span class="token function">Delete_Min</span><span class="token punctuation">(</span>HeapStruct <span class="token operator">*</span>H<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ElemType min <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>ElemType last <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>H<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//指向空穴结点的下标</span><span class="token keyword">int</span> child<span class="token punctuation">;</span><span class="token comment">//指向空穴的较小孩子结点</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">&lt;=</span> H<span class="token operator">-></span>size<span class="token punctuation">;</span> i <span class="token operator">=</span> child<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>child <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">;</span><span class="token comment">//如果有右孩子 并且 右孩子小于左孩子,child++ </span><span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> H<span class="token operator">-></span>size <span class="token operator">&amp;&amp;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>child<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将孩子结点与最后一个结点比较，如果小于最后一个结点</span><span class="token comment">//将孩子结点的值给父结点，此时孩子结点为新的空穴结点 </span><span class="token keyword">if</span><span class="token punctuation">(</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> last<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token comment">//last比最小的孩子结点还要小 </span><span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> H<span class="token operator">-></span>Elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> last<span class="token punctuation">;</span><span class="token keyword">return</span> min<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*heap sort：堆排序@a：待排序数组@n：元素个数返回值：无*/</span><span class="token keyword">void</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>ElemType a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//初始化一个堆结构体</span>HeapStruct <span class="token operator">*</span>H <span class="token operator">=</span> <span class="token function">Init_Heap</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//堆排序的步骤：</span><span class="token comment">//（1）建立堆</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">Insert_MinHeap</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//(2)删除最小值</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Delete_Min</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token function">free</span><span class="token punctuation">(</span>H<span class="token operator">-></span>Elements<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">heap_sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="e-堆排序In-place版本实现"><a href="#e-堆排序In-place版本实现" class="headerlink" title="e.堆排序In-place版本实现"></a>e.堆排序In-place版本实现</h4><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125205332.png" alt="image-20210125205332729" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125205641.png" alt="image-20210125205641584" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125210209.png" alt="image-20210125210004430" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125210413.png" alt="image-20210125210413532" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125211217.png" alt="image-20210125210611015" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125211206.png" alt="image-20210125211206046" loading="lazy"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5#define Parent(i) (((i) - 1)&#x2F;2)#define Lchild(i) (2*(i) + 1)#define Rchild(i) (Lchild(i) + 1)&#x2F;&#x2F;堆中结点的数据类型 typedef int ElemType;void swap(int *p,int *s)&#123;int t; t &#x3D; *p;*p &#x3D; *s;*s &#x3D; t;&#125;&#x2F;*PercDown：实现编号为i的结点下滤操作（最大堆）@A：数组名@i：下滤结点编号（数组下标）@n：数组A的有效元素个数（堆中结点数目）数组下标从开始，A[0]，A[1],A[2],...A[n-1]返回值:无*&#x2F;void PercDown(ElemType A[], int i, int n)&#123;int child;&#x2F;&#x2F;指向空穴结点的较大孩子结点ElemType tmp;&#x2F;&#x2F;保存空穴结点的元素值for(tmp &#x3D; A[i]; Lchild(i) &lt; n; i &#x3D; child)&#123;child &#x3D; Lchild(i);if(child + 1 &lt; n &amp;&amp; A[child + 1] &gt; A[child])&#123;child++;&#125;if(A[child] &gt; tmp)&#123;A[i] &#x3D; A[child];&#125;else&#x2F;&#x2F;tmp&gt;&#x3D; A[child]&#123;break;&#125;&#125;A[i] &#x3D; tmp;&#125;void heap_sort_v2(ElemType A[], int n)&#123;int i;&#x2F;&#x2F;下滤结点下标&#x2F;&#x2F;1. build max heap&#x2F;&#x2F;逐个下滤 &#x2F;&#x2F;建立最大堆for(i &#x3D; Parent(n-1); i &gt;&#x3D; 0; i--)&#123;PercDown( A, i, n);&#125; &#x2F;&#x2F;2.Delete_MAXfor(i &#x3D; n-1; i &gt; 0; i--)&#123;swap(&amp;A[0], &amp;A[i]);PercDown( A, 0, i);&#125;&#125;int main()&#123;int i;    int a[N];    for(i &#x3D; 0; i &lt; N; i++)    &#123;    scanf(&quot;%d&quot;,&amp;a[i]);&#125;heap_sort_v2(a, N);for(i &#x3D; 0; i &lt; N; i++)    &#123;    printf(&quot;%d\t&quot;,a[i]);&#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-堆排序的性能分析"><a href="#3-堆排序的性能分析" class="headerlink" title="3.堆排序的性能分析"></a>3.堆排序的性能分析</h2><h3 id="1-时间复杂度-6"><a href="#1-时间复杂度-6" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213026.png" alt="image-20210125213026686" loading="lazy"></p><h3 id="2-空间复杂度-6"><a href="#2-空间复杂度-6" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h3><p>​                    O（1）</p><h2 id="4-堆排序稳定性分析"><a href="#4-堆排序稳定性分析" class="headerlink" title="4.堆排序稳定性分析"></a>4.堆排序稳定性分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213250.png" alt="image-20210125213250651" loading="lazy"></p><h2 id="5-总结-4"><a href="#5-总结-4" class="headerlink" title="5.总结"></a>5.总结</h2><h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210125213328.png" alt="image-20210125213328663" loading="lazy"></p><h1 id="九-归并排序"><a href="#九-归并排序" class="headerlink" title="九.归并排序"></a>九.归并排序</h1><h2 id="1-什么是归并排序"><a href="#1-什么是归并排序" class="headerlink" title="1.什么是归并排序"></a>1.什么是归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210126193204.gif" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210126194241.png" alt="image-20210126194241579" loading="lazy"></p><h2 id="2-算法思路-6"><a href="#2-算法思路-6" class="headerlink" title="2.算法思路"></a>2.算法思路</h2><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210126194456.png" alt="image-20210126194456817" loading="lazy"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-5066-20161218163120151-452283750.png" alt="img" loading="lazy"></p><p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><p><strong>合并相邻有序子序列</strong></p><p>再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127185921.png" alt="img" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127185935.png" alt="img" loading="lazy"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 5typedef int ElemType;&#x2F;*Merge：对两个有序表S[Lpos].. S[Rpos-1]S[Rpos].. S[RightEnd]进行归并操作@s：数组@Lpos：左边有序表开始元素的下标@Rpos：右边有序表开始元素的下标@RightEnd：右边有序表最后元素的下标@Aux：辅助数组返回值：无*&#x2F;void Merge(ElemType s[], int Lpos, int Rpos, int RightEnd,ElemType Aux[])&#123;int LeftEnd &#x3D; Rpos - 1;int Num &#x3D; RightEnd - Lpos + 1;&#x2F;&#x2F;要归并的总共的元素个数 int C_pos &#x3D; Lpos;&#x2F;&#x2F;辅助数组的起始下标while(Lpos &lt;&#x3D; LeftEnd &amp;&amp; Rpos &lt;&#x3D; RightEnd)&#123;if(s[Lpos] &lt;&#x3D; s[Rpos])&#123;Aux[C_pos++] &#x3D; s[Lpos++];&#125; else&#123;Aux[C_pos++] &#x3D; s[Rpos++];&#125;&#125;&#x2F;&#x2F;右边那个序列先到末尾while(Lpos &lt;&#x3D; LeftEnd)&#123;Aux[C_pos++] &#x3D; s[Lpos++];&#125; while(Rpos &lt;&#x3D; RightEnd)&#123;Aux[C_pos++] &#x3D; s[Rpos++];&#125; int i&#x3D;0;&#x2F;&#x2F;拷贝次数for(i &#x3D; 0; i &lt; Num; RightEnd--,i++)&#123;s[RightEnd] &#x3D; Aux[RightEnd];&#125; &#125;&#x2F;*MSort：对数列进行归并排序@s：要进行归并排序的数组@Left：归并排序最左边元素的下标@Right：归并排序最右边元素的下标@Aux：辅助数组返回值：无。*&#x2F;void Msort(ElemType s[], int Left, int Right, ElemType Aux[])&#123;if(Left &lt; Right)&#123;&#x2F;&#x2F;1.分割int mid &#x3D; (Left + Right) &#x2F; 2;&#x2F;&#x2F;A: Left ... mid&#x2F;&#x2F;B: mid+1 ... Rught&#x2F;&#x2F;2.对A进行归并排序Msort(s, Left, mid, Aux);&#x2F;&#x2F;3.对B进行归并排序Msort(s, mid+1, Right, Aux);&#x2F;&#x2F;4.对A和B进行归并操作Merge(s, Left, mid+1, Right, Aux); &#125;&#125;void Merge_Sort(ElemType A[], int n)&#123;ElemType *Aux &#x3D; malloc(sizeof(ElemType) *n);Msort(A, 0, n-1, Aux);free(Aux);&#125;int main()&#123;int i;    int a[N];    for(i &#x3D; 0; i &lt; N; i++)    &#123;    scanf(&quot;%d&quot;,&amp;a[i]);&#125;Merge_Sort(a, N);for(i &#x3D; 0; i &lt; N; i++)    &#123;    printf(&quot;%d\t&quot;,a[i]);&#125;printf(&quot;\n&quot;);     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-归并排序的性能分析"><a href="#3-归并排序的性能分析" class="headerlink" title="3.归并排序的性能分析"></a>3.归并排序的性能分析</h2><h3 id="1-时间复杂度-7"><a href="#1-时间复杂度-7" class="headerlink" title="(1)时间复杂度"></a>(1)时间复杂度</h3><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127181648.png" alt="image-20210127181641062" loading="lazy"></p><h3 id="2-空间复杂度-7"><a href="#2-空间复杂度-7" class="headerlink" title="(2)空间复杂度"></a>(2)空间复杂度</h3><p>​                    O（n）</p><h2 id="4-归并排序稳定性分析"><a href="#4-归并排序稳定性分析" class="headerlink" title="4.归并排序稳定性分析"></a>4.归并排序稳定性分析</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127181751.png" alt="image-20210127181751056" loading="lazy"></p><h2 id="5-总结-5"><a href="#5-总结-5" class="headerlink" title="5.总结"></a>5.总结</h2><h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h3><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。</p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/master/img/20210127181853.png" alt="image-20210127181852807" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266使用方法</title>
      <link href="/posts/b2fc5f68/"/>
      <url>/posts/b2fc5f68/</url>
      
        <content type="html"><![CDATA[<h1 id="一、ESP8266连线方式"><a href="#一、ESP8266连线方式" class="headerlink" title="一、ESP8266连线方式"></a>一、ESP8266连线方式</h1><h2 id="1、ESP8266引脚定义"><a href="#1、ESP8266引脚定义" class="headerlink" title="1、ESP8266引脚定义"></a>1、ESP8266引脚定义</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220216220231.png" alt="image-20200613150457590" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220216220236.png" alt="81028683567b087f56647b7b5bbfd99e_20200228114215425" loading="lazy"></p><h2 id="2、ESP8266通过串口连接电脑"><a href="#2、ESP8266通过串口连接电脑" class="headerlink" title="2、ESP8266通过串口连接电脑"></a>2、ESP8266通过串口连接电脑</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220216220240.png" alt="image-20200613150508621" loading="lazy"></p><h2 id="3、ESP8266烧录连线图"><a href="#3、ESP8266烧录连线图" class="headerlink" title="3、ESP8266烧录连线图"></a>3、ESP8266烧录连线图</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220216220245.png" alt="SouthEast" loading="lazy"></p><h2 id="4、ESP8266连接单片机"><a href="#4、ESP8266连接单片机" class="headerlink" title="4、ESP8266连接单片机"></a>4、ESP8266连接单片机</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220216220249.png" alt="image-20200613150508621" loading="lazy"></p><h1 id="二、ESP8266的三种模式"><a href="#二、ESP8266的三种模式" class="headerlink" title="二、ESP8266的三种模式"></a>二、ESP8266的三种模式</h1><h2 id="1、Station-模式："><a href="#1、Station-模式：" class="headerlink" title="1、Station 模式："></a>1、Station 模式：</h2><p>ESP8266 模块通过路由器连接互联网，手机或电脑通过互联网实现对设备的远程控制。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">AT<span class="token operator">+</span>CWMODE<span class="token operator">=</span><span class="token number">1</span>                     <span class="token comment">//1是Station模式</span>AT<span class="token operator">+</span>RST                     <span class="token comment">//重新启动wifi模块</span>AT<span class="token operator">+</span>CWJAP<span class="token operator">=</span><span class="token string">"所要连接的局域网WIFI名称"</span><span class="token punctuation">,</span><span class="token string">"WiFi密码"</span>          <span class="token comment">//连接WiFi</span>AT<span class="token operator">+</span>CIPMUX<span class="token operator">=</span><span class="token number">1</span>                   <span class="token comment">//开启多连接模式，允许多个客户端接入 </span>AT<span class="token operator">+</span>CIPSERVER<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5000</span>                <span class="token comment">//启动TCP/IP 实现基于网络//控制，我自己设置服务器的端口号为5000，可以设置其他端口号</span>AT<span class="token operator">+</span>CIPSTO<span class="token operator">=</span><span class="token number">0</span>                <span class="token comment">//服务永远不超时</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是手机需要验证模块自身的IP地址和端口号才能连接成功，因为自己只知道设置的端口号，不确定模块自身IP地址，所以需要查询模块IP,就要用下边的命令来查询模块自身的IP地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">AT<span class="token operator">+</span>CIFSR<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>串口助手会返回模块的IP地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">+</span>CIFSR<span class="token operator">:</span>STAIP<span class="token punctuation">,</span><span class="token string">"192.168.0.105"</span><span class="token operator">+</span>CIFSR<span class="token operator">:</span>STAMAC<span class="token punctuation">,</span><span class="token string">"5c:cf:7f:03:22:46"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不同模块不同模式下的IP地址是不确定的，所以在操作时候要多次查询模块的IP地址，以防止模块IP地址发生变化，同时在验证IP和端口号前，手机连接的WIFI和模块连接的WiFi相同。</p><h2 id="2、AP-模式："><a href="#2、AP-模式：" class="headerlink" title="2、AP 模式："></a>2、AP 模式：</h2><p>ESP8266 模块作为热点，手机或电脑直接与模块连接，实现局域网无线控制。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">AT<span class="token operator">+</span>CWMODE<span class="token operator">=</span><span class="token number">2</span>                     <span class="token comment">//2是AP模式</span>AT<span class="token operator">+</span>RST                     <span class="token comment">//重新启动wifi模块</span>AT<span class="token operator">+</span>CWSAP<span class="token operator">=</span><span class="token string">"WIFI名称"</span><span class="token punctuation">,</span><span class="token string">"WIFI密码"</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">0</span>          <span class="token comment">//AP模式设置模块WIFI名称及密码和加密方式，0代表开放，不需要密码</span>AT<span class="token operator">+</span>CIPMUX<span class="token operator">=</span><span class="token number">1</span>                   <span class="token comment">//设置多客户端连接</span>AT<span class="token operator">+</span>CIPSERVER<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5000</span>                <span class="token comment">//设置服务器的端口号为5000</span>AT<span class="token operator">+</span>CIPSTO<span class="token operator">=</span><span class="token number">0</span>                <span class="token comment">//服务不超时</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、STA-AP-模式："><a href="#3、STA-AP-模式：" class="headerlink" title="3、STA+AP 模式："></a>3、STA+AP 模式：</h2><p>两种模式的共存模式，即可以通过互联网控制可实现无缝切换，方便操作。ESP8266有几种不同的使用方式，适用于不同水平的开发工作者。</p><h1 id="三、ESP8266基础网络通信"><a href="#三、ESP8266基础网络通信" class="headerlink" title="三、ESP8266基础网络通信"></a>三、ESP8266基础网络通信</h1><h2 id="1、TCP服务器（AP-模式-热点）"><a href="#1、TCP服务器（AP-模式-热点）" class="headerlink" title="1、TCP服务器（AP 模式    热点）"></a>1、TCP服务器（AP 模式    热点）</h2><p>使用环境：手机或电脑连接ESP8266的AP热点，正确填写服务器参数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ok则复位成功</span>AT<span class="token operator">+</span>CWMODE<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//准备设置AP模式，收到ok则设置成功</span>AT<span class="token operator">+</span>CIPAP<span class="token operator">=</span><span class="token string">"192.168.10.1"</span>；<span class="token comment">//设置AP热点IP，收到ok则设置成功</span>AT<span class="token operator">+</span>CWSAP<span class="token operator">=</span><span class="token string">"ESP8266-AP"</span><span class="token punctuation">,</span><span class="token string">"123456789"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//设置AP参数，WiFi名称，密码，加密方式，收到ok则设置成功</span>AT<span class="token operator">+</span>CIPMODE<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//关闭透传,收到ok则设置成功</span>AT<span class="token operator">+</span>CIPMUX<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//开启多路连接,收到ok则设置成功</span>AT<span class="token operator">+</span>CIPSERVER<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5050</span><span class="token punctuation">;</span><span class="token comment">//开启AP服务器,收到ok则设置成功,端口号5050</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、TCP客户端（AP-模式-热点）"><a href="#2、TCP客户端（AP-模式-热点）" class="headerlink" title="2、TCP客户端（AP 模式    热点）"></a>2、TCP客户端（AP 模式    热点）</h2><p>使用环境：手机或电脑连接ESP8266的AP热点，正确配置服务器参数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ok则复位成功</span>AT<span class="token operator">+</span>CWMODE<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//准备设置AP模式，收到ok则设置成功</span>AT<span class="token operator">+</span>CIPAP<span class="token operator">=</span><span class="token string">"192.168.10.1"</span>；<span class="token comment">//设置AP热点IP，收到ok则设置成功</span>AT<span class="token operator">+</span>CWSAP<span class="token operator">=</span><span class="token string">"ESP8266-AP"</span><span class="token punctuation">,</span><span class="token string">"123456789"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//设置AP参数，WiFi名称，密码，信道，加密方式，收到ok则设置成功</span>AT<span class="token operator">+</span>CIPMODE<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//开启透传,收到ok则设置成功</span>AT<span class="token operator">+</span>CIPMUX<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//关闭多路连接,收到ok则设置成功</span>AT<span class="token operator">+</span>CIPSTART<span class="token operator">=</span><span class="token string">"TCP"</span><span class="token punctuation">,</span><span class="token string">"192.168.10.2"</span><span class="token punctuation">,</span><span class="token number">5050</span><span class="token punctuation">;</span><span class="token comment">//协议，服务器IP或是域名，端口</span><span class="token comment">//如果接受到CONNECT表示连接成功</span><span class="token comment">//如果接受到CLOSED表示服务器未开启</span><span class="token comment">//如果接受到ALREADY CONNECTED已经建立连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、UDP模式（AP-模式-热点）"><a href="#3、UDP模式（AP-模式-热点）" class="headerlink" title="3、UDP模式（AP 模式    热点）"></a>3、UDP模式（AP 模式    热点）</h2><p>使用环境：手机或电脑连接ESP8266的AP热点，正确配置服务器参数</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ok则复位成功AT+CWMODE&#x3D;2;&#x2F;&#x2F;准备设置AP模式，收到ok则设置成功AT+CIPAP&#x3D;&quot;192.168.10.1&quot;；&#x2F;&#x2F;设置AP热点IP，收到ok则设置成功AT+CWSAP&#x3D;&quot;ESP8266-AP-UPD&quot;,&quot;123456789&quot;,4,4;&#x2F;&#x2F;设置AP参数，WiFi名称，密码，信道，加密方式，收到ok则设置成功AT+CIPMODE&#x3D;1;&#x2F;&#x2F;开启透传,收到ok则设置成功AT+CIPMUX&#x3D;0;&#x2F;&#x2F;关闭多路连接,收到ok则设置成功AT+CIPSTART&#x3D;&quot;UDP&quot;,&quot;192.168.10.2&quot;,5050,5050;&#x2F;&#x2F;协议，服务器IP或是域名，端口&#x2F;&#x2F;如果接受到CONNECT表示连接成功&#x2F;&#x2F;如果接受到CLOSED表示服务器未开启&#x2F;&#x2F;如果接受到ALREADY CONNECTED已经建立连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、TCP服务器（station模式-必须接路由器）"><a href="#4、TCP服务器（station模式-必须接路由器）" class="headerlink" title="4、TCP服务器（station模式     必须接路由器）"></a>4、TCP服务器（station模式     必须接路由器）</h2><p>使用环境：ESP8266与电脑（手机）在同一个局域网内</p><h3 id="（1）WIFI与密码在代码中"><a href="#（1）WIFI与密码在代码中" class="headerlink" title="（1）WIFI与密码在代码中"></a>（1）WIFI与密码在代码中</h3><p>上电后自动连接固定的WIFI</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">mode&#x3D;0；&#x2F;&#x2F;代码写死在代码中&#x2F;&#x2F;RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ready则复位成功AT+CWMODE&#x3D;1;&#x2F;&#x2F;准备设置station模式，收到ok则设置成功AT+CWAUTOCONN&#x3D;0;&#x2F;&#x2F;上电不自动连接AP，默认上电自动连接路由器AT+CWJAP&#x3D;&quot;king&quot;,&quot;12344321&quot;;&#x2F;&#x2F;连接路由器AT+CIFSR;&#x2F;&#x2F;查询本地 IP 地址,ESP8266的地址AT+CIPMODE&#x3D;0;&#x2F;&#x2F;关闭透传,收到ok则设置成功AT+CIPMUX&#x3D;1;&#x2F;&#x2F;开启多路连接,收到ok则设置成功AT+CIPSERVER&#x3D;1,5050;&#x2F;&#x2F;开启服务器,打开ESP8266的5050端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）手机APP配网"><a href="#（2）手机APP配网" class="headerlink" title="（2）手机APP配网"></a>（2）手机APP配网</h3><p>上电后自动连接WIFI，按住KEY2后重启，等待APP配网，不按住KEY2自动连接上次连接的WIFI</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ready则复位成功</span>AT<span class="token operator">+</span>CWMODE<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//准备设置station模式，收到ok则设置成功</span>AT<span class="token operator">+</span>CWAUTOCONN<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//上电不自动连接AP，默认上电自动连接路由器</span><span class="token comment">/*********************/</span>AT<span class="token operator">+</span>CWAUTOCONN<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//打开自动连接</span>AT<span class="token operator">+</span>CWSTARTSMART<span class="token punctuation">;</span><span class="token comment">//开启Smartconfig</span><span class="token comment">//获取到SSID和password后将尝试自动连接AP</span>AT<span class="token operator">+</span>CWSTOPSMART；<span class="token comment">//关闭Smartconfig</span><span class="token comment">//等待WiFi连接成功，提示WIFI CONNECTED</span><span class="token comment">//WIFI GOT IP</span><span class="token comment">/*********************/</span>AT<span class="token operator">+</span>CIFSR<span class="token punctuation">;</span><span class="token comment">//查询本地 IP 地址,ESP8266的地址</span>AT<span class="token operator">+</span>CIPMODE<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//关闭透传,收到ok则设置成功</span>AT<span class="token operator">+</span>CIPMUX<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//开启多路连接,收到ok则设置成功</span>AT<span class="token operator">+</span>CIPSERVER<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5050</span><span class="token punctuation">;</span><span class="token comment">//开启服务器,打开ESP8266的5050端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、TCP客户端（station模式-必须接路由器）"><a href="#5、TCP客户端（station模式-必须接路由器）" class="headerlink" title="5、TCP客户端（station模式     必须接路由器）"></a>5、TCP客户端（station模式     必须接路由器）</h2><p>使用环境：ESP8266与电脑（手机）在同一个局域网内</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ready则复位成功AT+CWMODE&#x3D;1;&#x2F;&#x2F;准备设置station模式，收到ok则设置成功AT+CWAUTOCONN&#x3D;0;&#x2F;&#x2F;上电不自动连接路由器，默认上电自动连接路由器AT+CWJAP&#x3D;&quot;king&quot;,&quot;12344321&quot;;&#x2F;&#x2F;连接路由器AT+CIFSR;&#x2F;&#x2F;查询本地 IP 地址,ESP8266的地址AT+CIPMODE&#x3D;1;&#x2F;&#x2F;开启透传,收到ok则设置成功AT+CIPMUX&#x3D;0;&#x2F;&#x2F;关闭多路连接,收到ok则设置成功AT+CIPSTART&#x3D;&quot;TCP&quot;,&quot;192.168.43.210&quot;,5050;&#x2F;&#x2F;协议，服务器IP或是域名，端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、UDP客户端（station模式-必须接路由器）"><a href="#6、UDP客户端（station模式-必须接路由器）" class="headerlink" title="6、UDP客户端（station模式     必须接路由器）"></a>6、UDP客户端（station模式     必须接路由器）</h2><p>使用环境：ESP8266与电脑（手机）在同一个局域网内</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ready则复位成功AT+CWMODE&#x3D;1;&#x2F;&#x2F;准备设置station模式，收到ok则设置成功AT+CWAUTOCONN&#x3D;0;&#x2F;&#x2F;上电不自动连接路由器，默认上电自动连接路由器AT+CWJAP&#x3D;&quot;nice&quot;,&quot;12344321&quot;;&#x2F;&#x2F;连接路由器AT+CIFSR;&#x2F;&#x2F;查询本地 IP 地址,ESP8266的地址AT+CIPMODE&#x3D;1;&#x2F;&#x2F;开启透传,收到ok则设置成功AT+CIPMUX&#x3D;0;&#x2F;&#x2F;关闭多路连接,收到ok则设置成功AT+CIPSTART&#x3D;&quot;UDP&quot;,&quot;192.168.43.210&quot;,5050,5050;&#x2F;&#x2F;协议，服务器IP或是域名，服务器端口，本地端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、一般物联网的远程控制的通信方案"><a href="#四、一般物联网的远程控制的通信方案" class="headerlink" title="四、一般物联网的远程控制的通信方案"></a>四、一般物联网的远程控制的通信方案</h1><p>1、要实现远程控制就必须得租用一个服务器，可以租用云服务器，比如阿里云的ECS</p><p>2、手机与服务器建立tcp长连接</p><p>3、esp8266与服务器建立tcp长连接</p><p>4、手机发送数据到云服务器，使用json数据的网络通信，云服务器接收到手机发的数据后，继续把手机发送过来数据转发给esp8266</p><p>5、esp8266发送数据到云服务器，云服务器接收到esp8266发过来的数据后，继续把数据推送给手机app</p><p>6、如上所述方式，实现手机+esp8266的双向通信的远程控制。</p><p>以小米智能台灯为例：</p><p>有一台自己的服务器:小米云服务器<br>终端设备:小米台灯  自身带有wifi，作为tcp客户端可以连接小米云服务器<br>手机APP  该APP作为tcp 客户端能够连接小米云服务器<br>通信过程概述：小米智能台灯和app同时接入小米云服务器，用户在app上选择要执行的功能，如开灯，则当用户触发按键时，app会向小米云服务器发送该消息，小米云服务器会对这条消息进行转发（或者在服务器中做解析处理），解析知道了用户想要执行开灯动作，则有小米云服务器向小米智能台灯发送开灯指令，电亮台灯，即app和小米智能台灯之间的通信，由小米云服务器来中转完成，app、小米智能台灯与小米云服务器之间均为tcp长连接通信。</p><h1 id="五、OneNet云服务器-HTTP协议"><a href="#五、OneNet云服务器-HTTP协议" class="headerlink" title="五、OneNet云服务器 HTTP协议"></a>五、OneNet云服务器 HTTP协议</h1><h2 id="1、ESP8266-开关控制"><a href="#1、ESP8266-开关控制" class="headerlink" title="1、ESP8266  开关控制"></a>1、ESP8266  开关控制</h2><p>OneNet网站：<a href="https://open.iot.10086.cn/">https://open.iot.10086.cn/</a></p><p>开发者中心——–&gt;多协议接入———-&gt;HTTP——–&gt;添加产品</p><p>进入创建的产品——&gt;设备列表———&gt;添加设备</p><p>进入数据流模板——–&gt;添加数据流模板</p><p>进入应用管理———–&gt;添加应用—–&gt;编辑应用</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;RST引脚复位，复位IO拉低电平，延时500ms，拉高电平，收到ready则复位成功AT+CWMODE&#x3D;1;&#x2F;&#x2F;准备设置station模式，收到ok则设置成功AT+CWAUTOCONN&#x3D;0;&#x2F;&#x2F;上电不自动连接路由器，默认上电自动连接路由器AT+CWJAP&#x3D;&quot;nice&quot;,&quot;12344321&quot;;&#x2F;&#x2F;连接路由器AT+CIFSR;&#x2F;&#x2F;查询本地 IP 地址,ESP8266的地址AT+CIPMODE&#x3D;1;&#x2F;&#x2F;开启透传,收到ok则设置成功AT+CIPMUX&#x3D;0;&#x2F;&#x2F;关闭多路连接,收到ok则设置成功AT+CIPSTART&#x3D;&quot;TCP&quot;,&quot;183.230.40.33&quot;,80;&#x2F;&#x2F;OneNet服务器IP地址，端口号，固定不变AT+CIPSEND;&#x2F;&#x2F;进入透传指令&#x2F;*********获取状态报文***********&#x2F;GET &#x2F;devices&#x2F;608231432&#x2F;datapoints HTTP&#x2F;1.1&#x2F;&#x2F;设备IDapi-key:0sjroaCBwqV9Vnz3qjRptlMkLV8&#x3D;&#x2F;&#x2F;Master-APIkeyHost:api.heclouds.com&#x2F;*********报文后面需要接两个换行符，表示发送完毕************&#x2F;&#x2F;*********返回报文************&#x2F;HTTP&#x2F;1.1 200 OKDate: Fri, 03 Jul 2020 08:38:22 GMTContent-Type: application&#x2F;jsonContent-Length: 137Connection: keep-aliveServer: Apache-Coyote&#x2F;1.1Pragma: no-cache&#123;&quot;errno&quot;:0,&quot;data&quot;:&#123;&quot;count&quot;:1,&quot;datastreams&quot;:[&#123;&quot;datapoints&quot;:[&#123;&quot;at&quot;:&quot;2020-07-03 16:27:20.000&quot;,&quot;value&quot;:0&#125;],&quot;id&quot;:&quot;switch_1&quot;&#125;]&#125;,&quot;error&quot;:&quot;succ&quot;&#125;&#x2F;*********************&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、数据上传"><a href="#2、数据上传" class="headerlink" title="2、数据上传"></a>2、数据上传</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;*********POST报文***********&#x2F;POST &#x2F;devices&#x2F;608297654&#x2F;datapoints?type&#x3D;3 HTTP&#x2F;1.1api-key:0sjroaCBwqV9Vnz3qjRptlMkLV8&#x3D;Host:api.heclouds.comContent-Length:32&#x2F;&#x2F;后面接两个回车换行&#123;&quot;temp_data&quot;:43,&quot;humi_data&quot;:132&#125;&#x2F;*********************&#x2F;&#x2F;*********返回报文***********&#x2F;HTTP&#x2F;1.1 200 OKDate: Sat, 04 Jul 2020 04:17:06 GMTContent-Type: application&#x2F;jsonContent-Length: 26Connection: keep-aliveServer: Apache-Coyote&#x2F;1.1Pragma: no-cache&#123;&quot;errno&quot;:0,&quot;error&quot;:&quot;succ&quot;&#125;AT+CIPCLOSE&#x2F;*********************&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="六、阿里智能生活平台-云智能APP"><a href="#六、阿里智能生活平台-云智能APP" class="headerlink" title="六、阿里智能生活平台 云智能APP"></a>六、阿里智能生活平台 云智能APP</h1><h2 id="MQTT介绍"><a href="#MQTT介绍" class="headerlink" title="MQTT介绍"></a>MQTT介绍</h2><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220225151833.jpg" alt="MQTT报文" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220225151839.JPG" alt="MQTT服务等级" loading="lazy"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/***************************************************************************/</span><span class="token punctuation">&#123;</span>  <span class="token string">"ProductKey"</span><span class="token operator">:</span> <span class="token string">"a125Pav0yBM"</span><span class="token punctuation">,</span>  <span class="token string">"DeviceName"</span><span class="token operator">:</span> <span class="token string">"D001"</span><span class="token punctuation">,</span>  <span class="token string">"DeviceSecret"</span><span class="token operator">:</span> <span class="token string">"c13e04cc8e7e93ed441f2435893bbfd1"</span><span class="token punctuation">&#125;</span><span class="token comment">/***************************************************************************/</span>阿里云服务器IP地址（华东<span class="token number">2</span>） <span class="token operator">:</span>  <span class="token operator">*</span><span class="token punctuation">.</span>iot<span class="token operator">-</span>as<span class="token operator">-</span>mqtt<span class="token punctuation">.</span>cn<span class="token operator">-</span>shanghai<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com    <span class="token operator">*</span>表示自己账号的ProductKey注意替换阿里云服务器端口号（华东<span class="token number">2</span>） <span class="token operator">:</span>  <span class="token number">1883</span>a125Pav0yBM<span class="token punctuation">.</span>iot<span class="token operator">-</span>as<span class="token operator">-</span>mqtt<span class="token punctuation">.</span>cn<span class="token operator">-</span>shanghai<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com <span class="token comment">/***************************************************************************/</span>hmacsha1加密在线计算网站：http<span class="token operator">:</span><span class="token comment">//encode.chahuo.com/</span>客户端ID ：  <span class="token operator">*</span><span class="token operator">|</span>securemode<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>signmethod<span class="token operator">=</span>hmacsha1<span class="token operator">|</span>   <span class="token operator">*</span>设备名称              注意替换 用户名   ：  <span class="token operator">*</span><span class="token operator">&amp;</span>#             <span class="token operator">*</span>设备名称 #ProductKey  注意替换                 密码：  用DeviceSecret做为秘钥对clientId<span class="token operator">*</span>deviceName<span class="token operator">*</span>productKey#进行hmacsha1加密后的结果<span class="token operator">*</span>设备名称 #ProductKey  注意替换<span class="token comment">/***************************************************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-CONNECT-——–-16进制"><a href="#1-CONNECT-——–-16进制" class="headerlink" title="1.CONNECT ——– 16进制"></a>1.CONNECT ——– 16进制</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/***************************************************************************/</span>固定报头：<span class="token number">10</span> 负载可变报头：<span class="token number">00</span> <span class="token number">04</span> <span class="token number">4</span>D <span class="token number">51</span> <span class="token number">54</span> <span class="token number">54</span> <span class="token number">04</span> C2 <span class="token number">00</span> <span class="token number">64</span> CONNECT <span class="token operator">=</span> 固定报头 <span class="token operator">+</span> 可变报头 <span class="token operator">+</span> 客户端ID <span class="token operator">+</span> 用户名 <span class="token operator">+</span> 密码<span class="token number">10</span> <span class="token number">6</span>E <span class="token number">00</span> <span class="token number">04</span> <span class="token number">4</span>D <span class="token number">51</span> <span class="token number">54</span> <span class="token number">54</span> <span class="token number">04</span> C2 <span class="token number">00</span> <span class="token number">64</span> <span class="token number">00</span> <span class="token number">26</span> <span class="token number">44</span> <span class="token number">30</span> <span class="token number">30</span> <span class="token number">31</span> <span class="token number">7</span>C <span class="token number">73</span> <span class="token number">65</span> <span class="token number">63</span> <span class="token number">75</span> <span class="token number">72</span> <span class="token number">65</span> <span class="token number">6</span>D <span class="token number">6F</span> <span class="token number">64</span> <span class="token number">65</span> <span class="token number">3</span>D <span class="token number">33</span> <span class="token number">2</span>C <span class="token number">73</span> <span class="token number">69</span> <span class="token number">67</span> <span class="token number">6</span>E <span class="token number">6</span>D <span class="token number">65</span> <span class="token number">74</span> <span class="token number">68</span> <span class="token number">6F</span> <span class="token number">64</span> <span class="token number">3</span>D <span class="token number">68</span> <span class="token number">6</span>D <span class="token number">61</span> <span class="token number">63</span> <span class="token number">73</span> <span class="token number">68</span> <span class="token number">61</span> <span class="token number">31</span> <span class="token number">7</span>C <span class="token number">00</span> <span class="token number">10</span> <span class="token number">44</span> <span class="token number">30</span> <span class="token number">30</span> <span class="token number">31</span> <span class="token number">26</span> <span class="token number">61</span> <span class="token number">31</span> <span class="token number">32</span> <span class="token number">35</span> <span class="token number">50</span> <span class="token number">61</span> <span class="token number">76</span> <span class="token number">30</span> <span class="token number">79</span> <span class="token number">42</span> <span class="token number">4</span>D <span class="token number">00</span> <span class="token number">28</span> <span class="token number">61</span> <span class="token number">33</span> <span class="token number">38</span> <span class="token number">31</span> <span class="token number">64</span> <span class="token number">30</span> <span class="token number">39</span> <span class="token number">38</span> <span class="token number">34</span> <span class="token number">61</span> <span class="token number">61</span> <span class="token number">33</span> <span class="token number">36</span> <span class="token number">64</span> <span class="token number">38</span> <span class="token number">65</span> <span class="token number">33</span> <span class="token number">35</span> <span class="token number">61</span> <span class="token number">34</span> <span class="token number">32</span> <span class="token number">30</span> <span class="token number">32</span> <span class="token number">64</span> <span class="token number">38</span> <span class="token number">64</span> <span class="token number">63</span> <span class="token number">33</span> <span class="token number">32</span> <span class="token number">35</span> <span class="token number">36</span> <span class="token number">62</span> <span class="token number">37</span> <span class="token number">38</span> <span class="token number">37</span> <span class="token number">31</span> <span class="token number">66</span> <span class="token number">37</span> <span class="token number">33</span> <span class="token number">63</span><span class="token comment">/***************************************************************************/</span>客户端ID ：D001<span class="token operator">|</span>securemode<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>signmethod<span class="token operator">=</span>hmacsha1<span class="token operator">|</span><span class="token number">44</span> <span class="token number">30</span> <span class="token number">30</span> <span class="token number">31</span> <span class="token number">7</span>C <span class="token number">73</span> <span class="token number">65</span> <span class="token number">63</span> <span class="token number">75</span> <span class="token number">72</span> <span class="token number">65</span> <span class="token number">6</span>D <span class="token number">6F</span> <span class="token number">64</span> <span class="token number">65</span> <span class="token number">3</span>D <span class="token number">33</span> <span class="token number">2</span>C <span class="token number">73</span> <span class="token number">69</span> <span class="token number">67</span> <span class="token number">6</span>E <span class="token number">6</span>D <span class="token number">65</span> <span class="token number">74</span> <span class="token number">68</span> <span class="token number">6F</span> <span class="token number">64</span> <span class="token number">3</span>D <span class="token number">68</span> <span class="token number">6</span>D <span class="token number">61</span> <span class="token number">63</span> <span class="token number">73</span> <span class="token number">68</span> <span class="token number">61</span> <span class="token number">31</span> <span class="token number">7</span>C      用户名   ：D001<span class="token operator">&amp;</span>a125Pav0yBM<span class="token number">44</span> <span class="token number">30</span> <span class="token number">30</span> <span class="token number">31</span> <span class="token number">26</span> <span class="token number">61</span> <span class="token number">31</span> <span class="token number">32</span> <span class="token number">35</span> <span class="token number">50</span> <span class="token number">61</span> <span class="token number">76</span> <span class="token number">30</span> <span class="token number">79</span> <span class="token number">42</span> <span class="token number">4</span>D密码： a381d0984aa36d8e35a4202d8dc3256b7871f73c<span class="token number">61</span> <span class="token number">33</span> <span class="token number">38</span> <span class="token number">31</span> <span class="token number">64</span> <span class="token number">30</span> <span class="token number">39</span> <span class="token number">38</span> <span class="token number">34</span> <span class="token number">61</span> <span class="token number">61</span> <span class="token number">33</span> <span class="token number">36</span> <span class="token number">64</span> <span class="token number">38</span> <span class="token number">65</span> <span class="token number">33</span> <span class="token number">35</span> <span class="token number">61</span> <span class="token number">34</span> <span class="token number">32</span> <span class="token number">30</span> <span class="token number">32</span> <span class="token number">64</span> <span class="token number">38</span> <span class="token number">64</span> <span class="token number">63</span> <span class="token number">33</span> <span class="token number">32</span> <span class="token number">35</span> <span class="token number">36</span> <span class="token number">62</span> <span class="token number">37</span> <span class="token number">38</span> <span class="token number">37</span> <span class="token number">31</span> <span class="token number">66</span> <span class="token number">37</span> <span class="token number">33</span> <span class="token number">63</span>    远程服务器地址：a125Pav0yBM<span class="token punctuation">.</span>iot<span class="token operator">-</span>as<span class="token operator">-</span>mqtt<span class="token punctuation">.</span>cn<span class="token operator">-</span>shanghai<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">1883</span><span class="token comment">/***************************************************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-DISCONNECT-——–-16进制"><a href="#14-DISCONNECT-——–-16进制" class="headerlink" title="14.DISCONNECT ——– 16进制"></a>14.DISCONNECT ——– 16进制</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">E0 <span class="token number">00</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="12-PING-——–-16进制"><a href="#12-PING-——–-16进制" class="headerlink" title="12.PING ——– 16进制"></a>12.PING ——– 16进制</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">C0 <span class="token number">00</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-SUBSCRIBE-——–-16进制"><a href="#8-SUBSCRIBE-——–-16进制" class="headerlink" title="8.SUBSCRIBE ——– 16进制"></a>8.SUBSCRIBE ——– 16进制</h2><p>按照报文标识符来区分是谁发送的数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//订阅</span><span class="token comment">//82 ?? 00 0A + 主题（00 0A 为报文标识符）--->有效载荷 + 00</span><span class="token operator">/</span>sys<span class="token operator">/</span>a125Pav0yBM<span class="token operator">/</span>D001<span class="token operator">/</span>thing<span class="token operator">/</span>service<span class="token operator">/</span>property<span class="token operator">/</span>set<span class="token number">2F</span> <span class="token number">73</span> <span class="token number">79</span> <span class="token number">73</span> <span class="token number">2F</span> <span class="token number">61</span> <span class="token number">31</span> <span class="token number">32</span> <span class="token number">35</span> <span class="token number">50</span> <span class="token number">61</span> <span class="token number">76</span> <span class="token number">30</span> <span class="token number">79</span> <span class="token number">42</span> <span class="token number">4</span>D <span class="token number">2F</span> <span class="token number">44</span> <span class="token number">30</span> <span class="token number">30</span> <span class="token number">31</span> <span class="token number">2F</span> <span class="token number">74</span> <span class="token number">68</span> <span class="token number">69</span> <span class="token number">6</span>E <span class="token number">67</span> <span class="token number">2F</span> <span class="token number">73</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">76</span> <span class="token number">69</span> <span class="token number">63</span> <span class="token number">65</span> <span class="token number">2F</span> <span class="token number">70</span> <span class="token number">72</span> <span class="token number">6F</span> <span class="token number">70</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">74</span> <span class="token number">79</span> <span class="token number">2F</span> <span class="token number">73</span> <span class="token number">65</span> <span class="token number">74</span><span class="token comment">//订阅报文 等级0----->    </span><span class="token number">82</span> <span class="token number">35</span> <span class="token number">00</span> <span class="token number">0</span>A <span class="token number">00</span> <span class="token number">30</span> <span class="token number">2F</span> <span class="token number">73</span> <span class="token number">79</span> <span class="token number">73</span> <span class="token number">2F</span> <span class="token number">61</span> <span class="token number">31</span> <span class="token number">32</span> <span class="token number">35</span> <span class="token number">50</span> <span class="token number">61</span> <span class="token number">76</span> <span class="token number">30</span> <span class="token number">79</span> <span class="token number">42</span> <span class="token number">4</span>D <span class="token number">2F</span> <span class="token number">44</span> <span class="token number">30</span> <span class="token number">30</span> <span class="token number">31</span> <span class="token number">2F</span> <span class="token number">74</span> <span class="token number">68</span> <span class="token number">69</span> <span class="token number">6</span>E <span class="token number">67</span> <span class="token number">2F</span> <span class="token number">73</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">76</span> <span class="token number">69</span> <span class="token number">63</span> <span class="token number">65</span> <span class="token number">2F</span> <span class="token number">70</span> <span class="token number">72</span> <span class="token number">6F</span> <span class="token number">70</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">74</span> <span class="token number">79</span> <span class="token number">2F</span> <span class="token number">73</span> <span class="token number">65</span> <span class="token number">74</span> <span class="token number">00</span><span class="token comment">//响应------></span><span class="token number">90</span> <span class="token number">03</span> <span class="token number">00</span> <span class="token number">0</span>A <span class="token number">01</span><span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">-</span> Failure 失败<span class="token punctuation">)</span>固定报头<span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span> <span class="token operator">+</span> 剩余长度 <span class="token operator">+</span> 可变报头<span class="token punctuation">(</span>报文标识符<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-SUBSCRIBE-等级1-——-16进制"><a href="#8-SUBSCRIBE-等级1-——-16进制" class="headerlink" title="8.SUBSCRIBE 等级1 ——- 16进制"></a>8.SUBSCRIBE 等级1 ——- 16进制</h2><p>按照报文标识符来区分是谁发送的数据</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;订阅&#x2F;&#x2F;82 ?? 00 0A（00 0A 为报文标识符） + 主题---&gt;有效载荷 + 01&#x2F;sys&#x2F;a125Pav0yBM&#x2F;D001&#x2F;thing&#x2F;service&#x2F;property&#x2F;set2F 73 79 73 2F 61 31 32 35 50 61 76 30 79 42 4D 2F 44 30 30 31 2F 74 68 69 6E 67 2F 73 65 72 76 69 63 65 2F 70 72 6F 70 65 72 74 79 2F 73 65 74&#x2F;&#x2F;订阅报文 等级0-----&gt;    82 35 00 0A 00 30 2F 73 79 73 2F 61 31 32 35 50 61 76 30 79 42 4D 2F 44 30 30 31 2F 74 68 69 6E 67 2F 73 65 72 76 69 63 65 2F 70 72 6F 70 65 72 74 79 2F 73 65 74 01&#x2F;&#x2F;响应------&gt;90 03 00 0A 01(0x80 - Failure 失败)固定报头(90) + 剩余长度 + 可变报头(报文标识符)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-UNSUBSCRIBE-——-16进制"><a href="#10-UNSUBSCRIBE-——-16进制" class="headerlink" title="10.UNSUBSCRIBE ——- 16进制"></a>10.UNSUBSCRIBE ——- 16进制</h2><p>改变报头和负载——&gt;A2 负载，去除等级，负载应该减一</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">A2 34 00 0A 00 30 2F 73 79 73 2F 61 31 32 35 50 61 76 30 79 42 4D 2F 44 30 30 31 2F 74 68 69 6E 67 2F 73 65 72 76 69 63 65 2F 70 72 6F 70 65 72 74 79 2F 73 65 74<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-发布-等级0-——-16进制"><a href="#3-发布-等级0-——-16进制" class="headerlink" title="3.发布 等级0 ——- 16进制"></a>3.发布 等级0 ——- 16进制</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">------&gt;开关&lt;--------&#x2F;&#x2F;030 95 01 00 2F 2F 73 79 73 2F 61 31 32 35 50 61 76 30 79 42 4D 2F 44 30 30 31 2F 74 68 69 6E 67 2F 65 76 65 6E 74 2F 70 72 6F 70 65 72 74 79 2F 70 6F 73 74 7B 22 6D 65 74 68 6F 64 22 3A 22 74 68 69 6E 67 2E 65 76 65 6E 74 2E 70 72 6F 70 65 72 74 79 2E 70 6F 73 74 22 2C 22 69 64 22 3A 22 30 30 30 30 30 30 30 30 31 22 2C 22 70 61 72 61 6D 73 22 3A 7B 22 50 6F 77 65 72 53 77 69 74 63 68 22 3A 30 7D 2C 22 76 65 72 73 69 6F 6E 22 3A 22 31 2E 30 2E 30 22 7D &#x2F;&#x2F;130 95 01 00 2F 2F 73 79 73 2F 61 31 32 35 50 61 76 30 79 42 4D 2F 44 30 30 31 2F 74 68 69 6E 67 2F 65 76 65 6E 74 2F 70 72 6F 70 65 72 74 79 2F 70 6F 73 74 7B 22 6D 65 74 68 6F 64 22 3A 22 74 68 69 6E 67 2E 65 76 65 6E 74 2E 70 72 6F 70 65 72 74 79 2E 70 6F 73 74 22 2C 22 69 64 22 3A 22 30 30 30 30 30 30 30 30 31 22 2C 22 70 61 72 61 6D 73 22 3A 7B 22 50 6F 77 65 72 53 77 69 74 63 68 22 3A 31 7D 2C 22 76 65 72 73 69 6F 6E 22 3A 22 31 2E 30 2E 30 22 7D固定报头 + 负载 + 发布主题 + 数据 &#x2F;&#x2F;发布主题&#x2F;sys&#x2F;a125Pav0yBM&#x2F;D001&#x2F;thing&#x2F;event&#x2F;property&#x2F;post&#x2F;&#x2F;数据&#123;&quot;method&quot;:&quot;thing.event.property.post&quot;,&quot;id&quot;:&quot;000000001&quot;,&quot;params&quot;:&#123;&quot;PowerSwitch&quot;:0&#125;,&quot;version&quot;:&quot;1.0.0&quot;&#125;------&gt;温湿度&lt;--------30 B5 01 00 2F 2F 73 79 73 2F 61 31 32 35 50 61 76 30 79 42 4D 2F 44 30 30 31 2F 74 68 69 6E 67 2F 65 76 65 6E 74 2F 70 72 6F 70 65 72 74 79 2F 70 6F 73 74 7B 22 6D 65 74 68 6F 64 22 3A 22 74 68 69 6E 67 2E 65 76 65 6E 74 2E 70 72 6F 70 65 72 74 79 2E 70 6F 73 74 22 2C 22 69 64 22 3A 22 30 30 30 30 30 30 30 30 31 22 2C 22 70 61 72 61 6D 73 22 3A 7B 22 43 75 72 72 65 6E 74 48 75 6D 69 64 69 74 79 22 3A 33 32 2C 22 43 75 72 72 65 6E 74 54 65 6D 70 65 72 61 74 75 72 65 22 3A 32 35 2E 36 35 7D 2C 22 76 65 72 73 69 6F 6E 22 3A 22 31 2E 30 2E 30 22 7D固定报头 + 负载 + 发布主题 + 数据 &#x2F;&#x2F;发布主题&#x2F;sys&#x2F;a125Pav0yBM&#x2F;D001&#x2F;thing&#x2F;event&#x2F;property&#x2F;post&#x2F;&#x2F;数据  &#123;&quot;method&quot;:&quot;thing.event.property.post&quot;,&quot;id&quot;:&quot;000000001&quot;,&quot;params&quot;:&#123;&quot;CurrentHumidity&quot;:32,&quot;CurrentTemperature&quot;:25.65&#125;,&quot;version&quot;:&quot;1.0.0&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ESP系列 </category>
          
          <category> 硬件基础模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPIO </tag>
            
            <tag> ESP8266 </tag>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派GPIO模块使用基础</title>
      <link href="/posts/dd95cd02/"/>
      <url>/posts/dd95cd02/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RPi-GPIO-模块使用基础"><a href="#1-RPi-GPIO-模块使用基础" class="headerlink" title="1.RPi.GPIO 模块使用基础"></a>1.RPi.GPIO 模块使用基础</h1><h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><p>导入 RPi.GPIO 模块：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过该操作，您可以将模块名称映射为 GPIO，以便接下来您其它脚本进行使用。</p><p>导入模块并检查它是否导入成功，可以尝试：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO<span class="token keyword">except</span> RuntimeError<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span> <span class="token string">"导入 RPi.GPIO 时出现错误！这可能由于没有超级用户权限造成的。您可以使用 'sudo' 来运行您的脚本。"</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="针脚编号"><a href="#针脚编号" class="headerlink" title="针脚编号"></a>针脚编号</h4><p>目前有两种方式可以通过 RPi.GPIO 对 Raspberry Pi 上的 IO 针脚进行编号。</p><p>第一种方式是使用 BOARD 编号系统。该方式参考 Raspberry Pi 主板上 P1 接线柱的针脚编号。使用该方式的优点是无需考虑主板的修订版本，您硬件始终都是可用的状态。您将无需从新连接线路和更改您的代码。</p><p>第二种方式是使用 BCM 编号。这是一种较低层的工作方式 – 该方式参考 Broadcom SOC 的通道编号。使用过程中，您始终要保证主板上的针脚与图表上标注的通道编号相对应。您的脚本可能在 Raspberry Pi 主板进行修订版本更新时无法工作。</p><p>指定您所使用的方式（必须指定）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BOARD<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>可能您的 Raspberry Pi 的 GPIO 上同时有多个脚本&#x2F;循环。因此，如果 RPi.GPIO 检测到某个针脚被设置为其它用途而非默认的状态（默认为输入），您会在尝试配置某脚本时得到警告消息。</p><p>禁用该警告消息：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>setwarnings<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="配置通道"><a href="#配置通道" class="headerlink" title="配置通道"></a>配置通道</h4><p>您需要为每个用于输入或输出的针脚配置通道。</p><p>配置为输入的通道：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>IN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（通道编号是基于您所使用的编号系统所指定的（BOARD 或 BCM）。）</p><p>更多关于输入通道的进阶信息可以在<a href="https://shumeipai.nxez.com/2016/09/28/rpi-gpio-module-inputs.html">这里</a>找到。</p><p>配置为输出的通道：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（通道编号是基于您所使用的编号系统所指定的（BOARD 或 BCM）。）</p><p>您还可以指定输出通道的初始值：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">,</span> initial <span class="token operator">=</span> GPIO<span class="token punctuation">.</span>HIGH<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>读取 GPIO 针脚的值：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span><span class="token builtin">input</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（通道编号是基于您所使用的编号系统所指定的（BOARD 或 BCM）。）这将返回 0 &#x2F; GPIO.LOW &#x2F; False 或者 1 &#x2F; GPIO.HIGH &#x2F; True。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>设置 GPIO 针脚的输出状态：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（通道编号是基于您所使用的编号系统所指定的（BOARD 或 BCM）。）</p><p>状态可以为 0 &#x2F; GPIO.LOW &#x2F; False 或者 1 &#x2F; GPIO.HIGH &#x2F; True。</p><h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><p>在任何程序结束后，请养成清理用过的资源的好习惯。使用 RPi.GPIO 也同样需要这样。恢复所有使用过的通道状态为输入，您可以避免由于短路意外损坏您的 Raspberry Pi 针脚。注意，该操作仅会清理您的脚本使用过的 GPIO 通道。</p><p>在您的脚本结束后进行清理：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Raspberry-Pi-修订版本和-RPi-GPIO-版本"><a href="#Raspberry-Pi-修订版本和-RPi-GPIO-版本" class="headerlink" title="Raspberry Pi 修订版本和 RPi.GPIO 版本"></a>Raspberry Pi 修订版本和 RPi.GPIO 版本</h4><p>检测 Raspberry Pi 主板的修订版本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>RPI_REVISION<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检测 RPi.GPIO 的版本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>VERSION<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-使用-RPi-GPIO-模块的输出（Output）功能"><a href="#2-使用-RPi-GPIO-模块的输出（Output）功能" class="headerlink" title="2.使用 RPi.GPIO 模块的输出（Output）功能"></a>2.使用 RPi.GPIO 模块的输出（Output）功能</h1><p>1、首先对 RPi.GPIO 进行设置（根据<a href="https://shumeipai.nxez.com/2016/09/28/rpi-gpio-module-basics.html">这里</a>的描述）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIOGPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span>GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、设置某个输出针脚状态为高电平：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>HIGH<span class="token punctuation">)</span><span class="token comment"># 或者</span>GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># 或者</span>GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、设置某个输出针脚状态为低电平：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>LOW<span class="token punctuation">)</span><span class="token comment"># 或者</span>GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># 或者</span>GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">12</span>`<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、程序结束后进行清理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，您可以读取使用 input() 函数设置的输出通道的当前状态。例如对输出进行切换：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token keyword">not</span> GPIO<span class="token punctuation">.</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-使用-RPI-GPIO-模块的脉宽调制（PWM）功能"><a href="#3-使用-RPI-GPIO-模块的脉宽调制（PWM）功能" class="headerlink" title="3.使用 RPI.GPIO 模块的脉宽调制（PWM）功能"></a>3.使用 RPI.GPIO 模块的脉宽调制（PWM）功能</h1><p>脉宽调制(PWM)是指用微处理器的数字输出来对模拟电路进行控制，是一种对模拟信号电平进行数字编码的方法。在树莓派上，可以通过对GPIO的编程来实现PWM。</p><p>创建一个 PWM 实例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p  <span class="token operator">=</span> GPIO<span class="token punctuation">.</span>PWM<span class="token punctuation">(</span>channel<span class="token punctuation">,</span> frequency<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启用 PWM：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>start<span class="token punctuation">(</span>dc<span class="token punctuation">)</span>   <span class="token comment"># dc 代表占空比（范围：0.0 &lt;= dc >= 100.0）</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更改频率：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>ChangeFrequency<span class="token punctuation">(</span>freq<span class="token punctuation">)</span>   <span class="token comment"># freq 为设置的新频率，单位为 Hz</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更改占空比：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>ChangeDutyCycle<span class="token punctuation">(</span>dc<span class="token punctuation">)</span>  <span class="token comment"># 范围：0.0 &lt;= dc >= 100.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>停止 PWM：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，如果实例中的变量“p”超出范围，也会导致 PWM 停止。</p><p>以下为使 LED 每两秒钟闪烁一次的示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIOGPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BOARD<span class="token punctuation">)</span>GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>p <span class="token operator">=</span> GPIO<span class="token punctuation">.</span>PWM<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">'点击回车停止：'</span><span class="token punctuation">)</span>   <span class="token comment"># 在 Python 2 中需要使用raw_input</span>p<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下为使 LED 在亮&#x2F;暗之间切换的示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time <span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIOGPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BOARD<span class="token punctuation">)</span>GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>p <span class="token operator">=</span> GPIO<span class="token punctuation">.</span>PWM<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>  <span class="token comment"># 通道为 12 频率为 50Hz</span>p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token keyword">for</span> dc <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">.</span>ChangeDutyCycle<span class="token punctuation">(</span>dc            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token keyword">for</span> dc  <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">.</span>ChangeDutyCycle<span class="token punctuation">(</span>dc<span class="token punctuation">)</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>exceptKeyboardInterrupt<span class="token punctuation">:</span><span class="token keyword">pass</span>p<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> RPi.GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派控制直流电机</title>
      <link href="/posts/f27d64d3/"/>
      <url>/posts/f27d64d3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-直流电机"><a href="#1-直流电机" class="headerlink" title="1.直流电机"></a>1.直流电机</h1><p>直流电机是一种将直流电能转换为机械能的装置，被广泛的用于驱动各种设备，如电风扇、遥控小车、电动车窗等，非常适合作为机器人的行走机构，您可以很容易的在网上购买到，价格也不是很贵。<br> 　　小型直流电机的的电压范围通常是1.5V~30V，使用两根导线连接到直流电源上就能让电机转动起来，电压越高转得就越快。每个直流电机都有一个推荐电压，超出推荐电压太多容易导致电机被烧毁，而供电电压太低则转不起来。通过交换两根连接在电机上的导线顺序（实际上是改变电源的正负极），可以改变电机的转向。前面章节我们说过，直流电机属于高功耗元件，不可以直接使用树莓派进行驱动，因此我们需要使用一个外部电源。<br> 　　小型直流电机通常输出很高的转速和较低的扭矩，在作为机器人的驱动装置时，一般需要连接一个变速器，将其转换为低转速、高扭矩，使之有足够的力量驱动机器人。图7.1是典型的带变速器的小型直流电机，建议变速器和电机一起购买。</p><p><img src="E:\大三上\树莓派学习\笔记\6.用树莓派控制直流电机（L298N）.assets\13532817-f31f5406bfcace7b.png" alt="img" loading="lazy"></p><h1 id="2-双H桥直流电机驱动模块（L298N）"><a href="#2-双H桥直流电机驱动模块（L298N）" class="headerlink" title="2.双H桥直流电机驱动模块（L298N）"></a>2.双H桥直流电机驱动模块（L298N）</h1><p>H桥（H-Bridge）是控制直流电机的常用电路，因其电路形状酷似字母H而得名，可以控制直流电机的转速和方向，典型的H桥芯片有L293D、L298N等，以下我们以L298N为例进行介绍。实际使用的时候，为提高芯片的安全性、可靠性和方便性，我们一般会给芯片外接一些保护电路，并把输入输出引脚引接到排针上，从而形成一个功能模块。图7.2是一款典型的L298N双H桥直流电机驱动模块，可以很容易从网上购买到，价格也便宜。该模块的主要特点如下：</p><p><img src="E:\大三上\树莓派学习\笔记\6.用树莓派控制直流电机（L298N）.assets\13532817-d33ac6916eb9f32c.png" alt="img" loading="lazy"></p><ul><li>采用L298N双桥直流电机驱动芯片</li><li>工作电压范围5V35V，如果需要从模块内取电，则供电范围为7V35V</li><li>峰值输出电流2A</li><li>每个通道有一个使能输入端</li><li>可以驱动两个直流电机或者一个四线步进电机</li></ul><p> 　L298N双H桥直流电机驱动模块的引脚可以归纳成电源、控制和输出等三大类，下面是各类引脚的功能说明。</p><ul><li><strong>电压类引脚</strong></li></ul><p> 　+12V输入：L298N芯片的电源正极，模块上标称+12V，但实际范围可以是5V35V，如果需从模块内取电，则其范围为7V35V。<br> 　　GND：L298N芯片的电源地，使用的时候应该把树莓派的GND接到这里，即两者需要共地。<br> 　　+5V输出：L298N芯片输出的5V电源，可以给外部设备供电，使用的时候需要用跳线把5V输出使能端短接起来。</p><ul><li><strong>控制类引脚</strong></li></ul><p> 　ENA、ENB：A、B通道的使能端，高电平有效，可以用PWM来实现调速。使用时，可以接到树莓派的GPIO上，实现用程序进行控制。<br> 　　IN1、IN2、IN3、IN4：IN1、IN2为A通道的控制输入，IN3、IN4为B通道的控制输入。</p><ul><li><strong>输出类引脚</strong></li></ul><p> 　OUT1、OUT2、OUT3、OUT4：OUT1、OUT2由A通道输出，OUT3、OUT4由B通道输出，可以用于连接直流电机等设备。</p><p> 　控制直流电机的转向和转速实际是通过给控制类引脚设置不同的值来实现的，表7.1是使用通道A的控制直流电机的真值表，通道B与此类似。</p><p><img src="https://upload-images.jianshu.io/upload_images/13532817-d724bfe24fac8005.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/421/format/webp" alt="img" loading="lazy"></p><p>通道A的控制直流电机的真值表</p><blockquote><p><strong>提示：</strong></p><p>您购买到的L298N双H桥直流电机驱动模块可能与本章介绍的存在一定的差异，但这一类功能模块大同小异，请跟商家索要相应的技术资料了解更多的使用细节。</p></blockquote><h1 id="3-让直流电机动起来"><a href="#3-让直流电机动起来" class="headerlink" title="3. 让直流电机动起来"></a>3. 让直流电机动起来</h1><p> 　下面进入实战环节，我们将用树莓派通过L298N双H桥直流电机驱动模块控制一个电机的转向和转速。为了能让读者更好的理解，我们首先演示如何控制电机的转向，然后再进一步介绍如何控制电机转速。</p><h2 id="3-1-实验电路"><a href="#3-1-实验电路" class="headerlink" title="3.1 实验电路"></a>3.1 实验电路</h2><p> 　图7.3所示的是树莓派、L298N双H桥直流电机驱动模块和电机间连接的电路图，最终实物连线图如图7.4所示。我们使用树莓派的GPIO13、GPIO19和GPIO26等3个引脚，分别连接到L298N双H桥直流电机驱动模块的ENA、IN1和IN2，通过输入表7.1所示的不同电平组合就可以实现对电机的操纵。控制电机的转向和转速都是使用该电路，向ENA输入不同占空比的PWM脉冲信号就可以控制电机的转速。</p><p><img src="https://upload-images.jianshu.io/upload_images/13532817-ac38b15a79d6272d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/436/format/webp" alt="img" loading="lazy"></p><p>图 7.3 小型直流电机控制电路图</p><p><img src="https://upload-images.jianshu.io/upload_images/13532817-e41c49bbc602d114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/756/format/webp" alt="img" loading="lazy"></p><p> 　尽管L298N双H桥直流电机驱动模块能驱动两个直流电机，但我们只演示如何驱动一个。驱动两个电机使用的是相同的技术，如果在您的项目中需要用到两个，也可以很容易地扩展它。</p><h2 id="3-2-程序思路"><a href="#3-2-程序思路" class="headerlink" title="3.2 程序思路"></a>3.2 程序思路</h2><p> 　控制电机转向和转速可以使用同一个电路，但程序思路上我们分两个程序来演示，具体思路如下：</p><ul><li><strong>控制电机转向思路</strong></li></ul><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">BEGIN</span>      引入<span class="token constant">GPIO</span>库      将连接<span class="token constant">ENA</span>的<span class="token constant">GPIO</span>引脚设置为输出模式    将连接<span class="token constant">IN1</span>的<span class="token constant">GPIO</span>引脚设置为输出模式    将连接<span class="token constant">IN2</span>的<span class="token constant">GPIO</span>引脚设置为输出模式        <span class="token constant">DO</span> <span class="token constant">FOREVER</span>          将<span class="token constant">IN1</span>设置为<span class="token number">0</span>，<span class="token constant">IN2</span>设置为<span class="token number">1</span>，将电机设置为正向转动          将<span class="token constant">ENA</span>设置为<span class="token number">1</span>，驱动<span class="token constant">A</span>通道电机转动          等待<span class="token number">5</span>秒          将<span class="token constant">ENA</span>设置为<span class="token number">0</span>，停止电机转动          等待<span class="token number">2</span>秒          将<span class="token constant">IN1</span>设置为<span class="token number">1</span>，<span class="token constant">IN2</span>设置为<span class="token number">0</span>，将电机设置为反向转动          将<span class="token constant">ENA</span>设置为<span class="token number">1</span>，驱动<span class="token constant">A</span>通道电机转动          等待<span class="token number">5</span>秒          将<span class="token constant">ENA</span>设置为<span class="token number">0</span>，停止电机转动          等待<span class="token number">2</span>秒    <span class="token constant">ENDO</span>      停止<span class="token constant">PWM</span>      清理释放<span class="token constant">GPIO</span>资源  <span class="token keyword">END</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>提示：</strong></p><p>除了采用将ENA置0的方法来让电机停止转动，将IN1和IN2同时设置为0或1也可以让电机停止下来。</p></blockquote><ul><li><strong>控制电机转速思路</strong></li></ul><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">BEGIN</span>      引入<span class="token constant">GPIO</span>库      将连接<span class="token constant">ENA</span>的<span class="token constant">GPIO</span>引脚设置为输出模式    将连接<span class="token constant">IN1</span>的<span class="token constant">GPIO</span>引脚设置为输出模式    将连接<span class="token constant">IN2</span>的<span class="token constant">GPIO</span>引脚设置为输出模式    设置<span class="token constant">ENA</span>输入一定频率的<span class="token constant">PWM</span>脉冲信号，创建<span class="token constant">PWM</span>对象      开始向<span class="token constant">ENA</span>输入占空比为<span class="token number">0</span>的<span class="token constant">PWM</span>脉冲信号          <span class="token constant">DO</span> <span class="token constant">FOREVER</span>          将<span class="token constant">IN1</span>设置为<span class="token number">0</span>，<span class="token constant">IN2</span>设置为<span class="token number">1</span>，将电机设置为正向转动          将<span class="token constant">ENA</span>设置为<span class="token number">1</span>，驱动<span class="token constant">A</span>通道电机转动                  speed <span class="token operator">=</span> <span class="token number">0</span>        <span class="token constant">DOWHILE</span> speed <span class="token operator">&lt;</span> <span class="token number">100</span>              将输入<span class="token constant">ENA</span>的<span class="token constant">PWM</span>脉冲信号的占空比修改为speed            speed <span class="token operator">+=</span> <span class="token number">5</span>            等待<span class="token number">1</span>秒        <span class="token constant">ENDDO</span>        将<span class="token constant">IN1</span>设置为<span class="token number">1</span>，<span class="token constant">IN2</span>设置为<span class="token number">0</span>，将电机设置为反向转动          将<span class="token constant">ENA</span>设置为<span class="token number">1</span>，驱动<span class="token constant">A</span>通道电机转动                  speed <span class="token operator">=</span> <span class="token number">0</span>        <span class="token constant">DOWHILE</span> speed <span class="token operator">&lt;</span> <span class="token number">100</span>              将输入<span class="token constant">ENA</span>的<span class="token constant">PWM</span>脉冲信号的占空比修改为speed            speed <span class="token operator">+=</span> <span class="token number">5</span>            等待<span class="token number">1</span>秒        <span class="token constant">ENDDO</span>    <span class="token constant">ENDO</span>          停止<span class="token constant">PWM</span>      清理释放<span class="token constant">GPIO</span>资源  <span class="token keyword">END</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 　电机的转向控制和转速控制的程序思路的最大区别在于ENA输入信号的不同。控制电机转向的程序思路只是简单的通过将ENA设置为1或0来启动和停止电机。对于电机转速控制，ENA输入的PWM脉冲信号，通过改变PWM脉冲信号的占空比来改变电机转速，占空比越大速度就越快，占空比为100%时相当于输入1（高电平），占空比为0%时相当于输入0（低电平）。</p><h2 id="3-3-程序代码"><a href="#3-3-程序代码" class="headerlink" title="3.3 程序代码"></a>3.3 程序代码</h2><p> 　以下是直流电机转向和转速控制程序，程序的详细说明见注释。</p><ul><li><strong>控制电机转向程序</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO         <span class="token comment"># 引入GPIO模块</span><span class="token keyword">import</span> time                     <span class="token comment"># 引入time模块</span>ENA <span class="token operator">=</span> <span class="token number">13</span>                        <span class="token comment"># 设置GPIO13连接ENA</span>IN1 <span class="token operator">=</span> <span class="token number">19</span>                        <span class="token comment"># 设置GPIO19连接IN1</span>IN2 <span class="token operator">=</span> <span class="token number">26</span>                        <span class="token comment"># 设置GPIO26连接IN2</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment"># 初始化</span>        GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span>          <span class="token comment"># 使用BCM编号方式</span>        GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>ENA<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>       <span class="token comment"># 将连接ENA的GPIO引脚设置为输出模式</span>        GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>       <span class="token comment"># 将连接IN1的GPIO引脚设置为输出模式</span>        GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>       <span class="token comment"># 将连接IN2的GPIO引脚设置为输出模式</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment"># 驱动电机正向旋转5秒</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>     <span class="token comment"># 将IN1设置为0</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>      <span class="token comment"># 将IN2设置为1</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>ENA<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>      <span class="token comment"># 将ENA设置为1，启动A通道电机</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>               <span class="token comment"># 等待电机转动5秒</span>            <span class="token comment"># 电机停止2秒</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>ENA<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>     <span class="token comment"># 将ENA设置为0</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>               <span class="token comment"># 等待电机停止2秒</span>            <span class="token comment"># 驱动电机反向旋转5秒</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>      <span class="token comment"># 将IN1设置为1</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>     <span class="token comment"># 将IN2设置为0</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>ENA<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>      <span class="token comment"># 将ENA设置为1，启动A通道电机</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>               <span class="token comment"># 等待电机转动5秒</span>            <span class="token comment"># 电机停止2秒</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>ENA<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>     <span class="token comment"># 将ENA设置为0</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>               <span class="token comment"># 等待电机停止2秒</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        pwm<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment"># 停止PWM</span>        GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment"># 清理释放GPIO资源，将GPIO复位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 　运行这个程序后，您将看到直流电机反复的正向转动5秒后，停止两秒，再反向转动5秒后，停止2秒。</p><ul><li><strong>控制电机转速程序</strong></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO         <span class="token comment"># 引入GPIO模块</span><span class="token keyword">import</span> time                     <span class="token comment"># 引入time模块</span>ENA <span class="token operator">=</span> <span class="token number">13</span>                        <span class="token comment"># 设置GPIO13连接ENA</span>IN1 <span class="token operator">=</span> <span class="token number">19</span>                        <span class="token comment"># 设置GPIO19连接IN1</span>IN2 <span class="token operator">=</span> <span class="token number">26</span>                        <span class="token comment"># 设置GPIO26连接IN2</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment"># 初始化</span>        GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span>              <span class="token comment"># 使用BCM编号方式</span>        GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>ENA<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>           <span class="token comment"># 将ENA对应的GPIO引脚设置为输出模式</span>        GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>           <span class="token comment"># 将IN1对应的GPIO引脚设置为输出模式</span>        GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>           <span class="token comment"># 将IN2对应的GPIO引脚设置为输出模式</span>        freq <span class="token operator">=</span> <span class="token number">500</span>        speed <span class="token operator">=</span> <span class="token number">0</span>        pwm <span class="token operator">=</span> GPIO<span class="token punctuation">.</span>PWM<span class="token punctuation">(</span>ENA<span class="token punctuation">,</span> freq<span class="token punctuation">)</span>           <span class="token comment"># 设置向ENA输入PWM脉冲信号，频率为freq并创建PWM对象</span>        pwm<span class="token punctuation">.</span>start<span class="token punctuation">(</span>speed<span class="token punctuation">)</span>                    <span class="token comment"># 以speed的初始占空比开始向ENA输入PWM脉冲信号</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment"># 将电机设置为正向转动</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>         <span class="token comment"># 将IN1设置为0</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>          <span class="token comment"># 将IN2设置为1</span>            <span class="token comment"># 通过改变PWM占空比，让电机转速不断加快</span>            <span class="token keyword">for</span> speed <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                pwm<span class="token punctuation">.</span>ChangeDutyCycle<span class="token punctuation">(</span>speed<span class="token punctuation">)</span>  <span class="token comment"># 改变PWM占空比</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 将电机设置为反向转动</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN1<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>          <span class="token comment"># 将IN1设置为1</span>            GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span>IN2<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>         <span class="token comment"># 将IN2设置为0</span>            <span class="token comment"># 通过改变PWM占空比，让电机转速不断加快</span>            <span class="token keyword">for</span> speed <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                pwm<span class="token punctuation">.</span>ChangeDutyCycle<span class="token punctuation">(</span>speed<span class="token punctuation">)</span>  <span class="token comment"># 改变PWM占空比</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        pwm<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>                          <span class="token comment"># 停止PWM</span>        GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment"># 清理释放GPIO资源，将GPIO复位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 　运行这个程序后，您将看到直流电机首先正向转动，转动速度不断增加，在达到最大转速后，直流电机短暂停止转动，然后反向转动，转动速度不断增加，如此反复运动。</p><h1 id="4-本章小结"><a href="#4-本章小结" class="headerlink" title="4 .本章小结"></a>4 .本章小结</h1><p> 　本章首先介绍了直流电机的基本知识，然后介绍了L298N双H桥直流电机驱动模块的相关基础知识，最后介绍了使用树莓派和L298N双H桥直流电机驱动模块来控制一个直流电机的转向和转速的电路、思路和程序等知识。</p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 直流电机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派常用模块</title>
      <link href="/posts/e45d4a36/"/>
      <url>/posts/e45d4a36/</url>
      
        <content type="html"><![CDATA[<h1 id="1-PWM"><a href="#1-PWM" class="headerlink" title="1.PWM"></a>1.PWM</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO                 <span class="token comment"># 引入GPIO模块</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    LedPin <span class="token operator">=</span> <span class="token number">19</span>    freq <span class="token operator">=</span> <span class="token number">100</span>                          <span class="token comment"># 存放PWM频率变量，这里初始值为100，可以根据实际需要修改</span>    dc <span class="token operator">=</span> <span class="token number">0</span>                              <span class="token comment"># 存放PWM占空比变量，这里初始值为0，可以根据实际需要修改</span>    GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span>              <span class="token comment"># 使用BCM编号方式</span>    GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span>LedPin<span class="token punctuation">,</span> GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>        <span class="token comment"># 将GPIO19设置为输出模式</span>    pwm <span class="token operator">=</span> GPIO<span class="token punctuation">.</span>PWM<span class="token punctuation">(</span>LedPin<span class="token punctuation">,</span> freq<span class="token punctuation">)</span>        <span class="token comment"># 创建PWM对象，并指定初始频率</span>    pwm<span class="token punctuation">.</span>start<span class="token punctuation">(</span>dc<span class="token punctuation">)</span>                       <span class="token comment"># 启动PWM，并指定初始占空比</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        freq <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Please input the frequency of PWM(1-2000Hz): "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 等待输入新PWM频率</span>        pwm<span class="token punctuation">.</span>ChangeFrequency<span class="token punctuation">(</span>freq<span class="token punctuation">)</span>       <span class="token comment"># 改变PWM频率</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            dc <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Please input the duty cycle(0-100): "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment"># 等待输入新PWM占空比</span>            pwm<span class="token punctuation">.</span>ChangeDutyCycle<span class="token punctuation">(</span>dc<span class="token punctuation">)</span>     <span class="token comment"># 改变PWM占空比</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        pwm<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment"># 停止PWM</span>        GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment"># 清理释放GPIO资源，将GPIO复位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> PWM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派运行实例</title>
      <link href="/posts/2cd3bcd8/"/>
      <url>/posts/2cd3bcd8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、树莓派引脚定义"><a href="#一、树莓派引脚定义" class="headerlink" title="一、树莓派引脚定义"></a>一、树莓派引脚定义</h1><p>学习如何用树莓派驱动LED灯时需要先了解树莓派管脚GPIO的编码方式，树莓派的管脚编码方式与51单片机的管脚编码有些不一样，在树莓派的GPIO上分为<strong>两种编码方式</strong>，分别为<strong>BCM</strong>和<strong>wiringPi编码</strong>，不同的编码方式在编写程序驱动GPIO时稍有区别，具体编码如下：</p><p><img src="https://i.loli.net/2020/12/19/EQvngLhCGaoP7Dk.png" alt="image-20201027185041036" loading="lazy"></p><p><img src="https://i.loli.net/2020/12/19/BhRGtWprT3yYZ6m.png" alt="image-20201027193659980" loading="lazy"></p><p><img src="https://i.loli.net/2020/12/19/bqijf82TmUxknwG.png" alt="image-20201027193715459" loading="lazy"></p><h1 id="二、蜂鸣器响"><a href="#二、蜂鸣器响" class="headerlink" title="二、蜂鸣器响"></a>二、蜂鸣器响</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> RPi<span class="token punctuation">.</span>GPIO <span class="token keyword">as</span> GPIO                <span class="token comment"># 引入GPIO模块</span><span class="token keyword">from</span> time <span class="token keyword">import</span> sleep                     <span class="token comment"># 引入time模块</span>GPIO<span class="token punctuation">.</span>setmode<span class="token punctuation">(</span>GPIO<span class="token punctuation">.</span>BCM<span class="token punctuation">)</span>            <span class="token comment"># 使用BCM编号方式</span>GPIO<span class="token punctuation">.</span>setup<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span>GPIO<span class="token punctuation">.</span>OUT<span class="token punctuation">)</span>            <span class="token comment"># 将GPIO19设置为输出模式</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>                                     <span class="token comment"># 无限循环  </span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span>GPIO<span class="token punctuation">.</span>HIGH<span class="token punctuation">)</span>   <span class="token comment"># 将GPIO19设置为高电平，点亮LED  </span>    sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                                    <span class="token comment"># 等待1秒钟 </span>    GPIO<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span>GPIO<span class="token punctuation">.</span>LOW<span class="token punctuation">)</span>  <span class="token comment"># 将GPIO19设置为低电平，熄灭LED </span>    sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                              <span class="token comment"># 等待0.5秒钟 </span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                      <span class="token comment"># 按下任意键退出</span>GPIO<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment"># 清理释放GPIO资源，将GPIO复位 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> RPi.GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派安装OpenCV</title>
      <link href="/posts/bbf58368/"/>
      <url>/posts/bbf58368/</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装所需要的库和依赖"><a href="#一、安装所需要的库和依赖" class="headerlink" title="一、安装所需要的库和依赖"></a>一、安装所需要的库和依赖</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo pip3 install numpysudo apt<span class="token operator">-</span>get install build<span class="token operator">-</span>essential git cmake pkg<span class="token operator">-</span>config <span class="token operator">-</span>ysudo apt<span class="token operator">-</span>get install libjpeg8<span class="token operator">-</span>dev <span class="token operator">-</span>ysudo apt<span class="token operator">-</span>get install libtiff5<span class="token operator">-</span>dev <span class="token operator">-</span>ysudo apt<span class="token operator">-</span>get install libjasper<span class="token operator">-</span>dev <span class="token operator">-</span>ysudo apt<span class="token operator">-</span>get install libpng12<span class="token operator">-</span>dev <span class="token operator">-</span>ysudo apt<span class="token operator">-</span>get install libavcodec<span class="token operator">-</span>dev libavformat<span class="token operator">-</span>dev libswscale<span class="token operator">-</span>dev libv4l<span class="token operator">-</span>dev <span class="token operator">-</span>ysudo apt<span class="token operator">-</span>get install libgtk2<span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">-</span>dev <span class="token operator">-</span>ysudo apt<span class="token operator">-</span>get install libatlas<span class="token operator">-</span>base<span class="token operator">-</span>dev gfortran <span class="token operator">-</span>y    sudo pip3 install opencv<span class="token operator">-</span>python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、测试安装环境"><a href="#二、测试安装环境" class="headerlink" title="二、测试安装环境"></a>二、测试安装环境</h1><blockquote><p>在终端输入 ：python3<br>然后 ：import cv2<br>如果安装成功，则import不会有问题<br>下面就可以输出OpenCv的版本号<br>使用 ：print(cv2.version)<br>退出python用： exit()</p></blockquote><p><img src="https://i.loli.net/2020/12/07/nPGjdg2J8tHpO9U.png" alt="image-20201026180316710" loading="lazy"></p><h1 id="三、简单应用"><a href="#三、简单应用" class="headerlink" title="三、简单应用"></a>三、简单应用</h1><blockquote><p>使用OpenCv库读取usb摄像头，实时显示并拍照</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npcap <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># get a frame</span> ret<span class="token punctuation">,</span> frame <span class="token operator">=</span> cap<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># show a frame</span> cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"capture"</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span>   <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span> <span class="token operator">==</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'q'</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#退出并拍照</span>  cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"takephoto2.jpg"</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"take Photo Ok"</span><span class="token punctuation">)</span>  <span class="token keyword">break</span>cap<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/12/07/rD73QjcCfSavMEK.png" alt="image-20201026175921758" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派环境搭建</title>
      <link href="/posts/f0a343d3/"/>
      <url>/posts/f0a343d3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-修改启动参数"><a href="#一、-修改启动参数" class="headerlink" title="一、 修改启动参数"></a>一、 修改启动参数</h1><h2 id="1、打开22号ssh端口"><a href="#1、打开22号ssh端口" class="headerlink" title="1、打开22号ssh端口"></a>1、打开22号ssh端口</h2><blockquote><p>在boot目录建立ssh空文件，不需要任何后缀名</p></blockquote><p><img src="https://i.loli.net/2020/12/19/lPsBZFKAov4OJ8f.png" alt="image-20201025213600034" loading="lazy"></p><h2 id="2、配置WIFI"><a href="#2、配置WIFI" class="headerlink" title="2、配置WIFI"></a>2、配置WIFI</h2><blockquote><p>在boot目录建立wpa_supplicant.conf内容如下（WiFi账号密码改为自己的）：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">country<span class="token operator">=</span>CNctrl_interface<span class="token operator">=</span>DIR<span class="token operator">=</span><span class="token operator">/</span>var<span class="token operator">/</span>run<span class="token operator">/</span>wpa_supplicant GROUP<span class="token operator">=</span>netdevupdate_config<span class="token operator">=</span><span class="token number">1</span>network<span class="token operator">=</span><span class="token punctuation">&#123;</span>ssid<span class="token operator">=</span><span class="token string">"hw1311"</span>psk<span class="token operator">=</span><span class="token string">"13111311"</span>key_mgmt<span class="token operator">=</span>WPA<span class="token operator">-</span>PSKpriority<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、连接树莓派"><a href="#二、连接树莓派" class="headerlink" title="二、连接树莓派"></a>二、连接树莓派</h1><h2 id="1、通过ssh连接树莓派"><a href="#1、通过ssh连接树莓派" class="headerlink" title="1、通过ssh连接树莓派"></a>1、通过ssh连接树莓派</h2><blockquote><p>打开命令行，输入<strong>ssh <a href="mailto:&#x70;&#105;&#64;&#114;&#97;&#115;&#x70;&#98;&#x65;&#114;&#x72;&#121;&#112;&#105;&#46;&#108;&#x6f;&#99;&#x61;&#108;">&#x70;&#105;&#64;&#114;&#97;&#115;&#x70;&#98;&#x65;&#114;&#x72;&#121;&#112;&#105;&#46;&#108;&#x6f;&#99;&#x61;&#108;</a></strong></p></blockquote><p>若出现报错，上传用户文件夹.ssh文件夹里面文件，再次登录</p><p><img src="https://i.loli.net/2020/12/19/kjeKxhu3dTJLWX7.png" alt="image-20201025214255208" loading="lazy"></p><p><img src="https://i.loli.net/2020/12/19/H948WAqePTOS5Xz.png" alt="image-20201025214311586" loading="lazy"></p><p><img src="https://i.loli.net/2020/12/19/s5GjY6rdTXlA3Mv.png" alt="image-20201025214715729" loading="lazy"></p><h2 id="2、通过VNC远程访问"><a href="#2、通过VNC远程访问" class="headerlink" title="2、通过VNC远程访问"></a>2、通过VNC远程访问</h2><blockquote><p>电脑安装VNC：<a href="https://www.realvnc.com/en/connect/download/viewer/">https://www.realvnc.com/en/connect/download/viewer/</a></p></blockquote><p>树莓派并不需要你为她配备单独的显示器、键盘和鼠标，你可以设置VNC或SSH，通过你平时常用的电脑来远程访问树莓派。</p><p>Raspbian系统安装后默认带有VNC和SSH软件包（除非你在官网选择下载的是最小安装包），你只需要把VNC和SSH服务打开就可以了。</p><blockquote><p>咱们的默认账户是：pi</p><p>pi账户的默认密码是：raspberry</p></blockquote><ul><li>启用VNC和SSH服务</li></ul><p>还是打开LX终端，在命令提示符后键入如下命令，然后按回车键：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo raspi<span class="token operator">-</span>config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你将打开树莓派的软件配置工具。</p><p><img src="https://i.loli.net/2020/12/19/JrnbRuW8HZKGsYN.png" alt="image-20201025215441969" loading="lazy"></p><p>使用上下方向键选择 5 Interfacing Option，按回车键进入接口配置。</p><p><img src="https://i.loli.net/2020/12/19/blXH72SDTVa8hf6.png" alt="image-20201025215527917" loading="lazy"></p><p>在这里你可以看到 P2 SSH 和 P3 VNC，二者的启用方法相同，下面以VNC为例介绍启用操作步骤。</p><p>使用上下方向键选择P3 VNC，按回车键进入 VNC配置。</p><p><img src="https://i.loli.net/2020/12/19/gJ8ryzdkRmDIGFQ.png" alt="image-20201025215610796" loading="lazy"></p><p>使用左右方向键选择&lt;是&gt;，按回车键，系统提示VNC服务已启动。</p><p><img src="https://i.loli.net/2020/12/19/BFvbxi2kCTuGI3h.png" alt="image-20201025215654238" loading="lazy"></p><p>按回车键&lt;确定&gt;，回到配置工具主界面，通过 Tab 键选中右下角的<Finish>，按回车即可完成VNC服务的打开。</p><p><img src="https://i.loli.net/2020/12/19/3NoiLP4rf1sdej9.png" alt="image-20201025215755506" loading="lazy"></p><p>最后不要忘了要查看树莓派的IP地址，在终端里输入 ifconfig 命令，按回车键后你将看到树莓派的IP地址。</p><p><img src="https://i.loli.net/2020/12/19/6i1UGRwHQmV5hat.png" alt="image-20201025215842212" loading="lazy"></p><ul><li><strong>使用VNC远程访问树莓派</strong></li></ul><p><img src="https://i.loli.net/2020/12/19/iL1wpTntHNrKW7l.png" alt="image-20201025220051910" loading="lazy"></p><ul><li>出现这种情况</li></ul><p><img src="https://i.loli.net/2020/12/19/GdgwDtUqFHE3vkA.png" alt="image-20201025220702840" loading="lazy"></p><p>解决办法：changing the resolution to the highest（更改更高的分辨率即可），ssh下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo raspi<span class="token operator">-</span>config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://i.loli.net/2020/12/19/c1rXkOH4fb8DnTo.png" alt="image-20201025220819826" loading="lazy"></p><p><img src="https://i.loli.net/2020/12/19/l9ImB2wUfSYhZka.png" alt="image-20201025220837492" loading="lazy"></p><p><img src="https://i.loli.net/2020/12/19/PfXCFtdZLO4Q1KA.png" alt="image-20201025220953102" loading="lazy"></p><p>重新用VNC连接</p><p><img src="https://i.loli.net/2020/12/19/7pesuBPzoYtwClH.png" alt="image-20201025221123776" loading="lazy"></p><h1 id="三、树莓派初始设置"><a href="#三、树莓派初始设置" class="headerlink" title="三、树莓派初始设置"></a>三、树莓派初始设置</h1><p>初次进入Raspbian，系统会自动弹出欢迎界面（Welcome to Raspberry Pi），也就是树莓派的初始设置引导程序，点击右下角的【Next】按钮，开始进行初始配置。<img src="https://i.loli.net/2020/12/19/o4tMXjGy7FJ96Uu.png" alt="image-20201025221315270" loading="lazy"></p><ul><li><strong>设置国家、语言和时区</strong></li></ul><p>你可以依次选择China、Chinese和Shanghai，选择完成后点击【Next】按钮。<img src="https://i.loli.net/2020/12/19/7NtsBGhuiDaV3RC.png" alt="image-20201025221357198" loading="lazy"></p><ul><li><strong>设置账户密码</strong></li></ul><p>Raspbian默认用户名为“pi”（不带引号），默认密码为“raspberry”（不带引号），为了安全起见，系统强烈建议你修改密码为一个只有你自己知道的密码，当然你千万不要把自己设置的密码忘了。录入完新的密码，点击【Next】按钮。<img src="https://i.loli.net/2020/12/19/yJPsmZejUxNvtgM.png" alt="image-20201025221437477" loading="lazy"></p><ul><li><strong>设置WiFI网络</strong></li></ul><p>选择你的WiFi热点，然后点击【Next】按钮，在接下来弹出的窗口中输入你的WiFi密码，随后点击【Next】按钮。<img src="https://i.loli.net/2020/12/19/5IuRtLXfzCBnNxc.png" alt="image-20201025221547544" loading="lazy"></p><ul><li><strong>软件升级</strong></li></ul><p>WiFi连接成功后，系统会提示你进行软件升级，你可以点击【Next】按钮进行升级，也可以点击【Skip】按钮跳过升级。升级需要较长时间，因此本文先跳过升级，日后再通过包管理工具来升级。<img src="https://i.loli.net/2020/12/19/fAXplQIqGTh86MH.png" alt="image-20201025221627595" loading="lazy"></p><ul><li><strong>重新启动</strong></li></ul><p>最后就是完成了上述全部设置，系统提示设置完成，点击【Restart】按钮重新启动系统。<img src="https://i.loli.net/2020/12/19/Q7yKu8Mibc4A1En.png" alt="image-20201025221654070" loading="lazy"></p><h1 id="四、配置静态IP"><a href="#四、配置静态IP" class="headerlink" title="四、配置静态IP"></a>四、配置静态IP</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//设置静态IP  加在文件后面</span>sudo nano <span class="token operator">/</span>etc<span class="token operator">/</span>dhcpcd<span class="token punctuation">.</span>conf    interface wlan0<span class="token keyword">static</span> ip_address<span class="token operator">=</span><span class="token number">172.16</span><span class="token number">.47</span><span class="token number">.86</span><span class="token operator">/</span><span class="token number">24</span><span class="token keyword">static</span> routers<span class="token operator">=</span><span class="token number">172.16</span><span class="token number">.47</span><span class="token number">.1</span><span class="token keyword">static</span> domain_name_servers<span class="token operator">=</span><span class="token number">218.196</span><span class="token number">.40</span><span class="token number">.9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、换源"><a href="#五、换源" class="headerlink" title="五、换源"></a>五、换源</h1><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</a></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"># 编辑 `<span class="token operator">/</span>etc<span class="token operator">/</span>apt<span class="token operator">/</span>sources<span class="token punctuation">.</span>list` 文件，删除原文件所有内容，用以下内容取代：deb http<span class="token operator">:</span><span class="token comment">//mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi</span>deb<span class="token operator">-</span>src http<span class="token operator">:</span><span class="token comment">//mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi</span># 编辑 `<span class="token operator">/</span>etc<span class="token operator">/</span>apt<span class="token operator">/</span>sources<span class="token punctuation">.</span>list<span class="token punctuation">.</span>d<span class="token operator">/</span>raspi<span class="token punctuation">.</span>list` 文件，删除原文件所有内容，用以下内容取代：deb http<span class="token operator">:</span><span class="token comment">//mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 镜像烧录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派开机自动发送IP地址到邮箱</title>
      <link href="/posts/3daa603a/"/>
      <url>/posts/3daa603a/</url>
      
        <content type="html"><![CDATA[<h1 id="1-编写开机获取IP地址的python程序"><a href="#1-编写开机获取IP地址的python程序" class="headerlink" title="1.编写开机获取IP地址的python程序"></a>1.编写开机获取IP地址的python程序</h1><blockquote><p>获取指定网卡的IP地址：ifconfig wlan0 | grep inet | grep -o -E ([0-9]+.){3}[0-9]+ | head -n 1</p><p>获取IP地址： hostname -I</p></blockquote><p><img src="https://i.loli.net/2020/12/17/8rsoDSpbYzmUANe.png" alt="image-20200725142149402" loading="lazy"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> smtplib<span class="token keyword">from</span> email<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>text <span class="token keyword">import</span> MIMEText<span class="token keyword">from</span> email<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>multipart <span class="token keyword">import</span> MIMEMultipart<span class="token keyword">from</span> email<span class="token punctuation">.</span>header <span class="token keyword">import</span> Header<span class="token keyword">from</span> email<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>image <span class="token keyword">import</span> MIMEImage<span class="token keyword">import</span> subprocess<span class="token keyword">import</span> time<span class="token keyword">import</span> traceback<span class="token comment">#延时15秒，使系统准备完毕（连上网络）</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token comment">#获取指定网卡 wlan0 的ip地址</span>cont <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>getoutput<span class="token punctuation">(</span><span class="token string">"ifconfig wlan0 | grep inet | grep -o -E \([0-9]+\.\)&#123;3&#125;[0-9]+ | head -n 1"</span><span class="token punctuation">)</span>localtime <span class="token operator">=</span> time<span class="token punctuation">.</span>asctime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#将时间和IP地址写入日志文件中</span>log <span class="token operator">=</span> cont<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>localtime<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"launlog.txt"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token comment"># 发送邮件服务器</span>smtpserver <span class="token operator">=</span> <span class="token string">'smtp.qq.com'</span><span class="token comment">#代发邮件的邮箱和用于登录的认证码(在QQ邮箱的设置中获取)</span>sender <span class="token operator">=</span> <span class="token string">"xxxxxxxxxx@qq.com"</span>aucode <span class="token operator">=</span> <span class="token string">'xxxxxxxxxxx'</span><span class="token comment">#接收邮件的IP地址</span>receiver <span class="token operator">=</span> <span class="token string">"xxxxxxxxxx@qq.com"</span>message <span class="token operator">=</span> MIMEMultipart<span class="token punctuation">(</span><span class="token string">'related'</span><span class="token punctuation">)</span>message<span class="token punctuation">[</span><span class="token string">'From'</span><span class="token punctuation">]</span> <span class="token operator">=</span> Header<span class="token punctuation">(</span><span class="token string">'RaspberryPi'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>message<span class="token punctuation">[</span><span class="token string">'To'</span><span class="token punctuation">]</span> <span class="token operator">=</span> Header<span class="token punctuation">(</span><span class="token string">'树莓派'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>subject <span class="token operator">=</span> <span class="token string">'树莓派'</span>message<span class="token punctuation">[</span><span class="token string">'Subject'</span><span class="token punctuation">]</span> <span class="token operator">=</span> Header<span class="token punctuation">(</span>subject<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>ipContent <span class="token operator">=</span> <span class="token string">"无线网络IP:"</span><span class="token operator">+</span>contcontent <span class="token operator">=</span> MIMEText<span class="token punctuation">(</span>ipContent<span class="token punctuation">,</span> <span class="token string">'plain'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>message<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    smtp <span class="token operator">=</span> smtplib<span class="token punctuation">.</span>SMTP_SSL<span class="token punctuation">(</span>smtpserver<span class="token punctuation">,</span> <span class="token number">465</span><span class="token punctuation">)</span>    smtp<span class="token punctuation">.</span>ehlo<span class="token punctuation">(</span><span class="token punctuation">)</span>    smtp<span class="token punctuation">.</span>login<span class="token punctuation">(</span>sender<span class="token punctuation">,</span>aucode<span class="token punctuation">)</span>    smtp<span class="token punctuation">.</span>sendmail<span class="token punctuation">(</span>sender<span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> message<span class="token punctuation">.</span>as_string<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    smtp<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">except</span> smtplib<span class="token punctuation">.</span>SMTPException<span class="token punctuation">:</span><span class="token comment">#将异常信息写入日志文件中</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"launlog.txt"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>traceback<span class="token punctuation">.</span>format_exc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-编写开机启动脚本"><a href="#2-编写开机启动脚本" class="headerlink" title="2.编写开机启动脚本"></a>2.编写开机启动脚本</h1><blockquote><p>wuxian.sh</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>bash### BEGIN INIT INFO<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Provides<span class="token operator">:</span>          scriptname</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Required<span class="token operator">-</span>Start<span class="token operator">:</span>    $remote_fs $network</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Required<span class="token operator">-</span>Stop<span class="token operator">:</span>     $remote_fs $network</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Default<span class="token operator">-</span>Start<span class="token operator">:</span>     <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Default<span class="token operator">-</span>Stop<span class="token operator">:</span>      <span class="token number">0</span> <span class="token number">1</span> <span class="token number">6</span> <span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Short<span class="token operator">-</span>Description<span class="token operator">:</span> Start daemon at boot time</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Description<span class="token operator">:</span>       Enable service provided by daemon<span class="token punctuation">.</span></span></span>### END INIT INFO<span class="token function">do_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    python3 <span class="token operator">/</span>home<span class="token operator">/</span>pi<span class="token operator">/</span>Desktop<span class="token operator">/</span>wuxian<span class="token punctuation">.</span>py    echo <span class="token string">" start"</span> <span class="token operator">>></span> <span class="token operator">/</span>home<span class="token operator">/</span>pi<span class="token operator">/</span>Desktop<span class="token operator">/</span>wuxian<span class="token punctuation">.</span>txt<span class="token punctuation">&#125;</span><span class="token function">do_stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   echo <span class="token string">"stop "</span> <span class="token operator">>></span> <span class="token operator">/</span>home<span class="token operator">/</span>pi<span class="token operator">/</span>Desktop<span class="token operator">/</span>wuxian<span class="token punctuation">.</span>txt<span class="token punctuation">&#125;</span><span class="token function">do_restart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    echo <span class="token string">"restart"</span> <span class="token operator">>></span> <span class="token operator">/</span>home<span class="token operator">/</span>pi<span class="token operator">/</span>Desktop<span class="token operator">/</span>wuxian<span class="token punctuation">.</span>txt<span class="token punctuation">&#125;</span><span class="token function">do_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    echo <span class="token string">"status"</span> <span class="token operator">>></span> <span class="token operator">/</span>home<span class="token operator">/</span>pi<span class="token operator">/</span>Desktop<span class="token operator">/</span>wuxian<span class="token punctuation">.</span>txt<span class="token punctuation">&#125;</span><span class="token function">do_fallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    echo <span class="token string">"fallback"</span> <span class="token operator">>></span> <span class="token operator">/</span>home<span class="token operator">/</span>pi<span class="token operator">/</span>Desktop<span class="token operator">/</span>wuxian<span class="token punctuation">.</span>txt<span class="token punctuation">&#125;</span><span class="token keyword">case</span> <span class="token string">"$1"</span> instart<span class="token punctuation">)</span> do_start    <span class="token punctuation">;</span><span class="token punctuation">;</span>stop<span class="token punctuation">)</span> do_stop    <span class="token punctuation">;</span><span class="token punctuation">;</span>restart<span class="token punctuation">)</span> do_restart    <span class="token punctuation">;</span><span class="token punctuation">;</span>status<span class="token punctuation">)</span> do_status    <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">)</span> do_fallback    <span class="token punctuation">;</span><span class="token punctuation">;</span>esacexit <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3、系统配置"><a href="#3、系统配置" class="headerlink" title="3、系统配置"></a>3、系统配置</h1><blockquote><p>（1）将 wuxian.sh 放置 &#x2F;etc&#x2F;init.d&#x2F; 文件夹中<br>（2）在 &#x2F;etc&#x2F;rc5.d&#x2F; 文件夹下创建一个wuxian.sh的软连接<br>（3）在终端中输入ln -s &#x2F;etc&#x2F;init.d&#x2F;wuxian.sh .&#x2F;S01wuxian.sh</p></blockquote><p>注意：</p><p>a.此时 wuxian.py 在 &#x2F;home&#x2F;pi&#x2F;Desktop&#x2F; 中</p><p>b.wuxian.sh在&#x2F;etc&#x2F;init.d&#x2F;中</p><p>c.软连接S01wuxian.sh在&#x2F;etc&#x2F;rc5.d&#x2F;中</p><p>d.有线网络的IP地址获取将Python脚本里面的<strong>wlan0</strong>改成<strong>eth0</strong>就行</p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派镜像烧录</title>
      <link href="/posts/9bd7a689/"/>
      <url>/posts/9bd7a689/</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装balenaEtcher烧录工具"><a href="#一、安装balenaEtcher烧录工具" class="headerlink" title="一、安装balenaEtcher烧录工具"></a>一、安装balenaEtcher烧录工具</h1><blockquote><p>下载链接：<a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a></p></blockquote><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220405001639.png" alt="image-20201025210635969" loading="lazy"></p><h1 id="二、烧录镜像文件"><a href="#二、烧录镜像文件" class="headerlink" title="二、烧录镜像文件"></a>二、烧录镜像文件</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220405001646.png" alt="image-20201025210732316" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220405001650.png" alt="image-20201025210823494" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220405001655.png" alt="image-20201025210848755" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220405001701.png" alt="image-20201025212943590" loading="lazy"></p><h1 id="三、烧录镜像成功"><a href="#三、烧录镜像成功" class="headerlink" title="三、烧录镜像成功"></a>三、烧录镜像成功</h1><p><img src="https://raw.githubusercontent.com/wushuai2000/PicGo/main/img/20220405001705.png" alt="image-20201025213002398" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 镜像烧录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入了解基本类型和引用类型的值</title>
      <link href="/posts/c9ad4580/"/>
      <url>/posts/c9ad4580/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-深入了解基本类型和引用类型的值"><a href="#JavaScript-深入了解基本类型和引用类型的值" class="headerlink" title="JavaScript 深入了解基本类型和引用类型的值"></a>JavaScript 深入了解基本类型和引用类型的值</h1><p>一个变量可以存放两种类型的值，基本类型的值（primitive values）和引用类型的值（reference values）。</p><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><hr><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>JavaScript 中共有 6 种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol (new in ES 6) ！</p><p><strong>约定：</strong>基本数据类型与原始数据类型等意。</p><p><strong>基本数据类型的值是按值访问的。</strong></p><ul><li><p>基本类型的值是不可变的</p>  <pre class="line-numbers language-none"><code class="language-none">var str &#x3D; &quot;123hello321&quot;;str.toUpperCase();     &#x2F;&#x2F; 123HELLO321console.log(str);      &#x2F;&#x2F; 123hello321<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>基本类型的比较是它们的值的比较</p>  <pre class="line-numbers language-none"><code class="language-none">var a &#x3D; 1;var b &#x3D; true;console.log(a &#x3D;&#x3D; b);    &#x2F;&#x2F; trueconsole.log(a &#x3D;&#x3D;&#x3D; b);   &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  上面 a 和 b 的数据类型不同，但是也可以进行值的比较，这是因为在比较之前，自动进行了数据类型的 隐式转换。</p><ul><li>&#x3D;&#x3D; : 只进行值的比较</li><li>&#x3D;&#x3D;&#x3D; : 不仅进行值得比较，还要进行数据类型的比较</li></ul></li><li><p>基本类型的变量是存放在栈内存（Stack）里的</p>  <pre class="line-numbers language-none"><code class="language-none">var a,b;a &#x3D; &quot;zyj&quot;;b &#x3D; a;console.log(a);   &#x2F;&#x2F; zyjconsole.log(b);   &#x2F;&#x2F; zyja &#x3D; &quot;呵呵&quot;;       &#x2F;&#x2F; 改变 a 的值，并不影响 b 的值console.log(a);   &#x2F;&#x2F; 呵呵console.log(b);   &#x2F;&#x2F; zyj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>图解如下：栈内存中包括了变量的标识符和变量的值</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/3834493100-57c3ff4a5dac7_articlex.png" alt="img" loading="lazy"></p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>除过上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等。</p><p><strong>引用类型的值是按引用访问的。</strong></p><ul><li><p>引用类型的值是可变的</p>  <pre class="line-numbers language-none"><code class="language-none">var obj &#x3D; &#123;name:&quot;zyj&quot;&#125;;   &#x2F;&#x2F; 创建一个对象obj.name &#x3D; &quot;percy&quot;;       &#x2F;&#x2F; 改变 name 属性的值obj.age &#x3D; 21;             &#x2F;&#x2F; 添加 age 属性obj.giveMeAll &#x3D; function()&#123;  return this.name + &quot; : &quot; + this.age;&#125;;                        &#x2F;&#x2F; 添加 giveMeAll 方法obj.giveMeAll();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>引用类型的比较是引用的比较</p>  <pre class="line-numbers language-none"><code class="language-none">var obj1 &#x3D; &#123;&#125;;    &#x2F;&#x2F; 新建一个空对象 obj1var obj2 &#x3D; &#123;&#125;;    &#x2F;&#x2F; 新建一个空对象 obj2console.log(obj1 &#x3D;&#x3D; obj2);    &#x2F;&#x2F; falseconsole.log(obj1 &#x3D;&#x3D;&#x3D; obj2);   &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  因为 obj1 和 obj2 分别引用的是存放在堆内存中的2个不同的对象，故变量 obj1 和 obj2 的值（引用地址）也是不一样的！</p></li><li><p>引用类型的值是保存在堆内存（Heap）中的对象（Object）</p><p>  与其他编程语言不同，JavaScript 不能直接操作对象的内存空间（堆内存）。</p>  <pre class="line-numbers language-none"><code class="language-none">var a &#x3D; &#123;name:&quot;percy&quot;&#125;;var b;b &#x3D; a;a.name &#x3D; &quot;zyj&quot;;console.log(b.name);    &#x2F;&#x2F; zyjb.age &#x3D; 22;console.log(a.age);     &#x2F;&#x2F; 22var c &#x3D; &#123;  name: &quot;zyj&quot;,  age: 22&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>图解如下：</p><ul><li>栈内存中保存了变量标识符和指向堆内存中该对象的指针</li><li>堆内存中保存了对象的内容</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/3309698956-57c41a89cddc7_articlex.png" alt="图片描述" loading="lazy"></p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a>：经常用来检测一个变量是不是最基本的数据类型</p>  <pre class="line-numbers language-none"><code class="language-none">var a;typeof a;    &#x2F;&#x2F; undefineda &#x3D; null;typeof a;    &#x2F;&#x2F; objecta &#x3D; true;typeof a;    &#x2F;&#x2F; booleana &#x3D; 666;typeof a;    &#x2F;&#x2F; number a &#x3D; &quot;hello&quot;;typeof a;    &#x2F;&#x2F; stringa &#x3D; Symbol();typeof a;    &#x2F;&#x2F; symbola &#x3D; function()&#123;&#125;typeof a;    &#x2F;&#x2F; functiona &#x3D; [];typeof a;    &#x2F;&#x2F; objecta &#x3D; &#123;&#125;;typeof a;    &#x2F;&#x2F; objecta &#x3D; &#x2F;aaa&#x2F;g;typeof a;    &#x2F;&#x2F; object   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a>：用来判断某个构造函数的 prototype 属性所指向的对象是否存在于另外一个要检测对象的原型链上</p><p>  简单说就是判断一个引用类型的变量具体是不是某种类型的对象</p>  <pre class="line-numbers language-none"><code class="language-none">(&#123;&#125;) instanceof Object              &#x2F;&#x2F; true([]) instanceof Array               &#x2F;&#x2F; true(&#x2F;aa&#x2F;g) instanceof RegExp           &#x2F;&#x2F; true(function()&#123;&#125;) instanceof Function  &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>原文地址：<a href="https://segmentfault.com/a/1190000006752076">https://segmentfault.com/a/1190000006752076</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端三剑客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基本类型、引用类型、简单赋值、对象引用</title>
      <link href="/posts/1351a4af/"/>
      <url>/posts/1351a4af/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-基本类型-引用类型-简单赋值-对象引用"><a href="#JavaScript-基本类型-引用类型-简单赋值-对象引用" class="headerlink" title="JavaScript 基本类型 引用类型 简单赋值 对象引用"></a>JavaScript 基本类型 引用类型 简单赋值 对象引用</h1><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>ECMAScirpt 变量有两种不同的数据类型：<code>基本类型，引用类型</code>。也有其他的叫法，比如<code>原始类型和对象类型</code>，<code>拥有方法的类型和不能拥有方法的类型</code>，还可以分为<code>可变类型和不可变类型</code>，其实这些叫法都是依据这两种的<code>类型特点</code>来命名的，大家爱叫啥就叫啥吧 o(╯□╰)o 。</p><h2 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h2><p>基本的数据类型有：undefined，boolean，number，string，null。基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值。基本类型有以下几个特点：</p><p><strong>1.基本类型的值是不可变得：</strong></p><p>任何方法都无法改变一个基本类型的值，比如一个字符串：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var name = 'jozo';name.toUpperCase(); // 输出 'JOZO'console.log(name); // 输出  'jozo'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>会发现原始的name并未发生改变，而是调用了toUpperCase()方法后返回的是一个新的字符串。<br>再来看个：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var person = 'jozo';person.age = 22;person.method = function()&#123;//...&#125;;console.log(person.age); // undefinedconsole.log(person.method); // undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面代码可知，我们不能给基本类型添加属性和方法，再次说明基本类型时不可变得；</p><p><strong>2.基本类型的比较是值的比较：</strong></p><p>只有在它们的值相等的时候它们才相等。<br>但你可能会这样：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var a = 1;var b = true;console.log(a == b);//true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它们不是相等吗？其实这是<code>类型转换</code>和 <code>==</code> 运算符的知识了，也就是说在用&#x3D;&#x3D;比较两个不同类型的变量时会进行一些类型转换。像上面的比较先会把true转换为数字1再和数字1进行比较，结果就是true了。 这是当比较的两个值的类型不同的时候&#x3D;&#x3D;运算符会进行类型转换，但是当两个值的类型相同的时候，即使是&#x3D;&#x3D;也相当于是&#x3D;&#x3D;&#x3D;。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var a = 'jozo';var b = 'jozo';console.log(a === b);//true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3.基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</strong></p><p>假如有以下几个基本类型的变量：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var name = 'jozo';var city = 'guangzhou';var age = 22;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么它的存储结构如下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/1480902711-55608eac1ef9b_articlex.png" alt="clipboard.png" loading="lazy"></p><p>栈区包括了 变量的标识符和变量的值。</p><h2 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h2><p>引用类型会比较好玩有趣一些。</p><p>javascript中除了上面的基本类型<code>(number,string,boolean,null,undefined)</code>之外就是引用类型了，也可以说是就是对象了。对象是属性和方法的集合。也就是说引用类型可以拥有属性和方法，属性又可以包含基本类型和引用类型。来看看引用类型的一些特性：</p><p><strong>1.引用类型的值是可变的</strong></p><p>我们可为为引用类型添加属性和方法，也可以删除其属性和方法，如：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var person = &#123;&#125;;//创建个控对象 --引用类型person.name = 'jozo';person.age = 22;person.sayName = function()&#123;console.log(person.name);&#125; person.sayName();// 'jozo'delete person.name; //删除person对象的name属性person.sayName(); // undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码说明引用类型可以拥有属性和方法，并且是可以动态改变的。</p><p><strong>2.引用类型的值是同时保存在栈内存和堆内存中的对象</strong></p><p>javascript和其他语言不同，其不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，那我们操作啥呢？ 实际上，是操作对象的引用，所以引用类型的值是按引用访问的。<br>准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。<br>假如有以下几个对象：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var person1 = &#123;name:'jozo'&#125;;var person2 = &#123;name:'xiaom'&#125;;var person3 = &#123;name:'xiaoq'&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则这三个对象的在内存中保存的情况如下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/1303646121-5560990755326_articlex.png" alt="clipboard.png" loading="lazy"></p><p><strong>3.引用类型的比较是引用的比较</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var person1 = '&#123;&#125;';var person2 = '&#123;&#125;';console.log(person1 == person2); // true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面讲基本类型的比较的时候提到了当两个比较值的类型相同的时候，相当于是用 &#x3D;&#x3D;&#x3D; ，所以输出是true了。再看看：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">var person1 = &#123;&#125;;var person2 = &#123;&#125;;console.log(person1 == person2); // false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可能你已经看出破绽了，上面比较的是两个字符串，而下面比较的是两个对象，为什么长的一模一样的对象就不相等了呢？</p><p>别忘了，引用类型时按引用访问的，换句话说就是比较两个对象的堆内存中的地址是否相同，那很明显，person1和person2在堆内存中地址是不同的：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/3278409663-55609d5ead9bd_articlex.png" alt="img" loading="lazy"></p><p>所以这两个是完全不同的对象，所以返回false;</p><h2 id="3-简单赋值"><a href="#3-简单赋值" class="headerlink" title="3.简单赋值"></a>3.简单赋值</h2><p>在从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上：</p><pre class="line-numbers language-none"><code class="language-none">var a &#x3D; 10;var b &#x3D; a;a ++ ;console.log(a); &#x2F;&#x2F; 11console.log(b); &#x2F;&#x2F; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，a中保存的值为 10 ，当使用 a 来初始化 b 时，b 中保存的值也为10，但b中的10与a中的是完全独立的，该值只是a中的值的一个副本，此后，这两个变量可以参加任何操作而相互不受影响。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/2267925907-556199deeed58_articlex.png" alt="clipboard.png" loading="lazy"></p><p>也就是说基本类型在赋值操作后，两个变量是相互不受影响的。</p><h2 id="4-对象引用"><a href="#4-对象引用" class="headerlink" title="4.对象引用"></a>4.对象引用</h2><p>当从一个变量向另一个变量赋值引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。前面讲引用类型的时候提到，保存在变量中的是对象在堆内存中的地址，所以，与简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。那么赋值操作后，两个变量都保存了同一个对象地址，则这两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响：</p><pre class="line-numbers language-none"><code class="language-none">var a &#x3D; &#123;&#125;; &#x2F;&#x2F; a保存了一个空对象的实例var b &#x3D; a;  &#x2F;&#x2F; a和b都指向了这个空对象a.name &#x3D; &#39;jozo&#39;;console.log(a.name); &#x2F;&#x2F; &#39;jozo&#39;console.log(b.name); &#x2F;&#x2F; &#39;jozo&#39;b.age &#x3D; 22;console.log(b.age);&#x2F;&#x2F; 22console.log(a.age);&#x2F;&#x2F; 22console.log(a &#x3D;&#x3D; b);&#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它们的关系如下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/2052038946-55619ed80a85e_articlex.png" alt="img" loading="lazy"></p><p>因此，引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。</p><blockquote><p>原文链接：<a href="https://segmentfault.com/a/1190000002789651">https://segmentfault.com/a/1190000002789651</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端三剑客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML状态消息</title>
      <link href="/posts/c473cc2a/"/>
      <url>/posts/c473cc2a/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-状态消息"><a href="#HTTP-状态消息" class="headerlink" title="HTTP 状态消息"></a>HTTP 状态消息</h1><hr><p>当浏览器从 web 服务器请求服务时，可能会发生错误。</p><p>以下列举了有可能会返回的一系列 HTTP 状态消息：</p><hr><h2 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx: 信息"></a>1xx: 信息</h2><table><thead><tr><th align="left">消息：</th><th align="left">描述：</th></tr></thead><tbody><tr><td align="left">100 Continue</td><td align="left">服务器仅接收到部分请求，如果服务器没有拒绝该请求，客户端应该继续发送其余的请求。</td></tr><tr><td align="left">101 Switching Protocols</td><td align="left">服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td></tr><tr><td align="left">103 Checkpoint</td><td align="left">用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。</td></tr></tbody></table><h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx: 成功"></a>2xx: 成功</h2><table><thead><tr><th align="left">消息：</th><th align="left">描述：</th></tr></thead><tbody><tr><td align="left">200 OK</td><td align="left">请求成功（这是对HTTP请求成功的标准应答。）</td></tr><tr><td align="left">201 Created</td><td align="left">请求被创建完成，同时新的资源被创建。</td></tr><tr><td align="left">202 Accepted</td><td align="left">供处理的请求已被接受，但是处理未完成。</td></tr><tr><td align="left">203 Non-Authoritative Information</td><td align="left">请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。</td></tr><tr><td align="left">204 No Content</td><td align="left">请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td></tr><tr><td align="left">205 Reset Content</td><td align="left">请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td></tr><tr><td align="left">206 Partial Content</td><td align="left">客户发送了一个带有Range头的GET请求，服务器完成了它。</td></tr></tbody></table><h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h2><table><thead><tr><th align="left">消息：</th><th align="left">描述：</th></tr></thead><tbody><tr><td align="left">300 Multiple Choices</td><td align="left">多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td></tr><tr><td align="left">301 Moved Permanently</td><td align="left">所请求的页面已经转移至新的 URL 。</td></tr><tr><td align="left">302 Found</td><td align="left">所请求的页面已经临时转移至新的 URL 。</td></tr><tr><td align="left">303 See Other</td><td align="left">所请求的页面可在别的 URL 下被找到。</td></tr><tr><td align="left">304 Not Modified</td><td align="left">未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td></tr><tr><td align="left">305 Use Proxy</td><td align="left">客户请求的文档应该通过Location头所指明的代理服务器提取。</td></tr><tr><td align="left">306 Switch Proxy</td><td align="left"><em>目前已不再使用，但是代码依然被保留。</em></td></tr><tr><td align="left">307 Temporary Redirect</td><td align="left">被请求的页面已经临时移至新的 URL 。</td></tr><tr><td align="left">308 Resume Incomplete</td><td align="left">用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。</td></tr></tbody></table><h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx: 客户端错误"></a>4xx: 客户端错误</h2><table><thead><tr><th align="left">消息：</th><th align="left">描述：</th></tr></thead><tbody><tr><td align="left">400 Bad Request</td><td align="left">因为语法错误，服务器未能理解请求。</td></tr><tr><td align="left">401 Unauthorized</td><td align="left">合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。</td></tr><tr><td align="left">402 Payment Required</td><td align="left"><em>此代码尚无法使用。</em></td></tr><tr><td align="left">403 Forbidden</td><td align="left">合法请求，但对被请求页面的访问被禁止。</td></tr><tr><td align="left">404 Not Found</td><td align="left">服务器无法找到被请求的页面。</td></tr><tr><td align="left">405 Method Not Allowed</td><td align="left">请求中指定的方法不被允许。</td></tr><tr><td align="left">406 Not Acceptable</td><td align="left">服务器生成的响应无法被客户端所接受。</td></tr><tr><td align="left">407 Proxy Authentication Required</td><td align="left">用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td></tr><tr><td align="left">408 Request Timeout</td><td align="left">请求超出了服务器的等待时间。</td></tr><tr><td align="left">409 Conflict</td><td align="left">由于冲突，请求无法被完成。</td></tr><tr><td align="left">410 Gone</td><td align="left">被请求的页面不可用。</td></tr><tr><td align="left">411 Length Required</td><td align="left">“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</td></tr><tr><td align="left">412 Precondition Failed</td><td align="left">请求中的前提条件被服务器评估为失败。</td></tr><tr><td align="left">413 Request Entity Too Large</td><td align="left">由于所请求的实体太大，服务器不会接受请求。</td></tr><tr><td align="left">414 Request-URI Too Long</td><td align="left">由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。</td></tr><tr><td align="left">415 Unsupported Media Type</td><td align="left">由于媒介类型不被支持，服务器不会接受请求。</td></tr><tr><td align="left">416 Requested Range Not Satisfiable</td><td align="left">客户端请求部分文档，但是服务器不能提供被请求的部分。</td></tr><tr><td align="left">417 Expectation Failed</td><td align="left">服务器不能满足客户在请求中指定的请求头。</td></tr></tbody></table><h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx: 服务器错误"></a>5xx: 服务器错误</h2><table><thead><tr><th align="left">消息：</th><th align="left">描述：</th></tr></thead><tbody><tr><td align="left">500 Internal Server Error</td><td align="left">请求未完成。服务器遇到不可预知的情况。</td></tr><tr><td align="left">501 Not Implemented</td><td align="left">请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。</td></tr><tr><td align="left">502 Bad Gateway</td><td align="left">请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。</td></tr><tr><td align="left">503 Service Unavailable</td><td align="left">服务器当前不可用（过载或者当机）。</td></tr><tr><td align="left">504 Gateway Timeout</td><td align="left">网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。</td></tr><tr><td align="left">505 HTTP Version Not Supported</td><td align="left">服务器不支持请求中指明的HTTP协议版本。</td></tr><tr><td align="left">511 Network Authentication Required</td><td align="left">用户需要提供身份验证来获取网络访问入口。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端三剑客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML入门与实战</title>
      <link href="/posts/a0c9f462/"/>
      <url>/posts/a0c9f462/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Web基础"><a href="#第一章-Web基础" class="headerlink" title="第一章 Web基础"></a>第一章 Web基础</h1><ul><li>浏览器：渲染网页展示</li></ul><h2 id="1、常见浏览器"><a href="#1、常见浏览器" class="headerlink" title="1、常见浏览器"></a>1、常见浏览器</h2><ul><li>IE、Edge</li><li>Google Chrome</li><li>Mozilla Firefox</li><li>Safari</li><li>Opera</li></ul><h2 id="2、浏览器内核"><a href="#2、浏览器内核" class="headerlink" title="2、浏览器内核"></a>2、浏览器内核</h2><ul><li><p>浏览器内核可以分成两部分：渲染引擎（Layout engineer 或者 Rendering Engine）和 JS 引擎。</p></li><li><p>渲染引擎负责取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后输出至显示器或打印机。</p></li><li><p>JS引擎则是解析JavaScript语言，执行JavaScript语言来实现网页的动态效果。</p>  <pre class="line-numbers language-none"><code class="language-none">Trident（IE内核）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>IE、Edge、360</p></li><li><p>大多多核浏览器的兼容内核</p>  <pre class="line-numbers language-none"><code class="language-none">Gecko（firefox内核）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>代码开源，可开发程度高</p></li><li><p>打开速度慢、升级频繁</p>  <pre class="line-numbers language-none"><code class="language-none">webkit（Safari内核）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>早期chrome使用webkit内核，现在改为blink</p>  <pre class="line-numbers language-none"><code class="language-none">chromium&#x2F;Blink（chrome内核）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>blink实际上是webkit的分支</p>  <pre class="line-numbers language-none"><code class="language-none">Presto（opera内核）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>presto是opera早期内核，现在已经换为谷歌的blink内核。</p>  <pre class="line-numbers language-none"><code class="language-none">移动端的浏览器内核<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>移动端的浏览器内核说的是系统内置浏览器的内核。</p><p>ios平台主要是webkit，Android 4.4之前的内核是webkit，后面切换到了chromium，Windows Phone 8的内核是Trident。</p><h2 id="3、web标准"><a href="#3、web标准" class="headerlink" title="3、web标准"></a>3、web标准</h2><p>Web标准是由W3C和其他标准化组织制定的一系列标准的集合。主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p><p>结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。</p><p>样式标准：表现用于设置网页元素的板式、颜色、大小等外观样式，主要指的是CSS。</p><p>行为标准：行为是指网页模型的定义以及交互的编写，主要包括DOM和ECMAScript两个部分。</p><p>理想状态的源码：.html、.css、.js 。</p><h1 id="第二章-HTML入门"><a href="#第二章-HTML入门" class="headerlink" title="第二章  HTML入门"></a>第二章  HTML入门</h1><h2 id="1、HTML初识"><a href="#1、HTML初识" class="headerlink" title="1、HTML初识"></a>1、HTML初识</h2><ul><li>HTML（英文Hyper Text Markup Language的缩写），中文译名为“超文本标签语言”，主要是通过对HTML标签对网页中的文本、图片、声音等内容进行描述。</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>加粗文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、骨架格式"><a href="#2、骨架格式" class="headerlink" title="2、骨架格式"></a>2、骨架格式</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、标签"><a href="#3、标签" class="headerlink" title="3、标签"></a>3、标签</h2><h3 id="（1）必要的标签"><a href="#（1）必要的标签" class="headerlink" title="（1）必要的标签"></a>（1）必要的标签</h3><ul><li>html标签：作为所有html中标签的一个根节点</li><li>head标签：用于存放title、meta、base、style、script、link，head标签中必须设置的标签是title</li><li>title标签：页面标题</li><li>body标签：页面主体部分</li></ul><h3 id="（2）标签分类"><a href="#（2）标签分类" class="headerlink" title="（2）标签分类"></a>（2）标签分类</h3><ul><li><p>在HTML页面中，带有&lt;&gt;符号的元素被称为标签或元素。</p></li><li><p>1、双标签：该语法中&lt;标签名&gt;表示该标签的作用开始，一般称为开始标签；&lt;&#x2F;标签名&gt;表示该标签的作用结束，一般称为结束标签。</p></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标签名</span><span class="token punctuation">></span></span>内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>标签名</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>2、单标签：单标签也称空标签，是指一个标签符号即可完整地描述某个功能的标签。</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标签名</span><span class="token punctuation">/></span></span>比如 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="（3）标签嵌套和并列关系"><a href="#（3）标签嵌套和并列关系" class="headerlink" title="（3）标签嵌套和并列关系"></a>（3）标签嵌套和并列关系</h3><ul><li>嵌套关系：html嵌套head，head嵌套title</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>并列关系：比如head和body</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>下列哪个标签是错误的？</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html">A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span>C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>XD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、开发工具：快速生成标签、骨架"><a href="#4、开发工具：快速生成标签、骨架" class="headerlink" title="4、开发工具：快速生成标签、骨架"></a>4、开发工具：快速生成标签、骨架</h2><ul><li>Dreamweaver</li><li>sublime</li><li>WebStorm</li><li>HBuilder</li><li>VSCode</li></ul><h2 id="5、doctype文档类型"><a href="#5、doctype文档类型" class="headerlink" title="5、doctype文档类型"></a>5、doctype文档类型</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>这句话告诉我们所使用的html版本，html 5的版本</li><li>位于文档的最前面，用于向浏览器说明当前文档使用哪种HTML或XHTML标准规范，必须在开头使用该标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。</li></ul><h2 id="6、字符集简介"><a href="#6、字符集简介" class="headerlink" title="6、字符集简介"></a>6、字符集简介</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>utf-8是目前最常用的字符集编码方式，还有gbk和gb2312等较常用。</li><li>GB2312简单中文，包含6763个汉字</li><li>GBK包含全部中文字符，是GB2312的扩展，兼容GB2312</li><li>UTF-8包含全世界所有国家需要用到的字符</li></ul><h1 id="第三章-HTML标签"><a href="#第三章-HTML标签" class="headerlink" title="第三章 HTML标签"></a>第三章 HTML标签</h1><h2 id="1、标签的语义化"><a href="#1、标签的语义化" class="headerlink" title="1、标签的语义化"></a>1、标签的语义化</h2><ul><li>标签语义化即标签的含义。</li><li>语义化标签</li></ul><pre class="line-numbers language-none"><code class="language-none">1、方便代码的阅读和维护2、同时让浏览器方便解析3、搜索引擎优化核心：合适的地方给一个合理的标签。语义良好：去掉CSS后，网页结构依然组织有序，并且有良好的可读性。原则：先确定语义的HTML，再选合适的CSS。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、排版标签"><a href="#2、排版标签" class="headerlink" title="2、排版标签"></a>2、排版标签</h2><ul><li>排版标签主要和CSS搭配使用，显示网页结构的标签，是网页布局最常用的标签。</li></ul><h3 id="（1）标题标签"><a href="#（1）标题标签" class="headerlink" title="（1）标题标签"></a>（1）标题标签</h3><ul><li>单词缩写head，头部、标题</li><li>HTML提供了6个等级的标题：&lt; h1 &gt;到&lt; h6 &gt;</li><li>语义：作为标题使用，并且依据重要性递减</li><li>最小到6级标题，数字再大无效</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>标题标签测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>三级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>四级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span><span class="token punctuation">></span></span>五级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）段落标签"><a href="#（2）段落标签" class="headerlink" title="（2）段落标签"></a>（2）段落标签</h3><ul><li>单词缩写：paragraph</li><li>就像写文章一样的，对内容分段</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>一段文字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</li></ul><h3 id="（3）水平线标签"><a href="#（3）水平线标签" class="headerlink" title="（3）水平线标签"></a>（3）水平线标签</h3><ul><li>单词缩写：horizontal 横线</li><li>在网页中用水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以通过标签完成。</li><li>单标签</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在网页中显示默认样式的水平线。</li></ul><h3 id="（4）换行标签"><a href="#（4）换行标签" class="headerlink" title="（4）换行标签"></a>（4）换行标签</h3><ul><li>单词缩写：break 打断，换行</li><li>在HTML中，一个段落中的文字会从左到右依次排列，知道浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签。</li><li>单标签</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（5）div-span标签"><a href="#（5）div-span标签" class="headerlink" title="（5）div span标签"></a>（5）div span标签</h3><ul><li>div就是division的缩写</li><li>span 跨度，跨距；范围</li><li>div和span是没有语义的，是网页布局主要的两个盒子</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span> 这是头部 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>今日价格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3、文本格式化标签"><a href="#3、文本格式化标签" class="headerlink" title="3、文本格式化标签"></a>3、文本格式化标签</h2><ul><li>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊方式显示。</li><li>表格中的标签不带内左右不带空格，因为CSDN不加空格显示不出来</li></ul><table><thead><tr><th align="center">标签</th><th align="center">显示效果</th></tr></thead><tbody><tr><td align="center">&lt; b &gt;&lt; &#x2F;b &gt;，&lt; strong &gt;&lt; &#x2F;strong &gt;</td><td align="center">文字以粗体方式显示（XHTML推荐使用strong）</td></tr><tr><td align="center">&lt; i &gt;&lt; &#x2F;i &gt;，&lt; em &gt;&lt; &#x2F;em&gt;</td><td align="center">文字以斜体方式显示（XHTML推荐使用em）</td></tr><tr><td align="center">&lt; s &gt;&lt; &#x2F;s &gt;，&lt; del &gt;&lt; &#x2F;del &gt;</td><td align="center">文字以加删除线方式显示（XHTML推荐使用del ）</td></tr><tr><td align="center">&lt; u &gt;&lt; &#x2F;u &gt;，&lt; ins &gt;&lt; &#x2F;ins &gt;</td><td align="center">文字以加下划线方式显示（XHTML推荐使用ins）</td></tr></tbody></table><ul><li>四列的后者语义更强烈</li></ul><h2 id="4、标签属性"><a href="#4、标签属性" class="headerlink" title="4、标签属性"></a>4、标签属性</h2><ul><li>属性就是特性，使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置，其基本语法如下：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标签名</span> <span class="token attr-name">属性1</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>属性值1<span class="token punctuation">"</span></span> <span class="token attr-name">属性2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>属性值2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>标签名</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均用空格分开。</li><li>任何标签的属性都有默认值，省略该属性则取默认值。</li><li>采取 键值对 的格式 key&#x3D;“value”</li><li>比如 水平线长度（宽）width为400，颜色为红色</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5、图像标签"><a href="#5、图像标签" class="headerlink" title="5、图像标签"></a>5、图像标签</h2><ul><li>单词缩写：image 图像</li><li>图像标签的语法如下：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>图像URL<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>图像标签的属性</li></ul><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th>描述</th></tr></thead><tbody><tr><td align="center">src</td><td align="center">URL</td><td>图像的路径</td></tr><tr><td align="center">alt</td><td align="center">文本</td><td>图像不能显示时的替换文本</td></tr><tr><td align="center">title</td><td align="center">文本</td><td>鼠标悬停时显示的内容</td></tr><tr><td align="center">width</td><td align="center">像素（XHTML不支持%页面百分比）</td><td>设置图像的宽度</td></tr><tr><td align="center">alt</td><td align="center">像素（XHTML不支持%页面百分比）</td><td>设置图像的高度</td></tr><tr><td align="center">border</td><td align="center">数字</td><td>设置图像边框的宽度</td></tr></tbody></table><h2 id="6、链接标签"><a href="#6、链接标签" class="headerlink" title="6、链接标签"></a>6、链接标签</h2><ul><li>单词缩写：anchor 锚</li><li>创建超链接，需要用链接标签环绕被链接的对象即可，语法如下：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>跳转目标<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>目标窗口的弹出方式<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>文本或图像<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。Hypertext Reference的缩写</p></li><li><p>target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。</p></li><li><p>注意：</p><p>  （1）外部链接 需要添加 http:&#x2F;&#x2F;<br>  （2）内部链接 直接链接内部页面名称即可，比如 &lt; a href&#x3D;“index.hrml”&gt;首页&lt; &#x2F;a&gt;<br>  （3）如果当时没有确定链接目标时，通常将链接标签的href属性值定义为#，表示该链接暂时为一个空链接。<br>  （4）不仅可以创建文本超链接，在网页中的各种元素，如图像、表格、音频、视频等都可以添加超链接。</p></li></ul><h2 id="7、锚点定位"><a href="#7、锚点定位" class="headerlink" title="7、锚点定位"></a>7、锚点定位</h2><ul><li>通过创建锚点链接，用户能快速定位到目标内容；比如CSDN博客的目录。</li><li>创建锚点链接分两步：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html">1、使用以下语句创建链接文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#id名<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>链接文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>2、使用相应的id名标注跳转目标的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="8、base标签"><a href="#8、base标签" class="headerlink" title="8、base标签"></a>8、base标签</h2><ul><li>base可以设置整体链接的打开状态</li><li>比如把链接都设置为新窗口打开</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base</span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="9、特殊字符"><a href="#9、特殊字符" class="headerlink" title="9、特殊字符"></a>9、特殊字符</h2><ul><li>HTML为这些特殊字符准备了专门的替代代码，可以用于CSDN博文。</li><li>字符的代码中，&amp;后没有空格，在CSDN博文中不加就被当特殊字符转义了</li></ul><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符的代码</th></tr></thead><tbody><tr><td></td><td>空格</td><td>&amp; nbsp;</td></tr><tr><td>&lt;</td><td>小于号</td><td>&amp; lt;</td></tr><tr><td>&gt;</td><td>小于号</td><td>&amp; gt;</td></tr><tr><td>&amp;</td><td>小于号</td><td>&amp; amp;</td></tr><tr><td>￥</td><td>人名币</td><td>&amp; yen;</td></tr><tr><td>©</td><td>版权</td><td>&amp; copy;</td></tr><tr><td>®</td><td>注册商标</td><td>&amp; reg;</td></tr><tr><td>°</td><td>摄氏度</td><td>&amp; deg;</td></tr><tr><td>±</td><td>正负号</td><td>&amp; plusmn;</td></tr><tr><td>×</td><td>乘号</td><td>&amp; times;</td></tr><tr><td>÷</td><td>除号</td><td>&amp; divide;</td></tr><tr><td>²</td><td>平方（上标2）</td><td>&amp; sup2;</td></tr><tr><td>³</td><td>立方（上标3）</td><td>&amp; sup3;</td></tr></tbody></table><h2 id="10、注释标签"><a href="#10、注释标签" class="headerlink" title="10、注释标签"></a>10、注释标签</h2><ul><li>如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。语法如下：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 注释语句 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>注释内容不会显示在浏览器窗口中，但是作为HTML文档的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</li></ul><h2 id="11、路径"><a href="#11、路径" class="headerlink" title="11、路径"></a>11、路径</h2><ul><li><p>路径可以分为：相对路径和绝对路径</p></li><li><p>相对路径：</p><p>  （1）图像文件和HTML文件位于同一文件夹：只需要输入图像文件的名称即可。<br>  （2）图像文件位于HTML文件的下一级文件夹：输入文件夹和文件名，之间用&#x2F;分开。<br>  （3）图像文件位于HTML文件的上一级文件夹：在文件名之前加“…&#x2F;”，如果是上两级，则需要使用“…&#x2F;…&#x2F;”，以此类推。</p></li><li><p>绝对路径：完整的地址信息。</p></li></ul><h2 id="12、列表标签"><a href="#12、列表标签" class="headerlink" title="12、列表标签"></a>12、列表标签</h2><ul><li>容器内装载着文字或者图表的一种形式，叫列表。</li><li>列表最大的特点是整齐、有序。</li><li>列表分为无序列表、有序列表和自定义列表。</li></ul><h3 id="1-无序列表-ul"><a href="#1-无序列表-ul" class="headerlink" title="(1)无序列表 ul"></a>(1)无序列表 ul</h3><ul><li>无序列表的各个列表项之间没有顺序级别之分，是并列的。基本语法如下：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>···<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意事项：</li></ul><blockquote><p>&lt; ul&gt;&lt; &#x2F;ul&gt;中只能嵌套&lt; li&gt;&lt; &#x2F;li&gt;，直接在无序列表标签中输入其他标签或者文字的做法是不允许的。<br>&lt; li&gt;与&lt; &#x2F;li&gt;之间相当于一个容器，可以容纳所有元素。<br>无序列表会带有自己的样式属性。</p></blockquote><h3 id="2-有序列表-ol"><a href="#2-有序列表-ol" class="headerlink" title="(2)有序列表 ol"></a>(2)有序列表 ol</h3><ul><li>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>列表项3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>···<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-自定义列表"><a href="#3-自定义列表" class="headerlink" title="(3)自定义列表"></a>(3)自定义列表</h3><ul><li>自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>名词1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词1解释1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词1解释2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>···<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>名词2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词2解释1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词2解释2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端三剑客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
